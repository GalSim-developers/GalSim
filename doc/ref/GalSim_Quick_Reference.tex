\documentclass[preprint,11pt]{../../devel/modules/aastex}

% Copyright 2012, 2013 The GalSim developers:
% https://github.com/GalSim-developers
%
% This file is part of GalSim: The modular galaxy image simulation toolkit.
%
% GalSim is free software: you can redistribute it and/or modify
% it under the terms of the GNU General Public License as published by
% the Free Software Foundation, either version 3 of the License, or
% (at your option) any later version.
%
% GalSim is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
% GNU General Public License for more details.
%
% You should have received a copy of the GNU General Public License
% along with GalSim.  If not, see <http://www.gnu.org/licenses/>
%

% packages for figures
\usepackage{graphicx,times}
% packages for symbols
\usepackage{latexsym,amssymb,hyperref}
% AMS-LaTeX package for e.g. subequations
\usepackage{amsmath}

%=====================================================================
% FRONT MATTER
%=====================================================================

\slugcomment{Draft \today}

%=====================================================================
% BEGIN DOCUMENT
%=====================================================================

\begin{document}

\setlength{\parskip}{2.0ex plus 0.5ex minus 0.5ex}
\setlength{\parindent}{0cm} 

\title{GalSim Quick Reference}

\tableofcontents

\newpage

\section{Overview}

%\emph{BARNEY TODO: Tidy this whole thing up, make it look a lot less ugly,
%maybe use an entirely different document class.}

The GalSim package provides a number of Python classes and methods for
simulating astronomical images.  We assume GalSim is installed; see the
\href{https://github.com/GalSim-developers/GalSim/wiki}{\emph{GalSim
    Wiki}} or the file \texttt{INSTALL.md} in the base directory \texttt{/your/path/to/GalSim/}
for instructions.  The package is imported into Python with

\texttt{>>> import galsim}

and the typical work flow, as demonstrated in the example scripts in the {\tt
examples/} directory (all paths given relative to
\texttt{/your/path/to/GalSim/} from now on), will normally
be something like the following:
\begin{itemize}

\item Construct a representation of your desired astronomical object
  as an instance of the {\tt GSObject} class, which represent surface brightness profiles (of galaxies or PSFs).  Multiple components can be
  combined using the special
  \href{http://galsim-developers.github.com/GalSim/classgalsim_1_1base_1_1_add.html}{\texttt{Add}}
  and 
  \href{http://galsim-developers.github.com/GalSim/classgalsim_1_1base_1_1_convolve.html}{\texttt{Convolve}}
  classes --- see Section~\ref{sect:gsobjects}.
\item Apply transformations such as shears, shifts or magnification
  using the methods of the \texttt{GSObject} --- see Section~\ref{sect:gsobjectmethods}.
\item Draw the object into a GalSim \texttt{Image}, representing a postage
  stamp image of your astronomical object.  This can be done using the
  \texttt{obj.}\href{http://galsim-developers.github.com/GalSim/classgalsim_1_1base_1_1_g_s_object.html#ae0b346a8b438dedbc7f60a52220869d8}{\texttt{draw}}\texttt{(\dots)}
  or
  \texttt{obj.}\href{http://galsim-developers.github.com/GalSim/classgalsim_1_1base_1_1_g_s_object.html#a42ac334d2840ba3fa832988e998beca0}{\texttt{drawShoot}}\texttt{(\dots)}
  methods carried by all \texttt{GSObject}s for rendering images --- see
  Sections~\ref{sect:gsobjectmethods}~\&~\ref{sect:image}.
\item Add noise to the \texttt{Image}~using one of the GalSim
  random deviate classes --- see Section~\ref{sect:random}.
\item Add the postage stamp \texttt{Image}~to a subsection of a larger
  \texttt{Image} 
  instance --- see
  Section~\ref{sect:imagemethods} --- or to a Python
  \texttt{list} containing multiple \texttt{Image} instances.
\item Save the \texttt{Image}(s) to file in FITS (Flexible Image Transport
  System) format --- see Sections~\ref{sect:imagemethods}~\&~\ref{sect:multifits}.
\end{itemize}

There are many examples of this workflow in the directory {\tt
 examples/}, showing most of the GalSim library in action, in
the scripts named \texttt{demo1.py} -- \texttt{demo8.py}.  This
document provides a brief, reference description of the GalSim classes
and methods which can be used in these workflows.

Where possible in the following Sections this document has been hyperlinked to the online
GalSim documentation generated by \emph{doxygen}, where a more detailed
description can be found.  We also suggest accessing the full docstrings for \emph{all} the
classes and functions described below in Python itself, e.g.\ by typing

{\tt >>> help(galsim.<ObjectName>)}

within the Python interpreter.  If using the \emph{ipython} package,
which is recommended, instead simply type

{\tt In [1]: galsim.<ObjectName>?}

and be sure to use the excellent tab-completion feature to explore the many
methods and attributes of the GalSim classes.

\newpage

%\section{GSObject classes and methods}
\section{GSObjects}\label{sect:gsobjects}

\subsection{GSObject classes and when to use them}\label{sect:gsobjectclasses}
There are currently 13 types of \texttt{GSObject}s that represent
various types of surface brightness profiles. The first 11 listed are
`simple' \texttt{GSObject}s that can be initialized by providing
values for their required and optional parameters.  The last two are
`compound' classes used to represent combinations of
\texttt{GSObject}s.

They are summarized in the following hyperlinked list, in which we also give
the required parameters for initializing each class in parentheses
after the class name.  For more information and initialization details for each \texttt{GSObject},
the Python docstring for each class is available within the Python interpreter, for example for
\texttt{Sersic} the documentation would be accessed using 

{\tt >>> help(galsim.Sersic)}

Alternatively follow the hyperlinks on
the class names listed below to view the documentation based
on the Python docstrings.

We now list, in the order in which
the classes appear in {\tt galsim/base.py}, the \texttt{GSObject}s.
Where multiple options for specifying the object \emph{\texttt{size}}
exist we list these in the object description. We also show some of the non-optional
parameters available for use (e.g.\ total \texttt{flux}) along with default values:
\begin{itemize}
\item[$\circ$]
  \texttt{galsim.}\href{http://galsim-developers.github.com/GalSim/classgalsim_1_1base_1_1_gaussian.html}{\texttt{Gaussian}}\texttt{(\emph{size}, flux=1.)}
  \newline {a 2D Gaussian light profile. Requires one of the
    following \emph{\texttt{size}} parameters to be set as a keyword argument: \texttt{sigma}; \texttt{fwhm}; \texttt{half\_light\_radius}.}
\item[$\circ$]
  \texttt{galsim.}\href{http://galsim-developers.github.com/GalSim/classgalsim_1_1base_1_1_moffat.html}{\texttt{Moffat}}\texttt{(beta, \emph{size}, flux=1.)}
  \newline {a Moffat profile with slope parameter \texttt{beta}, used to approximate ground-based
    telescope PSFs. Requires one of the
    following \emph{\texttt{size}} parameters to be set as a keyword argument: \texttt{scale\_radius};
    \texttt{fwhm}; \texttt{half\_light\_radius}.  For information
    about other optional parameters, see the documentation for this object.}
\item[$\circ$]
  \texttt{galsim.}\href{http://galsim-developers.github.com/GalSim/classgalsim_1_1base_1_1_atmospheric_p_s_f.html}{\texttt{AtmosphericPSF}}\texttt{(\emph{size}, flux=1.)}
  \newline {currently simply an image-based
  implementation of a Kolmogorov PSF (see below), and therefore deprecated, but expected to evolve to
  store a stochastically modelled atmospheric PSF in the near future.
Requires one of the
    following \emph{\texttt{size}} parameters to be set as a keyword argument:
    \texttt{fwhm}; \texttt{lam\_over\_r0}.  For information
    about other optional parameters, see the documentation for this object.}
\item[$\circ$]
  \texttt{galsim.}\href{http://galsim-developers.github.com/GalSim/classgalsim_1_1base_1_1_airy.html}{\texttt{Airy}}\texttt{(lam\_over\_diam, obscuration=0., flux=1.)}
  \newline {an Airy PSF for ideal diffraction
  through a circular aperture, parametrized by the wavelength-aperture
  diameter ratio \texttt{lam\_over\_diam}, with optional
  \texttt{obscuration}.}
\item[$\circ$]
  \texttt{galsim.}\href{http://galsim-developers.github.com/GalSim/classgalsim_1_1base_1_1_kolmogorov.html}{\texttt{Kolmogorov}}\texttt{(\emph{size}, flux=1.)} 
  \newline {the Kolmogorov PSF for long-exposure
  images through a turbulent atmosphere. Requires one of the
    following \emph{\texttt{size}} parameters to be set as a keyword
    argument: \texttt{lam\_over\_r0}; \texttt{fwhm}; \\
\texttt{half\_light\_radius}.}
\item[$\circ$]
  \texttt{galsim.}\href{http://galsim-developers.github.com/GalSim/classgalsim_1_1base_1_1_optical_p_s_f.html}{\texttt{OpticalPSF}}\texttt{(lam\_over\_diam, flux=1.)}
  \newline {a simple model for non-ideal
  (aberrated) propagation through circular/square apertures, parametrized by the wavelength-aperture
  dimension ratio \texttt{lam\_over\_diam}, with
  optional \texttt{obscuration}.  For information
    about other optional parameters, see the documentation for this object.}
\item[$\circ$]
  \texttt{galsim.}\href{http://galsim-developers.github.com/GalSim/classgalsim_1_1base_1_1_interpolated_image.html}{\texttt{InterpolatedImage}}\texttt{(image, \dots)} 
  \newline {a base class representing in principle
    arbitrary surface brightness
    profiles for which we have an Image representation.  For information
    about other optional parameters, see the documentation for this object.}
\item[$\circ$]
  \texttt{galsim.}\href{http://galsim-developers.github.com/GalSim/classgalsim_1_1base_1_1_pixel.html}{\texttt{Pixel}}\texttt{(xw, yw = None, flux=1.)} 
  \newline {used for integrating light onto square or
  rectangular pixels, requires at least one side dimension
  \texttt{xw}.  If no width \texttt{yw} for the $y$ dimension of the
  \texttt{Pixel}} is given, the assumed shape is square.
\item[$\circ$]
  \texttt{galsim.}\href{http://galsim-developers.github.com/GalSim/classgalsim_1_1base_1_1_sersic.html}{\texttt{Sersic}}\texttt{(n, half\_light\_radius, flux=1.)} 
  \newline{ the S\'{e}rsic family of galaxy light
  profiles, parametrized by an index \texttt{n} and \texttt{half\_light\_radius}.}
\item[$\circ$]
  \texttt{galsim.}\href{http://galsim-developers.github.com/GalSim/classgalsim_1_1base_1_1_exponential.html}{\texttt{Exponential}}\texttt{(\emph{size}, flux=1.)}
  \newline {the Exponential galaxy disc profile, a S\'{e}rsic
    with index \texttt{n=1}.  Requires one of the
    following \texttt{\emph{size}} parameters to be set as a keyword argument: \texttt{scale\_radius}; \texttt{half\_light\_radius}.}
\item[$\circ$]
  \texttt{galsim.}\href{http://galsim-developers.github.com/GalSim/classgalsim_1_1base_1_1_de_vaucouleurs.html}{\texttt{DeVaucouleurs}}\texttt{(half\_light\_radius, flux=1.)}
  \newline {the De Vaucouleurs galaxy bulge profile, a S\'{e}rsic
    with index \texttt{n=4} and input
    \texttt{half\_light\_radius}.}
\item[$\circ$]
  \texttt{galsim.}\href{http://galsim-developers.github.com/GalSim/classgalsim_1_1base_1_1_real_galaxy.html}{\texttt{RealGalaxy}}\texttt{(real\_galaxy\_catalog, \dots)} 
  \newline {models galaxies using real
  data, including a correction for the original PSF.   Requires the
  download of external data, stored and input as the
  \texttt{real\_galaxy\_catalog} parameter (an instance of the
  \href{http://galsim-developers.github.com/GalSim/classgalsim_1_1real_1_1_real_galaxy_catalog.html}{\texttt{RealGalaxyCatalog}}
  class), for full functionality.  

  An example catalog of 100 real galaxies is in the repository itself; a set of $\sim$26\,000 real galaxy
  images, with original PSFs, can be downloaded from the
  \emph{RealGalaxy Data Download Page} on the 
  \emph{GalSim Wiki}: \newline
  \href{https://github.com/GalSim-developers/GalSim/wiki/RealGalaxy\%20Data\%20Download\%20Page}{\emph{https://github.com/GalSim-developers/GalSim/wiki/RealGalaxy\%20Data\%20Download\%20Page}}. \newline
For information
    about other optional parameters, see the documentation for this object.}
\item[$\circ$]
  \texttt{galsim.}\href{http://galsim-developers.github.com/GalSim/classgalsim_1_1base_1_1_add.html}{\texttt{Add}}\texttt{( [ list of objects ] )}
  \newline {a {compound} object representing the sum of 
  multiple \texttt{GSObject}s.}
\item[$\circ$]
  \texttt{galsim.}\href{http://galsim-developers.github.com/GalSim/classgalsim_1_1base_1_1_convolve.html}{\texttt{Convolve}}\texttt{( [ list of objects ] )}
  \newline {a compound object representing the convolution of 
multiple \texttt{GSObject}s.}
\end{itemize}

Note that all of the \texttt{GSObject}s except for \texttt{RealGalaxy}, \texttt{Add}, and
\texttt{Convolve} {\em require} the specification of one radius size
parameter. 

\subsection{Units}
The choice of units for the size parameters is up to the user,
but it must be kept consistent between all \texttt{GSObjects}.  These
units must also adopted when specifying the \texttt{Image} pixel
scale \texttt{dx}, whether this is set via the \texttt{GSObject}
instance methods \texttt{obj.}\href{http://galsim-developers.github.com/GalSim/classgalsim_1_1base_1_1_g_s_object.html#ae0b346a8b438dedbc7f60a52220869d8}{\texttt{draw}}\texttt{(\dots)}
and
\texttt{obj.}\href{http://galsim-developers.github.com/GalSim/classgalsim_1_1base_1_1_g_s_object.html#a42ac334d2840ba3fa832988e998beca0}{\texttt{drawShoot}}\texttt{(\dots)}
(see Section~\ref{sect:gsobjectmethods}),
or when setting the scale of an \texttt{Image} with a given
\texttt{dx} using the \texttt{image.setScale(dx)} method (see Section~\ref{sect:image}).

As an example, consider the
\texttt{lam\_over\_diam} parameter, which provides an angular scale for
the \texttt{Airy} via
the ratio $\lambda / D$ for light at wavelength $\lambda$ passing
through a telescope of diameter $D$. Putting both $\lambda$ and
$D$ in metres and taking the ratio gives \texttt{lam\_over\_diam} in
radians, but this is not a commonly used angular scale when describing
astronomical objects such as galaxies and stellar PSFs, nor is
it often used for image pixel scales.  If wishing to use arcsec, which
is more common in both cases, the user should multiply the result in
radians by the conversion factor
$648000 / \pi$.  In principle, however, any consistent
system of units could be used.


\subsection{Important GSObject methods}\label{sect:gsobjectmethods}
A number of methods are shared by all the \texttt{GSObject}s of
Section~\ref{sect:gsobjects}, and are also to be found in \\ {\tt
 galsim/base.py} within the definition of the
\texttt{GSObject} base class.  In what follows, we assume that a
\texttt{GSObject} labelled \texttt{obj} has been instantiated using
one of the calls described in the documentation linked above.  For
example,

{\tt >>> obj = galsim.Sersic(n=3.5, half\_light\_radius=1.743)}.

One important fact about \texttt{GSObject}s is that all of the
methods which change the properties of the astronomical object
represented by the instance (e.g., \texttt{setFlux()},
  \texttt{applyShear()} etc.) also make fundamental changes to the
  instance itself.  In most cases this will mean that special methods
  available to individual classes described in Section
  \ref{sect:gsobjectclasses}, such as \texttt{getFWHM()} for the
  \texttt{Moffat}, will be unavailable.

Once again, for more information regarding each \texttt{galsim.GSObject}~method,
the Python docstring is available

{\tt >>> help(obj.<methodName>)}

within the Python interpreter.  Alternatively follow the hyperlinks on
the class names above to view the documentation based
on the Python docstrings. 

Some of the most important and commonly-used methods for such an
instance are:
\begin{itemize}
\item[$\circ$]
  \texttt{obj.}\href{http://galsim-developers.github.com/GalSim/classgalsim_1_1base_1_1_g_s_object.html#aa0b398d4b0fca70211e4a73f81ea7e1a}{\texttt{copy}}\texttt{()}
  \newline {return a copy of the \texttt{GSObject}.}
\item[$\circ$]
  \texttt{obj.}\href{http://galsim-developers.github.com/GalSim/classgalsim_1_1base_1_1_g_s_object.html#a662d8ce421ecd90080bdcaaf6890aed8}{\texttt{centroid}}\texttt{()}
  \newline {return the $(x, y)$ centroid of the \texttt{GSObject} as a
    \texttt{PositionD} (see Section~\ref{sect:bounds}).}
\item[$\circ$]
  \texttt{obj.}\href{http://galsim-developers.github.com/GalSim/classgalsim_1_1base_1_1_g_s_object.html#a662d8ce421ecd90080bdcaaf6890aed8}{\texttt{getFlux}}\texttt{()}
  \newline {get the flux of the \texttt{GSObject}.}
\item[$\circ$]
  \texttt{obj.}\href{http://galsim-developers.github.com/GalSim/classgalsim_1_1base_1_1_g_s_object.html#af4193645a9af52e7d54a044cafec8ab9}{\texttt{scaleFlux}}\texttt{(flux\_ratio)}
  \newline {multiply the flux of the \texttt{GSObject}~by \texttt{flux\_ratio}.}
\item[$\circ$]
  \texttt{obj.}\href{http://galsim-developers.github.com/GalSim/classgalsim_1_1base_1_1_g_s_object.html#a1993652591ddc802b734186391b28894}{\texttt{setFlux}}\texttt{(flux)}
    \newline {set the flux of the \texttt{GSObject}~to \texttt{flux}.}
\item[$\circ$]
  \texttt{obj.}\href{http://galsim-developers.github.com/GalSim/classgalsim_1_1base_1_1_g_s_object.html#ad491a1276fda07b148c6466d5dbd07b1}{\texttt{applyTransformation}}\texttt{(ellipse)}
\newline {apply an \texttt{Ellipse} transformation represented by
  \texttt{ellipse} to the \texttt{GSObject} (see \href{http://galsim-developers.github.com/GalSim/classgalsim_1_1ellipse_1_1_ellipse.html}{\texttt{Ellipse}}; Section~\ref{sect:shears}).}
\item[$\circ$]
  \texttt{obj.}\href{http://galsim-developers.github.com/GalSim/classgalsim_1_1base_1_1_g_s_object.html#a4301c73bbc1491ebb170e64c509cadd5}{\texttt{applyDilation}}\texttt{(scale)}
  \newline {change of the linear size of the \texttt{GSObject}~by a
    factor \texttt{scale}, conserving flux.}
\item[$\circ$]
  \texttt{obj.}\href{http://galsim-developers.github.com/GalSim/classgalsim_1_1base_1_1_g_s_object.html#a9d13b0238057f6d5d01f2681d91c09b0}{\texttt{applyMagnification}}\texttt{(scale)}
  \newline {dilate linear size by \texttt{scale} and multiply total flux by
  \texttt{scale}$^2$, conserving surface brightness.}
\item[$\circ$]
  \texttt{obj.}\href{http://galsim-developers.github.com/GalSim/classgalsim_1_1base_1_1_g_s_object.html#a85cc0094dcf470cfbff93d9830ab80bd}{\texttt{applyShear}}\texttt{(\dots)}
  \newline {apply a shear to the \texttt{GSObject}, handling a number of different
  input conventions (see also 
  \href{http://galsim-developers.github.com/GalSim/classgalsim_1_1shear_1_1_shear.html}{\texttt{Shear}};
  Section~\ref{sect:shears}).  Commonly-used input conventions
  (supplied as keyword arguments, default values zero):
   \begin{itemize}
  \item \texttt{obj.applyShear(g1=g1, g2=g2)} \\
    apply the first (\texttt{g1}) and second (\texttt{g2}) component
    of a shear defined so that $|g| = (a - b) / (a + b)$ where $a$ and
    $b$ are the semi-major and semi-minor axes of an ellipse.
   \item \texttt{obj.applyShear(e1=e1, e2=e2)} \\
   apply the first (\texttt{e1}) and second (\texttt{e2}) component
    of a shear defined so that $|e| = (a^2 - b^2) / (a^2 + b^2)$ where $a$ and
    $b$ are the semi-major and semi-minor axes of an ellipse.
   \item \texttt{obj.applyShear(g=g, beta=beta)} \\
   apply magnitude (\texttt{g}) and polar angle (\texttt{beta}) of a
   shear defined using the $|g|$ definition above. %so that $|g| = (a - b) / (a + b)$ where $a$ and
    %$b$ are the semi-major and semi-minor axes of an ellipse.
   \item \texttt{obj.applyShear(e=e, beta=beta)} \\
    apply magnitude (\texttt{e}) and polar angle (\texttt{beta}) of a
   shear defined using the $|e|$ definition above.%so that $|e| = (a^2 - b^2) / (a^2 + b^2)$ where $a$ and
    %$b$ are the semi-major and semi-minor axes of an ellipse.
   \end{itemize}}
\item[$\circ$]
  \texttt{obj.}\href{http://galsim-developers.github.com/GalSim/classgalsim_1_1base_1_1_g_s_object.html#ad6236e3153f23f1201396369dd67f1c7}{\texttt{applyRotation}}\texttt{(theta)}
  \newline {apply a rotation of \texttt{theta} (positive direction
  anti-clockwise) to the \texttt{GSObject}, where \texttt{theta} is an
  \texttt{Angle} instance (see Section~\ref{sect:angles}).}
\item[$\circ$]
  \texttt{obj.}\href{http://galsim-developers.github.com/GalSim/classgalsim_1_1base_1_1_g_s_object.html#a6b547741eeec4086de9abe227dae9325}{\texttt{applyShift}}\texttt{(dx, dy)} 
  \newline {apply a $(dx, dy)$ position shift to the
    \texttt{GSObject} centroid.}
\item[$\circ$]
  \texttt{image = obj.}\href{http://galsim-developers.github.com/GalSim/classgalsim_1_1base_1_1_g_s_object.html#ae0b346a8b438dedbc7f60a52220869d8}{\texttt{draw}}\texttt{(image=None, dx=None, add\_to\_image=False, \dots)}
  \newline {draw and return an \texttt{Image} (see Section \ref{sect:image}) of the \texttt{GSObject}~using Discrete Fourier
  Transforms and interpolation to perform the image rendering.  
  Note
  that if a profile is not convolved with a pixel response before drawing, then
  \texttt{draw} samples the surface brightness distribution without
  integrating within pixels, so the sum of pixel values might not
  equal the GSObject flux.
  Some information about important optional parameters (see the
  linked / Python docstrings for more detail), along with default values:
  \begin{itemize}
  \item \texttt{image} (default = \texttt{None}) \newline 
    if supplied, the drawing will be done into a user-supplied
    \texttt{Image} instance \texttt{image}.  If not supplied
    (i.e. \texttt{image = None}), an
    automatically-sized \texttt{Image} instance will be returned.
  \item \texttt{dx} (default = \texttt{None}) \newline 
    the optional image pixel scale \texttt{dx}, which if provided
    should use the same units as used for the \texttt{GSObject} size
    parameters.  If not provided, will take either the scale from a
    supplied \texttt{image}, else use the Nyquist scale given the
    maximum modelled frequency in the \texttt{GSObject}.
  \item \texttt{add\_to\_image} (default = \texttt{False}) \newline
   Whether to add flux to a (must be supplied) \texttt{image} rather than clear out
   anything in the image before drawing.
 \end{itemize}
The \texttt{draw} method has a number of additional optional
 parameters.  Please see the linked / Python docstrings for more
 details.
 }
\item[$\circ$]
  \texttt{image = obj.}\href{http://galsim-developers.github.com/GalSim/classgalsim_1_1base_1_1_g_s_object.html#a42ac334d2840ba3fa832988e998beca0}{\texttt{drawShoot}}\texttt{(image=None, dx=None, \\~~ add\_to\_image=False, \dots)}
  \newline {draw and return an \texttt{Image} (see
    Section \ref{sect:image}) of the \texttt{GSObject}~by shooting a
    finite number of photons.
    The resulting rendering therefore
    contains stochastic noise, but uses few approximations.  Note
    however, that you cannot \texttt{drawShoot} with a
    \texttt{RealGalaxy} instance.  \texttt{drawShoot} shares all the parameters
    listed for \texttt{draw}, above, but the \texttt{drawShoot} method
    also has a number of additional optional parameters. Important
    examples worthy of mention are:
\begin{itemize}
\item \texttt{n\_photons} (default = \texttt{0}) \newline If provided,
  the number of photons to use.  If not provided, use as many photons
  as necessary to end up with an image with the correct poisson shot
  noise for the object's \texttt{flux}.
\item \texttt{max\_extra\_noise} (default = \texttt{0.}) \newline If
  provided, the allowed extra noise in each pixel.  This is only
  relevant if \texttt{n\_photons = 0}, so the number of photons is
  being automatically calculated.  In that case, if the image noise is
  dominated by the sky background, you can get away with using fewer
  shot photons than the full \texttt{n\_photons = flux}.  Essentially
  each shot photon can have a $\texttt{flux} > 1$, which increases the
  noise in each pixel.  The \texttt{max\_extra\_noise} parameter
  specifies how much extra noise per pixel is allowed because of this
  approximation.
\item \texttt{poisson\_flux} (default = \texttt{True}) \newline
  Whether to allow total object flux scaling to vary according to
  Poisson statistics for \texttt{n\_photons} samples.
\end{itemize}
As before, you are strongly encouraged to see the linked / Python
docstrings for more details.
}
\end{itemize}

Finally, you may see by exploring the docstrings that many of the \texttt{GSObject}
instances also have their own specialized methods, often for
retrieving parameter values. Examples are
  \texttt{obj.}\href{http://galsim-developers.github.com/GalSim/classgalsim_1_1base_1_1_gaussian.html#a418f2826a7b8934cfedc181de23ce826}{\texttt{getSigma}}\texttt{()}
for the
\href{http://galsim-developers.github.com/GalSim/classgalsim_1_1base_1_1_gaussian.html}{\texttt{Gaussian}},
or
  \texttt{obj.}\href{http://galsim-developers.github.com/GalSim/classgalsim_1_1base_1_1_sersic.html#ad6ca39293c6b478fc052d07ea51d086f}{\texttt{getHalfLightRadius}}\texttt{()}
for many of the \texttt{GSObject}s.

\section{Random deviates}\label{sect:random}
\subsection{Random deviate classes and when to use them}
Random deviates can be used to add a stochastic
component to the modelling of astronomical images, such as drawing
object parameters according to a given distribution or generating random
numbers to be added to image pixel values to model noise. 

We now give a short summary of the 9 random deviates currently
implemented in GalSim.   The optional parameter \emph{\texttt{seed}}
listed below is used
to seed the pseudo-random number generator: it can
either be omitted (the random deviate seed will be set using the
current time), set to an integer seed, or used to pass another random
deviate (the new instance will then use and update the same underlying
generator as the input deviate).
The deviates, with a description of their distributions, parametrization and
default parameter values, are as follows:
\begin{itemize}

\item[$\circ$] \texttt{galsim.UniformDeviate(\emph{seed})} \newline {uniform distribution in the
  interval $[0, 1)$.}

\item[$\circ$] \texttt{galsim.GaussianDeviate(\emph{seed}, mean=0., sigma=1.)} \newline {Gaussian distribution
with \texttt{mean} and standard deviation \texttt{sigma}.}

\item[$\circ$] \texttt{galsim.BinomialDeviate(\emph{seed}, N=1, p=0.5)} \newline {Binomial
    distribution for \texttt{N} trials each of probability \texttt{p}.}

\item[$\circ$] \texttt{galsim.PoissonDeviate(\emph{seed}, mean=1.)} \newline {Poisson distribution
    with a single \texttt{mean} rate.}

\item[$\circ$] \texttt{galsim.WeibullDeviate(\emph{seed}, a=1., b=1.)} \newline {Weibull distribution
    family (includes Rayleigh and Exponential) with shape parameters \texttt{a} and \texttt{b}.}

\item[$\circ$] \texttt{galsim.GammaDeviate(\emph{seed}, alpha=1., beta=1.)} \newline {Gamma distribution with
    parameters \texttt{alpha} and \texttt{beta}.}

\item[$\circ$] \texttt{galsim.Chi2Deviate(\emph{seed}, n=1.)} \newline {$\chi^2$ distribution
    with degrees-of-freedom parameter \texttt{n}.}

\item[$\circ$] \texttt{galsim.DistDeviate(\emph{seed}, function, x\_min, x\_max)}  \newline {Use an 
    arbitrary function for $P(x)$ from \texttt{x\_min} .. \texttt{x\_max}.}

\end{itemize}

It is possible to specify the random seed so as to get fully
deterministic behavior of the noise when running a particular script.
Unfortunately the random deviate classes are not yet fully integrated
within the documentation, due to their being C++ with compiled Python
wrappers.  This means that the class names above and methods below are
not yet hyperlinked.  For more information, please refer to the full docstrings in
\texttt{galsim/random.py}, 
or type

{\tt >>> help(galsim.<RandomDeviateName>)}

within the Python interpreter.

\subsection{Important random deviate methods}\label{sect:randommethods}
We now illustrate the most commonly-used methods of the random
deviates, assuming that some random deviate instance \texttt{dev} has
been instantiated, for example by

{\tt >>> dev = galsim.GaussianDeviate(sigma=3.9, mean=50.)}.

The most important and commonly-used method for such
instances is:
\begin{itemize}

\item[$\circ$] \texttt{dev()} \newline {calling the deviate
    directly simply returns a single new random number drawn from the
    distribution
    represented by \texttt{dev}.  As an example:\newline \\
    {\tt >>> dev = galsim.UniformDeviate(12345)}\\
    {\tt >>> dev()} \\
    {\tt 0.9296160866506398} \\
    {\tt >>> dev() }\\
    {\tt 0.8901547130662948}}

\end{itemize}

\subsection{Noise models}\label{sect:noisemodels}

One common way to use the random deviates is as part of a noise model for adding 
noise to an image.  These have their own separate hierarchy of classes

\begin{itemize}
\item[$\circ$] \texttt{galsim.GaussianNoise(rng, sigma=1.)} 
\newline {Every pixel gets Gaussian noise with rms \texttt{sigma}.}

\item[$\circ$] \texttt{galsim.PoissonNoise(rng, sky\_level=0.)} 
\newline {Every pixel gets Poisson noise according to the flux in the image plus an option sky level, \texttt{sky\_level}.}

\item[$\circ$] \texttt{galsim.DeviateNoise(dev)} 
\newline {The noise value for every pixel is drawn from the given Deviate instance.}

\item[$\circ$] \texttt{galsim.CCDNoise(rng, sky\_level=0., gain=1., read\_noise=0.)}  
\newline {A combination of Poisson noise (with a gain value in electrons/ADU) and Gaussian read noise.}

\end{itemize}

These noise models are used with a method of \texttt{Image} objects
(see Section \ref{sect:image}, below).  This takes the following form:

\begin{itemize}

\item[$\circ$] \texttt{image.addNoise(noise)} \newline {this adds
    stochastic noise, according to the noise model \texttt{noise},
    to each element of the data array in the
    \texttt{Image} instance \texttt{image}.}

\end{itemize}

\section{Images}\label{sect:image}

\subsection{Image classes and when to use them}\label{sect:imageclasses}
The GalSim \texttt{Image} classes store array data, along with a
figure for the pixel separation in physical units and image bounds
information (origin, extent).\footnote{
There are additional flavours
of \texttt{Image} that you might also encounter: \texttt{ImageView}
provides a mutable view into \texttt{Image} instance data, and
\texttt{ConstImageView} an immutable view into \texttt{Image}
instance data.  These may be the type of images returned from
various GalSim functions, but as they work the same way as \texttt{Image},
you shouldn't notice the difference.  See their docstrings for more information.}
\texttt{Image} instances can be operated upon to add stochastic noise
simulating real astronomical images (see Section~\ref{sect:random}),
and have methods for writing to FITS format output.

There are four types of GalSim \texttt{Image}, one for each of four
supported array data types.  The most common way to initialize an
image is with two integer parameters \texttt{nx} and \texttt{ny},
giving the image extent in the $x$ and $y$ dimensions, respectively.
Example initialization calls for the four types of \texttt{Image} are
therefore:
\begin{itemize}
\item[$\circ$] \texttt{galsim.ImageS(nx, ny)} {for short integers (typically 16 bit).}

\item[$\circ$] \texttt{galsim.ImageI(nx, ny)} {for integers (typically 32 bit).}

\item[$\circ$] \texttt{galsim.ImageF(nx, ny)} {for single precision (typically 32 bit)
  floats.}

\item[$\circ$] \texttt{galsim.ImageD(nx, ny)} {for double precision (typically 64 bit)
  floats.}

\end{itemize}
Other ways to construct an \texttt{Image} can be found in the docstrings.

To access the data as a NumPy array, simply use the \texttt{image.array}
attribute, where \texttt{image} is an instance of one of these
\texttt{Image} classes.  However, note that the individual elements in
the array attribute are accessed as \texttt{image.array[y,x]}, matching
the standard NumPy convention, while the \texttt{Image} class's own
accessors are all $(x,y)$ in ordering.

Unfortunately the \texttt{Image} classes are not yet fully integrated
within the online documentation, due to their being in C++ with
compiled Python wrappers.  This means that the class names above and
methods below are not hyperlinked.  However, the full docstrings are
available in \texttt{galsim/image.py}, so please refer there for more
information, or type

{\tt >>> help(galsim.<ImageName>)}

within the Python interpreter.

\subsection{Important Image methods and operations}\label{sect:imagemethods}
We now illustrate the most commonly-used methods of \texttt{Image}
class instances.  We will assume that some \texttt{Image} instance
\texttt{image} has been instantiated, for example by

{\tt >>> image = galsim.ImageD(100, 100)}.

This \texttt{Image} instance is then ready to pass to a
\texttt{GSObject} for drawing.  The most important and commonly-used
methods for such an instance are:
\begin{itemize}

\item[$\circ$] \texttt{image.getScale()} \newline {get the pixel
    scale \texttt{dx} for this image.}

\item[$\circ$] \texttt{image.setScale(dx)} \newline {set the pixel
    scale for this image to \texttt{dx} --- note that this scale
    should use the same units adopted for the \texttt{GSObject}
    sizes.}

\item[$\circ$] \texttt{image.addNoise(dev)} \newline {this adds
    stochastic noise, distributed as represented by the random deviate
    instance \texttt{dev}, to each element of the data array in
    \texttt{image}.  This is the method previously referenced in Section~\ref{sect:random}.}

\item[$\circ$] \texttt{image.write(fits, \dots)}  \newline {write the
    \texttt{imageView} to a FITS file or object as determined by the
    \texttt{fits} input parameter
    (see \\
    \texttt{galsim/fits.py}).  In Section~\ref{sect:multifits} we
    discuss how to write to multi-extension FITS files.}

\end{itemize}

\texttt{Image}\footnote{Actually, the functionally almost-equivalent
  \texttt{ImageView}, see the footnote in Section
  \ref{sect:imageclasses}.}  instances are also returned when
accessing a sub-section of an existing \texttt{Image}.  For example

{\tt >>> imsub = image.subImage(bounds)}

where \texttt{bounds} is a \texttt{BoundsI} instance (see Section
\ref{sect:bounds}) assigns \texttt{imsub} as an view into
the sub-region of \texttt{image} lying in the area represented by
\texttt{bounds}.  Equivalent syntax is also

{\tt >>> imsub = image[bounds]}

It is also possible to change the values of a sub-region of an image
this way, for example

{\tt >>> image[imsub.bounds] += imsub}

if wishing to add the contents of \texttt{imsub} to the area lying
within its bounds in \texttt{image}.  Note that here we have made use of
the \texttt{image.bounds} attribute carried by all of the \texttt{Image}
classes.

\section{Miscellaneous classes and functions}\label{sect:misc}

A summary of miscellaneous GalSim library objects, subcategorized into
broad themes.  As ever, docstrings for \emph{all} the classes and
functions below can be accessed via

{\tt >>> help(galsim.<Name>)}

within the Python interpreter.

\subsection{Angles}\label{sect:angles}
\begin{itemize}

\item[$\circ$] \texttt{galsim.Angle(value, angle\_unit)} \newline
  {class to represent angles (with multiple unit types),
    which can be initialized by multiplying a numerical
    value and an \texttt{AngleUnit} instance \texttt{angle\_unit} (see
    below, and \texttt{galsim/angle.py}).}

\item[$\circ$] \texttt{galsim.AngleUnit} \newline {There are five built-in \texttt{AngleUnit}s which are
    always available for use:
 \begin{itemize}
 \item {\tt galsim.radians}
 \item {\tt galsim.degrees}
 \item {\tt galsim.hours}
 \item {\tt galsim.arcmin}
 \item {\tt galsim.arcsec}
 \end{itemize}}
 Please see the Python docstrings for information about defining your
 own \texttt{AngleUnit}s.
\end{itemize}

\subsection{Bounds and Positions}\label{sect:bounds}

\begin{itemize}

\item[$\circ$] \texttt{galsim.BoundsI(\dots)} \newline
  \texttt{galsim.BoundsD(\dots)} \newline {classes to represent
    image boundaries as the vertices of
    a rectangle (see \texttt{galsim/bounds.py}).}

\item[$\circ$] \texttt{galsim.PositionI(x, y)} \newline
  \texttt{galsim.PositionD(x, y)} \newline {classes to represent
    2D positions on the \texttt{x}-\texttt{y} plane (see
    \texttt{galsim/position.py}), e.g., for describing object centroid
    positions.}

For both bounds and positions, the \texttt{I} and \texttt{D} refer to
integer and double-precision floating point representations.

\end{itemize}

\subsection{Shear and Ellipse transformations}\label{sect:shears}

\begin{itemize}

\item[$\circ$]
  \texttt{galsim.}\href{http://galsim-developers.github.com/GalSim/classgalsim_1_1shear_1_1_shear.html}{\texttt{Shear}}\texttt{(\dots)}
  \newline {class to represent shears in a variety of ways.  This class can be initialized using a
    variety of different parameter conventions (see
    \texttt{galsim/shear.py}).  Commonly-used examples (supplied as
    keyword arguments, default values zero):
   \begin{itemize}
  \item \texttt{galsim.Shear(g1=g1, g2=g2)} \\
    set via the first (\texttt{g1}) and second (\texttt{g2}) component
    of a shear defined so that $|g| = (a - b) / (a + b)$ where $a$ and
    $b$ are the semi-major and semi-minor axes of an ellipse.
   \item \texttt{galsim.Shear(e1=e1, e2=e2)} \\
   set via the first (\texttt{e1}) and second (\texttt{e2}) component
    of a shear defined so that $|e| = (a^2 - b^2) / (a^2 + b^2)$ where $a$ and
    $b$ are the semi-major and semi-minor axes of an ellipse.
   \item \texttt{galsim.Shear(g=g, beta=beta)} \\
   set via magnitude (\texttt{g}) and polar angle (\texttt{beta}) of a
   shear defined according to the $|g|$ definition above.
   \item \texttt{galsim.Shear(e=e, beta=beta)} \\
    set via magnitude (\texttt{e}) and polar angle (\texttt{beta}) of a
   shear defined according to the $|e|$ definition above.
   \end{itemize}}

\item[$\circ$]
  \texttt{galsim.}\href{http://galsim-developers.github.com/GalSim/classgalsim_1_1ellipse_1_1_ellipse.html}{\texttt{Ellipse}}\texttt{(\dots)}
  \newline {class to represent ellipses and thus ellipse-type
    transformations, specifically shears, shifts, and dilations.  The class can be initialized using a variety of
    different parameter conventions (see, e.g., \texttt{galsim/ellipse.py}),
    including being initialized with a Shear instance.}

\end{itemize}

\subsection{Lensing shear fields}\label{sect:lensing}

GalSim has functionality to simulate scientifically-motivated lensing
shear fields. The code and documentation for the
``lensing engine'' is in {\tt galsim/lensing.py}.  The two relevant
classes for users are:

\begin{itemize}
\item[$\circ$]
  \texttt{galsim.}\href{http://galsim-developers.github.com/GalSim/classgalsim_1_1lensing_1_1_power_spectrum.html}{\texttt{PowerSpectrum}}\texttt{(\dots)}
  \newline {represents a flat-sky shear power spectrum $P(k)$, where the $E$ and
    $B$-mode power spectra can be separately specified as 
    \texttt{E\_power\_function} and \texttt{B\_power\_function}.  The
    \texttt{getShear(\dots)} method is used to generate a random realization of
    a shear field from a given \texttt{PowerSpectrum} object,
    and there are methods to get convergence or magnification as well.}

\item[$\circ$]
  \texttt{galsim.}\href{http://galsim-developers.github.com/GalSim/classgalsim_1_1lensing_1_1_n_f_w_halo.html}{\texttt{NFWHalo}}\texttt{(\dots)}
  \newline {represents a matter density profile corresponding to a projected,
    circularly-symmetric NFW profile such as might be used to simulate lensing
    by a galaxy cluster.  This class has two methods of interest for users,
    \texttt{getShear()} and \texttt{getConvergence()}, which can be used to get
    the shears and convergences at {\em any} (non-gridded) image-plane
    position.}
\end{itemize}

These classes have additional requirements on the units used to specify
positions; see the documentation for these classes for more details.

The GalSim repository also contains a module with a
PowerSpectrumEstimator class that can be used to estimate shear power
spectra from gridded shear values even if GalSim is not installed:
galsim/pse.py (see documentation in that file for more information).

\subsection{Additional FITS input/output tools}\label{sect:multifits}

\begin{itemize}

\item[$\circ$] \texttt{image = galsim.fits.read(fits)} \newline
{returns an \texttt{Image} instance \texttt{image} from a FITS
  representation \texttt{fits}.  If \texttt{fits} is a string it is
  interpreted as a filename, otherwise it is interpreted as a PyFITS
  representation of HDU data (see
  \texttt{galsim/fits.py}).}
\item[$\circ$] \texttt{image\_list = galsim.fits.readMulti(fits)}
  \newline
{returns a Python \texttt{list} of \texttt{Image} instances (\texttt{image\_list}) from a
Multi-Extension FITS file or PyFITS HDU object, specified by the
\texttt{fits} input parameter (see \texttt{galsim/fits.py}).}
\item[$\circ$] \texttt{galsim.fits.writeMulti(image\_list, fits, \dots)}
  \newline {write multiple \texttt{Image} instances stored in a Python
    \texttt{list} (\texttt{image\_list}) to a Multi-Extension
    FITS file or PyFITS HDU object, specified by the \texttt{fits} input
    parameter (see \texttt{galsim/fits.py}).}
\item[$\circ$] \texttt{galsim.fits.writeCube(image\_list, fits, \dots)}
  \newline {write multiple \texttt{Image} instances stored in a Python
    \texttt{list} (\texttt{image\_list}) to a three-dimensional
    FITS datacube or PyFITS HDU object, specified by the \texttt{fits} input
    parameter (see \texttt{galsim/fits.py}).}

\end{itemize}

The routines for reading and writing FITS images are able to handle
compressed inputs / outputs via keywords.

\end{document}
