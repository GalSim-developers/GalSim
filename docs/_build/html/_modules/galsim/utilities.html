<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>galsim.utilities &mdash; GalSim 2.7.0 documentation</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/sphinx_highlight.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            GalSim
          </a>
              <div class="version">
                2.7
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../overview.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../install.html">Installation Instructions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tutorials.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../image.html">Images and Related Concepts</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../sb.html">Surface Brightness Profiles</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../chromatic.html">Wavelength-dependent Profiles</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../units.html">Units</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../wcs.html">World Coordinate Systems</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../random.html">Noise and Random Values</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../wl.html">Weak Lensing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../photon.html">Photon Shooting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../utilities.html">Helper Functions and Classes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../errors.html">Errors and Warnings</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../config.html">The Config Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../hsm.html">The HSM Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../des.html">The DES Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../roman.html">The Roman Space Telescope Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../cpp.html">C++ Layer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../shared.html">Shared Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../history.html">Revision History</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">GalSim</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">galsim.utilities</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for galsim.utilities</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright (c) 2012-2023 by the GalSim developers team on GitHub</span>
<span class="c1"># https://github.com/GalSim-developers</span>
<span class="c1">#</span>
<span class="c1"># This file is part of GalSim: The modular galaxy image simulation toolkit.</span>
<span class="c1"># https://github.com/GalSim-developers/GalSim</span>
<span class="c1">#</span>
<span class="c1"># GalSim is free software: redistribution and use in source and binary forms,</span>
<span class="c1"># with or without modification, are permitted provided that the following</span>
<span class="c1"># conditions are met:</span>
<span class="c1">#</span>
<span class="c1"># 1. Redistributions of source code must retain the above copyright notice, this</span>
<span class="c1">#    list of conditions, and the disclaimer given in the accompanying LICENSE</span>
<span class="c1">#    file.</span>
<span class="c1"># 2. Redistributions in binary form must reproduce the above copyright notice,</span>
<span class="c1">#    this list of conditions, and the disclaimer given in the documentation</span>
<span class="c1">#    and/or other materials provided with the distribution.</span>
<span class="c1">#</span>
<span class="kn">import</span> <span class="nn">functools</span>
<span class="kn">from</span> <span class="nn">contextlib</span> <span class="kn">import</span> <span class="n">contextmanager</span>
<span class="kn">import</span> <span class="nn">weakref</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pstats</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">heapq</span>
<span class="kn">import</span> <span class="nn">multiprocessing</span>
<span class="kn">import</span> <span class="nn">cProfile</span><span class="o">,</span> <span class="nn">pstats</span>
<span class="kn">from</span> <span class="nn">io</span> <span class="kn">import</span> <span class="n">StringIO</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Hashable</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">Counter</span>
<span class="kn">import</span> <span class="nn">pickle</span>
<span class="kn">import</span> <span class="nn">copy</span>

<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">_galsim</span>
<span class="kn">from</span> <span class="nn">.errors</span> <span class="kn">import</span> <span class="n">GalSimError</span><span class="p">,</span> <span class="n">GalSimValueError</span><span class="p">,</span> <span class="n">GalSimIncompatibleValuesError</span><span class="p">,</span> <span class="n">GalSimRangeError</span>
<span class="kn">from</span> <span class="nn">.errors</span> <span class="kn">import</span> <span class="n">galsim_warn</span>
<span class="kn">from</span> <span class="nn">.position</span> <span class="kn">import</span> <span class="n">Position</span><span class="p">,</span> <span class="n">PositionD</span><span class="p">,</span> <span class="n">_PositionD</span>
<span class="kn">from</span> <span class="nn">.angle</span> <span class="kn">import</span> <span class="n">AngleUnit</span><span class="p">,</span> <span class="n">arcsec</span>
<span class="kn">from</span> <span class="nn">.image</span> <span class="kn">import</span> <span class="n">Image</span>
<span class="kn">from</span> <span class="nn">.table</span> <span class="kn">import</span> <span class="n">trapz</span><span class="p">,</span> <span class="n">_LookupTable</span><span class="p">,</span> <span class="n">LookupTable2D</span>
<span class="kn">from</span> <span class="nn">.wcs</span> <span class="kn">import</span> <span class="n">JacobianWCS</span><span class="p">,</span> <span class="n">PixelScale</span>
<span class="kn">from</span> <span class="nn">.random</span> <span class="kn">import</span> <span class="n">BaseDeviate</span><span class="p">,</span> <span class="n">UniformDeviate</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">meta_data</span>

<span class="c1"># A couple things are documented as galsim.utilties.* functions, but live in other files.</span>
<span class="c1"># Bring them into scope here.</span>
<span class="kn">from</span> <span class="nn">.interpolant</span> <span class="kn">import</span> <span class="n">convert_interpolant</span>
<span class="kn">from</span> <span class="nn">.table</span> <span class="kn">import</span> <span class="n">find_out_of_bounds_position</span>
<span class="kn">from</span> <span class="nn">.position</span> <span class="kn">import</span> <span class="n">parse_pos_args</span>
<span class="kn">from</span> <span class="nn">._utilities</span> <span class="kn">import</span> <span class="o">*</span>


<div class="viewcode-block" id="roll2d"><a class="viewcode-back" href="../../misc.html#galsim.utilities.roll2d">[docs]</a><span class="k">def</span> <span class="nf">roll2d</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">shape</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Perform a 2D roll (circular shift) on a supplied 2D NumPy array, conveniently.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        image:      The NumPy array to be circular shifted.</span>
<span class="sd">        shape:      (iroll, jroll) The roll in the i and j dimensions, respectively.</span>

<span class="sd">    Returns:</span>
<span class="sd">        the rolled array</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="p">(</span><span class="n">iroll</span><span class="p">,</span> <span class="n">jroll</span><span class="p">)</span> <span class="o">=</span> <span class="n">shape</span>
    <span class="c1"># The ascontiguousarray bit didn&#39;t used to be necessary.  But starting with</span>
    <span class="c1"># numpy v1.12, np.roll doesn&#39;t seem to always return a C-contiguous array.</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">jroll</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">iroll</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span></div>

<div class="viewcode-block" id="kxky"><a class="viewcode-back" href="../../misc.html#galsim.utilities.kxky">[docs]</a><span class="k">def</span> <span class="nf">kxky</span><span class="p">(</span><span class="n">array_shape</span><span class="o">=</span><span class="p">(</span><span class="mi">256</span><span class="p">,</span> <span class="mi">256</span><span class="p">)):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return the tuple (kx, ky) corresponding to the DFT of a unit integer-sampled array of</span>
<span class="sd">    input shape.</span>

<span class="sd">    Uses the FFTW conventions for Fourier space, so k varies in approximate range (-pi, pi],</span>
<span class="sd">    and the (0, 0) array element corresponds to (kx, ky) = (0, 0).</span>

<span class="sd">    See also the docstring for np.fftfreq, which uses the same DFT convention, and is called here,</span>
<span class="sd">    but misses a factor of pi.</span>

<span class="sd">    Adopts NumPy array index ordering so that the trailing axis corresponds to kx, rather than</span>
<span class="sd">    the leading axis as would be expected in IDL/Fortran.  See docstring for ``numpy.meshgrid``</span>
<span class="sd">    which also uses this convention.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        array_shape:    The NumPy array shape desired for kx, ky.</span>

<span class="sd">    Returns:</span>
<span class="sd">        kx, ky</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Note: numpy shape is y,x</span>
    <span class="n">k_xaxis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftfreq</span><span class="p">(</span><span class="n">array_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="mf">2.</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
    <span class="n">k_yaxis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftfreq</span><span class="p">(</span><span class="n">array_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="mf">2.</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">k_xaxis</span><span class="p">,</span> <span class="n">k_yaxis</span><span class="p">)</span></div>

<div class="viewcode-block" id="g1g2_to_e1e2"><a class="viewcode-back" href="../../misc.html#galsim.utilities.g1g2_to_e1e2">[docs]</a><span class="k">def</span> <span class="nf">g1g2_to_e1e2</span><span class="p">(</span><span class="n">g1</span><span class="p">,</span> <span class="n">g2</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Convenience function for going from (g1, g2) -&gt; (e1, e2).</span>

<span class="sd">    Here g1 and g2 are reduced shears, and e1 and e2 are distortions - see `Shear`</span>
<span class="sd">    for definitions of reduced shear and distortion in terms of axis ratios or other ways of</span>
<span class="sd">    specifying ellipses.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        g1:     First reduced shear component</span>
<span class="sd">        g2:     Second reduced shear component</span>

<span class="sd">    Returns:</span>
<span class="sd">        the corresponding distortions, e1 and e2.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Conversion:</span>
    <span class="c1"># e = (a^2-b^2) / (a^2+b^2)</span>
    <span class="c1"># g = (a-b) / (a+b)</span>
    <span class="c1"># b/a = (1-g)/(1+g)</span>
    <span class="c1"># e = (1-(b/a)^2) / (1+(b/a)^2)</span>
    <span class="n">gsq</span> <span class="o">=</span> <span class="n">g1</span><span class="o">*</span><span class="n">g1</span> <span class="o">+</span> <span class="n">g2</span><span class="o">*</span><span class="n">g2</span>
    <span class="k">if</span> <span class="n">gsq</span> <span class="o">==</span> <span class="mf">0.</span><span class="p">:</span>
        <span class="k">return</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">gsq</span><span class="p">)</span>
        <span class="n">boa</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">g</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">g</span><span class="p">)</span>
        <span class="n">e</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">boa</span><span class="o">*</span><span class="n">boa</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">boa</span><span class="o">*</span><span class="n">boa</span><span class="p">)</span>
        <span class="n">e1</span> <span class="o">=</span> <span class="n">g1</span> <span class="o">*</span> <span class="p">(</span><span class="n">e</span><span class="o">/</span><span class="n">g</span><span class="p">)</span>
        <span class="n">e2</span> <span class="o">=</span> <span class="n">g2</span> <span class="o">*</span> <span class="p">(</span><span class="n">e</span><span class="o">/</span><span class="n">g</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">e1</span><span class="p">,</span> <span class="n">e2</span></div>

<div class="viewcode-block" id="rotate_xy"><a class="viewcode-back" href="../../misc.html#galsim.utilities.rotate_xy">[docs]</a><span class="k">def</span> <span class="nf">rotate_xy</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">theta</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Rotates points in the xy-Cartesian plane counter-clockwise through an angle ``theta`` about</span>
<span class="sd">    the origin of the Cartesian coordinate system.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        x:      NumPy array of input x coordinates</span>
<span class="sd">        y:      NumPy array of input y coordinates</span>
<span class="sd">        theta:  Rotation angle (+ve counter clockwise) as an `Angle` instance</span>

<span class="sd">    Returns:</span>
<span class="sd">        the rotated coordinates (x_rot,y_rot).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">sint</span><span class="p">,</span> <span class="n">cost</span> <span class="o">=</span> <span class="n">theta</span><span class="o">.</span><span class="n">sincos</span><span class="p">()</span>
    <span class="n">x_rot</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">cost</span> <span class="o">-</span> <span class="n">y</span> <span class="o">*</span> <span class="n">sint</span>
    <span class="n">y_rot</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">sint</span> <span class="o">+</span> <span class="n">y</span> <span class="o">*</span> <span class="n">cost</span>
    <span class="k">return</span> <span class="n">x_rot</span><span class="p">,</span> <span class="n">y_rot</span></div>


<div class="viewcode-block" id="SimpleGenerator"><a class="viewcode-back" href="../../misc.html#galsim.utilities.SimpleGenerator">[docs]</a><span class="k">class</span> <span class="nc">SimpleGenerator</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A simple class that is constructed with an arbitrary object.</span>
<span class="sd">    Then generator() will return that object.</span>

<span class="sd">    This is useful as a way to use an already existing object in a multiprocessing Proxy,</span>
<span class="sd">    since that normally needs a factory function.  So this is a factory function that</span>
<span class="sd">    just returns an already existing object.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span> <span class="bp">self</span><span class="o">.</span><span class="n">_obj</span> <span class="o">=</span> <span class="n">obj</span>
    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>  <span class="c1"># pragma: no cover</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_obj</span></div>

<div class="viewcode-block" id="rand_arr"><a class="viewcode-back" href="../../misc.html#galsim.utilities.rand_arr">[docs]</a><span class="k">def</span> <span class="nf">rand_arr</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">deviate</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Function to make a 2d array of random deviates (of any sort).</span>

<span class="sd">    Parameters:</span>
<span class="sd">        shape:      A list of length 2, indicating the desired 2d array dimensions</span>
<span class="sd">        deviate:    Any GalSim deviate (see random.py) such as `UniformDeviate`, `GaussianDeviate`,</span>
<span class="sd">                    etc. to be used to generate random numbers</span>

<span class="sd">    Returns:</span>
<span class="sd">        a NumPy array of the desired dimensions with random numbers generated using the</span>
<span class="sd">        supplied deviate.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">shape</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">deviate</span><span class="o">.</span><span class="n">generate</span><span class="p">(</span><span class="n">tmp</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span>
    <span class="k">return</span> <span class="n">tmp</span></div>

<span class="c1"># A helper function for parsing the input position arguments for PowerSpectrum and NFWHalo:</span>
<span class="k">def</span> <span class="nf">_convertPositions</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">units</span><span class="p">,</span> <span class="n">func</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Convert ``pos`` from the valid ways to input positions to two NumPy arrays</span>

<span class="sd">    This is used by the functions getShear(), getConvergence(), getMagnification(), and</span>
<span class="sd">    getLensing() for both PowerSpectrum and NFWHalo.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Check for PositionD or PositionI:</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">Position</span><span class="p">):</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="p">[</span> <span class="n">pos</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">pos</span><span class="o">.</span><span class="n">y</span> <span class="p">]</span>

    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Unable to parse the input pos argument for </span><span class="si">%s</span><span class="s2">.&quot;</span><span class="o">%</span><span class="n">func</span><span class="p">)</span>

    <span class="c1"># Check for list of Position:</span>
    <span class="c1"># The only other options allow pos[0], so if this is invalid, an exception</span>
    <span class="c1"># will be raised:</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pos</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Position</span><span class="p">):</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="p">[</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">p</span><span class="o">.</span><span class="n">x</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">pos</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">),</span>
                <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">p</span><span class="o">.</span><span class="n">y</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">pos</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span> <span class="p">]</span>

    <span class="c1"># Now pos must be a tuple of length 2</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Unable to parse the input pos argument for </span><span class="si">%s</span><span class="s2">.&quot;</span><span class="o">%</span><span class="n">func</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Check for (x,y):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="p">[</span> <span class="nb">float</span><span class="p">(</span><span class="n">pos</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">float</span><span class="p">(</span><span class="n">pos</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="p">]</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="c1"># Only other valid option is ( xlist , ylist )</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="p">[</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pos</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">),</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pos</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span> <span class="p">]</span>

    <span class="c1"># Check validity of units</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">units</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="c1"># if the string is invalid, this raises a reasonable error message.</span>
        <span class="n">units</span> <span class="o">=</span> <span class="n">AngleUnit</span><span class="o">.</span><span class="n">from_name</span><span class="p">(</span><span class="n">units</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">units</span><span class="p">,</span> <span class="n">AngleUnit</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">GalSimValueError</span><span class="p">(</span><span class="s2">&quot;units must be either an AngleUnit or a string&quot;</span><span class="p">,</span> <span class="n">units</span><span class="p">,</span>
                               <span class="p">(</span><span class="s1">&#39;arcsec&#39;</span><span class="p">,</span> <span class="s1">&#39;arcmin&#39;</span><span class="p">,</span> <span class="s1">&#39;degree&#39;</span><span class="p">,</span> <span class="s1">&#39;hour&#39;</span><span class="p">,</span> <span class="s1">&#39;radian&#39;</span><span class="p">))</span>

    <span class="c1"># Convert pos to arcsec</span>
    <span class="k">if</span> <span class="n">units</span> <span class="o">!=</span> <span class="n">arcsec</span><span class="p">:</span>
        <span class="n">scale</span> <span class="o">=</span> <span class="mf">1.</span> <span class="o">*</span> <span class="n">units</span> <span class="o">/</span> <span class="n">arcsec</span>
        <span class="c1"># Note that for the next two lines, pos *must* be a list, not a tuple.  Assignments to</span>
        <span class="c1"># elements of tuples is not allowed.</span>
        <span class="n">pos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*=</span> <span class="n">scale</span>
        <span class="n">pos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*=</span> <span class="n">scale</span>

    <span class="k">return</span> <span class="n">pos</span>

<span class="k">def</span> <span class="nf">_spline_approx_err</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">splitpoints</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
    <span class="c1"># For splines, we can&#39;t just do the integral over a small range, since the spline slopes</span>
    <span class="c1"># are all wrong.  Rather we compute a spline function with the current splitpoints and</span>
    <span class="c1"># just the single point in the trial region and recompute a spline function with that.</span>
    <span class="c1"># Then we can compute the total error from that approximation.</span>
    <span class="c1"># (For the error integral, we still use linear.)</span>

    <span class="n">indices</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">splitpoints</span> <span class="o">+</span> <span class="p">[</span><span class="n">i</span><span class="p">])</span>
    <span class="n">new_tab</span> <span class="o">=</span> <span class="n">_LookupTable</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">indices</span><span class="p">],</span> <span class="n">f</span><span class="p">[</span><span class="n">indices</span><span class="p">],</span> <span class="s1">&#39;spline&#39;</span><span class="p">)</span>

    <span class="n">xleft</span><span class="p">,</span> <span class="n">xright</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">left</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">right</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">fleft</span><span class="p">,</span> <span class="n">fright</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="n">left</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">right</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">f2left</span> <span class="o">=</span> <span class="n">new_tab</span><span class="p">(</span><span class="n">xleft</span><span class="p">)</span>
    <span class="n">f2right</span> <span class="o">=</span> <span class="n">new_tab</span><span class="p">(</span><span class="n">xright</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">trapz</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">fleft</span><span class="o">-</span><span class="n">f2left</span><span class="p">),</span> <span class="n">xleft</span><span class="p">),</span> <span class="n">trapz</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">fright</span><span class="o">-</span><span class="n">f2right</span><span class="p">),</span> <span class="n">xright</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_spline_approx_split</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">splitpoints</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Split a tabulated function into a two-part piecewise spline approximation by exactly</span>
<span class="sd">    minimizing \int abs(f(x) - approx(x)) dx.  Operates in O(N^2) time.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">errs</span> <span class="o">=</span> <span class="p">[</span><span class="n">_spline_approx_err</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">splitpoints</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">left</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">right</span><span class="p">)]</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">errs</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">i</span><span class="o">+</span><span class="n">left</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">errs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">_lin_approx_err</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Error as \int abs(f(x) - approx(x)) when using ith data point to make piecewise linear</span>
<span class="sd">    approximation.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">xleft</span><span class="p">,</span> <span class="n">xright</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">left</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">right</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">fleft</span><span class="p">,</span> <span class="n">fright</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="n">left</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">right</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">xi</span><span class="p">,</span> <span class="n">fi</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="n">mleft</span> <span class="o">=</span> <span class="p">(</span><span class="n">fi</span><span class="o">-</span><span class="n">f</span><span class="p">[</span><span class="n">left</span><span class="p">])</span><span class="o">/</span><span class="p">(</span><span class="n">xi</span><span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="n">left</span><span class="p">])</span>
    <span class="n">mright</span> <span class="o">=</span> <span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="n">right</span><span class="p">]</span><span class="o">-</span><span class="n">fi</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">right</span><span class="p">]</span><span class="o">-</span><span class="n">xi</span><span class="p">)</span>
    <span class="n">f2left</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="n">left</span><span class="p">]</span><span class="o">+</span><span class="n">mleft</span><span class="o">*</span><span class="p">(</span><span class="n">xleft</span><span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="n">left</span><span class="p">])</span>
    <span class="n">f2right</span> <span class="o">=</span> <span class="n">fi</span><span class="o">+</span><span class="n">mright</span><span class="o">*</span><span class="p">(</span><span class="n">xright</span><span class="o">-</span><span class="n">xi</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">trapz</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">fleft</span><span class="o">-</span><span class="n">f2left</span><span class="p">),</span> <span class="n">xleft</span><span class="p">),</span> <span class="n">trapz</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">fright</span><span class="o">-</span><span class="n">f2right</span><span class="p">),</span> <span class="n">xright</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_exact_lin_approx_split</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">splitpoints</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Split a tabulated function into a two-part piecewise linear approximation by exactly</span>
<span class="sd">    minimizing \int abs(f(x) - approx(x)) dx.  Operates in O(N^2) time.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">errs</span> <span class="o">=</span> <span class="p">[</span><span class="n">_lin_approx_err</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">left</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">right</span><span class="p">)]</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">errs</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">i</span><span class="o">+</span><span class="n">left</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">errs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">_lin_approx_split</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">splitpoints</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Split a tabulated function into a two-part piecewise linear approximation by approximately</span>
<span class="sd">    minimizing \int abs(f(x) - approx(x)) dx.  Chooses the split point by exactly minimizing</span>
<span class="sd">    \int (f(x) - approx(x))^2 dx in O(N) time.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">left</span><span class="p">:</span><span class="n">right</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="n">left</span><span class="p">:</span><span class="n">right</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">dx</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
    <span class="c1"># Error contribution on the left.</span>
    <span class="n">ff0</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># Only need to search between j=1..(N-1)</span>
    <span class="n">xx0</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">mleft</span> <span class="o">=</span> <span class="n">ff0</span><span class="o">/</span><span class="n">xx0</span>  <span class="c1"># slope</span>
    <span class="n">errleft</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">dx</span><span class="o">*</span><span class="n">ff0</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
               <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">mleft</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">dx</span><span class="o">*</span><span class="n">ff0</span><span class="o">*</span><span class="n">xx0</span><span class="p">)</span>
               <span class="o">+</span> <span class="n">mleft</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">dx</span><span class="o">*</span><span class="n">xx0</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
    <span class="c1"># Error contribution on the right.</span>
    <span class="n">dx</span> <span class="o">=</span> <span class="n">dx</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># Reversed so that np.cumsum effectively works right-to-left.</span>
    <span class="n">ffN</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">f</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">xxN</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">mright</span> <span class="o">=</span> <span class="n">ffN</span><span class="o">/</span><span class="n">xxN</span>
    <span class="n">errright</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">dx</span><span class="o">*</span><span class="n">ffN</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
                <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">mright</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">dx</span><span class="o">*</span><span class="n">ffN</span><span class="o">*</span><span class="n">xxN</span><span class="p">)</span>
                <span class="o">+</span> <span class="n">mright</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">dx</span><span class="o">*</span><span class="n">xxN</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
    <span class="n">errright</span> <span class="o">=</span> <span class="n">errright</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># Get absolute error for the found point.</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">errleft</span><span class="o">+</span><span class="n">errright</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">i</span><span class="o">+</span><span class="n">left</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">_lin_approx_err</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

<div class="viewcode-block" id="thin_tabulated_values"><a class="viewcode-back" href="../../misc.html#galsim.utilities.thin_tabulated_values">[docs]</a><span class="k">def</span> <span class="nf">thin_tabulated_values</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">rel_err</span><span class="o">=</span><span class="mf">1.e-4</span><span class="p">,</span> <span class="n">trim_zeros</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">preserve_range</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                          <span class="n">fast_search</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">interpolant</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Remove items from a set of tabulated f(x) values so that the error in the integral is still</span>
<span class="sd">    accurate to a given relative accuracy.</span>

<span class="sd">    The input ``x`` and ``f`` values can be lists, NumPy arrays, or really anything that can be</span>
<span class="sd">    converted to a NumPy array.  The new lists will be output as numpy arrays.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        x:              The ``x`` values in the f(x) tabulation.</span>
<span class="sd">        f:              The ``f`` values in the f(x) tabulation.</span>
<span class="sd">        rel_err:        The maximum relative error to allow in the integral from the removal.</span>
<span class="sd">                        [default: 1.e-4]</span>
<span class="sd">        trim_zeros:     Remove redundant leading and trailing points where f=0?  (The last</span>
<span class="sd">                        leading point with f=0 and the first trailing point with f=0 will be</span>
<span class="sd">                        retained).  Note that if both trim_leading_zeros and preserve_range are</span>
<span class="sd">                        True, then the only the range of ``x`` *after* zero trimming is preserved.</span>
<span class="sd">                        [default: True]</span>
<span class="sd">        preserve_range: Should the original range of ``x`` be preserved? (True) Or should the ends</span>
<span class="sd">                        be trimmed to include only the region where the integral is</span>
<span class="sd">                        significant? (False)  [default: True]</span>
<span class="sd">        fast_search:    If set to True, then the underlying algorithm will use a relatively fast</span>
<span class="sd">                        O(N) algorithm to select points to include in the thinned approximation.</span>
<span class="sd">                        If set to False, then a slower O(N^2) algorithm will be used.  We have</span>
<span class="sd">                        found that the slower algorithm tends to yield a thinned representation</span>
<span class="sd">                        that retains fewer samples while still meeting the relative error</span>
<span class="sd">                        requirement.  [default: True]</span>
<span class="sd">        interpolant:    The interpolant to assume for the tabulated values. [default: &#39;linear&#39;]</span>

<span class="sd">    Returns:</span>
<span class="sd">        a tuple of lists (x_new, y_new) with the thinned tabulation.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">interpolant</span> <span class="o">==</span> <span class="s1">&#39;spline&#39;</span><span class="p">:</span>
        <span class="n">split_fn</span> <span class="o">=</span> <span class="n">_spline_approx_split</span>
    <span class="k">elif</span> <span class="n">fast_search</span><span class="p">:</span>
        <span class="n">split_fn</span> <span class="o">=</span> <span class="n">_lin_approx_split</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">split_fn</span> <span class="o">=</span> <span class="n">_exact_lin_approx_split</span>

    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

    <span class="c1"># Check for valid inputs</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">GalSimIncompatibleValuesError</span><span class="p">(</span><span class="s2">&quot;len(x) != len(f)&quot;</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">f</span><span class="o">=</span><span class="n">f</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">rel_err</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">rel_err</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">GalSimRangeError</span><span class="p">(</span><span class="s2">&quot;rel_err must be between 0 and 1&quot;</span><span class="p">,</span> <span class="n">rel_err</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
        <span class="k">raise</span> <span class="n">GalSimValueError</span><span class="p">(</span><span class="s2">&quot;input x is not sorted.&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>

    <span class="c1"># Check for trivial noop.</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="c1"># Nothing to do</span>
        <span class="k">return</span> <span class="n">x</span><span class="p">,</span><span class="n">f</span>

    <span class="n">total_integ</span> <span class="o">=</span> <span class="n">trapz</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">f</span><span class="p">),</span> <span class="n">x</span><span class="p">,</span> <span class="n">interpolant</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">total_integ</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span> <span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">f</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="p">])</span>
    <span class="n">thresh</span> <span class="o">=</span> <span class="n">total_integ</span> <span class="o">*</span> <span class="n">rel_err</span>

    <span class="k">if</span> <span class="n">trim_zeros</span><span class="p">:</span>
        <span class="n">first</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>  <span class="c1"># -1 to keep one non-redundant zero.</span>
        <span class="n">last</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># +1 to keep one non-redundant zero.</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">f</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">first</span><span class="p">:</span><span class="n">last</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">f</span><span class="p">[</span><span class="n">first</span><span class="p">:</span><span class="n">last</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">preserve_range</span><span class="p">:</span>
        <span class="c1"># Remove values from the front that integrate to less than thresh.</span>
        <span class="n">err_integ1</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="nb">abs</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">k0</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">x_range</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">while</span> <span class="n">k0</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">-</span><span class="mi">2</span> <span class="ow">and</span> <span class="n">err_integ1</span> <span class="o">&lt;</span> <span class="n">thresh</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">k0</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="n">x_range</span><span class="p">:</span>
            <span class="n">k0</span> <span class="o">=</span> <span class="n">k0</span><span class="o">+</span><span class="mi">1</span>
            <span class="n">err_integ1</span> <span class="o">+=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="n">k0</span><span class="p">])</span> <span class="o">+</span> <span class="nb">abs</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="n">k0</span><span class="o">+</span><span class="mi">1</span><span class="p">]))</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">k0</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="n">k0</span><span class="p">])</span>
        <span class="c1"># Now the integral from 0 to k0+1 (inclusive) is a bit too large.</span>
        <span class="c1"># That means k0 is the largest value we can use that will work as the starting value.</span>

        <span class="c1"># Remove values from the back that integrate to less than thresh.</span>
        <span class="n">k1</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>
        <span class="n">err_integ2</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="n">k1</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="nb">abs</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="n">k1</span><span class="p">]))</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">k1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="n">k1</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">while</span> <span class="n">k1</span> <span class="o">&gt;</span> <span class="n">k0</span> <span class="ow">and</span> <span class="n">err_integ2</span> <span class="o">&lt;</span> <span class="n">thresh</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="n">k1</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="n">x_range</span><span class="p">:</span>
            <span class="n">k1</span> <span class="o">=</span> <span class="n">k1</span><span class="o">-</span><span class="mi">1</span>
            <span class="n">err_integ2</span> <span class="o">+=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="n">k1</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="nb">abs</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="n">k1</span><span class="p">]))</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">k1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="n">k1</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="c1"># Now the integral from k1-1 to len(x)-1 (inclusive) is a bit too large.</span>
        <span class="c1"># That means k1 is the smallest value we can use that will work as the ending value.</span>

        <span class="c1"># Subtract the error so far from thresh</span>
        <span class="k">if</span> <span class="n">interpolant</span> <span class="o">==</span> <span class="s1">&#39;spline&#39;</span><span class="p">:</span>
            <span class="n">new_integ</span> <span class="o">=</span> <span class="n">trapz</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="n">k0</span><span class="p">:</span><span class="n">k1</span><span class="o">+</span><span class="mi">1</span><span class="p">]),</span><span class="n">x</span><span class="p">[</span><span class="n">k0</span><span class="p">:</span><span class="n">k1</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">interpolant</span><span class="o">=</span><span class="s1">&#39;spline&#39;</span><span class="p">)</span>
            <span class="n">thresh</span> <span class="o">-=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">new_integ</span><span class="o">-</span><span class="n">total_integ</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">thresh</span> <span class="o">-=</span> <span class="n">trapz</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">f</span><span class="p">[:</span><span class="n">k0</span><span class="p">]),</span><span class="n">x</span><span class="p">[:</span><span class="n">k0</span><span class="p">])</span> <span class="o">+</span> <span class="n">trapz</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="n">k1</span><span class="p">:]),</span><span class="n">x</span><span class="p">[</span><span class="n">k1</span><span class="p">:])</span>

        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">k0</span><span class="p">:</span><span class="n">k1</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># +1 since end of range is given as one-past-the-end.</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="n">k0</span><span class="p">:</span><span class="n">k1</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># Check again for noop after trimming endpoints.</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">x</span><span class="p">,</span><span class="n">f</span>

    <span class="c1"># Thin interior points.  Start with no interior points and then greedily add them back in one at</span>
    <span class="c1"># a time until relative error goal is met.</span>
    <span class="c1"># Use a heap to track:</span>
    <span class="n">heap</span> <span class="o">=</span> <span class="p">[(</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">thresh</span><span class="p">,</span>  <span class="c1"># -err; initialize large enough to trigger while loop below.</span>
             <span class="mi">0</span><span class="p">,</span>          <span class="c1"># first index of interval</span>
             <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span>  <span class="c1"># last index of interval</span>
    <span class="n">splitpoints</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">heap</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">heapq</span><span class="o">.</span><span class="n">heappop</span><span class="p">(</span><span class="n">heap</span><span class="p">)</span>
        <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">errleft</span><span class="p">,</span> <span class="n">errright</span><span class="p">)</span> <span class="o">=</span> <span class="n">split_fn</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">splitpoints</span><span class="p">)</span>
        <span class="n">splitpoints</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">left</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">heap</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="n">errleft</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">right</span> <span class="o">&gt;</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">heap</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="n">errright</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">right</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">interpolant</span> <span class="o">!=</span> <span class="s1">&#39;spline&#39;</span><span class="p">:</span>
            <span class="c1"># This is a sufficient stopping criterion for linear</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">-</span><span class="nb">sum</span><span class="p">(</span><span class="n">h</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">heap</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">thresh</span><span class="p">):</span>
                <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># For spline, we also need to recompute the total integral to make sure</span>
            <span class="c1"># that the realized total error is less than thresh.</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">-</span><span class="nb">sum</span><span class="p">(</span><span class="n">h</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">heap</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">thresh</span><span class="p">):</span>
                <span class="n">splitpoints</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">splitpoints</span><span class="p">)</span>
                <span class="n">current_integ</span> <span class="o">=</span> <span class="n">trapz</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="n">splitpoints</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="n">splitpoints</span><span class="p">],</span> <span class="n">interpolant</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">current_integ</span> <span class="o">-</span> <span class="n">total_integ</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">thresh</span><span class="p">:</span>
                    <span class="k">break</span>
    <span class="n">splitpoints</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">splitpoints</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">x</span><span class="p">[</span><span class="n">splitpoints</span><span class="p">],</span> <span class="n">f</span><span class="p">[</span><span class="n">splitpoints</span><span class="p">]</span></div>

<div class="viewcode-block" id="old_thin_tabulated_values"><a class="viewcode-back" href="../../misc.html#galsim.utilities.old_thin_tabulated_values">[docs]</a><span class="k">def</span> <span class="nf">old_thin_tabulated_values</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">rel_err</span><span class="o">=</span><span class="mf">1.e-4</span><span class="p">,</span> <span class="n">preserve_range</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span> <span class="c1"># pragma: no cover</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Remove items from a set of tabulated f(x) values so that the error in the integral is still</span>
<span class="sd">    accurate to a given relative accuracy.</span>

<span class="sd">    The input ``x`` and ``f`` values can be lists, NumPy arrays, or really anything that can be</span>
<span class="sd">    converted to a NumPy array.  The new lists will be output as python lists.</span>

<span class="sd">    .. note::</span>
<span class="sd">        In Issue #739, Josh wrote `thin_tabulated_values`  as a replacement for this function,</span>
<span class="sd">        which had been buggy -- not actually hitting its target relative accuracy.  So on the</span>
<span class="sd">        same issue, Mike fixed this algorithm to at least work correctly.</span>

<span class="sd">        However, we recommend using the above algorithm, since it keeps fewer sample locations</span>
<span class="sd">        for a given ``rel_err`` than the old algorithm.</span>

<span class="sd">        On the other hand, the old algorithm (this one) may be quite a bit faster, so we retain</span>
<span class="sd">        it here in case there is a use case where it is more appropriate.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        x:              The ``x`` values in the f(x) tabulation.</span>
<span class="sd">        f:              The ``f`` values in the f(x) tabulation.</span>
<span class="sd">        rel_err:        The maximum relative error to allow in the integral from the removal.</span>
<span class="sd">                        [default: 1.e-4]</span>
<span class="sd">        preserve_range: Should the original range of ``x`` be preserved? (True) Or should the ends</span>
<span class="sd">                        be trimmed to include only the region where the integral is</span>
<span class="sd">                        significant? (False)  [default: False]</span>

<span class="sd">    Returns:</span>
<span class="sd">        a tuple of lists (x_new, y_new) with the thinned tabulation.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

    <span class="c1"># Check for valid inputs</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">GalSimIncompatibleValuesError</span><span class="p">(</span><span class="s2">&quot;len(x) != len(f)&quot;</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">f</span><span class="o">=</span><span class="n">f</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">rel_err</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">rel_err</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">GalSimRangeError</span><span class="p">(</span><span class="s2">&quot;rel_err must be between 0 and 1&quot;</span><span class="p">,</span> <span class="n">rel_err</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
        <span class="k">raise</span> <span class="n">GalSimValueError</span><span class="p">(</span><span class="s2">&quot;input x is not sorted.&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>

    <span class="c1"># Check for trivial noop.</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="c1"># Nothing to do</span>
        <span class="k">return</span> <span class="n">x</span><span class="p">,</span><span class="n">f</span>

    <span class="c1"># Start by calculating the complete integral of |f|</span>
    <span class="n">total_integ</span> <span class="o">=</span> <span class="n">trapz</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">f</span><span class="p">),</span><span class="n">x</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">total_integ</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span> <span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">f</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="p">])</span>
    <span class="n">thresh</span> <span class="o">=</span> <span class="n">rel_err</span> <span class="o">*</span> <span class="n">total_integ</span>
    <span class="n">x_range</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">preserve_range</span><span class="p">:</span>
        <span class="c1"># Remove values from the front that integrate to less than thresh.</span>
        <span class="n">err_integ1</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="nb">abs</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">k0</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">k0</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">-</span><span class="mi">2</span> <span class="ow">and</span> <span class="n">err_integ1</span> <span class="o">&lt;</span> <span class="n">thresh</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">k0</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="n">x_range</span><span class="p">:</span>
            <span class="n">k0</span> <span class="o">=</span> <span class="n">k0</span><span class="o">+</span><span class="mi">1</span>
            <span class="n">err_integ1</span> <span class="o">+=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="n">k0</span><span class="p">])</span> <span class="o">+</span> <span class="nb">abs</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="n">k0</span><span class="o">+</span><span class="mi">1</span><span class="p">]))</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">k0</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="n">k0</span><span class="p">])</span>
        <span class="c1"># Now the integral from 0 to k0+1 (inclusive) is a bit too large.</span>
        <span class="c1"># That means k0 is the largest value we can use that will work as the starting value.</span>

        <span class="c1"># Remove values from the back that integrate to less than thresh.</span>
        <span class="n">k1</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>
        <span class="n">err_integ2</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="n">k1</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="nb">abs</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="n">k1</span><span class="p">]))</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">k1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="n">k1</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">while</span> <span class="n">k1</span> <span class="o">&gt;</span> <span class="n">k0</span> <span class="ow">and</span> <span class="n">err_integ2</span> <span class="o">&lt;</span> <span class="n">thresh</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="n">k1</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="n">x_range</span><span class="p">:</span>
            <span class="n">k1</span> <span class="o">=</span> <span class="n">k1</span><span class="o">-</span><span class="mi">1</span>
            <span class="n">err_integ2</span> <span class="o">+=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="n">k1</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="nb">abs</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="n">k1</span><span class="p">]))</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">k1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="n">k1</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="c1"># Now the integral from k1-1 to len(x)-1 (inclusive) is a bit too large.</span>
        <span class="c1"># That means k1 is the smallest value we can use that will work as the ending value.</span>

        <span class="c1"># Subtract the error so far from thresh</span>
        <span class="n">thresh</span> <span class="o">-=</span> <span class="n">trapz</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">f</span><span class="p">[:</span><span class="n">k0</span><span class="p">]),</span><span class="n">x</span><span class="p">[:</span><span class="n">k0</span><span class="p">])</span> <span class="o">+</span> <span class="n">trapz</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="n">k1</span><span class="p">:]),</span><span class="n">x</span><span class="p">[</span><span class="n">k1</span><span class="p">:])</span>

        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">k0</span><span class="p">:</span><span class="n">k1</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># +1 since end of range is given as one-past-the-end.</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="n">k0</span><span class="p">:</span><span class="n">k1</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># And update x_range for the new values</span>
        <span class="n">x_range</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># Start a new list with just the first item so far</span>
    <span class="n">newx</span> <span class="o">=</span> <span class="p">[</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">]</span>
    <span class="n">newf</span> <span class="o">=</span> <span class="p">[</span> <span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">]</span>

    <span class="n">k0</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># The last item currently in the new array</span>
    <span class="n">k1</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># The current item we are considering to skip or include</span>
    <span class="k">while</span> <span class="n">k1</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
        <span class="c1"># We are considering replacing all the true values between k0 and k1+1 (non-inclusive)</span>
        <span class="c1"># with a linear approxmation based on the points at k0 and k1+1.</span>
        <span class="n">lin_f</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="n">k0</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="n">k1</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">f</span><span class="p">[</span><span class="n">k0</span><span class="p">])</span><span class="o">/</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">k1</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="n">k0</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">k0</span><span class="p">:</span><span class="n">k1</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="n">k0</span><span class="p">])</span>
        <span class="c1"># Integrate | f(x) - lin_f(x) | from k0 to k1+1, inclusive.</span>
        <span class="n">err_integ</span> <span class="o">=</span> <span class="n">trapz</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="n">k0</span><span class="p">:</span><span class="n">k1</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">lin_f</span><span class="p">),</span> <span class="n">x</span><span class="p">[</span><span class="n">k0</span><span class="p">:</span><span class="n">k1</span><span class="o">+</span><span class="mi">2</span><span class="p">])</span>
        <span class="c1"># If the integral of the difference is &lt; thresh * (dx/x_range), we can skip this item.</span>
        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">err_integ</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">thresh</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">k1</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="n">k0</span><span class="p">])</span> <span class="o">/</span> <span class="n">x_range</span><span class="p">:</span>
            <span class="c1"># OK to skip item k1</span>
            <span class="n">k1</span> <span class="o">=</span> <span class="n">k1</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Also ok to keep if its own relative error is less than rel_err</span>
            <span class="n">true_integ</span> <span class="o">=</span> <span class="n">trapz</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="n">k0</span><span class="p">:</span><span class="n">k1</span><span class="o">+</span><span class="mi">2</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="n">k0</span><span class="p">:</span><span class="n">k1</span><span class="o">+</span><span class="mi">2</span><span class="p">])</span>
            <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">err_integ</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">rel_err</span> <span class="o">*</span> <span class="nb">abs</span><span class="p">(</span><span class="n">true_integ</span><span class="p">):</span>
                <span class="c1"># OK to skip item k1</span>
                <span class="n">k1</span> <span class="o">=</span> <span class="n">k1</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Have to include this one.</span>
                <span class="n">newx</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">k1</span><span class="p">])</span>
                <span class="n">newf</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="n">k1</span><span class="p">])</span>
                <span class="n">k0</span> <span class="o">=</span> <span class="n">k1</span>
                <span class="n">k1</span> <span class="o">=</span> <span class="n">k1</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="c1"># Always include the last item</span>
    <span class="n">newx</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">newf</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">newx</span><span class="p">,</span> <span class="n">newf</span></div>


<div class="viewcode-block" id="horner"><a class="viewcode-back" href="../../misc.html#galsim.utilities.horner">[docs]</a><span class="k">def</span> <span class="nf">horner</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">coef</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Evaluate univariate polynomial using Horner&#39;s method.</span>

<span class="sd">    I.e., take A + Bx + Cx^2 + Dx^3 and evaluate it as</span>
<span class="sd">    A + x(B + x(C + x(D)))</span>

<span class="sd">    Parameters:</span>
<span class="sd">        x:      A numpy array of values at which to evaluate the polynomial.</span>
<span class="sd">        coef:   Polynomial coefficients of increasing powers of x.</span>
<span class="sd">        dtype:  Optionally specify the dtype of the return array. [default: None]</span>

<span class="sd">    Returns:</span>
<span class="sd">        a numpy array of the evaluated polynomial.  Will be the same shape as x.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">result_type</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">min_scalar_type</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
            <span class="n">np</span><span class="o">.</span><span class="n">min_scalar_type</span><span class="p">(</span><span class="n">coef</span><span class="p">)</span>
        <span class="p">)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
    <span class="c1"># Make sure everything is an array</span>
    <span class="k">if</span> <span class="n">result</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="nb">float</span><span class="p">:</span>
        <span class="c1"># And if the result is float, it&#39;s worth making sure x, coef are also float and</span>
        <span class="c1"># contiguous, so we can use the faster c++ implementation.</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">coef</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">coef</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">coef</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">coef</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">coef</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">GalSimValueError</span><span class="p">(</span><span class="s2">&quot;coef must be 1-dimensional&quot;</span><span class="p">,</span> <span class="n">coef</span><span class="p">)</span>
    <span class="n">_horner</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">coef</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span></div>

<div class="viewcode-block" id="_horner"><a class="viewcode-back" href="../../misc.html#galsim.utilities._horner">[docs]</a><span class="k">def</span> <span class="nf">_horner</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">coef</span><span class="p">,</span> <span class="n">result</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Equivalent to `horner`, but ``x``, ``coef``, and ``result`` must be contiguous arrays.</span>

<span class="sd">    In particular, ``result`` must be already allocated as an array in which to put the answer.</span>
<span class="sd">    This is the thing that is returned from the regular `horner`.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        x:      A numpy array of values at which to evaluate the polynomial.</span>
<span class="sd">        coef:   Polynomial coefficients of increasing powers of x.</span>
<span class="sd">        result: Numpy array into which to write the result.  Must be same shape as x.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">result</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="nb">float</span><span class="p">:</span>
        <span class="n">_x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">__array_interface__</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">_coef</span> <span class="o">=</span> <span class="n">coef</span><span class="o">.</span><span class="n">__array_interface__</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">_result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">__array_interface__</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">_galsim</span><span class="o">.</span><span class="n">Horner</span><span class="p">(</span><span class="n">_x</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">_coef</span><span class="p">,</span> <span class="n">coef</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">_result</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">coef</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">trim_zeros</span><span class="p">(</span><span class="n">coef</span><span class="p">,</span> <span class="n">trim</span><span class="o">=</span><span class="s1">&#39;b&#39;</span><span class="p">)</span>  <span class="c1"># trim only from the back</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">coef</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">result</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="n">result</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">coef</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">coef</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">result</span> <span class="o">*=</span> <span class="n">x</span>
            <span class="k">if</span> <span class="n">c</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span> <span class="n">result</span> <span class="o">+=</span> <span class="n">c</span></div>

<div class="viewcode-block" id="horner2d"><a class="viewcode-back" href="../../misc.html#galsim.utilities.horner2d">[docs]</a><span class="k">def</span> <span class="nf">horner2d</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">coefs</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">triangle</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Evaluate bivariate polynomial using nested Horner&#39;s method.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        x:          A numpy array of the x values at which to evaluate the polynomial.</span>
<span class="sd">        y:          A numpy array of the y values at which to evaluate the polynomial.</span>
<span class="sd">        coefs:      2D array-like of coefficients in increasing powers of x and y.</span>
<span class="sd">                    The first axis corresponds to increasing the power of y, and the second to</span>
<span class="sd">                    increasing the power of x.</span>
<span class="sd">        dtype:      Optionally specify the dtype of the return array. [default: None]</span>
<span class="sd">        triangle:   If True, then the coefs are only non-zero in the upper-left triangle</span>
<span class="sd">                    of the array. [default: False]</span>

<span class="sd">    Returns:</span>
<span class="sd">        a numpy array of the evaluated polynomial.  Will be the same shape as x and y.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">result_type</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">min_scalar_type</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
            <span class="n">np</span><span class="o">.</span><span class="n">min_scalar_type</span><span class="p">(</span><span class="n">y</span><span class="p">),</span>
            <span class="n">np</span><span class="o">.</span><span class="n">min_scalar_type</span><span class="p">(</span><span class="n">coefs</span><span class="p">)</span>
        <span class="p">)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">temp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
    <span class="c1"># Make sure everything is an array</span>
    <span class="k">if</span> <span class="n">result</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="nb">float</span><span class="p">:</span>
        <span class="c1"># And if the result is float, it&#39;s worth making sure x, coef are also float,</span>
        <span class="c1"># so we can use the faster c++ implementation.</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">coefs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">coefs</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="n">coefs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">coefs</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">GalSimIncompatibleValuesError</span><span class="p">(</span><span class="s2">&quot;x and y are not the same shape&quot;</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">coefs</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">GalSimValueError</span><span class="p">(</span><span class="s2">&quot;coefs must be 2-dimensional&quot;</span><span class="p">,</span> <span class="n">coefs</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">triangle</span> <span class="ow">and</span> <span class="n">coefs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">coefs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="n">GalSimIncompatibleValuesError</span><span class="p">(</span><span class="s2">&quot;coefs must be square if triangle is True&quot;</span><span class="p">,</span>
                                            <span class="n">coefs</span><span class="o">=</span><span class="n">coefs</span><span class="p">,</span> <span class="n">triangle</span><span class="o">=</span><span class="n">triangle</span><span class="p">)</span>
    <span class="n">_horner2d</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">coefs</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">temp</span><span class="p">,</span> <span class="n">triangle</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span></div>

<div class="viewcode-block" id="_horner2d"><a class="viewcode-back" href="../../misc.html#galsim.utilities._horner2d">[docs]</a><span class="k">def</span> <span class="nf">_horner2d</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">coefs</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">temp</span><span class="p">,</span> <span class="n">triangle</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Equivalent to `horner2d`, but ``x``, ``y``, ``coefs``, ``result``, and ``temp``</span>
<span class="sd">    must be contiguous arrays.</span>

<span class="sd">    In particular, ``result`` must be already allocated as an array in which to put the answer.</span>
<span class="sd">    This is the thing that is returned from the regular `horner`.  In addition, ``temp`` must</span>
<span class="sd">    be allocated for the function to use as temporary work space.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        x:          A numpy array of the x values at which to evaluate the polynomial.</span>
<span class="sd">        y:          A numpy array of the y values at which to evaluate the polynomial.</span>
<span class="sd">        coefs:      2D array-like of coefficients in increasing powers of x and y.</span>
<span class="sd">                    The first axis corresponds to increasing the power of y, and the second to</span>
<span class="sd">                    increasing the power of x.</span>
<span class="sd">        result:     Numpy array into which to write the result.  Must be same shape as x.</span>
<span class="sd">        temp:       Numpy array to hold temporary results.  Must be the same shape as x.</span>
<span class="sd">        triangle:   If True, then the coefs are only non-zero in the upper-left triangle</span>
<span class="sd">                    of the array. [default: False]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">result</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="nb">float</span><span class="p">:</span>
        <span class="c1"># Note: the c++ implementation doesn&#39;t need to care about triangle.</span>
        <span class="c1"># It is able to trivially account for the zeros without special handling.</span>
        <span class="n">_x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">__array_interface__</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">_y</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">__array_interface__</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">_coefs</span> <span class="o">=</span> <span class="n">coefs</span><span class="o">.</span><span class="n">__array_interface__</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">_result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">__array_interface__</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">_temp</span> <span class="o">=</span> <span class="n">temp</span><span class="o">.</span><span class="n">__array_interface__</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">_galsim</span><span class="o">.</span><span class="n">Horner2D</span><span class="p">(</span><span class="n">_x</span><span class="p">,</span> <span class="n">_y</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">_coefs</span><span class="p">,</span> <span class="n">coefs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">coefs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">_result</span><span class="p">,</span> <span class="n">_temp</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">triangle</span><span class="p">:</span>
            <span class="n">result</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">coefs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">coef</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">coefs</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
                <span class="n">result</span> <span class="o">*=</span> <span class="n">x</span>
                <span class="n">_horner</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">coef</span><span class="p">[:</span><span class="n">k</span><span class="o">+</span><span class="mi">2</span><span class="p">],</span> <span class="n">temp</span><span class="p">)</span>
                <span class="n">result</span> <span class="o">+=</span> <span class="n">temp</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_horner</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">coefs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">result</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">coef</span> <span class="ow">in</span> <span class="n">coefs</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">result</span> <span class="o">*=</span> <span class="n">x</span>
                <span class="n">_horner</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">coef</span><span class="p">,</span> <span class="n">temp</span><span class="p">)</span>
                <span class="n">result</span> <span class="o">+=</span> <span class="n">temp</span></div>


<span class="k">def</span> <span class="nf">horner3d</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">coefs</span><span class="p">):</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">horner2d</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">coefs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">for</span> <span class="n">coef</span> <span class="ow">in</span> <span class="n">coefs</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
        <span class="n">result</span> <span class="o">*=</span> <span class="n">x</span>
        <span class="n">result</span> <span class="o">+=</span> <span class="n">horner2d</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">coef</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span>


<span class="k">def</span> <span class="nf">horner4d</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">coefs</span><span class="p">):</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">horner3d</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">coefs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">for</span> <span class="n">coef</span> <span class="ow">in</span> <span class="n">coefs</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
        <span class="n">result</span> <span class="o">*=</span> <span class="n">x</span>
        <span class="n">result</span> <span class="o">+=</span> <span class="n">horner3d</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">coef</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span>


<div class="viewcode-block" id="deInterleaveImage"><a class="viewcode-back" href="../../misc.html#galsim.utilities.deInterleaveImage">[docs]</a><span class="k">def</span> <span class="nf">deInterleaveImage</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">conserve_flux</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">suppress_warnings</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The routine to do the opposite of what `interleaveImages` routine does. It generates a</span>
<span class="sd">    (uniform) dither sequence of low resolution images from a high resolution image.</span>

<span class="sd">    Many pixel level detector effects, such as interpixel capacitance, persistence, charge</span>
<span class="sd">    diffusion etc. can be included only on images drawn at the native pixel scale, which happen to</span>
<span class="sd">    be undersampled in most cases. Nyquist-sampled images that also include the effects of detector</span>
<span class="sd">    non-idealities can be obtained by drawing multiple undersampled images (with the detector</span>
<span class="sd">    effects included) that are offset from each other by a fraction of a pixel. If the offsets are</span>
<span class="sd">    uniformly spaced, then images can be combined using `interleaveImages` into a Nyquist-sampled</span>
<span class="sd">    image.</span>

<span class="sd">    Drawing multiple low resolution images of a light profile can be a lot slower than drawing a</span>
<span class="sd">    high resolution image of the same profile, even if the total number of pixels is the same. A</span>
<span class="sd">    uniformly offset dither sequence can be extracted from a well-resolved image that is drawn by</span>
<span class="sd">    convolving the surface brightness profile explicitly with the native pixel response and setting</span>
<span class="sd">    a lower sampling scale (or higher sampling rate) using the ``pixel_scale`` argument in</span>
<span class="sd">    `GSObject.drawImage` routine and setting the ``method`` parameter to &#39;no_pixel&#39;.</span>

<span class="sd">    Here is an example script using this routine:</span>

<span class="sd">    Example::</span>

<span class="sd">        &gt;&gt;&gt; n = 2</span>
<span class="sd">        &gt;&gt;&gt; gal = galsim.Gaussian(sigma=2.8)</span>
<span class="sd">        &gt;&gt;&gt; gal_pix = galsim.Convolve([gal,galsim.Pixel(scale=1.0)])</span>
<span class="sd">        &gt;&gt;&gt; img = gal_pix.drawImage(gal_pix,scale=1.0/n,method=&#39;no_pixel&#39;)</span>
<span class="sd">        &gt;&gt;&gt; im_list, offsets = galsim.utilities.deInterleaveImage(img,N=n)</span>
<span class="sd">        &gt;&gt;&gt; for im in im_list:</span>
<span class="sd">        &gt;&gt;&gt;     im.applyNonlinearity(lambda x: x-0.01*x**2) #detector effects</span>
<span class="sd">        &gt;&gt;&gt; img_new = galsim.utilities.interleaveImages(im_list,N=n,offsets)</span>

<span class="sd">    Parameters:</span>
<span class="sd">        image:              Input image from which lower resolution images are extracted.</span>
<span class="sd">        N:                  Number of images extracted in either directions. It can be of type</span>
<span class="sd">                            &#39;int&#39; if equal number of images are extracted in both directions or a</span>
<span class="sd">                            list or tuple of two integers, containing the number of images in x</span>
<span class="sd">                            and y directions respectively.</span>
<span class="sd">        conserve_flux:      Should the routine output images that have, on average, same total</span>
<span class="sd">                            pixel values as the input image (True) or should the pixel values</span>
<span class="sd">                            summed over all the images equal the sum of pixel values of the input</span>
<span class="sd">                            image (False)? [default: False]</span>
<span class="sd">        suppress_warnings:  Suppresses the warnings about the pixel scale of the output, if True.</span>
<span class="sd">                            [default: False]</span>

<span class="sd">    Returns:</span>
<span class="sd">        a list of images (`Image`) and offsets (`PositionD`) to reconstruct the input image using</span>
<span class="sd">        `interleaveImages`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="nb">int</span><span class="p">):</span>
        <span class="n">n1</span><span class="p">,</span><span class="n">n2</span> <span class="o">=</span> <span class="n">N</span><span class="p">,</span><span class="n">N</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">n1</span><span class="p">,</span><span class="n">n2</span> <span class="o">=</span> <span class="n">N</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;N must be an integer or a tuple of two integers&quot;</span><span class="p">)</span> <span class="kn">from</span> <span class="kc">None</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">Image</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;image must be an instance of galsim.Image&quot;</span><span class="p">)</span>

    <span class="n">y_size</span><span class="p">,</span><span class="n">x_size</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span>
    <span class="k">if</span> <span class="n">x_size</span><span class="o">%</span><span class="n">n1</span> <span class="ow">or</span> <span class="n">y_size</span><span class="o">%</span><span class="n">n2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">GalSimIncompatibleValuesError</span><span class="p">(</span>
            <span class="s2">&quot;The value of N is incompatible with the dimensions of the image to be deinterleaved&quot;</span><span class="p">,</span>
            <span class="n">N</span><span class="o">=</span><span class="n">N</span><span class="p">,</span> <span class="n">image</span><span class="o">=</span><span class="n">image</span><span class="p">)</span>

    <span class="n">im_list</span><span class="p">,</span> <span class="n">offsets</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n1</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n2</span><span class="p">):</span>
            <span class="c1"># The tricky part - going from array indices to Image coordinates (x,y)</span>
            <span class="c1"># DX[i&#39;] = -(i+0.5)/n+0.5 = -i/n + 0.5*(n-1)/n</span>
            <span class="c1">#    i  = -n DX[i&#39;] + 0.5*(n-1)</span>
            <span class="n">dx</span><span class="p">,</span><span class="n">dy</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mf">0.5</span><span class="p">)</span><span class="o">/</span><span class="n">n1</span><span class="o">+</span><span class="mf">0.5</span><span class="p">,</span><span class="o">-</span><span class="p">(</span><span class="n">j</span><span class="o">+</span><span class="mf">0.5</span><span class="p">)</span><span class="o">/</span><span class="n">n2</span><span class="o">+</span><span class="mf">0.5</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="n">_PositionD</span><span class="p">(</span><span class="n">dx</span><span class="p">,</span><span class="n">dy</span><span class="p">)</span>
            <span class="n">img_arr</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">array</span><span class="p">[</span><span class="n">j</span><span class="p">::</span><span class="n">n2</span><span class="p">,</span><span class="n">i</span><span class="p">::</span><span class="n">n1</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">img</span> <span class="o">=</span> <span class="n">Image</span><span class="p">(</span><span class="n">img_arr</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">conserve_flux</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">img</span> <span class="o">*=</span> <span class="n">n1</span><span class="o">*</span><span class="n">n2</span>
            <span class="n">im_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
            <span class="n">offsets</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">offset</span><span class="p">)</span>

    <span class="n">wcs</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">wcs</span>
    <span class="k">if</span> <span class="n">wcs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">wcs</span><span class="o">.</span><span class="n">_isUniform</span><span class="p">:</span>
        <span class="n">jac</span> <span class="o">=</span> <span class="n">wcs</span><span class="o">.</span><span class="n">jacobian</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">img</span> <span class="ow">in</span> <span class="n">im_list</span><span class="p">:</span>
            <span class="n">img_wcs</span> <span class="o">=</span> <span class="n">JacobianWCS</span><span class="p">(</span><span class="n">jac</span><span class="o">.</span><span class="n">dudx</span><span class="o">*</span><span class="n">n1</span><span class="p">,</span><span class="n">jac</span><span class="o">.</span><span class="n">dudy</span><span class="o">*</span><span class="n">n2</span><span class="p">,</span><span class="n">jac</span><span class="o">.</span><span class="n">dvdx</span><span class="o">*</span><span class="n">n1</span><span class="p">,</span><span class="n">jac</span><span class="o">.</span><span class="n">dvdy</span><span class="o">*</span><span class="n">n2</span><span class="p">)</span>
            <span class="c1">## Since pixel scale WCS is not equal to its jacobian, checking if img_wcs is a pixel</span>
            <span class="c1">## scale</span>
            <span class="n">img_wcs_decomp</span> <span class="o">=</span> <span class="n">img_wcs</span><span class="o">.</span><span class="n">getDecomposition</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">img_wcs_decomp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">g</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                <span class="n">img</span><span class="o">.</span><span class="n">wcs</span> <span class="o">=</span> <span class="n">PixelScale</span><span class="p">(</span><span class="n">img_wcs_decomp</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">img</span><span class="o">.</span><span class="n">wcs</span> <span class="o">=</span> <span class="n">img_wcs</span>
            <span class="c1">## Preserve the origin so that the interleaved image has the same bounds as the image</span>
            <span class="c1">## that is being deinterleaved.</span>
            <span class="n">img</span><span class="o">.</span><span class="n">setOrigin</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">origin</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">suppress_warnings</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
        <span class="n">galsim_warn</span><span class="p">(</span><span class="s2">&quot;Individual images could not be assigned a WCS automatically.&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">im_list</span><span class="p">,</span> <span class="n">offsets</span></div>


<div class="viewcode-block" id="interleaveImages"><a class="viewcode-back" href="../../misc.html#galsim.utilities.interleaveImages">[docs]</a><span class="k">def</span> <span class="nf">interleaveImages</span><span class="p">(</span><span class="n">im_list</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">offsets</span><span class="p">,</span> <span class="n">add_flux</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">suppress_warnings</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                     <span class="n">catch_offset_errors</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Interleaves the pixel values from two or more images and into a single larger image.</span>

<span class="sd">    This routine converts a list of images taken at a series of (uniform) dither offsets into a</span>
<span class="sd">    single higher resolution image, where the value in each final pixel is the observed pixel</span>
<span class="sd">    value from exactly one of the original images.  It can be used to build a Nyquist-sampled image</span>
<span class="sd">    from a set of images that were observed with pixels larger than the Nyquist scale.</span>

<span class="sd">    In the original observed images, the integration of the surface brightness over the pixels is</span>
<span class="sd">    equivalent to convolution by the pixel profile and then sampling at the centers of the pixels.</span>
<span class="sd">    This procedure simulates an observation sampled at a higher resolution than the original images,</span>
<span class="sd">    while retaining the original pixel convolution.</span>

<span class="sd">    Such an image can be obtained in a fairly simple manner in simulations of surface brightness</span>
<span class="sd">    profiles by convolving them explicitly with the native pixel response and setting a lower</span>
<span class="sd">    sampling scale (or higher sampling rate) using the ``pixel_scale`` argument in</span>
<span class="sd">    `GSObject.drawImage` routine and setting the ``method`` parameter to &#39;no_pixel&#39;.</span>

<span class="sd">    However, pixel level detector effects can be included only on images drawn at the native pixel</span>
<span class="sd">    scale, which happen to be undersampled in most cases. Nyquist-sampled images that also include</span>
<span class="sd">    the effects of detector non-idealities can be obtained by drawing multiple undersampled images</span>
<span class="sd">    (with the detector effects included) that are offset from each other by a fraction of a pixel.</span>

<span class="sd">    This is similar to other procedures that build a higher resolution image from a set of low</span>
<span class="sd">    resolution images, such as MultiDrizzle and IMCOM. A disadvantage of this routine compared to</span>
<span class="sd">    ther others is that the images must be offset in equal steps in each direction. This is</span>
<span class="sd">    difficult to acheive with real observations but can be precisely acheived in a series of</span>
<span class="sd">    simulated images.</span>

<span class="sd">    An advantage of this procedure is that the noise in the final image is not correlated as the</span>
<span class="sd">    pixel values are each taken from just a single input image. Thus, this routine preserves the</span>
<span class="sd">    noise properties of the pixels.</span>

<span class="sd">    Here&#39;s an example script using this routine:</span>

<span class="sd">    Example::</span>

<span class="sd">        &gt;&gt;&gt; n = 2</span>
<span class="sd">        &gt;&gt;&gt; gal = galsim.Gaussian(sigma=2.8)</span>
<span class="sd">        &gt;&gt;&gt; DX = numpy.arange(0.0,1.0,1./n)</span>
<span class="sd">        &gt;&gt;&gt; DX -= DX.mean()</span>
<span class="sd">        &gt;&gt;&gt; im_list, offsets = [], []</span>
<span class="sd">        &gt;&gt;&gt; for dx in DX:</span>
<span class="sd">            ... offset = galsim.PositionD(dx,0.0)</span>
<span class="sd">            ... offsets.append(offset)</span>
<span class="sd">            ... im = galsim.Image(16,16)</span>
<span class="sd">            ... gal.drawImage(image=im,offset=offset,scale=1.0)</span>
<span class="sd">            ... im.applyNonlinearity(lambda x: x - 0.01*x**2) # detector effects</span>
<span class="sd">            ... im_list.append(im)</span>
<span class="sd">        &gt;&gt;&gt; img = galsim.utilities.interleaveImages(im_list=im_list,N=(n,1),offsets=offsets)</span>

<span class="sd">    Parameters:</span>
<span class="sd">        im_list:                A list containing the `galsim.Image` instances to be interleaved.</span>
<span class="sd">        N:                      Number of images to interleave in either directions. It can be of</span>
<span class="sd">                                type ``int`` if equal number of images are interleaved in both</span>
<span class="sd">                                directions or a list or tuple of two integers, containing the number</span>
<span class="sd">                                of images in x and y directions respectively.</span>
<span class="sd">        offsets:                A list containing the offsets as galsim.PositionD instances</span>
<span class="sd">                                corresponding to every image in ``im_list``. The offsets must be</span>
<span class="sd">                                spaced equally and must span an entire pixel area. The offset</span>
<span class="sd">                                values must be symmetric around zero, hence taking positive and</span>
<span class="sd">                                negative values, with upper and lower limits of +0.5 and -0.5</span>
<span class="sd">                                (limit values excluded).</span>
<span class="sd">        add_flux:               Should the routine add the fluxes of all the images (True) or</span>
<span class="sd">                                average them (False)? [default: True]</span>
<span class="sd">        suppress_warnings:      Suppresses the warnings about the pixel scale of the output, if</span>
<span class="sd">                                True.  [default: False]</span>
<span class="sd">        catch_offset_errors:    Checks for the consistency of ``offsets`` with ``N`` and raises</span>
<span class="sd">                                errors if inconsistencies found (True). Recommended, but could slow</span>
<span class="sd">                                down the routine a little. [default: True]</span>

<span class="sd">    Returns:</span>
<span class="sd">        the interleaved `Image`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="nb">int</span><span class="p">):</span>
        <span class="n">n1</span><span class="p">,</span><span class="n">n2</span> <span class="o">=</span> <span class="n">N</span><span class="p">,</span><span class="n">N</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">n1</span><span class="p">,</span><span class="n">n2</span> <span class="o">=</span> <span class="n">N</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;N must be an integer or a tuple of two integers&quot;</span><span class="p">)</span> <span class="kn">from</span> <span class="kc">None</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">im_list</span><span class="p">)</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">GalSimValueError</span><span class="p">(</span><span class="s2">&quot;im_list must have at least two instances of galsim.Image&quot;</span><span class="p">,</span> <span class="n">im_list</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">n1</span><span class="o">*</span><span class="n">n2</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">im_list</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="n">GalSimIncompatibleValuesError</span><span class="p">(</span>
            <span class="s2">&quot;N is incompatible with the number of images in im_list&quot;</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="n">N</span><span class="p">,</span> <span class="n">im_list</span><span class="o">=</span><span class="n">im_list</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">im_list</span><span class="p">)</span><span class="o">!=</span><span class="nb">len</span><span class="p">(</span><span class="n">offsets</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">GalSimIncompatibleValuesError</span><span class="p">(</span>
            <span class="s2">&quot;im_list and offsets must be lists of same length&quot;</span><span class="p">,</span> <span class="n">im_list</span><span class="o">=</span><span class="n">im_list</span><span class="p">,</span> <span class="n">offsets</span><span class="o">=</span><span class="n">offsets</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">offset</span> <span class="ow">in</span> <span class="n">offsets</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="n">PositionD</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;offsets must be a list of galsim.PositionD instances&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">im_list</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Image</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;im_list must be a list of galsim.Image instances&quot;</span><span class="p">)</span>

    <span class="c1"># These should be the same for all images in im_list.</span>
    <span class="n">y_size</span><span class="p">,</span> <span class="n">x_size</span> <span class="o">=</span> <span class="n">im_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">wcs</span> <span class="o">=</span> <span class="n">im_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">wcs</span>

    <span class="k">for</span> <span class="n">im</span> <span class="ow">in</span> <span class="n">im_list</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">Image</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;im_list must be a list of galsim.Image instances&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">im</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="n">y_size</span><span class="p">,</span><span class="n">x_size</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">GalSimIncompatibleValuesError</span><span class="p">(</span>
                <span class="s2">&quot;All galsim.Image instances in im_list must be of the same size&quot;</span><span class="p">,</span> <span class="n">im_list</span><span class="o">=</span><span class="n">im_list</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">im</span><span class="o">.</span><span class="n">wcs</span> <span class="o">!=</span> <span class="n">wcs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">GalSimIncompatibleValuesError</span><span class="p">(</span>
                <span class="s2">&quot;All galsim.Image instances in im_list must have the same WCS&quot;</span><span class="p">,</span> <span class="n">im_list</span><span class="o">=</span><span class="n">im_list</span><span class="p">)</span>

    <span class="n">img_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n2</span><span class="o">*</span><span class="n">y_size</span><span class="p">,</span><span class="n">n1</span><span class="o">*</span><span class="n">x_size</span><span class="p">))</span>
    <span class="c1"># The tricky part - going from (x,y) Image coordinates to array indices</span>
    <span class="c1"># DX[i&#39;] = -(i+0.5)/n+0.5 = -i/n + 0.5*(n-1)/n</span>
    <span class="c1">#    i  = -n DX[i&#39;] + 0.5*(n-1)</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">offsets</span><span class="p">)):</span>
        <span class="n">dx</span><span class="p">,</span> <span class="n">dy</span> <span class="o">=</span> <span class="n">offsets</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">offsets</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">y</span>

        <span class="n">i</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">((</span><span class="n">n1</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="mf">0.5</span><span class="o">-</span><span class="n">n1</span><span class="o">*</span><span class="n">dx</span><span class="p">))</span>
        <span class="n">j</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">((</span><span class="n">n2</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="mf">0.5</span><span class="o">-</span><span class="n">n2</span><span class="o">*</span><span class="n">dy</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">catch_offset_errors</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">err_i</span> <span class="o">=</span> <span class="p">(</span><span class="n">n1</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="mf">0.5</span><span class="o">-</span><span class="n">n1</span><span class="o">*</span><span class="n">dx</span> <span class="o">-</span> <span class="nb">round</span><span class="p">((</span><span class="n">n1</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="mf">0.5</span><span class="o">-</span><span class="n">n1</span><span class="o">*</span><span class="n">dx</span><span class="p">)</span>
            <span class="n">err_j</span> <span class="o">=</span> <span class="p">(</span><span class="n">n2</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="mf">0.5</span><span class="o">-</span><span class="n">n2</span><span class="o">*</span><span class="n">dy</span> <span class="o">-</span> <span class="nb">round</span><span class="p">((</span><span class="n">n2</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="mf">0.5</span><span class="o">-</span><span class="n">n2</span><span class="o">*</span><span class="n">dy</span><span class="p">)</span>
            <span class="n">tol</span> <span class="o">=</span> <span class="mf">1.e-6</span>
            <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">err_i</span><span class="p">)</span><span class="o">&gt;</span><span class="n">tol</span> <span class="ow">or</span> <span class="nb">abs</span><span class="p">(</span><span class="n">err_j</span><span class="p">)</span><span class="o">&gt;</span><span class="n">tol</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">GalSimIncompatibleValuesError</span><span class="p">(</span>
                    <span class="s2">&quot;offsets must be a list of galsim.PositionD instances with x values &quot;</span>
                    <span class="s2">&quot;spaced by 1/</span><span class="si">{0}</span><span class="s2"> and y values by 1/</span><span class="si">{1}</span><span class="s2"> around 0.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">n1</span><span class="p">,</span><span class="n">n2</span><span class="p">),</span>
                    <span class="n">N</span><span class="o">=</span><span class="n">N</span><span class="p">,</span> <span class="n">offsets</span><span class="o">=</span><span class="n">offsets</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">0</span> <span class="ow">or</span> <span class="n">j</span><span class="o">&lt;</span><span class="mi">0</span> <span class="ow">or</span> <span class="n">i</span><span class="o">&gt;=</span><span class="n">n1</span> <span class="ow">or</span> <span class="n">j</span><span class="o">&gt;=</span><span class="n">n2</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">GalSimIncompatibleValuesError</span><span class="p">(</span>
                    <span class="s2">&quot;offsets must be a list of galsim.PositionD instances with x values &quot;</span>
                    <span class="s2">&quot;spaced by 1/</span><span class="si">{0}</span><span class="s2"> and y values by 1/</span><span class="si">{1}</span><span class="s2"> around 0.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">n1</span><span class="p">,</span><span class="n">n2</span><span class="p">),</span>
                    <span class="n">N</span><span class="o">=</span><span class="n">N</span><span class="p">,</span> <span class="n">offsets</span><span class="o">=</span><span class="n">offsets</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># If we&#39;re told to just trust the offsets, at least make sure the slice will be</span>
            <span class="c1"># the right shape.</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">i</span><span class="o">%</span><span class="n">n1</span>
            <span class="n">j</span> <span class="o">=</span> <span class="n">j</span><span class="o">%</span><span class="n">n2</span>

        <span class="n">img_array</span><span class="p">[</span><span class="n">j</span><span class="p">::</span><span class="n">n2</span><span class="p">,</span><span class="n">i</span><span class="p">::</span><span class="n">n1</span><span class="p">]</span> <span class="o">=</span> <span class="n">im_list</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">array</span>

    <span class="n">img</span> <span class="o">=</span> <span class="n">Image</span><span class="p">(</span><span class="n">img_array</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">add_flux</span><span class="p">:</span>
        <span class="c1"># Fix the flux normalization</span>
        <span class="n">img</span> <span class="o">/=</span> <span class="mf">1.0</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">im_list</span><span class="p">)</span>

    <span class="c1"># Assign an appropriate WCS for the output</span>
    <span class="k">if</span> <span class="n">wcs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">wcs</span><span class="o">.</span><span class="n">_isUniform</span><span class="p">:</span>
        <span class="n">jac</span> <span class="o">=</span> <span class="n">wcs</span><span class="o">.</span><span class="n">jacobian</span><span class="p">()</span>
        <span class="n">dudx</span><span class="p">,</span> <span class="n">dudy</span><span class="p">,</span> <span class="n">dvdx</span><span class="p">,</span> <span class="n">dvdy</span> <span class="o">=</span> <span class="n">jac</span><span class="o">.</span><span class="n">dudx</span><span class="p">,</span> <span class="n">jac</span><span class="o">.</span><span class="n">dudy</span><span class="p">,</span> <span class="n">jac</span><span class="o">.</span><span class="n">dvdx</span><span class="p">,</span> <span class="n">jac</span><span class="o">.</span><span class="n">dvdy</span>
        <span class="n">img_wcs</span> <span class="o">=</span> <span class="n">JacobianWCS</span><span class="p">(</span><span class="mf">1.</span><span class="o">*</span><span class="n">dudx</span><span class="o">/</span><span class="n">n1</span><span class="p">,</span><span class="mf">1.</span><span class="o">*</span><span class="n">dudy</span><span class="o">/</span><span class="n">n2</span><span class="p">,</span><span class="mf">1.</span><span class="o">*</span><span class="n">dvdx</span><span class="o">/</span><span class="n">n1</span><span class="p">,</span><span class="mf">1.</span><span class="o">*</span><span class="n">dvdy</span><span class="o">/</span><span class="n">n2</span><span class="p">)</span>
        <span class="c1">## Since pixel scale WCS is not equal to its jacobian, checking if img_wcs is a pixel scale</span>
        <span class="n">img_wcs_decomp</span> <span class="o">=</span> <span class="n">img_wcs</span><span class="o">.</span><span class="n">getDecomposition</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">img_wcs_decomp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">g</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span> <span class="c1">## getDecomposition returns scale,shear,angle,flip</span>
            <span class="n">img</span><span class="o">.</span><span class="n">wcs</span> <span class="o">=</span> <span class="n">PixelScale</span><span class="p">(</span><span class="n">img_wcs_decomp</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">img</span><span class="o">.</span><span class="n">wcs</span> <span class="o">=</span> <span class="n">img_wcs</span>

    <span class="k">elif</span> <span class="ow">not</span> <span class="n">suppress_warnings</span><span class="p">:</span>
        <span class="n">galsim_warn</span><span class="p">(</span><span class="s2">&quot;Interleaved image could not be assigned a WCS automatically.&quot;</span><span class="p">)</span>

    <span class="c1"># Assign a possibly non-trivial origin and warn if individual image have different origins.</span>
    <span class="n">orig</span> <span class="o">=</span> <span class="n">im_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">origin</span>
    <span class="n">img</span><span class="o">.</span><span class="n">setOrigin</span><span class="p">(</span><span class="n">orig</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">im</span><span class="o">.</span><span class="n">origin</span> <span class="o">!=</span> <span class="n">orig</span> <span class="k">for</span> <span class="n">im</span> <span class="ow">in</span> <span class="n">im_list</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">suppress_warnings</span><span class="p">:</span>
            <span class="n">galsim_warn</span><span class="p">(</span><span class="s2">&quot;Images in im_list have multiple values for origin. Assigning the &quot;</span>
                        <span class="s2">&quot;origin of the first Image instance in im_list to the interleaved image.&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">img</span></div>

<div class="viewcode-block" id="printoptions"><a class="viewcode-back" href="../../misc.html#galsim.utilities.printoptions">[docs]</a><span class="nd">@contextmanager</span>
<span class="k">def</span> <span class="nf">printoptions</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A context manager for using different numpy printoptions temporarily</span>

<span class="sd">    From http://stackoverflow.com/questions/2891790/pretty-printing-of-numpy-array</span>

<span class="sd">    Usage::</span>

<span class="sd">        with printoptions(threshold=len(long_arr)):</span>
<span class="sd">            print(long_arr)  # Doesn&#39;t omit values in the middle of the array</span>
<span class="sd">        print(long_arr)  # If the array is long enough, will use ... in the middle.</span>

<span class="sd">    .. note::</span>
<span class="sd">        It seems Numpy finally added this feature in version 1.15.  So this is probably</span>
<span class="sd">        equivalent to using ``numpy.printoptions`` instead of ``galsim.utilities.printoptions``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">original</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">get_printoptions</span><span class="p">()</span>
    <span class="n">np</span><span class="o">.</span><span class="n">set_printoptions</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="c1"># contextmanager exception handling is tricky.  Don&#39;t forget to wrap the yield:</span>
    <span class="c1"># http://preshing.com/20110920/the-python-with-statement-by-example/</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">yield</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="n">np</span><span class="o">.</span><span class="n">set_printoptions</span><span class="p">(</span><span class="o">**</span><span class="n">original</span><span class="p">)</span></div>


<span class="n">_pickle_shared</span> <span class="o">=</span> <span class="kc">False</span>

<div class="viewcode-block" id="pickle_shared"><a class="viewcode-back" href="../../misc.html#galsim.utilities.pickle_shared">[docs]</a><span class="nd">@contextmanager</span>
<span class="k">def</span> <span class="nf">pickle_shared</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A context manager to flag that one wishes to include object state from shared memory in</span>
<span class="sd">    pickle objects.</span>

<span class="sd">    Example::</span>

<span class="sd">        obj = galsim_obj_with_shared_state()  # e.g., galsim.phase_screens.AtmosphericScreen</span>
<span class="sd">        pickle.dump(obj, file)</span>

<span class="sd">        # restart python, unloading shared state</span>
<span class="sd">        obj = pickle.load(file)  # fails due to missing shared state.</span>

<span class="sd">        obj = galsim_obj_with_shared_state()</span>
<span class="sd">        with pickle_shared():</span>
<span class="sd">            pickle.dump(obj, filename)</span>

<span class="sd">        # restart python, again unloading shared state</span>
<span class="sd">        obj = pickle.load(file)  # loads both obj and required shared state.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">global</span> <span class="n">_pickle_shared</span>
    <span class="n">original</span> <span class="o">=</span> <span class="n">_pickle_shared</span>
    <span class="n">_pickle_shared</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">yield</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="n">_pickle_shared</span> <span class="o">=</span> <span class="n">original</span></div>


<div class="viewcode-block" id="listify"><a class="viewcode-back" href="../../misc.html#galsim.utilities.listify">[docs]</a><span class="k">def</span> <span class="nf">listify</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Turn argument into a list if not already iterable.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        arg:        An argument that may be a lit or a single item</span>

<span class="sd">    Returns:</span>
<span class="sd">        [arg] if arg was not already a list, otherwise arg.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">arg</span><span class="p">]</span> <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="s1">&#39;__iter__&#39;</span><span class="p">)</span> <span class="k">else</span> <span class="n">arg</span></div>


<div class="viewcode-block" id="dol_to_lod"><a class="viewcode-back" href="../../misc.html#galsim.utilities.dol_to_lod">[docs]</a><span class="k">def</span> <span class="nf">dol_to_lod</span><span class="p">(</span><span class="n">dol</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">scalar_string</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generate list of dicts from dict of lists (with broadcasting).</span>
<span class="sd">    Specifically, generate &quot;scalar-valued&quot; kwargs dictionaries from a kwarg dictionary with values</span>
<span class="sd">    that are length-N lists, or possibly length-1 lists or scalars that should be broadcasted up to</span>
<span class="sd">    length-N lists.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        dol:            A dict of lists</span>
<span class="sd">        N:              The length of the lists if known in advance. [default: None, which will</span>
<span class="sd">                        determine the maximum length of the lists for you]</span>
<span class="sd">        scalar_string:  Whether strings in the input list should be treated as scalars (and thus</span>
<span class="sd">                        broadcast to each item in the output) or not (in which case, they will</span>
<span class="sd">                        be treated as lists of characters) [default: True]</span>

<span class="sd">    Returns:</span>
<span class="sd">        A list of dicts</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">N</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">scalar_string</span><span class="p">:</span>
            <span class="n">lens</span> <span class="o">=</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">dol</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
                           <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="s1">&#39;__len__&#39;</span><span class="p">)</span>
                           <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="nb">str</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">lens</span> <span class="o">=</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">dol</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
                           <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="s1">&#39;__len__&#39;</span><span class="p">)]</span>
        <span class="n">N</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">lens</span><span class="p">)</span> <span class="k">if</span> <span class="n">lens</span> <span class="o">!=</span> <span class="p">[]</span> <span class="k">else</span> <span class="mi">1</span>
    <span class="c1"># Loop through broadcast range</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
        <span class="n">out</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">dol</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">scalar_string</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">out</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
                <span class="k">continue</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">out</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>  <span class="c1"># It&#39;s list-like, but too short.</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">GalSimIncompatibleValuesError</span><span class="p">(</span>
                        <span class="s2">&quot;Cannot broadcast kwargs of different non-length-1 lengths.&quot;</span><span class="p">,</span> <span class="n">dol</span><span class="o">=</span><span class="n">dol</span><span class="p">)</span> <span class="kn">from</span> <span class="kc">None</span>
                <span class="n">out</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>  <span class="c1"># Value is not list-like, so broadcast it in its entirety.</span>
                <span class="n">out</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">GalSimIncompatibleValuesError</span><span class="p">(</span>
                    <span class="s2">&quot;Cannot broadcast kwarg </span><span class="si">{0}</span><span class="s2">=</span><span class="si">{1}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">),</span> <span class="n">dol</span><span class="o">=</span><span class="n">dol</span><span class="p">)</span>
        <span class="k">yield</span> <span class="n">out</span></div>

<div class="viewcode-block" id="structure_function"><a class="viewcode-back" href="../../misc.html#galsim.utilities.structure_function">[docs]</a><span class="k">def</span> <span class="nf">structure_function</span><span class="p">(</span><span class="n">image</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Estimate the angularly-averaged structure function of a 2D random field.</span>

<span class="sd">    The angularly-averaged structure function D(r) of the 2D field phi is defined as:</span>

<span class="sd">    .. math::</span>
<span class="sd">        D(|r|) = \langle |phi(x) - phi(x+r)|^2 \rangle</span>

<span class="sd">    where the x and r on the RHS are 2D vectors, but the :math:`|r|` on the LHS is just a scalar</span>
<span class="sd">    length.</span>

<span class="sd">    The image must have its ``scale`` attribute defined.  It will be used in the calculations to</span>
<span class="sd">    set the scale of the radial distances.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        image:  `Image` containing random field realization.</span>

<span class="sd">    Returns:</span>
<span class="sd">        A python callable mapping a separation length r to the estimate of the structure</span>
<span class="sd">        function D(r).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">array</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">array</span>
    <span class="n">ny</span><span class="p">,</span> <span class="n">nx</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">scale</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">scale</span>

    <span class="c1"># The structure function can be derived from the correlation function B(r) as:</span>
    <span class="c1"># D(r) = 2 * [B(0) - B(r)]</span>

    <span class="n">corr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifft2</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft2</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span><span class="n">array</span><span class="p">)))</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">real</span> <span class="o">/</span> <span class="p">(</span><span class="n">nx</span> <span class="o">*</span> <span class="n">ny</span><span class="p">)</span>
    <span class="c1"># Check that the zero-lag correlation function is equal to the variance before doing the</span>
    <span class="c1"># ifftshift.</span>
    <span class="c1">#assert (corr[0, 0] / np.var(array) - 1.0) &lt; 1e-6</span>
    <span class="n">corr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifftshift</span><span class="p">(</span><span class="n">corr</span><span class="p">)</span>

    <span class="n">x</span> <span class="o">=</span> <span class="n">scale</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nx</span><span class="p">)</span> <span class="o">-</span> <span class="n">nx</span><span class="o">//</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">scale</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">ny</span><span class="p">)</span> <span class="o">-</span> <span class="n">ny</span><span class="o">//</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">tab</span> <span class="o">=</span> <span class="n">LookupTable2D</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">corr</span><span class="p">)</span>
    <span class="n">thetas</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">0.</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>  <span class="c1"># Average over these angles.</span>

    <span class="k">return</span> <span class="k">lambda</span> <span class="n">r</span><span class="p">:</span> <span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">tab</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">tab</span><span class="p">(</span><span class="n">r</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">thetas</span><span class="p">),</span> <span class="n">r</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">thetas</span><span class="p">))))</span></div>

<div class="viewcode-block" id="merge_sorted"><a class="viewcode-back" href="../../misc.html#galsim.utilities.merge_sorted">[docs]</a><span class="k">def</span> <span class="nf">merge_sorted</span><span class="p">(</span><span class="n">arrays</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Merge 2 or more numpy arrays into a single merged array.</span>

<span class="sd">    Each of the input arrays must be already sorted.</span>

<span class="sd">    This is equivalent to np.unique(np.concatenate(arrays)), but much faster.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        arrays:     A list of arrays to merge.</span>

<span class="sd">    Returns:</span>
<span class="sd">        A single numpy.array with the merged values.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_galsim</span><span class="o">.</span><span class="n">MergeSorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">arrays</span><span class="p">))</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="c1"># Probably the inputs are not sorted.  Try to give the user more information.</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">a</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">arrays</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">):</span>
                <span class="k">raise</span> <span class="n">GalSimValueError</span><span class="p">(</span><span class="s2">&quot;Not all arrays input to merge_sorted are sorted.&quot;</span> <span class="o">+</span>
                                       <span class="s2">&quot;The first such case is at index </span><span class="si">%s</span><span class="s2">&quot;</span><span class="o">%</span><span class="n">i</span><span class="p">,</span>
                                       <span class="n">value</span><span class="o">=</span><span class="n">a</span><span class="p">)</span> <span class="kn">from</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># That wasn&#39;t it.  Just reraise the exception, converted to a GalSimError.</span>
            <span class="k">raise</span> <span class="n">GalSimError</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">))</span> <span class="kn">from</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="combine_wave_list"><a class="viewcode-back" href="../../misc.html#galsim.utilities.combine_wave_list">[docs]</a><span class="k">def</span> <span class="nf">combine_wave_list</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Combine wave_list attributes of all objects in obj_list while respecting blue_limit and</span>
<span class="sd">    red_limit attributes.  Should work with any combination of `SED`, `Bandpass`, and</span>
<span class="sd">    `ChromaticObject` instances.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        obj_list:   List of `SED`, `Bandpass`, or `ChromaticObject` instances.</span>

<span class="sd">    Returns:</span>
<span class="sd">        wave_list, blue_limit, red_limit</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
            <span class="n">args</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Single input argument must be a list or tuple&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">),</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">obj</span><span class="o">.</span><span class="n">wave_list</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s1">&#39;blue_limit&#39;</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">),</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s1">&#39;red_limit&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>

    <span class="n">blue_limit</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">([</span><span class="nb">getattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s1">&#39;blue_limit&#39;</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span> <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">args</span><span class="p">])</span>
    <span class="n">red_limit</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">([</span><span class="nb">getattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s1">&#39;red_limit&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span> <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">args</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">blue_limit</span> <span class="o">&gt;</span> <span class="n">red_limit</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">GalSimError</span><span class="p">(</span><span class="s2">&quot;Empty wave_list intersection.&quot;</span><span class="p">)</span>

    <span class="n">waves</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">wave_list</span><span class="p">)</span> <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">args</span><span class="p">]</span>
    <span class="n">waves</span> <span class="o">=</span> <span class="p">[</span><span class="n">w</span><span class="p">[(</span><span class="n">blue_limit</span> <span class="o">&lt;=</span> <span class="n">w</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">w</span> <span class="o">&lt;=</span> <span class="n">red_limit</span><span class="p">)]</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">waves</span><span class="p">]</span>
    <span class="c1"># Make sure both limits are included in final list</span>
    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">waves</span><span class="p">):</span>
        <span class="n">waves</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">blue_limit</span><span class="p">,</span> <span class="n">red_limit</span><span class="p">])</span>
    <span class="n">wave_list</span> <span class="o">=</span> <span class="n">merge_sorted</span><span class="p">(</span><span class="n">waves</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">wave_list</span><span class="p">,</span> <span class="n">blue_limit</span><span class="p">,</span> <span class="n">red_limit</span></div>

<div class="viewcode-block" id="functionize"><a class="viewcode-back" href="../../misc.html#galsim.utilities.functionize">[docs]</a><span class="k">def</span> <span class="nf">functionize</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Decorate a function ``f`` which accepts scalar positional or keyword arguments, to accept</span>
<span class="sd">    arguments that can be either scalars or _functions_.  If the arguments include univariate</span>
<span class="sd">    (N-variate) functions, then the output will be a univariate (N-variate) function.  While it&#39;s</span>
<span class="sd">    okay to mix scalar and N-variate function arguments, it is an error to mix N-variate and</span>
<span class="sd">    M-variate function arguments.</span>

<span class="sd">    Example::</span>

<span class="sd">        &gt;&gt;&gt; def f(x, y):      # Function of two scalars.</span>
<span class="sd">        ...     return x + y</span>
<span class="sd">        &gt;&gt;&gt; decorated = functionize(f)   # Function of two scalars, functions, or a mix.</span>
<span class="sd">        &gt;&gt;&gt; result = f(2, 3)  # 5</span>
<span class="sd">        &gt;&gt;&gt; result = f(2, lambda u: u)  # Generates a TypeError</span>
<span class="sd">        &gt;&gt;&gt; result = decorated(2, 3)  # Scalar args returns a scalar</span>
<span class="sd">        &gt;&gt;&gt; result = decorated(2, lambda u: u)  # Univariate argument leads to a univariate output.</span>
<span class="sd">        &gt;&gt;&gt; print(result(5))  # 7</span>
<span class="sd">        &gt;&gt;&gt; result = decorated(2, lambda u,v: u*v)  # Bivariate argument leads to a bivariate output.</span>
<span class="sd">        &gt;&gt;&gt; print(result(5, 7))  # 2 + (5*7) = 37</span>

<span class="sd">    We can use arguments that accept keyword arguments too::</span>

<span class="sd">        &gt;&gt;&gt; def f2(u, v=None):</span>
<span class="sd">        ...    if v is None:</span>
<span class="sd">        ...        v = 6.0</span>
<span class="sd">        ...    return u / v</span>
<span class="sd">        &gt;&gt;&gt; result = decorated(2, f2)</span>
<span class="sd">        &gt;&gt;&gt; print(result(12))  # 2 + (12./6) = 4.0</span>
<span class="sd">        &gt;&gt;&gt; print(result(12, v=4))  # 2 + (12/4) = 5</span>

<span class="sd">    Note that you can also use python&#39;s decorator syntax::</span>

<span class="sd">        &gt;&gt;&gt; @functionize</span>
<span class="sd">        &gt;&gt;&gt; def f(x, y):</span>
<span class="sd">        ...     return x + y</span>

<span class="sd">    Parameters:</span>
<span class="sd">        f:      The function to be decorated.</span>

<span class="sd">    Returns:</span>
<span class="sd">        The decorated function.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nd">@functools</span><span class="o">.</span><span class="n">wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">ff</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># First check if any of the arguments are callable...</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="nb">hasattr</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="s1">&#39;__call__&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span><span class="o">+</span><span class="nb">tuple</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">values</span><span class="p">())):</span>
            <span class="k">return</span> <span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>  <span class="c1"># ... if not, then keep output type a scalar ...</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">def</span> <span class="nf">fff</span><span class="p">(</span><span class="o">*</span><span class="n">inner_args</span><span class="p">,</span> <span class="o">**</span><span class="n">inner_kwargs</span><span class="p">):</span> <span class="c1"># ...else the output type is a function: fff.</span>
                <span class="n">new_args</span> <span class="o">=</span> <span class="p">[</span><span class="n">arg</span>
                            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="s1">&#39;__call__&#39;</span><span class="p">)</span>
                            <span class="k">else</span> <span class="n">arg</span><span class="p">(</span><span class="o">*</span><span class="n">inner_args</span><span class="p">,</span> <span class="o">**</span><span class="n">inner_kwargs</span><span class="p">)</span>
                            <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span><span class="p">]</span>
                <span class="n">new_kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
                                   <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="s1">&#39;__call__&#39;</span><span class="p">)</span>
                                   <span class="k">else</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">(</span><span class="o">*</span><span class="n">inner_args</span><span class="p">,</span> <span class="o">**</span><span class="n">inner_kwargs</span><span class="p">))</span>
                                   <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">()])</span>
                <span class="k">return</span> <span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="n">new_args</span><span class="p">,</span> <span class="o">**</span><span class="n">new_kwargs</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">fff</span>
    <span class="k">return</span> <span class="n">ff</span></div>

<div class="viewcode-block" id="binomial"><a class="viewcode-back" href="../../misc.html#galsim.utilities.binomial">[docs]</a><span class="k">def</span> <span class="nf">binomial</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return xy coefficients of (ax + by)^n ordered by descending powers of a.</span>

<span class="sd">    Example::</span>

<span class="sd">        # (x + y)^3 = 1 x^3 + 3 x^2 y + 3 x y^2 + 1 y^3</span>
<span class="sd">        &gt;&gt;&gt;  print(binomial(1, 1, 3))</span>
<span class="sd">        array([ 1.,  3.,  3.,  1.])</span>


<span class="sd">        # (2 x + y)^3 = 8 x^3 + 12 x^2 y + 6 x y^2 + 1 y^3</span>
<span class="sd">        &gt;&gt;&gt;  print(binomial(2, 1, 3))</span>
<span class="sd">        array([ 8.,  12.,  6.,  1.])</span>

<span class="sd">    Parameters:</span>
<span class="sd">        a:      First scalar in binomial to be expanded.</span>
<span class="sd">        b:      Second scalar in binomial to be expanded.</span>
<span class="sd">        n:      Exponent of expansion.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Array of coefficients in expansion.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">b_over_a</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">generate</span><span class="p">():</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">a</span><span class="o">**</span><span class="n">n</span>
        <span class="k">yield</span> <span class="n">c</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>  <span class="c1"># pragma: no branch  (It never actually gets past the last yield.)</span>
            <span class="n">c</span> <span class="o">*=</span> <span class="n">b_over_a</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="n">i</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">yield</span> <span class="n">c</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">fromiter</span><span class="p">(</span><span class="n">generate</span><span class="p">(),</span> <span class="nb">float</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span></div>

<div class="viewcode-block" id="unweighted_moments"><a class="viewcode-back" href="../../misc.html#galsim.utilities.unweighted_moments">[docs]</a><span class="k">def</span> <span class="nf">unweighted_moments</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Computes unweighted 0th, 1st, and 2nd moments in image coordinates.  Respects image bounds,</span>
<span class="sd">    but ignores any scale or wcs.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        image:      `Image` from which to compute moments</span>
<span class="sd">        origin:     Optional origin in image coordinates used to compute Mx and My</span>
<span class="sd">                    [default: galsim.PositionD(0, 0)].</span>

<span class="sd">    Returns:</span>
<span class="sd">        Dict with entries for [M0, Mx, My, Mxx, Myy, Mxy]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">origin</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">origin</span> <span class="o">=</span> <span class="n">_PositionD</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">offset</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">origin</span> <span class="o">-</span> <span class="n">origin</span>
    <span class="n">xgrid</span><span class="p">,</span> <span class="n">ygrid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">offset</span><span class="o">.</span><span class="n">x</span><span class="p">,</span>
                               <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="n">offset</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
    <span class="n">M0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">Mx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">xgrid</span> <span class="o">*</span> <span class="n">a</span><span class="p">)</span> <span class="o">/</span> <span class="n">M0</span>
    <span class="n">My</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ygrid</span> <span class="o">*</span> <span class="n">a</span><span class="p">)</span> <span class="o">/</span> <span class="n">M0</span>
    <span class="n">Mxx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(((</span><span class="n">xgrid</span><span class="o">-</span><span class="n">Mx</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">a</span><span class="p">)</span> <span class="o">/</span> <span class="n">M0</span>
    <span class="n">Myy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(((</span><span class="n">ygrid</span><span class="o">-</span><span class="n">My</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">a</span><span class="p">)</span> <span class="o">/</span> <span class="n">M0</span>
    <span class="n">Mxy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">xgrid</span><span class="o">-</span><span class="n">Mx</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">ygrid</span><span class="o">-</span><span class="n">My</span><span class="p">)</span> <span class="o">*</span> <span class="n">a</span><span class="p">)</span> <span class="o">/</span> <span class="n">M0</span>
    <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="n">M0</span><span class="o">=</span><span class="n">M0</span><span class="p">,</span> <span class="n">Mx</span><span class="o">=</span><span class="n">Mx</span><span class="p">,</span> <span class="n">My</span><span class="o">=</span><span class="n">My</span><span class="p">,</span> <span class="n">Mxx</span><span class="o">=</span><span class="n">Mxx</span><span class="p">,</span> <span class="n">Myy</span><span class="o">=</span><span class="n">Myy</span><span class="p">,</span> <span class="n">Mxy</span><span class="o">=</span><span class="n">Mxy</span><span class="p">)</span></div>

<div class="viewcode-block" id="unweighted_shape"><a class="viewcode-back" href="../../misc.html#galsim.utilities.unweighted_shape">[docs]</a><span class="k">def</span> <span class="nf">unweighted_shape</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Computes unweighted second moment size and ellipticity given either an image or a dict of</span>
<span class="sd">    unweighted moments.</span>

<span class="sd">    The size is:</span>
<span class="sd">        rsqr = Mxx+Myy</span>
<span class="sd">    The ellipticities are:</span>
<span class="sd">        e1 = (Mxx-Myy) / rsqr</span>
<span class="sd">        e2 = 2*Mxy / rsqr</span>

<span class="sd">    Parameters:</span>
<span class="sd">        arg:    Either a `galsim.Image` or the output of unweighted_moments(image).</span>

<span class="sd">    Returns:</span>
<span class="sd">        Dict with entries for [rsqr, e1, e2]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">Image</span><span class="p">):</span>
        <span class="n">arg</span> <span class="o">=</span> <span class="n">unweighted_moments</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
    <span class="n">rsqr</span> <span class="o">=</span> <span class="n">arg</span><span class="p">[</span><span class="s1">&#39;Mxx&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">arg</span><span class="p">[</span><span class="s1">&#39;Myy&#39;</span><span class="p">]</span>
    <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="n">rsqr</span><span class="o">=</span><span class="n">rsqr</span><span class="p">,</span> <span class="n">e1</span><span class="o">=</span><span class="p">(</span><span class="n">arg</span><span class="p">[</span><span class="s1">&#39;Mxx&#39;</span><span class="p">]</span><span class="o">-</span><span class="n">arg</span><span class="p">[</span><span class="s1">&#39;Myy&#39;</span><span class="p">])</span><span class="o">/</span><span class="n">rsqr</span><span class="p">,</span> <span class="n">e2</span><span class="o">=</span><span class="mi">2</span><span class="o">*</span><span class="n">arg</span><span class="p">[</span><span class="s1">&#39;Mxy&#39;</span><span class="p">]</span><span class="o">/</span><span class="n">rsqr</span><span class="p">)</span></div>

<div class="viewcode-block" id="rand_with_replacement"><a class="viewcode-back" href="../../misc.html#galsim.utilities.rand_with_replacement">[docs]</a><span class="k">def</span> <span class="nf">rand_with_replacement</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">n_choices</span><span class="p">,</span> <span class="n">rng</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">_n_rng_calls</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Select some number of random choices from a list, with replacement, using a supplied RNG.</span>

<span class="sd">    ``n`` random choices with replacement are made assuming that those choices should range from 0</span>
<span class="sd">    to ``n_choices-1``, so they can be used as indices in a list/array.  If ``weight`` is supplied,</span>
<span class="sd">    then it should be an array of length ``n_choices`` that ranges from 0-1, and can be used to</span>
<span class="sd">    make weighted choices from the list.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        n:          Number of random selections to make.</span>
<span class="sd">        n_choices:  Number of entries from which to choose.</span>
<span class="sd">        rng:        RNG to use.  Must a `galsim.BaseDeviate` instance.</span>
<span class="sd">        weight:     Optional list of weight factors to use for weighting the selection of</span>
<span class="sd">                    random indices.</span>

<span class="sd">    Returns:</span>
<span class="sd">        a NumPy array of length n containing the integer-valued indices that were selected.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Make sure we got a proper RNG.</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">rng</span><span class="p">,</span> <span class="n">BaseDeviate</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;The rng provided to rand_with_replacement() must be a BaseDeviate&quot;</span><span class="p">)</span>
    <span class="n">ud</span> <span class="o">=</span> <span class="n">UniformDeviate</span><span class="p">(</span><span class="n">rng</span><span class="p">)</span>

    <span class="c1"># Sanity check the requested number of random indices.</span>
    <span class="c1"># Note: we do not require that the type be an int, as long as the value is consistent with</span>
    <span class="c1"># an integer value (i.e., it could be a float 1.0 or 1).</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">!=</span> <span class="nb">int</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="ow">or</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">GalSimValueError</span><span class="p">(</span><span class="s2">&quot;n must be an integer &gt;= 1.&quot;</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">n_choices</span> <span class="o">!=</span> <span class="nb">int</span><span class="p">(</span><span class="n">n_choices</span><span class="p">)</span> <span class="ow">or</span> <span class="n">n_choices</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">GalSimValueError</span><span class="p">(</span><span class="s2">&quot;n_choices must be an integer &gt;= 1.&quot;</span><span class="p">,</span> <span class="n">n_choices</span><span class="p">)</span>

    <span class="c1"># Sanity check the input weight.</span>
    <span class="k">if</span> <span class="n">weight</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># We need some sanity checks here in case people passed in weird values.</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">weight</span><span class="p">)</span> <span class="o">!=</span> <span class="n">n_choices</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">GalSimIncompatibleValuesError</span><span class="p">(</span>
                <span class="s2">&quot;Array of weights has wrong length&quot;</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="n">weight</span><span class="p">,</span> <span class="n">n_choices</span><span class="o">=</span><span class="n">n_choices</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">weight</span><span class="p">))</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">weight</span><span class="p">))</span> <span class="ow">or</span>
            <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">weight</span><span class="p">)</span><span class="o">&lt;</span><span class="mi">0</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">weight</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">GalSimRangeError</span><span class="p">(</span><span class="s2">&quot;Supplied weights include values outside [0,1] or inf/NaN.&quot;</span><span class="p">,</span>
                                   <span class="n">weight</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">)</span>

    <span class="c1"># We first make a random list of integer indices.</span>
    <span class="n">index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="n">ud</span><span class="o">.</span><span class="n">generate</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">_n_rng_calls</span><span class="p">:</span>
        <span class="c1"># Here we use the undocumented kwarg (for internal use by config) to track the number of</span>
        <span class="c1"># RNG calls.</span>
        <span class="n">n_rng_calls</span> <span class="o">=</span> <span class="n">n</span>
    <span class="n">index</span> <span class="o">=</span> <span class="p">(</span><span class="n">n_choices</span><span class="o">*</span><span class="n">index</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

    <span class="c1"># Then we account for the weights, if possible.</span>
    <span class="k">if</span> <span class="n">weight</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># If weight factors are available, make sure the random selection uses the weights.</span>
        <span class="n">test_vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="c1"># Note that the weight values by definition have a maximum of 1, as enforced above.</span>
        <span class="n">ud</span><span class="o">.</span><span class="n">generate</span><span class="p">(</span><span class="n">test_vals</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">_n_rng_calls</span><span class="p">:</span>
            <span class="n">n_rng_calls</span> <span class="o">+=</span> <span class="n">n</span>
        <span class="c1"># The ones with mask==True are the ones we should replace.</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">test_vals</span> <span class="o">&gt;</span> <span class="n">weight</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
        <span class="k">while</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">mask</span><span class="p">):</span>
            <span class="c1"># Update the index and test values for those that failed. We have to do this by</span>
            <span class="c1"># generating random numbers into new arrays, because ud.generate() does not enable</span>
            <span class="c1"># us to directly populate a sub-array like index[mask] or test_vals[mask].</span>
            <span class="n">n_fail</span> <span class="o">=</span> <span class="n">mask</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
            <span class="c1"># First update the indices that failed.</span>
            <span class="n">new_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_fail</span><span class="p">)</span>
            <span class="n">ud</span><span class="o">.</span><span class="n">generate</span><span class="p">(</span><span class="n">new_arr</span><span class="p">)</span>
            <span class="n">index</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">n_choices</span><span class="o">*</span><span class="n">new_arr</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
            <span class="c1"># Then update the test values that failed.</span>
            <span class="n">new_test_vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_fail</span><span class="p">)</span>
            <span class="n">ud</span><span class="o">.</span><span class="n">generate</span><span class="p">(</span><span class="n">new_test_vals</span><span class="p">)</span>
            <span class="n">test_vals</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_test_vals</span>
            <span class="k">if</span> <span class="n">_n_rng_calls</span><span class="p">:</span>
                <span class="n">n_rng_calls</span> <span class="o">+=</span> <span class="mi">2</span><span class="o">*</span><span class="n">n_fail</span>
            <span class="c1"># Finally, update the test array used to determine whether any galaxies failed.</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">test_vals</span> <span class="o">&gt;</span> <span class="n">weight</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">_n_rng_calls</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">index</span><span class="p">,</span> <span class="n">n_rng_calls</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">index</span></div>


<div class="viewcode-block" id="check_share_file"><a class="viewcode-back" href="../../misc.html#galsim.utilities.check_share_file">[docs]</a><span class="k">def</span> <span class="nf">check_share_file</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">subdir</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Find `SED` or `Bandpass` file, possibly adding share_dir/subdir.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        filename:       The file name to look for</span>
<span class="sd">        subdir:         The subdirectory of `galsim.meta_data.share_dir` where this file might be.</span>

<span class="sd">    Returns:</span>
<span class="sd">        True, correct_filename      if the file was found</span>
<span class="sd">        False, &#39;&#39;                   if not</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">True</span><span class="p">,</span> <span class="n">filename</span>

    <span class="n">new_filename</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">meta_data</span><span class="o">.</span><span class="n">share_dir</span><span class="p">,</span> <span class="n">subdir</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">new_filename</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">True</span><span class="p">,</span> <span class="n">new_filename</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span><span class="p">,</span> <span class="s1">&#39;&#39;</span></div>


<div class="viewcode-block" id="OrderedWeakRef"><a class="viewcode-back" href="../../misc.html#galsim.utilities.OrderedWeakRef">[docs]</a><span class="k">class</span> <span class="nc">OrderedWeakRef</span><span class="p">(</span><span class="n">weakref</span><span class="o">.</span><span class="n">ref</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Assign an arbitrary ordering to weakref.ref so that it can be part of a heap.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">id</span><span class="p">(</span><span class="n">other</span><span class="p">)</span></div>


<div class="viewcode-block" id="nCr"><a class="viewcode-back" href="../../misc.html#galsim.utilities.nCr">[docs]</a><span class="k">def</span> <span class="nf">nCr</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Combinations.  I.e., the number of ways to choose ``r`` distiguishable things from ``n``</span>
<span class="sd">    distinguishable things.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        n       The number of options to choose from.</span>
<span class="sd">        r       The number of items to choose</span>

<span class="sd">    Returns:</span>
<span class="sd">        nCr, the (n,r) binomial coefficient.</span>

<span class="sd">    .. note::</span>
<span class="sd">        In Python 3, the factorial function was improved such that doing this the direct way</span>
<span class="sd">        of calculating n! / (r! (n-r)!) seems to be the fastest algorith.  In Python 2, for</span>
<span class="sd">        largish values of n, a more complicated algorithm that avoided large integers was</span>
<span class="sd">        faster.  This function uses the direct method for both -- we don&#39;t bother to check the</span>
<span class="sd">        version of Python to potentially select a different algorithm in the two cases.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">r</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">math</span><span class="o">.</span><span class="n">factorial</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">//</span> <span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">factorial</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">factorial</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="n">r</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span></div>

<div class="viewcode-block" id="set_omp_threads"><a class="viewcode-back" href="../../misc.html#galsim.utilities.set_omp_threads">[docs]</a><span class="k">def</span> <span class="nf">set_omp_threads</span><span class="p">(</span><span class="n">num_threads</span><span class="p">,</span> <span class="n">logger</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Set the number of OpenMP threads to use in the C++ layer.</span>

<span class="sd">    :param num_threads: The target number of threads to use (If None or &lt;=0, then try to use the</span>
<span class="sd">                        numer of cpus.)</span>
<span class="sd">    :param logger:      If desired, a logger object for logging any warnings here. (default: None)</span>

<span class="sd">    :returns:           The  number of threads OpenMP reports that it will use.  Typically this</span>
<span class="sd">                        matches the input, but OpenMP reserves the right not to comply with</span>
<span class="sd">                        the requested number of threads.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># This function was copied shamelessly from TreeCorr&#39;s function of the same name.</span>

    <span class="n">input_num_threads</span> <span class="o">=</span> <span class="n">num_threads</span>  <span class="c1"># Save the input value.</span>

    <span class="c1"># If num_threads is auto, get it from cpu_count</span>
    <span class="k">if</span> <span class="n">num_threads</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">num_threads</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">num_threads</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">cpu_count</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">logger</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;multiprocessing.cpu_count() = </span><span class="si">%d</span><span class="s1">&#39;</span><span class="p">,</span><span class="n">num_threads</span><span class="p">)</span>

    <span class="c1"># Tell OpenMP to use this many threads</span>
    <span class="k">if</span> <span class="n">logger</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Telling OpenMP to use </span><span class="si">%d</span><span class="s1"> threads&#39;</span><span class="p">,</span><span class="n">num_threads</span><span class="p">)</span>

    <span class="c1"># Cf. comment in get_omp_threads.  Do it here too.</span>
    <span class="n">var</span> <span class="o">=</span> <span class="s2">&quot;OMP_PROC_BIND&quot;</span>
    <span class="k">if</span> <span class="n">var</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">:</span>
        <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;false&quot;</span>
    <span class="n">num_threads</span> <span class="o">=</span> <span class="n">_galsim</span><span class="o">.</span><span class="n">SetOMPThreads</span><span class="p">(</span><span class="n">num_threads</span><span class="p">)</span>

    <span class="c1"># Report back appropriately.</span>
    <span class="k">if</span> <span class="n">logger</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;OpenMP reports that it will use </span><span class="si">%d</span><span class="s1"> threads&#39;</span><span class="p">,</span><span class="n">num_threads</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">num_threads</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Using </span><span class="si">%d</span><span class="s1"> threads.&#39;</span><span class="p">,</span><span class="n">num_threads</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">input_num_threads</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">input_num_threads</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># Only warn if the user specifically asked for num_threads != 1.</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Unable to use multiple threads, since OpenMP is not enabled.&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">num_threads</span></div>

<div class="viewcode-block" id="get_omp_threads"><a class="viewcode-back" href="../../misc.html#galsim.utilities.get_omp_threads">[docs]</a><span class="k">def</span> <span class="nf">get_omp_threads</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Get the current number of OpenMP threads to be used in the C++ layer.</span>

<span class="sd">    :returns: num_threads</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Some OMP implemenations have a bug where if omp_get_max_threads() is called</span>
    <span class="c1"># (which is what this function does), it sets something called thread affinity.</span>
    <span class="c1"># The upshot of that is that multiprocessing (i.e. not even just omp threading) is confined</span>
    <span class="c1"># to a single hardware thread.  Yeah, it&#39;s idiotic, but that seems to be the case.</span>
    <span class="c1"># The only solution found by Eli, who looked into it pretty hard, is to set the env</span>
    <span class="c1"># variable OMP_PROC_BIND to &quot;false&quot;.  This seems to stop the bad behavior.</span>
    <span class="c1"># So we do it here always before calling GetOMPThreads.</span>
    <span class="c1"># If this breaks someone valid use of this variable, let us know and we can try to</span>
    <span class="c1"># come up with another solution, but without this lots of multiprocessing breaks.</span>
    <span class="n">var</span> <span class="o">=</span> <span class="s2">&quot;OMP_PROC_BIND&quot;</span>
    <span class="k">if</span> <span class="n">var</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">:</span>
        <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;false&quot;</span>
    <span class="k">return</span> <span class="n">_galsim</span><span class="o">.</span><span class="n">GetOMPThreads</span><span class="p">()</span></div>

<div class="viewcode-block" id="single_threaded"><a class="viewcode-back" href="../../misc.html#galsim.utilities.single_threaded">[docs]</a><span class="nd">@contextmanager</span>
<span class="k">def</span> <span class="nf">single_threaded</span><span class="p">(</span><span class="o">*</span><span class="p">,</span> <span class="n">num_threads</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A context manager that turns off (or down) OpenMP threading e.g. during multiprocessing.</span>

<span class="sd">    Usage:</span>

<span class="sd">    .. code::</span>

<span class="sd">        with single_threaded():</span>
<span class="sd">            # Code where you don&#39;t want to use any OpenMP threads in the C++ layer</span>
<span class="sd">            # E.g. starting a multiprocessing pool, where you don&#39;t want each process</span>
<span class="sd">            # to use multiple threads, potentially ending up with n_cpu^2 threads</span>
<span class="sd">            # running at once, which would generally be bad for performance.</span>

<span class="sd">    .. note::</span>

<span class="sd">        This is especaily important when your compiler is gcc and you are using the</span>
<span class="sd">        &quot;fork&quot; context in multiprocessing.  There is a bug in gcc that can cause an</span>
<span class="sd">        OpenMP parallel block to hang after forking.</span>
<span class="sd">        cf. `make it possible to use OMP on both sides of a fork &lt;https://patchwork.ozlabs.org/project/gcc/patch/CAPJVwBkOF5GnrMr=4d1ehEKRGkY0tHzJzfXAYBguawu9y5wxXw@mail.gmail.com/#712883&gt;`_</span>
<span class="sd">        for more discussion about this issue.</span>

<span class="sd">    It can also be used to set a particular number of threads other than 1, using the</span>
<span class="sd">    optional parameter ``num_threads``, although the original intent of this class is</span>
<span class="sd">    to leave that as 1 (the default).</span>

<span class="sd">    Parameters:</span>
<span class="sd">        num_threads:    The number of threads you want during the context [default: 1]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Get the current number of threads here, so we can set it back when we&#39;re done.</span>
    <span class="n">orig_num_threads</span> <span class="o">=</span> <span class="n">get_omp_threads</span><span class="p">()</span>
    <span class="n">temp_num_threads</span> <span class="o">=</span> <span class="n">num_threads</span>

    <span class="c1"># If threadpoolctl is installed, use that too, since it will set blas libraries to</span>
    <span class="c1"># be single threaded too. This makes it so you don&#39;t need to set the environment</span>
    <span class="c1"># variables OPENBLAS_NUM_THREAD=1 or MKL_NUM_THREADS=1, etc.</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="kn">import</span> <span class="nn">threadpoolctl</span>
    <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
        <span class="n">tpl</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">else</span><span class="p">:</span>  <span class="c1"># pragma: no cover  (Not installed on GHA currently.)</span>
        <span class="n">tpl</span> <span class="o">=</span> <span class="n">threadpoolctl</span><span class="o">.</span><span class="n">threadpool_limits</span><span class="p">(</span><span class="n">num_threads</span><span class="p">)</span>

    <span class="n">set_omp_threads</span><span class="p">(</span><span class="n">temp_num_threads</span><span class="p">)</span>
    <span class="k">with</span> <span class="n">warnings</span><span class="o">.</span><span class="n">catch_warnings</span><span class="p">():</span>
        <span class="c1"># Starting in python 3.12, there is a deprecation warning about using fork when</span>
        <span class="c1"># a process is multithreaded.  Unfortunately, this applies even to processes that</span>
        <span class="c1"># are currently single threaded, but used multi-threading previously.</span>
        <span class="c1"># So if a user is doing something in an explicitly single-threaded context,</span>
        <span class="c1"># suppress this DeprecationWarning.</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">filterwarnings</span><span class="p">(</span><span class="s2">&quot;ignore&quot;</span><span class="p">,</span> <span class="n">category</span><span class="o">=</span><span class="ne">DeprecationWarning</span><span class="p">)</span>
        <span class="k">yield</span>

    <span class="n">set_omp_threads</span><span class="p">(</span><span class="n">orig_num_threads</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">tpl</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
        <span class="n">tpl</span><span class="o">.</span><span class="n">unregister</span><span class="p">()</span></div>



<span class="c1"># The rest of these are only used by the tests in GalSim.  But we make them available</span>
<span class="c1"># for other code bases who may want to use them as well.</span>

<div class="viewcode-block" id="check_pickle"><a class="viewcode-back" href="../../misc.html#galsim.utilities.check_pickle">[docs]</a><span class="k">def</span> <span class="nf">check_pickle</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">func</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span> <span class="p">:</span> <span class="n">x</span><span class="p">,</span> <span class="n">irreprable</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">random</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Check that the object is picklable.</span>

<span class="sd">    Also check some related desirable properties that we want for (almost) all galsim objects:</span>

<span class="sd">    1. pickle.loads(pickle.dumps(obj)) recovers something equivalent to the original.</span>
<span class="sd">    2. obj != object() and object() != obj.  (I.e. it doesn&#39;t == things it shouldn&#39;t.)</span>
<span class="sd">    3. hash(obj) is the same for two equivalent objects, if it is hashable.</span>
<span class="sd">    4. copy.copy(obj) returns an equivalent copy unless random=True.</span>
<span class="sd">    5. copy.deepcopy(obj) returns an equivalent copy.</span>
<span class="sd">    6. eval(repr(obj)) returns an equivalent copy unless random or irreprable=True.</span>
<span class="sd">    7. repr(obj) makes something if irreprable=False.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        obj:            The object to test</span>
<span class="sd">        func:           A function of obj to use to test for equivalence.  [default: lambda x: x]</span>
<span class="sd">        irreprable:     Whether to skip the eval(repr(obj)) test.  [default: False]</span>
<span class="sd">        random:         Whether the obj has some intrinsic randomness. [default: False, unless</span>
<span class="sd">                        it has an rng attribute or it is a galsim.BaseDeviate]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># In case the repr uses these:</span>
    <span class="kn">import</span> <span class="nn">galsim</span>
    <span class="kn">import</span> <span class="nn">coord</span>
    <span class="kn">import</span> <span class="nn">astropy</span>
    <span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">array</span><span class="p">,</span> <span class="n">uint16</span><span class="p">,</span> <span class="n">uint32</span><span class="p">,</span> <span class="n">int16</span><span class="p">,</span> <span class="n">int32</span><span class="p">,</span> <span class="n">float32</span><span class="p">,</span> <span class="n">float64</span><span class="p">,</span> <span class="n">complex64</span><span class="p">,</span> <span class="n">complex128</span><span class="p">,</span> <span class="n">ndarray</span>
    <span class="kn">from</span> <span class="nn">astropy.units</span> <span class="kn">import</span> <span class="n">Unit</span>
    <span class="kn">import</span> <span class="nn">astropy.io.fits</span>

    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Try pickling &#39;</span><span class="p">,</span><span class="nb">str</span><span class="p">(</span><span class="n">obj</span><span class="p">))</span>

    <span class="n">obj2</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">pickle</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">obj</span><span class="p">))</span>
    <span class="k">assert</span> <span class="n">obj2</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">obj</span>
    <span class="n">f1</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
    <span class="n">f2</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">obj2</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">f2</span> <span class="o">==</span> <span class="n">f1</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;func(obj) = </span><span class="si">{</span><span class="n">f1</span><span class="si">}</span><span class="se">\n</span><span class="s2">func(obj2) = </span><span class="si">{</span><span class="n">f2</span><span class="si">}</span><span class="se">\n</span><span class="s2">repr(obj) = </span><span class="si">{</span><span class="nb">repr</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span><span class="si">}</span><span class="se">\n</span><span class="s2">repr(obj2)=</span><span class="si">{</span><span class="nb">repr</span><span class="p">(</span><span class="n">obj2</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>

    <span class="c1"># Check that == works properly if the other thing isn&#39;t the same type.</span>
    <span class="k">assert</span> <span class="n">f1</span> <span class="o">!=</span> <span class="nb">object</span><span class="p">()</span>
    <span class="k">assert</span> <span class="nb">object</span><span class="p">()</span> <span class="o">!=</span> <span class="n">f1</span>

    <span class="c1"># Test the hash values are equal for two equivalent objects.</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">Hashable</span><span class="p">):</span>
        <span class="k">assert</span> <span class="nb">hash</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="o">==</span> <span class="nb">hash</span><span class="p">(</span><span class="n">obj2</span><span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;hash(obj) = </span><span class="si">{</span><span class="nb">hash</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span><span class="si">}</span><span class="s2">, hash(obj2) = </span><span class="si">{</span><span class="nb">hash</span><span class="p">(</span><span class="n">obj2</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>

    <span class="n">obj3</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">obj3</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">obj</span>
    <span class="k">if</span> <span class="n">random</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">random</span> <span class="o">=</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s1">&#39;rng&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">BaseDeviate</span><span class="p">)</span> <span class="ow">or</span> <span class="s1">&#39;rng&#39;</span> <span class="ow">in</span> <span class="nb">repr</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">random</span><span class="p">:</span>  <span class="c1"># Things with an rng attribute won&#39;t be identical on copy.</span>
        <span class="n">f3</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">obj3</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">f3</span> <span class="o">==</span> <span class="n">f1</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">BaseDeviate</span><span class="p">):</span>
        <span class="n">f1</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>  <span class="c1"># But BaseDeviates will be ok.  Just need to remake f1.</span>
        <span class="n">f3</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">obj3</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">f3</span> <span class="o">==</span> <span class="n">f1</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;func(obj) = </span><span class="si">{</span><span class="n">f1</span><span class="si">}</span><span class="se">\n</span><span class="s2">func(obj3) = </span><span class="si">{</span><span class="n">f3</span><span class="si">}</span><span class="s2">&quot;</span>

    <span class="n">obj4</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">obj4</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">obj</span>
    <span class="n">f4</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">obj4</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">random</span><span class="p">:</span> <span class="n">f1</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
    <span class="c1"># But everything should be identical with deepcopy.</span>
    <span class="k">assert</span> <span class="n">f4</span> <span class="o">==</span> <span class="n">f1</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;func(obj) = </span><span class="si">{</span><span class="n">f1</span><span class="si">}</span><span class="se">\n</span><span class="s2">func(obj4) = </span><span class="si">{</span><span class="n">f4</span><span class="si">}</span><span class="s2">&quot;</span>

    <span class="c1"># Also test that the repr is an accurate representation of the object.</span>
    <span class="c1"># The gold standard is that eval(repr(obj)) == obj.  So check that here as well.</span>
    <span class="c1"># A few objects we don&#39;t expect to work this way in GalSim; when testing these, we set the</span>
    <span class="c1"># `irreprable` kwarg to true.  Also, we skip anything with random deviates since these don&#39;t</span>
    <span class="c1"># respect the eval/repr roundtrip.</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">random</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">irreprable</span><span class="p">:</span>
        <span class="c1"># A further complication is that the default numpy print options do not lead to sufficient</span>
        <span class="c1"># precision for the eval string to exactly reproduce the original object, and start</span>
        <span class="c1"># truncating the output for relatively small size arrays.  So we temporarily bump up the</span>
        <span class="c1"># precision and truncation threshold for testing.</span>
        <span class="k">with</span> <span class="n">printoptions</span><span class="p">(</span><span class="n">precision</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">):</span>
            <span class="n">obj5</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">obj</span><span class="p">))</span>
        <span class="n">f5</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">obj5</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">f5</span> <span class="o">==</span> <span class="n">f1</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;func(obj) = </span><span class="si">{</span><span class="n">f1</span><span class="si">}</span><span class="se">\n</span><span class="s2">func(obj5) = </span><span class="si">{</span><span class="n">f5</span><span class="si">}</span><span class="se">\n</span><span class="s2">repr(obj) = </span><span class="si">{</span><span class="nb">repr</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span><span class="si">}</span><span class="se">\n</span><span class="s2">repr(obj5)=</span><span class="si">{</span><span class="nb">repr</span><span class="p">(</span><span class="n">obj5</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Even if we&#39;re not actually doing the test, still make the repr to check for syntax errors.</span>
        <span class="nb">repr</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span></div>

    <span class="c1"># Historical note:</span>
    <span class="c1"># We used to have a test here where we perturbed the construction arguments to make sure</span>
    <span class="c1"># that objects that should be different really are different.  However, that used</span>
    <span class="c1"># `__getinitargs__`, which we don&#39;t use anymore, so we removed this section.</span>
    <span class="c1"># This means that this inequality test has to be done manually via check_all_diff.</span>
    <span class="c1"># See releases v2.3 or earlier for the old way we did this.</span>


<div class="viewcode-block" id="check_all_diff"><a class="viewcode-back" href="../../misc.html#galsim.utilities.check_all_diff">[docs]</a><span class="k">def</span> <span class="nf">check_all_diff</span><span class="p">(</span><span class="n">objs</span><span class="p">,</span> <span class="n">check_hash</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Test that all objects test as being unequal.</span>

<span class="sd">    It checks all pairs of objects in the list and asserts that obj1 != obj2.</span>

<span class="sd">    If check_hash=True, then it also checks that their hashes are different.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        objs:           A list of objects to test.</span>
<span class="sd">        check_hash:     Whether to also check the hash values.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Check that all objects are unique.</span>
    <span class="c1"># Would like to use `assert len(objs) == len(set(objs))` here, but this requires that the</span>
    <span class="c1"># elements of objs are hashable (and that they have unique hashes!, which is what we&#39;re trying</span>
    <span class="c1"># to test!.  So instead, we just loop over all combinations.</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">obji</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">objs</span><span class="p">):</span>
        <span class="k">assert</span> <span class="n">obji</span> <span class="o">==</span> <span class="n">obji</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="p">(</span><span class="n">obji</span> <span class="o">!=</span> <span class="n">obji</span><span class="p">)</span>
        <span class="c1"># Could probably start the next loop at `i+1`, but we start at 0 for completeness</span>
        <span class="c1"># (and to verify a != b implies b != a)</span>
        <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">objj</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">objs</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">assert</span> <span class="n">obji</span> <span class="o">!=</span> <span class="n">objj</span><span class="p">,</span> <span class="p">(</span><span class="s2">&quot;Found equivalent objects </span><span class="si">{0}</span><span class="s2"> == </span><span class="si">{1}</span><span class="s2"> at indices </span><span class="si">{2}</span><span class="s2"> and </span><span class="si">{3}</span><span class="s2">&quot;</span>
                                  <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">obji</span><span class="p">,</span> <span class="n">objj</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">))</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">check_hash</span><span class="p">:</span>
        <span class="k">return</span>
    <span class="c1"># Now check that all hashes are unique (if the items are hashable).</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">objs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Hashable</span><span class="p">):</span>
        <span class="k">return</span>
    <span class="n">hashes</span> <span class="o">=</span> <span class="p">[</span><span class="nb">hash</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">objs</span><span class="p">]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">hashes</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">hashes</span><span class="p">))):</span>  <span class="c1"># pragma: no cover</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">Counter</span><span class="p">(</span><span class="n">hashes</span><span class="p">)</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">v</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Found multiple equivalent object hashes:&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">obj</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">objs</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">hash</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="o">==</span> <span class="n">k</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">repr</span><span class="p">(</span><span class="n">obj</span><span class="p">))</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">hashes</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">hashes</span><span class="p">))</span></div>


<div class="viewcode-block" id="timer"><a class="viewcode-back" href="../../misc.html#galsim.utilities.timer">[docs]</a><span class="k">def</span> <span class="nf">timer</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A decorator that reports how long a function took to run.</span>

<span class="sd">    In GalSim we decorate all of our tests with this to try to watch for long-running tests.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nd">@functools</span><span class="o">.</span><span class="n">wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">f2</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">t0</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">t1</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">fname</span> <span class="o">=</span> <span class="nb">repr</span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;time for </span><span class="si">%s</span><span class="s1"> = </span><span class="si">%.2f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">t1</span><span class="o">-</span><span class="n">t0</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">result</span>
    <span class="k">return</span> <span class="n">f2</span></div>


<div class="viewcode-block" id="CaptureLog"><a class="viewcode-back" href="../../misc.html#galsim.utilities.CaptureLog">[docs]</a><span class="k">class</span> <span class="nc">CaptureLog</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A context manager that saves logging output into a string that is accessible for</span>
<span class="sd">    checking in unit tests.</span>

<span class="sd">    After exiting the context, the attribute ``output`` will have the logging output.</span>

<span class="sd">    Sample usage:</span>

<span class="sd">            &gt;&gt;&gt; with CaptureLog() as cl:</span>
<span class="sd">            ...     cl.logger.info(&#39;Do some stuff&#39;)</span>
<span class="sd">            &gt;&gt;&gt; assert cl.output == &#39;Do some stuff&#39;</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>
        <span class="n">logging_levels</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span><span class="p">:</span> <span class="n">logging</span><span class="o">.</span><span class="n">CRITICAL</span><span class="p">,</span>
                           <span class="mi">1</span><span class="p">:</span> <span class="n">logging</span><span class="o">.</span><span class="n">WARNING</span><span class="p">,</span>
                           <span class="mi">2</span><span class="p">:</span> <span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span>
                           <span class="mi">3</span><span class="p">:</span> <span class="n">logging</span><span class="o">.</span><span class="n">DEBUG</span> <span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s1">&#39;CaptureLog&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">setLevel</span><span class="p">(</span><span class="n">logging_levels</span><span class="p">[</span><span class="n">level</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stream</span> <span class="o">=</span> <span class="n">StringIO</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">handler</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">StreamHandler</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stream</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">addHandler</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">handler</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__enter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="fm">__exit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">type</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">traceback</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">handler</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stream</span><span class="o">.</span><span class="n">getvalue</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">handler</span><span class="o">.</span><span class="n">close</span><span class="p">()</span></div>


<span class="c1"># Context to make it easier to profile bits of the code</span>
<div class="viewcode-block" id="Profile"><a class="viewcode-back" href="../../misc.html#galsim.utilities.Profile">[docs]</a><span class="k">class</span> <span class="nc">Profile</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A context manager that profiles a snippet of code.</span>

<span class="sd">    Sample usage:</span>

<span class="sd">            &gt;&gt;&gt; with Profile():</span>
<span class="sd">            ...     slow_function()</span>

<span class="sd">    Parameters:</span>
<span class="sd">        sortby:     What parameter to sort the results by.  [default: tottime]</span>
<span class="sd">        nlines:     How many lines of output to report.  [default: 30]</span>
<span class="sd">        reverse:    Whether to reverse the order of the output lines to put the most important</span>
<span class="sd">                    items at the bottom rather than the top. [default: False]</span>
<span class="sd">        filename:   If desired, a file to output the full profile information in pstats format.</span>
<span class="sd">                    [default: None]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sortby</span><span class="o">=</span><span class="s1">&#39;tottime&#39;</span><span class="p">,</span> <span class="n">nlines</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sortby</span> <span class="o">=</span> <span class="n">sortby</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nlines</span> <span class="o">=</span> <span class="n">nlines</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reverse</span> <span class="o">=</span> <span class="n">reverse</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filename</span> <span class="o">=</span> <span class="n">filename</span>

    <span class="k">def</span> <span class="fm">__enter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pr</span> <span class="o">=</span> <span class="n">cProfile</span><span class="o">.</span><span class="n">Profile</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pr</span><span class="o">.</span><span class="n">enable</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="fm">__exit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">type</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">traceback</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pr</span><span class="o">.</span><span class="n">disable</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pr</span><span class="o">.</span><span class="n">dump_stats</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="p">)</span>
        <span class="n">ps</span> <span class="o">=</span> <span class="n">pstats</span><span class="o">.</span><span class="n">Stats</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pr</span><span class="p">)</span><span class="o">.</span><span class="n">sort_stats</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sortby</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">reverse</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
            <span class="n">ps</span> <span class="o">=</span> <span class="n">ps</span><span class="o">.</span><span class="n">reverse_order</span><span class="p">()</span>
        <span class="n">ps</span><span class="o">.</span><span class="n">print_stats</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nlines</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">least_squares</span><span class="p">(</span><span class="n">fun</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(),</span> <span class="n">kwargs</span><span class="o">=</span><span class="p">{},</span> <span class="n">max_iter</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1e-9</span><span class="p">,</span> <span class="n">lambda_init</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Perform a non-linear least squares fit using the Levenberg-Marquardt algorithm.</span>

<span class="sd">    Drop in replacement for scipy.optimize.least_squares when using default options,</span>
<span class="sd">    though many fewer options available in general.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        fun: Function which computes vector of residuals, with the signature</span>
<span class="sd">             fun(params, *args, **kwargs) -&gt; np.ndarray.</span>
<span class="sd">        x0: Initial guess for the parameters.</span>
<span class="sd">        args: Additional arguments to pass to the function.</span>
<span class="sd">        kwargs: Additional keyword arguments to pass to the function.</span>
<span class="sd">        max_iter: Maximum number of iterations.  [default: 1000]</span>
<span class="sd">        tol: Tolerance for convergence.  [default: 1e-9]</span>
<span class="sd">        lambda_init: Initial damping factor for Levenberg-Marquardt.  [default: 1.0]</span>

<span class="sd">    Returns:</span>
<span class="sd">        A named tuple with fields:</span>
<span class="sd">            x: The final parameter values.</span>
<span class="sd">            cost: The final cost (sum of squared residuals).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># JM: This is a tweaked version of a ChatGPT-generated implementation of</span>
    <span class="c1"># Levenberg-Marquardt (cross-checked against the wikipedia page</span>
    <span class="c1"># https://en.wikipedia.org/wiki/Levenberg%E2%80%93Marquardt_algorithm).</span>

    <span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">namedtuple</span>
    <span class="n">params</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x0</span><span class="p">)</span>
    <span class="n">lambda_</span> <span class="o">=</span> <span class="n">lambda_init</span>

    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max_iter</span><span class="p">):</span>  <span class="c1"># pragma: no branch</span>
        <span class="n">residuals</span> <span class="o">=</span> <span class="n">fun</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Jacobian matrix</span>
        <span class="n">J</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">residuals</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">params</span><span class="p">)))</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">params</span><span class="p">)):</span>
            <span class="n">perturbation</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">params</span><span class="p">))</span>
            <span class="n">perturbation</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">tol</span>
            <span class="n">J</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">fun</span><span class="p">(</span><span class="n">params</span> <span class="o">+</span> <span class="n">perturbation</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-</span> <span class="n">residuals</span><span class="p">)</span> <span class="o">/</span> <span class="n">tol</span>

        <span class="c1"># Regular least squares param update</span>
        <span class="n">JTJ</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">J</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">J</span><span class="p">)</span>
        <span class="n">JTr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">J</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">residuals</span><span class="p">)</span>

        <span class="c1"># Levenberg-Marquardt adjustment</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">JTJ</span> <span class="o">+</span> <span class="n">lambda_</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">JTJ</span><span class="p">))</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">delta_params</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">JTr</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">LinAlgError</span><span class="p">:</span>
            <span class="n">lambda_</span> <span class="o">*=</span> <span class="mi">2</span>
            <span class="k">continue</span>

        <span class="n">new_params</span> <span class="o">=</span> <span class="n">params</span> <span class="o">-</span> <span class="n">delta_params</span>
        <span class="n">new_residuals</span> <span class="o">=</span> <span class="n">fun</span><span class="p">(</span><span class="n">new_params</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">new_residuals</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">residuals</span><span class="p">):</span>
            <span class="n">params</span> <span class="o">=</span> <span class="n">new_params</span>
            <span class="n">residuals</span> <span class="o">=</span> <span class="n">new_residuals</span>
            <span class="n">lambda_</span> <span class="o">/=</span> <span class="mi">3</span>  <span class="c1"># reduce damping</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">lambda_</span> <span class="o">*=</span> <span class="mi">3</span>  <span class="c1"># increase damping</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">delta_params</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">:</span>
            <span class="k">break</span>

    <span class="n">cost</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">residuals</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

    <span class="c1"># Create a result object similar to scipy.optimize.OptimizeResult</span>
    <span class="n">Result</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s1">&#39;Result&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;cost&#39;</span><span class="p">])</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">Result</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">params</span><span class="p">,</span> <span class="n">cost</span><span class="o">=</span><span class="n">cost</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">result</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, GalSim-developers.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>