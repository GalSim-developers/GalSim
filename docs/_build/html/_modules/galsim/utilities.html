

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>galsim.utilities &mdash; GalSim 2.2.1 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../_static/language_data.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home"> GalSim
          

          
          </a>

          
            
            
              <div class="version">
                2.2
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../overview.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../install.html">Installation Instructions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tutorials.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../image.html">Images and Related Concepts</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../sb.html">Surface Brightness Profiles</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../chromatic.html">Wavelength-dependent Profiles</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../units.html">Units</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../wcs.html">World Coordinate Systems</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../random.html">Noise and Random Values</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../wl.html">Weak Lensing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../photon.html">Photon Shooting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../utilities.html">Helper Functions and Classes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../errors.html">Errors and Warnings</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../config.html">The Config Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../hsm.html">The HSM Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../des.html">The DES Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../wfirst.html">The WFIRST Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../shared.html">Shared Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../history.html">Revision History</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">GalSim</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
      <li>galsim.utilities</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for galsim.utilities</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright (c) 2012-2019 by the GalSim developers team on GitHub</span>
<span class="c1"># https://github.com/GalSim-developers</span>
<span class="c1">#</span>
<span class="c1"># This file is part of GalSim: The modular galaxy image simulation toolkit.</span>
<span class="c1"># https://github.com/GalSim-developers/GalSim</span>
<span class="c1">#</span>
<span class="c1"># GalSim is free software: redistribution and use in source and binary forms,</span>
<span class="c1"># with or without modification, are permitted provided that the following</span>
<span class="c1"># conditions are met:</span>
<span class="c1">#</span>
<span class="c1"># 1. Redistributions of source code must retain the above copyright notice, this</span>
<span class="c1">#    list of conditions, and the disclaimer given in the accompanying LICENSE</span>
<span class="c1">#    file.</span>
<span class="c1"># 2. Redistributions in binary form must reproduce the above copyright notice,</span>
<span class="c1">#    this list of conditions, and the disclaimer given in the documentation</span>
<span class="c1">#    and/or other materials provided with the distribution.</span>
<span class="c1">#</span>
<span class="kn">import</span> <span class="nn">functools</span>
<span class="kn">from</span> <span class="nn">contextlib</span> <span class="k">import</span> <span class="n">contextmanager</span>
<span class="kn">from</span> <span class="nn">future.utils</span> <span class="k">import</span> <span class="n">iteritems</span>
<span class="kn">from</span> <span class="nn">builtins</span> <span class="k">import</span> <span class="nb">range</span><span class="p">,</span> <span class="nb">object</span>
<span class="kn">import</span> <span class="nn">weakref</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">_galsim</span>
<span class="kn">from</span> <span class="nn">.errors</span> <span class="k">import</span> <span class="n">GalSimError</span><span class="p">,</span> <span class="n">GalSimValueError</span><span class="p">,</span> <span class="n">GalSimIncompatibleValuesError</span><span class="p">,</span> <span class="n">GalSimRangeError</span>
<span class="kn">from</span> <span class="nn">.errors</span> <span class="k">import</span> <span class="n">galsim_warn</span>


<div class="viewcode-block" id="isinteger"><a class="viewcode-back" href="../../misc.html#galsim.utilities.isinteger">[docs]</a><span class="k">def</span> <span class="nf">isinteger</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Check if a value is an integer type (including np.int64, long, etc.)</span>

<span class="sd">    Specifically, it checks whether value == int(value).</span>

<span class="sd">    Parameter:</span>
<span class="sd">        value:      The value to be checked whether it is an integer</span>

<span class="sd">    Returns:</span>
<span class="sd">        True if the value is an integer type, False otherwise.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">value</span> <span class="o">==</span> <span class="nb">int</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span></div>

<div class="viewcode-block" id="roll2d"><a class="viewcode-back" href="../../misc.html#galsim.utilities.roll2d">[docs]</a><span class="k">def</span> <span class="nf">roll2d</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">shape</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Perform a 2D roll (circular shift) on a supplied 2D NumPy array, conveniently.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        image:      The NumPy array to be circular shifted.</span>
<span class="sd">        shape:      (iroll, jroll) The roll in the i and j dimensions, respectively.</span>

<span class="sd">    Returns:</span>
<span class="sd">        the rolled array</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="p">(</span><span class="n">iroll</span><span class="p">,</span> <span class="n">jroll</span><span class="p">)</span> <span class="o">=</span> <span class="n">shape</span>
    <span class="c1"># The ascontiguousarray bit didn&#39;t used to be necessary.  But starting with</span>
    <span class="c1"># numpy v1.12, np.roll doesn&#39;t seem to always return a C-contiguous array.</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">jroll</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">iroll</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span></div>

<div class="viewcode-block" id="kxky"><a class="viewcode-back" href="../../misc.html#galsim.utilities.kxky">[docs]</a><span class="k">def</span> <span class="nf">kxky</span><span class="p">(</span><span class="n">array_shape</span><span class="o">=</span><span class="p">(</span><span class="mi">256</span><span class="p">,</span> <span class="mi">256</span><span class="p">)):</span>
    <span class="sd">&quot;&quot;&quot;Return the tuple (kx, ky) corresponding to the DFT of a unit integer-sampled array of</span>
<span class="sd">    input shape.</span>

<span class="sd">    Uses the FFTW conventions for Fourier space, so k varies in approximate range (-pi, pi],</span>
<span class="sd">    and the (0, 0) array element corresponds to (kx, ky) = (0, 0).</span>

<span class="sd">    See also the docstring for np.fftfreq, which uses the same DFT convention, and is called here,</span>
<span class="sd">    but misses a factor of pi.</span>

<span class="sd">    Adopts NumPy array index ordering so that the trailing axis corresponds to kx, rather than</span>
<span class="sd">    the leading axis as would be expected in IDL/Fortran.  See docstring for ``numpy.meshgrid``</span>
<span class="sd">    which also uses this convention.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        array_shape:    The NumPy array shape desired for kx, ky.</span>

<span class="sd">    Returns:</span>
<span class="sd">        kx, ky</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Note: numpy shape is y,x</span>
    <span class="n">k_xaxis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftfreq</span><span class="p">(</span><span class="n">array_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="mf">2.</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
    <span class="n">k_yaxis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftfreq</span><span class="p">(</span><span class="n">array_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="mf">2.</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">k_xaxis</span><span class="p">,</span> <span class="n">k_yaxis</span><span class="p">)</span></div>

<div class="viewcode-block" id="g1g2_to_e1e2"><a class="viewcode-back" href="../../misc.html#galsim.utilities.g1g2_to_e1e2">[docs]</a><span class="k">def</span> <span class="nf">g1g2_to_e1e2</span><span class="p">(</span><span class="n">g1</span><span class="p">,</span> <span class="n">g2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Convenience function for going from (g1, g2) -&gt; (e1, e2).</span>

<span class="sd">    Here g1 and g2 are reduced shears, and e1 and e2 are distortions - see `Shear`</span>
<span class="sd">    for definitions of reduced shear and distortion in terms of axis ratios or other ways of</span>
<span class="sd">    specifying ellipses.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        g1:     First reduced shear component</span>
<span class="sd">        g2:     Second reduced shear component</span>

<span class="sd">    Returns:</span>
<span class="sd">        the corresponding distortions, e1 and e2.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Conversion:</span>
    <span class="c1"># e = (a^2-b^2) / (a^2+b^2)</span>
    <span class="c1"># g = (a-b) / (a+b)</span>
    <span class="c1"># b/a = (1-g)/(1+g)</span>
    <span class="c1"># e = (1-(b/a)^2) / (1+(b/a)^2)</span>
    <span class="n">gsq</span> <span class="o">=</span> <span class="n">g1</span><span class="o">*</span><span class="n">g1</span> <span class="o">+</span> <span class="n">g2</span><span class="o">*</span><span class="n">g2</span>
    <span class="k">if</span> <span class="n">gsq</span> <span class="o">==</span> <span class="mf">0.</span><span class="p">:</span>
        <span class="k">return</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">gsq</span><span class="p">)</span>
        <span class="n">boa</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">g</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">g</span><span class="p">)</span>
        <span class="n">e</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">boa</span><span class="o">*</span><span class="n">boa</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">boa</span><span class="o">*</span><span class="n">boa</span><span class="p">)</span>
        <span class="n">e1</span> <span class="o">=</span> <span class="n">g1</span> <span class="o">*</span> <span class="p">(</span><span class="n">e</span><span class="o">/</span><span class="n">g</span><span class="p">)</span>
        <span class="n">e2</span> <span class="o">=</span> <span class="n">g2</span> <span class="o">*</span> <span class="p">(</span><span class="n">e</span><span class="o">/</span><span class="n">g</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">e1</span><span class="p">,</span> <span class="n">e2</span></div>

<div class="viewcode-block" id="rotate_xy"><a class="viewcode-back" href="../../misc.html#galsim.utilities.rotate_xy">[docs]</a><span class="k">def</span> <span class="nf">rotate_xy</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">theta</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Rotates points in the xy-Cartesian plane counter-clockwise through an angle ``theta`` about</span>
<span class="sd">    the origin of the Cartesian coordinate system.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        x:      NumPy array of input x coordinates</span>
<span class="sd">        y:      NumPy array of input y coordinates</span>
<span class="sd">        theta:  Rotation angle (+ve counter clockwise) as an `Angle` instance</span>

<span class="sd">    Returns:</span>
<span class="sd">        the rotated coordinates (x_rot,y_rot).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">sint</span><span class="p">,</span> <span class="n">cost</span> <span class="o">=</span> <span class="n">theta</span><span class="o">.</span><span class="n">sincos</span><span class="p">()</span>
    <span class="n">x_rot</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">cost</span> <span class="o">-</span> <span class="n">y</span> <span class="o">*</span> <span class="n">sint</span>
    <span class="n">y_rot</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">sint</span> <span class="o">+</span> <span class="n">y</span> <span class="o">*</span> <span class="n">cost</span>
    <span class="k">return</span> <span class="n">x_rot</span><span class="p">,</span> <span class="n">y_rot</span></div>

<div class="viewcode-block" id="parse_pos_args"><a class="viewcode-back" href="../../misc.html#galsim.utilities.parse_pos_args">[docs]</a><span class="k">def</span> <span class="nf">parse_pos_args</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">,</span> <span class="n">name1</span><span class="p">,</span> <span class="n">name2</span><span class="p">,</span> <span class="n">integer</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">others</span><span class="o">=</span><span class="p">[]):</span>
    <span class="sd">&quot;&quot;&quot;Parse the args and kwargs of a function call to be some kind of position.</span>

<span class="sd">    We allow four options:</span>

<span class="sd">        f(x,y)</span>
<span class="sd">        f(galsim.PositionD(x,y)) or f(galsim.PositionI(x,y))</span>
<span class="sd">        f( (x,y) )  (or any indexable thing)</span>
<span class="sd">        f(name1=x, name2=y)</span>

<span class="sd">    If the inputs must be integers, set ``integer=True``.</span>
<span class="sd">    If there are other args/kwargs to parse after these, then their names should be</span>
<span class="sd">    be given as the parameter ``others``, which are passed back in a tuple after the position.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        args:       The args of the original function.</span>
<span class="sd">        kwargs:     The kwargs of the original function.</span>
<span class="sd">        name1:      The allowed kwarg for the first coordinate.</span>
<span class="sd">        name2:      The allowed kwarg for the second coordinate.</span>
<span class="sd">        integer:    Whether to return a `PositionI` rather than a `PositionD`. [default: False]</span>
<span class="sd">        others:     If given, other values to also parse and return from the kwargs. [default: []]</span>

<span class="sd">    Returns:</span>
<span class="sd">        a `Position` instance, possibly also with other values if ``others`` is given.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">.position</span> <span class="k">import</span> <span class="n">PositionD</span><span class="p">,</span> <span class="n">PositionI</span>
    <span class="k">def</span> <span class="nf">canindex</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span> <span class="n">arg</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">arg</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">IndexError</span><span class="p">):</span> <span class="k">return</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span> <span class="k">return</span> <span class="kc">True</span>

    <span class="n">other_vals</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># Then name1,name2 need to be kwargs</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">name1</span><span class="p">)</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">name2</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Expecting kwargs </span><span class="si">%s</span><span class="s1">, </span><span class="si">%s</span><span class="s1">.  Got </span><span class="si">%s</span><span class="s1">&#39;</span><span class="o">%</span><span class="p">(</span><span class="n">name1</span><span class="p">,</span> <span class="n">name2</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
    <span class="k">elif</span> <span class="p">(</span> <span class="p">(</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">PositionI</span><span class="p">)</span> <span class="ow">or</span>
             <span class="p">(</span><span class="ow">not</span> <span class="n">integer</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">PositionD</span><span class="p">))</span> <span class="p">)</span> <span class="ow">and</span>
           <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="o">+</span><span class="nb">len</span><span class="p">(</span><span class="n">others</span><span class="p">)</span> <span class="p">):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">x</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">y</span>
        <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="n">other_vals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
            <span class="n">others</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">canindex</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="o">+</span><span class="nb">len</span><span class="p">(</span><span class="n">others</span><span class="p">):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="n">other_vals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
            <span class="n">others</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">integer</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Cannot parse argument </span><span class="si">%s</span><span class="s2"> as a PositionI&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Cannot parse argument </span><span class="si">%s</span><span class="s2"> as a PositionD&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">2</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">others</span><span class="p">):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span><span class="p">[</span><span class="mi">2</span><span class="p">:]:</span>
            <span class="n">other_vals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
            <span class="n">others</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Too many arguments supplied&quot;</span><span class="p">)</span>
    <span class="c1"># Read any remaining other kwargs</span>
    <span class="k">if</span> <span class="n">others</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">others</span><span class="p">:</span>
            <span class="n">val</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
            <span class="n">other_vals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">kwargs</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Received unexpected keyword arguments: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">integer</span><span class="p">:</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="n">PositionI</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">),</span><span class="nb">int</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="n">PositionD</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">x</span><span class="p">),</span><span class="nb">float</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">other_vals</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">pos</span><span class="p">,)</span> <span class="o">+</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">other_vals</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">pos</span></div>


<div class="viewcode-block" id="SimpleGenerator"><a class="viewcode-back" href="../../misc.html#galsim.utilities.SimpleGenerator">[docs]</a><span class="k">class</span> <span class="nc">SimpleGenerator</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;A simple class that is constructed with an arbitrary object.</span>
<span class="sd">    Then generator() will return that object.</span>

<span class="sd">    This is useful as a way to use an already existing object in a multiprocessing Proxy,</span>
<span class="sd">    since that normally needs a factory function.  So this is a factory function that</span>
<span class="sd">    just returns an already existing object.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span> <span class="bp">self</span><span class="o">.</span><span class="n">_obj</span> <span class="o">=</span> <span class="n">obj</span>
    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>  <span class="c1"># pragma: no cover  (It is covered, but coveralls doesn&#39;t get it right.)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_obj</span></div>

<div class="viewcode-block" id="AttributeDict"><a class="viewcode-back" href="../../misc.html#galsim.utilities.AttributeDict">[docs]</a><span class="k">class</span> <span class="nc">AttributeDict</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span> <span class="c1"># pragma: no cover</span>
    <span class="sd">&quot;&quot;&quot;Dictionary class that allows for easy initialization and refs to key values via attributes.</span>

<span class="sd">    NOTE: Modified a little from Jim&#39;s bot.git AttributeDict class so that tab completion now works</span>
<span class="sd">    in ipython since attributes are actually added to __dict__.</span>

<span class="sd">    HOWEVER this means the __dict__ attribute has been redefined to be a collections.defaultdict()</span>
<span class="sd">    so that Jim&#39;s previous default attribute behaviour is also replicated.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="kn">import</span> <span class="nn">collections</span>
        <span class="nb">object</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;__dict__&quot;</span><span class="p">,</span> <span class="n">collections</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="n">AttributeDict</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span> <span class="nf">merge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">iteritems</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">AttributeDict</span><span class="p">):</span>
                <span class="n">v</span><span class="o">.</span><span class="n">_write</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="s2">&quot;</span><span class="si">{0}{1}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">prefix</span><span class="p">,</span> <span class="n">k</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">output</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{0}{1}</span><span class="s2"> = </span><span class="si">{2}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">prefix</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="nb">repr</span><span class="p">(</span><span class="n">v</span><span class="p">)))</span>

    <span class="k">def</span> <span class="nf">__bool__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">output</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_write</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">output</span><span class="p">)</span>

    <span class="fm">__str__</span> <span class="o">=</span> <span class="fm">__repr__</span>

    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">)</span></div>

<div class="viewcode-block" id="rand_arr"><a class="viewcode-back" href="../../misc.html#galsim.utilities.rand_arr">[docs]</a><span class="k">def</span> <span class="nf">rand_arr</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">deviate</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Function to make a 2d array of random deviates (of any sort).</span>

<span class="sd">    Parameters:</span>
<span class="sd">        shape:      A list of length 2, indicating the desired 2d array dimensions</span>
<span class="sd">        deviate:    Any GalSim deviate (see random.py) such as `UniformDeviate`, `GaussianDeviate`,</span>
<span class="sd">                    etc. to be used to generate random numbers</span>

<span class="sd">    Returns:</span>
<span class="sd">        a NumPy array of the desired dimensions with random numbers generated using the</span>
<span class="sd">        supplied deviate.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">shape</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">deviate</span><span class="o">.</span><span class="n">generate</span><span class="p">(</span><span class="n">tmp</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span>
    <span class="k">return</span> <span class="n">tmp</span></div>

<div class="viewcode-block" id="convert_interpolant"><a class="viewcode-back" href="../../misc.html#galsim.utilities.convert_interpolant">[docs]</a><span class="k">def</span> <span class="nf">convert_interpolant</span><span class="p">(</span><span class="n">interpolant</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Convert a given interpolant to an `Interpolant` if it is given as a string.</span>

<span class="sd">    Parameter:</span>
<span class="sd">        interpolant:    Either an `Interpolant` or a string to convert.</span>

<span class="sd">    Returns:</span>
<span class="sd">        an `Interpolant`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">.interpolant</span> <span class="k">import</span> <span class="n">Interpolant</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">interpolant</span><span class="p">,</span> <span class="n">Interpolant</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">interpolant</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Will raise an appropriate exception if this is invalid.</span>
        <span class="k">return</span> <span class="n">Interpolant</span><span class="o">.</span><span class="n">from_name</span><span class="p">(</span><span class="n">interpolant</span><span class="p">)</span></div>

<span class="c1"># A helper function for parsing the input position arguments for PowerSpectrum and NFWHalo:</span>
<span class="k">def</span> <span class="nf">_convertPositions</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">units</span><span class="p">,</span> <span class="n">func</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Convert ``pos`` from the valid ways to input positions to two NumPy arrays</span>

<span class="sd">    This is used by the functions getShear(), getConvergence(), getMagnification(), and</span>
<span class="sd">    getLensing() for both PowerSpectrum and NFWHalo.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">.position</span> <span class="k">import</span> <span class="n">Position</span>
    <span class="kn">from</span> <span class="nn">.angle</span> <span class="k">import</span> <span class="n">AngleUnit</span><span class="p">,</span> <span class="n">arcsec</span>
    <span class="c1"># Check for PositionD or PositionI:</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">Position</span><span class="p">):</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="p">[</span> <span class="n">pos</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">pos</span><span class="o">.</span><span class="n">y</span> <span class="p">]</span>

    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Unable to parse the input pos argument for </span><span class="si">%s</span><span class="s2">.&quot;</span><span class="o">%</span><span class="n">func</span><span class="p">)</span>

    <span class="c1"># Check for list of Position:</span>
    <span class="c1"># The only other options allow pos[0], so if this is invalid, an exception</span>
    <span class="c1"># will be raised:</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pos</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Position</span><span class="p">):</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="p">[</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">p</span><span class="o">.</span><span class="n">x</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">pos</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">),</span>
                <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">p</span><span class="o">.</span><span class="n">y</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">pos</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span> <span class="p">]</span>

    <span class="c1"># Now pos must be a tuple of length 2</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Unable to parse the input pos argument for </span><span class="si">%s</span><span class="s2">.&quot;</span><span class="o">%</span><span class="n">func</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Check for (x,y):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="p">[</span> <span class="nb">float</span><span class="p">(</span><span class="n">pos</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">float</span><span class="p">(</span><span class="n">pos</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="p">]</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="c1"># Only other valid option is ( xlist , ylist )</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="p">[</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pos</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">),</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pos</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span> <span class="p">]</span>

    <span class="c1"># Check validity of units</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">units</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="c1"># if the string is invalid, this raises a reasonable error message.</span>
        <span class="n">units</span> <span class="o">=</span> <span class="n">AngleUnit</span><span class="o">.</span><span class="n">from_name</span><span class="p">(</span><span class="n">units</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">units</span><span class="p">,</span> <span class="n">AngleUnit</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">GalSimValueError</span><span class="p">(</span><span class="s2">&quot;units must be either an AngleUnit or a string&quot;</span><span class="p">,</span> <span class="n">units</span><span class="p">,</span>
                               <span class="p">(</span><span class="s1">&#39;arcsec&#39;</span><span class="p">,</span> <span class="s1">&#39;arcmin&#39;</span><span class="p">,</span> <span class="s1">&#39;degree&#39;</span><span class="p">,</span> <span class="s1">&#39;hour&#39;</span><span class="p">,</span> <span class="s1">&#39;radian&#39;</span><span class="p">))</span>

    <span class="c1"># Convert pos to arcsec</span>
    <span class="k">if</span> <span class="n">units</span> <span class="o">!=</span> <span class="n">arcsec</span><span class="p">:</span>
        <span class="n">scale</span> <span class="o">=</span> <span class="mf">1.</span> <span class="o">*</span> <span class="n">units</span> <span class="o">/</span> <span class="n">arcsec</span>
        <span class="c1"># Note that for the next two lines, pos *must* be a list, not a tuple.  Assignments to</span>
        <span class="c1"># elements of tuples is not allowed.</span>
        <span class="n">pos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*=</span> <span class="n">scale</span>
        <span class="n">pos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*=</span> <span class="n">scale</span>

    <span class="k">return</span> <span class="n">pos</span>

<span class="k">def</span> <span class="nf">_lin_approx_err</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Error as \int abs(f(x) - approx(x)) when using ith data point to make piecewise linear</span>
<span class="sd">    approximation.&quot;&quot;&quot;</span>
    <span class="n">xleft</span><span class="p">,</span> <span class="n">xright</span> <span class="o">=</span> <span class="n">x</span><span class="p">[:</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">:]</span>
    <span class="n">fleft</span><span class="p">,</span> <span class="n">fright</span> <span class="o">=</span> <span class="n">f</span><span class="p">[:</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">:]</span>
    <span class="n">xi</span><span class="p">,</span> <span class="n">fi</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="n">mleft</span> <span class="o">=</span> <span class="p">(</span><span class="n">fi</span><span class="o">-</span><span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">/</span><span class="p">(</span><span class="n">xi</span><span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">mright</span> <span class="o">=</span> <span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">fi</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">xi</span><span class="p">)</span>
    <span class="n">f2left</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">mleft</span><span class="o">*</span><span class="p">(</span><span class="n">xleft</span><span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">f2right</span> <span class="o">=</span> <span class="n">fi</span><span class="o">+</span><span class="n">mright</span><span class="o">*</span><span class="p">(</span><span class="n">xright</span><span class="o">-</span><span class="n">xi</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">trapz</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">fleft</span><span class="o">-</span><span class="n">f2left</span><span class="p">),</span> <span class="n">xleft</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">trapz</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">fright</span><span class="o">-</span><span class="n">f2right</span><span class="p">),</span> <span class="n">xright</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_exact_lin_approx_split</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">f</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Split a tabulated function into a two-part piecewise linear approximation by exactly</span>
<span class="sd">    minimizing \int abs(f(x) - approx(x)) dx.  Operates in O(N^2) time.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">errs</span> <span class="o">=</span> <span class="p">[</span><span class="n">_lin_approx_err</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">errs</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">errs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">_lin_approx_split</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">f</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Split a tabulated function into a two-part piecewise linear approximation by approximately</span>
<span class="sd">    minimizing \int abs(f(x) - approx(x)) dx.  Chooses the split point by exactly minimizing</span>
<span class="sd">    \int (f(x) - approx(x))^2 dx in O(N) time.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dx</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
    <span class="c1"># Error contribution on the left.</span>
    <span class="n">ff0</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># Only need to search between j=1..(N-1)</span>
    <span class="n">xx0</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">mleft</span> <span class="o">=</span> <span class="n">ff0</span><span class="o">/</span><span class="n">xx0</span>  <span class="c1"># slope</span>
    <span class="n">errleft</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">dx</span><span class="o">*</span><span class="n">ff0</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
               <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">mleft</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">dx</span><span class="o">*</span><span class="n">ff0</span><span class="o">*</span><span class="n">xx0</span><span class="p">)</span>
               <span class="o">+</span> <span class="n">mleft</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">dx</span><span class="o">*</span><span class="n">xx0</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
    <span class="c1"># Error contribution on the right.</span>
    <span class="n">dx</span> <span class="o">=</span> <span class="n">dx</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># Reversed so that np.cumsum effectively works right-to-left.</span>
    <span class="n">ffN</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">f</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">xxN</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">mright</span> <span class="o">=</span> <span class="n">ffN</span><span class="o">/</span><span class="n">xxN</span>
    <span class="n">errright</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">dx</span><span class="o">*</span><span class="n">ffN</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
                <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">mright</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">dx</span><span class="o">*</span><span class="n">ffN</span><span class="o">*</span><span class="n">xxN</span><span class="p">)</span>
                <span class="o">+</span> <span class="n">mright</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">dx</span><span class="o">*</span><span class="n">xxN</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
    <span class="n">errright</span> <span class="o">=</span> <span class="n">errright</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># Get absolute error for the found point.</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">errleft</span><span class="o">+</span><span class="n">errright</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">_lin_approx_err</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

<div class="viewcode-block" id="thin_tabulated_values"><a class="viewcode-back" href="../../misc.html#galsim.utilities.thin_tabulated_values">[docs]</a><span class="k">def</span> <span class="nf">thin_tabulated_values</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">rel_err</span><span class="o">=</span><span class="mf">1.e-4</span><span class="p">,</span> <span class="n">trim_zeros</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">preserve_range</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                          <span class="n">fast_search</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Remove items from a set of tabulated f(x) values so that the error in the integral is still</span>
<span class="sd">    accurate to a given relative accuracy.</span>

<span class="sd">    The input ``x`` and ``f`` values can be lists, NumPy arrays, or really anything that can be</span>
<span class="sd">    converted to a NumPy array.  The new lists will be output as numpy arrays.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        x:              The ``x`` values in the f(x) tabulation.</span>
<span class="sd">        f:              The ``f`` values in the f(x) tabulation.</span>
<span class="sd">        rel_err:        The maximum relative error to allow in the integral from the removal.</span>
<span class="sd">                        [default: 1.e-4]</span>
<span class="sd">        trim_zeros:     Remove redundant leading and trailing points where f=0?  (The last</span>
<span class="sd">                        leading point with f=0 and the first trailing point with f=0 will be</span>
<span class="sd">                        retained).  Note that if both trim_leading_zeros and preserve_range are</span>
<span class="sd">                        True, then the only the range of ``x`` *after* zero trimming is preserved.</span>
<span class="sd">                        [default: True]</span>
<span class="sd">        preserve_range: Should the original range of ``x`` be preserved? (True) Or should the ends</span>
<span class="sd">                        be trimmed to include only the region where the integral is</span>
<span class="sd">                        significant? (False)  [default: True]</span>
<span class="sd">        fast_search:    If set to True, then the underlying algorithm will use a relatively fast</span>
<span class="sd">                        O(N) algorithm to select points to include in the thinned approximation.</span>
<span class="sd">                        If set to False, then a slower O(N^2) algorithm will be used.  We have</span>
<span class="sd">                        found that the slower algorithm tends to yield a thinned representation</span>
<span class="sd">                        that retains fewer samples while still meeting the relative error</span>
<span class="sd">                        requirement.  [default: True]</span>

<span class="sd">    Returns:</span>
<span class="sd">        a tuple of lists (x_new, y_new) with the thinned tabulation.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">heapq</span> <span class="k">import</span> <span class="n">heappush</span><span class="p">,</span> <span class="n">heappop</span>

    <span class="n">split_fn</span> <span class="o">=</span> <span class="n">_lin_approx_split</span> <span class="k">if</span> <span class="n">fast_search</span> <span class="k">else</span> <span class="n">_exact_lin_approx_split</span>

    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

    <span class="c1"># Check for valid inputs</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">GalSimIncompatibleValuesError</span><span class="p">(</span><span class="s2">&quot;len(x) != len(f)&quot;</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">f</span><span class="o">=</span><span class="n">f</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">rel_err</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">rel_err</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">GalSimRangeError</span><span class="p">(</span><span class="s2">&quot;rel_err must be between 0 and 1&quot;</span><span class="p">,</span> <span class="n">rel_err</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
        <span class="k">raise</span> <span class="n">GalSimValueError</span><span class="p">(</span><span class="s2">&quot;input x is not sorted.&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>

    <span class="c1"># Check for trivial noop.</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="c1"># Nothing to do</span>
        <span class="k">return</span> <span class="n">x</span><span class="p">,</span><span class="n">f</span>

    <span class="n">total_integ</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">trapz</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">f</span><span class="p">),</span> <span class="n">x</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">total_integ</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span> <span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">f</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="p">])</span>
    <span class="n">thresh</span> <span class="o">=</span> <span class="n">total_integ</span> <span class="o">*</span> <span class="n">rel_err</span>

    <span class="k">if</span> <span class="n">trim_zeros</span><span class="p">:</span>
        <span class="n">first</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>  <span class="c1"># -1 to keep one non-redundant zero.</span>
        <span class="n">last</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># +1 to keep one non-redundant zero.</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">f</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">first</span><span class="p">:</span><span class="n">last</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">f</span><span class="p">[</span><span class="n">first</span><span class="p">:</span><span class="n">last</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>

    <span class="n">x_range</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">preserve_range</span><span class="p">:</span>
        <span class="c1"># Remove values from the front that integrate to less than thresh.</span>
        <span class="n">err_integ1</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="nb">abs</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">k0</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">k0</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">-</span><span class="mi">2</span> <span class="ow">and</span> <span class="n">err_integ1</span> <span class="o">&lt;</span> <span class="n">thresh</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">k0</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="n">x_range</span><span class="p">:</span>
            <span class="n">k0</span> <span class="o">=</span> <span class="n">k0</span><span class="o">+</span><span class="mi">1</span>
            <span class="n">err_integ1</span> <span class="o">+=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="n">k0</span><span class="p">])</span> <span class="o">+</span> <span class="nb">abs</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="n">k0</span><span class="o">+</span><span class="mi">1</span><span class="p">]))</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">k0</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="n">k0</span><span class="p">])</span>
        <span class="c1"># Now the integral from 0 to k0+1 (inclusive) is a bit too large.</span>
        <span class="c1"># That means k0 is the largest value we can use that will work as the starting value.</span>

        <span class="c1"># Remove values from the back that integrate to less than thresh.</span>
        <span class="n">k1</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>
        <span class="n">err_integ2</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="n">k1</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="nb">abs</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="n">k1</span><span class="p">]))</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">k1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="n">k1</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">while</span> <span class="n">k1</span> <span class="o">&gt;</span> <span class="n">k0</span> <span class="ow">and</span> <span class="n">err_integ2</span> <span class="o">&lt;</span> <span class="n">thresh</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="n">k1</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="n">x_range</span><span class="p">:</span>
            <span class="n">k1</span> <span class="o">=</span> <span class="n">k1</span><span class="o">-</span><span class="mi">1</span>
            <span class="n">err_integ2</span> <span class="o">+=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="n">k1</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="nb">abs</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="n">k1</span><span class="p">]))</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">k1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="n">k1</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="c1"># Now the integral from k1-1 to len(x)-1 (inclusive) is a bit too large.</span>
        <span class="c1"># That means k1 is the smallest value we can use that will work as the ending value.</span>

        <span class="c1"># Subtract the error so far from thresh</span>
        <span class="n">thresh</span> <span class="o">-=</span> <span class="n">np</span><span class="o">.</span><span class="n">trapz</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">f</span><span class="p">[:</span><span class="n">k0</span><span class="p">]),</span><span class="n">x</span><span class="p">[:</span><span class="n">k0</span><span class="p">])</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">trapz</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="n">k1</span><span class="p">:]),</span><span class="n">x</span><span class="p">[</span><span class="n">k1</span><span class="p">:])</span>

        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">k0</span><span class="p">:</span><span class="n">k1</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># +1 since end of range is given as one-past-the-end.</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="n">k0</span><span class="p">:</span><span class="n">k1</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># And update x_range for the new values</span>
        <span class="n">x_range</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># Check again for noop after trimming endpoints.</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">x</span><span class="p">,</span><span class="n">f</span>

    <span class="c1"># Thin interior points.  Start with no interior points and then greedily add them back in one at</span>
    <span class="c1"># a time until relative error goal is met.</span>
    <span class="c1"># Use a heap to track:</span>
    <span class="n">heap</span> <span class="o">=</span> <span class="p">[(</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">thresh</span><span class="p">,</span>  <span class="c1"># -err; initialize large enough to trigger while loop below.</span>
             <span class="mi">0</span><span class="p">,</span>          <span class="c1"># first index of interval</span>
             <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span>  <span class="c1"># last index of interval</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">-</span><span class="nb">sum</span><span class="p">(</span><span class="n">h</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">heap</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">thresh</span><span class="p">):</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">heappop</span><span class="p">(</span><span class="n">heap</span><span class="p">)</span>
        <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">errleft</span><span class="p">,</span> <span class="n">errright</span><span class="p">)</span> <span class="o">=</span> <span class="n">split_fn</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">left</span><span class="p">:</span><span class="n">right</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">f</span><span class="p">[</span><span class="n">left</span><span class="p">:</span><span class="n">right</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">heappush</span><span class="p">(</span><span class="n">heap</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="n">errleft</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="n">left</span><span class="p">))</span>
        <span class="n">heappush</span><span class="p">(</span><span class="n">heap</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="n">errright</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">))</span>
    <span class="n">splitpoints</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">([</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="p">[</span><span class="n">h</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">heap</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">x</span><span class="p">[</span><span class="n">splitpoints</span><span class="p">],</span> <span class="n">f</span><span class="p">[</span><span class="n">splitpoints</span><span class="p">]</span></div>

<div class="viewcode-block" id="old_thin_tabulated_values"><a class="viewcode-back" href="../../misc.html#galsim.utilities.old_thin_tabulated_values">[docs]</a><span class="k">def</span> <span class="nf">old_thin_tabulated_values</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">rel_err</span><span class="o">=</span><span class="mf">1.e-4</span><span class="p">,</span> <span class="n">preserve_range</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span> <span class="c1"># pragma: no cover</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Remove items from a set of tabulated f(x) values so that the error in the integral is still</span>
<span class="sd">    accurate to a given relative accuracy.</span>

<span class="sd">    The input ``x`` and ``f`` values can be lists, NumPy arrays, or really anything that can be</span>
<span class="sd">    converted to a NumPy array.  The new lists will be output as python lists.</span>

<span class="sd">    .. note::</span>
<span class="sd">        In Issue #739, Josh wrote `thin_tabulated_values`  as a replacement for this function,</span>
<span class="sd">        which had been buggy -- not actually hitting its target relative accuracy.  So on the</span>
<span class="sd">        same issue, Mike fixed this algorithm to at least work correctly.</span>

<span class="sd">        However, we recommend using the above algorithm, since it keeps fewer sample locations</span>
<span class="sd">        for a given ``rel_err`` than the old algorithm.</span>

<span class="sd">        On the other hand, the old algorithm (this one) may be quite a bit faster, so we retain</span>
<span class="sd">        it here in case there is a use case where it is more appropriate.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        x:              The ``x`` values in the f(x) tabulation.</span>
<span class="sd">        f:              The ``f`` values in the f(x) tabulation.</span>
<span class="sd">        rel_err:        The maximum relative error to allow in the integral from the removal.</span>
<span class="sd">                        [default: 1.e-4]</span>
<span class="sd">        preserve_range: Should the original range of ``x`` be preserved? (True) Or should the ends</span>
<span class="sd">                        be trimmed to include only the region where the integral is</span>
<span class="sd">                        significant? (False)  [default: False]</span>

<span class="sd">    Returns:</span>
<span class="sd">        a tuple of lists (x_new, y_new) with the thinned tabulation.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

    <span class="c1"># Check for valid inputs</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">GalSimIncompatibleValuesError</span><span class="p">(</span><span class="s2">&quot;len(x) != len(f)&quot;</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">f</span><span class="o">=</span><span class="n">f</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">rel_err</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">rel_err</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">GalSimRangeError</span><span class="p">(</span><span class="s2">&quot;rel_err must be between 0 and 1&quot;</span><span class="p">,</span> <span class="n">rel_err</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
        <span class="k">raise</span> <span class="n">GalSimValueError</span><span class="p">(</span><span class="s2">&quot;input x is not sorted.&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>

    <span class="c1"># Check for trivial noop.</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="c1"># Nothing to do</span>
        <span class="k">return</span> <span class="n">x</span><span class="p">,</span><span class="n">f</span>

    <span class="c1"># Start by calculating the complete integral of |f|</span>
    <span class="n">total_integ</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">trapz</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">f</span><span class="p">),</span><span class="n">x</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">total_integ</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span> <span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">f</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="p">])</span>
    <span class="n">thresh</span> <span class="o">=</span> <span class="n">rel_err</span> <span class="o">*</span> <span class="n">total_integ</span>
    <span class="n">x_range</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">preserve_range</span><span class="p">:</span>
        <span class="c1"># Remove values from the front that integrate to less than thresh.</span>
        <span class="n">err_integ1</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="nb">abs</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">k0</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">k0</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">-</span><span class="mi">2</span> <span class="ow">and</span> <span class="n">err_integ1</span> <span class="o">&lt;</span> <span class="n">thresh</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">k0</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="n">x_range</span><span class="p">:</span>
            <span class="n">k0</span> <span class="o">=</span> <span class="n">k0</span><span class="o">+</span><span class="mi">1</span>
            <span class="n">err_integ1</span> <span class="o">+=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="n">k0</span><span class="p">])</span> <span class="o">+</span> <span class="nb">abs</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="n">k0</span><span class="o">+</span><span class="mi">1</span><span class="p">]))</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">k0</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="n">k0</span><span class="p">])</span>
        <span class="c1"># Now the integral from 0 to k0+1 (inclusive) is a bit too large.</span>
        <span class="c1"># That means k0 is the largest value we can use that will work as the starting value.</span>

        <span class="c1"># Remove values from the back that integrate to less than thresh.</span>
        <span class="n">k1</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>
        <span class="n">err_integ2</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="n">k1</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="nb">abs</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="n">k1</span><span class="p">]))</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">k1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="n">k1</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">while</span> <span class="n">k1</span> <span class="o">&gt;</span> <span class="n">k0</span> <span class="ow">and</span> <span class="n">err_integ2</span> <span class="o">&lt;</span> <span class="n">thresh</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="n">k1</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="n">x_range</span><span class="p">:</span>
            <span class="n">k1</span> <span class="o">=</span> <span class="n">k1</span><span class="o">-</span><span class="mi">1</span>
            <span class="n">err_integ2</span> <span class="o">+=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="n">k1</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="nb">abs</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="n">k1</span><span class="p">]))</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">k1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="n">k1</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="c1"># Now the integral from k1-1 to len(x)-1 (inclusive) is a bit too large.</span>
        <span class="c1"># That means k1 is the smallest value we can use that will work as the ending value.</span>

        <span class="c1"># Subtract the error so far from thresh</span>
        <span class="n">thresh</span> <span class="o">-=</span> <span class="n">np</span><span class="o">.</span><span class="n">trapz</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">f</span><span class="p">[:</span><span class="n">k0</span><span class="p">]),</span><span class="n">x</span><span class="p">[:</span><span class="n">k0</span><span class="p">])</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">trapz</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="n">k1</span><span class="p">:]),</span><span class="n">x</span><span class="p">[</span><span class="n">k1</span><span class="p">:])</span>

        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">k0</span><span class="p">:</span><span class="n">k1</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># +1 since end of range is given as one-past-the-end.</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="n">k0</span><span class="p">:</span><span class="n">k1</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># And update x_range for the new values</span>
        <span class="n">x_range</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># Start a new list with just the first item so far</span>
    <span class="n">newx</span> <span class="o">=</span> <span class="p">[</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">]</span>
    <span class="n">newf</span> <span class="o">=</span> <span class="p">[</span> <span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">]</span>

    <span class="n">k0</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># The last item currently in the new array</span>
    <span class="n">k1</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># The current item we are considering to skip or include</span>
    <span class="k">while</span> <span class="n">k1</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
        <span class="c1"># We are considering replacing all the true values between k0 and k1+1 (non-inclusive)</span>
        <span class="c1"># with a linear approxmation based on the points at k0 and k1+1.</span>
        <span class="n">lin_f</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="n">k0</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="n">k1</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">f</span><span class="p">[</span><span class="n">k0</span><span class="p">])</span><span class="o">/</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">k1</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="n">k0</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">k0</span><span class="p">:</span><span class="n">k1</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="n">k0</span><span class="p">])</span>
        <span class="c1"># Integrate | f(x) - lin_f(x) | from k0 to k1+1, inclusive.</span>
        <span class="n">err_integ</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">trapz</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="n">k0</span><span class="p">:</span><span class="n">k1</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">lin_f</span><span class="p">),</span> <span class="n">x</span><span class="p">[</span><span class="n">k0</span><span class="p">:</span><span class="n">k1</span><span class="o">+</span><span class="mi">2</span><span class="p">])</span>
        <span class="c1"># If the integral of the difference is &lt; thresh * (dx/x_range), we can skip this item.</span>
        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">err_integ</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">thresh</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">k1</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="n">k0</span><span class="p">])</span> <span class="o">/</span> <span class="n">x_range</span><span class="p">:</span>
            <span class="c1"># OK to skip item k1</span>
            <span class="n">k1</span> <span class="o">=</span> <span class="n">k1</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Also ok to keep if its own relative error is less than rel_err</span>
            <span class="n">true_integ</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">trapz</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="n">k0</span><span class="p">:</span><span class="n">k1</span><span class="o">+</span><span class="mi">2</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="n">k0</span><span class="p">:</span><span class="n">k1</span><span class="o">+</span><span class="mi">2</span><span class="p">])</span>
            <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">err_integ</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">rel_err</span> <span class="o">*</span> <span class="nb">abs</span><span class="p">(</span><span class="n">true_integ</span><span class="p">):</span>
                <span class="c1"># OK to skip item k1</span>
                <span class="n">k1</span> <span class="o">=</span> <span class="n">k1</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Have to include this one.</span>
                <span class="n">newx</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">k1</span><span class="p">])</span>
                <span class="n">newf</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="n">k1</span><span class="p">])</span>
                <span class="n">k0</span> <span class="o">=</span> <span class="n">k1</span>
                <span class="n">k1</span> <span class="o">=</span> <span class="n">k1</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="c1"># Always include the last item</span>
    <span class="n">newx</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">newf</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">newx</span><span class="p">,</span> <span class="n">newf</span></div>


<div class="viewcode-block" id="horner"><a class="viewcode-back" href="../../misc.html#galsim.utilities.horner">[docs]</a><span class="k">def</span> <span class="nf">horner</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">coef</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Evaluate univariate polynomial using Horner&#39;s method.</span>

<span class="sd">    I.e., take A + Bx + Cx^2 + Dx^3 and evaluate it as</span>
<span class="sd">    A + x(B + x(C + x(D)))</span>

<span class="sd">    Parameters:</span>
<span class="sd">        x:      A numpy array of values at which to evaluate the polynomial.</span>
<span class="sd">        coef:   Polynomial coefficients of increasing powers of x.</span>
<span class="sd">        dtype:  Optionally specify the dtype of the return array. [default: None]</span>

<span class="sd">    Returns:</span>
<span class="sd">        a numpy array of the evaluated polynomial.  Will be the same shape as x.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
    <span class="c1"># Make sure everything is an array</span>
    <span class="k">if</span> <span class="n">result</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="nb">float</span><span class="p">:</span>
        <span class="c1"># And if the result is float, it&#39;s worth making sure x, coef are also float and</span>
        <span class="c1"># contiguous, so we can use the faster c++ implementation.</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">coef</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">coef</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">coef</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">coef</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">coef</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">GalSimValueError</span><span class="p">(</span><span class="s2">&quot;coef must be 1-dimensional&quot;</span><span class="p">,</span> <span class="n">coef</span><span class="p">)</span>
    <span class="n">_horner</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">coef</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span></div>

<div class="viewcode-block" id="_horner"><a class="viewcode-back" href="../../misc.html#galsim.utilities._horner">[docs]</a><span class="k">def</span> <span class="nf">_horner</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">coef</span><span class="p">,</span> <span class="n">result</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Equivalent to `horner`, but ``x``, ``coeff``, and ``result`` must be contiguous arrays</span>
<span class="sd">    with dtype == float.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        x:      A numpy array of values at which to evaluate the polynomial.</span>
<span class="sd">        coef:   Polynomial coefficients of increasing powers of x.</span>
<span class="sd">        result: Numpy array into which to write the result.  Must be same shape as x.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">result</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="nb">float</span><span class="p">:</span>
        <span class="n">_galsim</span><span class="o">.</span><span class="n">Horner</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">ctypes</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">coef</span><span class="o">.</span><span class="n">ctypes</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">coef</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">result</span><span class="o">.</span><span class="n">ctypes</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">coef</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">trim_zeros</span><span class="p">(</span><span class="n">coef</span><span class="p">,</span> <span class="n">trim</span><span class="o">=</span><span class="s1">&#39;b&#39;</span><span class="p">)</span>  <span class="c1"># trim only from the back</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">coef</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">result</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="n">result</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">coef</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">coef</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">result</span> <span class="o">*=</span> <span class="n">x</span>
            <span class="k">if</span> <span class="n">c</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span> <span class="n">result</span> <span class="o">+=</span> <span class="n">c</span></div>

<div class="viewcode-block" id="horner2d"><a class="viewcode-back" href="../../misc.html#galsim.utilities.horner2d">[docs]</a><span class="k">def</span> <span class="nf">horner2d</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">coefs</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">triangle</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Evaluate bivariate polynomial using nested Horner&#39;s method.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        x:          A numpy array of the x values at which to evaluate the polynomial.</span>
<span class="sd">        y:          A numpy array of the y values at which to evaluate the polynomial.</span>
<span class="sd">        coefs:      2D array-like of coefficients in increasing powers of x and y.</span>
<span class="sd">                    The first axis corresponds to increasing the power of y, and the second to</span>
<span class="sd">                    increasing the power of x.</span>
<span class="sd">        dtype:      Optionally specify the dtype of the return array. [default: None]</span>
<span class="sd">        triangle:   If True, then the coefs are only non-zero in the upper-left triangle</span>
<span class="sd">                    of the array. [default: False]</span>

<span class="sd">    Returns:</span>
<span class="sd">        a numpy array of the evaluated polynomial.  Will be the same shape as x and y.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">temp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
    <span class="c1"># Make sure everything is an array</span>
    <span class="k">if</span> <span class="n">result</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="nb">float</span><span class="p">:</span>
        <span class="c1"># And if the result is float, it&#39;s worth making sure x, coef are also float,</span>
        <span class="c1"># so we can use the faster c++ implementation.</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">coefs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">coefs</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">coefs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">coefs</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">GalSimIncompatibleValuesError</span><span class="p">(</span><span class="s2">&quot;x and y are not the same size&quot;</span><span class="p">,</span>
                                            <span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">coefs</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">GalSimValueError</span><span class="p">(</span><span class="s2">&quot;coefs must be 2-dimensional&quot;</span><span class="p">,</span> <span class="n">coefs</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">triangle</span> <span class="ow">and</span> <span class="n">coefs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">coefs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="n">GalSimIncompatibleValuesError</span><span class="p">(</span><span class="s2">&quot;coefs must be square if triangle is True&quot;</span><span class="p">,</span>
                                            <span class="n">coefs</span><span class="o">=</span><span class="n">coefs</span><span class="p">,</span> <span class="n">triangle</span><span class="o">=</span><span class="n">triangle</span><span class="p">)</span>
    <span class="n">_horner2d</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">coefs</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">temp</span><span class="p">,</span> <span class="n">triangle</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span></div>

<div class="viewcode-block" id="_horner2d"><a class="viewcode-back" href="../../misc.html#galsim.utilities._horner2d">[docs]</a><span class="k">def</span> <span class="nf">_horner2d</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">coefs</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">temp</span><span class="p">,</span> <span class="n">triangle</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Equivalent to `horner2d`, but ``x``, ``y``, ``coeff``, ``result``, and ``temp``</span>
<span class="sd">    must be contiguous arrays with dtype == float.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        x:          A numpy array of the x values at which to evaluate the polynomial.</span>
<span class="sd">        y:          A numpy array of the y values at which to evaluate the polynomial.</span>
<span class="sd">        coefs:      2D array-like of coefficients in increasing powers of x and y.</span>
<span class="sd">                    The first axis corresponds to increasing the power of y, and the second to</span>
<span class="sd">                    increasing the power of x.</span>
<span class="sd">        result:     Numpy array into which to write the result.  Must be same shape as x.</span>
<span class="sd">        temp:       Numpy array to hold temporary results.  Must be the same shape as x.</span>
<span class="sd">        triangle:   If True, then the coefs are only non-zero in the upper-left triangle</span>
<span class="sd">                    of the array. [default: False]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">result</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="nb">float</span><span class="p">:</span>
        <span class="c1"># Note: the c++ implementation doesn&#39;t need to care about triangle.</span>
        <span class="c1"># It is able to trivially account for the zeros without special handling.</span>
        <span class="n">_galsim</span><span class="o">.</span><span class="n">Horner2D</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">ctypes</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">y</span><span class="o">.</span><span class="n">ctypes</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">size</span><span class="p">,</span>
                         <span class="n">coefs</span><span class="o">.</span><span class="n">ctypes</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">coefs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">coefs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                         <span class="n">result</span><span class="o">.</span><span class="n">ctypes</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">temp</span><span class="o">.</span><span class="n">ctypes</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">triangle</span><span class="p">:</span>
            <span class="n">result</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">coefs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">coef</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">coefs</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
                <span class="n">result</span> <span class="o">*=</span> <span class="n">x</span>
                <span class="n">_horner</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">coef</span><span class="p">[:</span><span class="n">k</span><span class="o">+</span><span class="mi">2</span><span class="p">],</span> <span class="n">temp</span><span class="p">)</span>
                <span class="n">result</span> <span class="o">+=</span> <span class="n">temp</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_horner</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">coefs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">result</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">coef</span> <span class="ow">in</span> <span class="n">coefs</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">result</span> <span class="o">*=</span> <span class="n">x</span>
                <span class="n">_horner</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">coef</span><span class="p">,</span> <span class="n">temp</span><span class="p">)</span>
                <span class="n">result</span> <span class="o">+=</span> <span class="n">temp</span></div>


<div class="viewcode-block" id="deInterleaveImage"><a class="viewcode-back" href="../../misc.html#galsim.utilities.deInterleaveImage">[docs]</a><span class="k">def</span> <span class="nf">deInterleaveImage</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">conserve_flux</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">suppress_warnings</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The routine to do the opposite of what `interleaveImages` routine does. It generates a</span>
<span class="sd">    (uniform) dither sequence of low resolution images from a high resolution image.</span>

<span class="sd">    Many pixel level detector effects, such as interpixel capacitance, persistence, charge</span>
<span class="sd">    diffusion etc. can be included only on images drawn at the native pixel scale, which happen to</span>
<span class="sd">    be undersampled in most cases. Nyquist-sampled images that also include the effects of detector</span>
<span class="sd">    non-idealities can be obtained by drawing multiple undersampled images (with the detector</span>
<span class="sd">    effects included) that are offset from each other by a fraction of a pixel. If the offsets are</span>
<span class="sd">    uniformly spaced, then images can be combined using `interleaveImages` into a Nyquist-sampled</span>
<span class="sd">    image.</span>

<span class="sd">    Drawing multiple low resolution images of a light profile can be a lot slower than drawing a</span>
<span class="sd">    high resolution image of the same profile, even if the total number of pixels is the same. A</span>
<span class="sd">    uniformly offset dither sequence can be extracted from a well-resolved image that is drawn by</span>
<span class="sd">    convolving the surface brightness profile explicitly with the native pixel response and setting</span>
<span class="sd">    a lower sampling scale (or higher sampling rate) using the ``pixel_scale`` argument in</span>
<span class="sd">    `GSObject.drawImage` routine and setting the ``method`` parameter to &#39;no_pixel&#39;.</span>

<span class="sd">    Here is an example script using this routine:</span>

<span class="sd">    Example::</span>

<span class="sd">        &gt;&gt;&gt; n = 2</span>
<span class="sd">        &gt;&gt;&gt; gal = galsim.Gaussian(sigma=2.8)</span>
<span class="sd">        &gt;&gt;&gt; gal_pix = galsim.Convolve([gal,galsim.Pixel(scale=1.0)])</span>
<span class="sd">        &gt;&gt;&gt; img = gal_pix.drawImage(gal_pix,scale=1.0/n,method=&#39;no_pixel&#39;)</span>
<span class="sd">        &gt;&gt;&gt; im_list, offsets = galsim.utilities.deInterleaveImage(img,N=n)</span>
<span class="sd">        &gt;&gt;&gt; for im in im_list:</span>
<span class="sd">        &gt;&gt;&gt;     im.applyNonlinearity(lambda x: x-0.01*x**2) #detector effects</span>
<span class="sd">        &gt;&gt;&gt; img_new = galsim.utilities.interleaveImages(im_list,N=n,offsets)</span>

<span class="sd">    Parameters:</span>
<span class="sd">        image:              Input image from which lower resolution images are extracted.</span>
<span class="sd">        N:                  Number of images extracted in either directions. It can be of type</span>
<span class="sd">                            &#39;int&#39; if equal number of images are extracted in both directions or a</span>
<span class="sd">                            list or tuple of two integers, containing the number of images in x</span>
<span class="sd">                            and y directions respectively.</span>
<span class="sd">        conserve_flux:      Should the routine output images that have, on average, same total</span>
<span class="sd">                            pixel values as the input image (True) or should the pixel values</span>
<span class="sd">                            summed over all the images equal the sum of pixel values of the input</span>
<span class="sd">                            image (False)? [default: False]</span>
<span class="sd">        suppress_warnings:  Suppresses the warnings about the pixel scale of the output, if True.</span>
<span class="sd">                            [default: False]</span>

<span class="sd">    Returns:</span>
<span class="sd">        a list of images (`Image`) and offsets (`PositionD`) to reconstruct the input image using</span>
<span class="sd">        `interleaveImages`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">.image</span> <span class="k">import</span> <span class="n">Image</span>
    <span class="kn">from</span> <span class="nn">.position</span> <span class="k">import</span> <span class="n">PositionD</span>
    <span class="kn">from</span> <span class="nn">.wcs</span> <span class="k">import</span> <span class="n">JacobianWCS</span><span class="p">,</span> <span class="n">PixelScale</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="nb">int</span><span class="p">):</span>
        <span class="n">n1</span><span class="p">,</span><span class="n">n2</span> <span class="o">=</span> <span class="n">N</span><span class="p">,</span><span class="n">N</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">n1</span><span class="p">,</span><span class="n">n2</span> <span class="o">=</span> <span class="n">N</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;N must be an integer or a tuple of two integers&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">Image</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;image must be an instance of galsim.Image&quot;</span><span class="p">)</span>

    <span class="n">y_size</span><span class="p">,</span><span class="n">x_size</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span>
    <span class="k">if</span> <span class="n">x_size</span><span class="o">%</span><span class="n">n1</span> <span class="ow">or</span> <span class="n">y_size</span><span class="o">%</span><span class="n">n2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">GalSimIncompatibleValuesError</span><span class="p">(</span>
            <span class="s2">&quot;The value of N is incompatible with the dimensions of the image to be deinterleaved&quot;</span><span class="p">,</span>
            <span class="n">N</span><span class="o">=</span><span class="n">N</span><span class="p">,</span> <span class="n">image</span><span class="o">=</span><span class="n">image</span><span class="p">)</span>

    <span class="n">im_list</span><span class="p">,</span> <span class="n">offsets</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n1</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n2</span><span class="p">):</span>
            <span class="c1"># The tricky part - going from array indices to Image coordinates (x,y)</span>
            <span class="c1"># DX[i&#39;] = -(i+0.5)/n+0.5 = -i/n + 0.5*(n-1)/n</span>
            <span class="c1">#    i  = -n DX[i&#39;] + 0.5*(n-1)</span>
            <span class="n">dx</span><span class="p">,</span><span class="n">dy</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mf">0.5</span><span class="p">)</span><span class="o">/</span><span class="n">n1</span><span class="o">+</span><span class="mf">0.5</span><span class="p">,</span><span class="o">-</span><span class="p">(</span><span class="n">j</span><span class="o">+</span><span class="mf">0.5</span><span class="p">)</span><span class="o">/</span><span class="n">n2</span><span class="o">+</span><span class="mf">0.5</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="n">PositionD</span><span class="p">(</span><span class="n">dx</span><span class="p">,</span><span class="n">dy</span><span class="p">)</span>
            <span class="n">img_arr</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">array</span><span class="p">[</span><span class="n">j</span><span class="p">::</span><span class="n">n2</span><span class="p">,</span><span class="n">i</span><span class="p">::</span><span class="n">n1</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">img</span> <span class="o">=</span> <span class="n">Image</span><span class="p">(</span><span class="n">img_arr</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">conserve_flux</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">img</span> <span class="o">*=</span> <span class="n">n1</span><span class="o">*</span><span class="n">n2</span>
            <span class="n">im_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
            <span class="n">offsets</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">offset</span><span class="p">)</span>

    <span class="n">wcs</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">wcs</span>
    <span class="k">if</span> <span class="n">wcs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">wcs</span><span class="o">.</span><span class="n">isUniform</span><span class="p">():</span>
        <span class="n">jac</span> <span class="o">=</span> <span class="n">wcs</span><span class="o">.</span><span class="n">jacobian</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">img</span> <span class="ow">in</span> <span class="n">im_list</span><span class="p">:</span>
            <span class="n">img_wcs</span> <span class="o">=</span> <span class="n">JacobianWCS</span><span class="p">(</span><span class="n">jac</span><span class="o">.</span><span class="n">dudx</span><span class="o">*</span><span class="n">n1</span><span class="p">,</span><span class="n">jac</span><span class="o">.</span><span class="n">dudy</span><span class="o">*</span><span class="n">n2</span><span class="p">,</span><span class="n">jac</span><span class="o">.</span><span class="n">dvdx</span><span class="o">*</span><span class="n">n1</span><span class="p">,</span><span class="n">jac</span><span class="o">.</span><span class="n">dvdy</span><span class="o">*</span><span class="n">n2</span><span class="p">)</span>
            <span class="c1">## Since pixel scale WCS is not equal to its jacobian, checking if img_wcs is a pixel</span>
            <span class="c1">## scale</span>
            <span class="n">img_wcs_decomp</span> <span class="o">=</span> <span class="n">img_wcs</span><span class="o">.</span><span class="n">getDecomposition</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">img_wcs_decomp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">g</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                <span class="n">img</span><span class="o">.</span><span class="n">wcs</span> <span class="o">=</span> <span class="n">PixelScale</span><span class="p">(</span><span class="n">img_wcs_decomp</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">img</span><span class="o">.</span><span class="n">wcs</span> <span class="o">=</span> <span class="n">img_wcs</span>
            <span class="c1">## Preserve the origin so that the interleaved image has the same bounds as the image</span>
            <span class="c1">## that is being deinterleaved.</span>
            <span class="n">img</span><span class="o">.</span><span class="n">setOrigin</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">origin</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">suppress_warnings</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
        <span class="n">galsim_warn</span><span class="p">(</span><span class="s2">&quot;Individual images could not be assigned a WCS automatically.&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">im_list</span><span class="p">,</span> <span class="n">offsets</span></div>


<div class="viewcode-block" id="interleaveImages"><a class="viewcode-back" href="../../misc.html#galsim.utilities.interleaveImages">[docs]</a><span class="k">def</span> <span class="nf">interleaveImages</span><span class="p">(</span><span class="n">im_list</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">offsets</span><span class="p">,</span> <span class="n">add_flux</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">suppress_warnings</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                     <span class="n">catch_offset_errors</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Interleaves the pixel values from two or more images and into a single larger image.</span>

<span class="sd">    This routine converts a list of images taken at a series of (uniform) dither offsets into a</span>
<span class="sd">    single higher resolution image, where the value in each final pixel is the observed pixel</span>
<span class="sd">    value from exactly one of the original images.  It can be used to build a Nyquist-sampled image</span>
<span class="sd">    from a set of images that were observed with pixels larger than the Nyquist scale.</span>

<span class="sd">    In the original observed images, the integration of the surface brightness over the pixels is</span>
<span class="sd">    equivalent to convolution by the pixel profile and then sampling at the centers of the pixels.</span>
<span class="sd">    This procedure simulates an observation sampled at a higher resolution than the original images,</span>
<span class="sd">    while retaining the original pixel convolution.</span>

<span class="sd">    Such an image can be obtained in a fairly simple manner in simulations of surface brightness</span>
<span class="sd">    profiles by convolving them explicitly with the native pixel response and setting a lower</span>
<span class="sd">    sampling scale (or higher sampling rate) using the ``pixel_scale`` argument in</span>
<span class="sd">    `GSObject.drawImage` routine and setting the ``method`` parameter to &#39;no_pixel&#39;.</span>

<span class="sd">    However, pixel level detector effects can be included only on images drawn at the native pixel</span>
<span class="sd">    scale, which happen to be undersampled in most cases. Nyquist-sampled images that also include</span>
<span class="sd">    the effects of detector non-idealities can be obtained by drawing multiple undersampled images</span>
<span class="sd">    (with the detector effects included) that are offset from each other by a fraction of a pixel.</span>

<span class="sd">    This is similar to other procedures that build a higher resolution image from a set of low</span>
<span class="sd">    resolution images, such as MultiDrizzle and IMCOM. A disadvantage of this routine compared to</span>
<span class="sd">    ther others is that the images must be offset in equal steps in each direction. This is</span>
<span class="sd">    difficult to acheive with real observations but can be precisely acheived in a series of</span>
<span class="sd">    simulated images.</span>

<span class="sd">    An advantage of this procedure is that the noise in the final image is not correlated as the</span>
<span class="sd">    pixel values are each taken from just a single input image. Thus, this routine preserves the</span>
<span class="sd">    noise properties of the pixels.</span>

<span class="sd">    Here&#39;s an example script using this routine:</span>

<span class="sd">    Example::</span>

<span class="sd">        &gt;&gt;&gt; n = 2</span>
<span class="sd">        &gt;&gt;&gt; gal = galsim.Gaussian(sigma=2.8)</span>
<span class="sd">        &gt;&gt;&gt; DX = numpy.arange(0.0,1.0,1./n)</span>
<span class="sd">        &gt;&gt;&gt; DX -= DX.mean()</span>
<span class="sd">        &gt;&gt;&gt; im_list, offsets = [], []</span>
<span class="sd">        &gt;&gt;&gt; for dx in DX:</span>
<span class="sd">            ... offset = galsim.PositionD(dx,0.0)</span>
<span class="sd">            ... offsets.append(offset)</span>
<span class="sd">            ... im = galsim.Image(16,16)</span>
<span class="sd">            ... gal.drawImage(image=im,offset=offset,scale=1.0)</span>
<span class="sd">            ... im.applyNonlinearity(lambda x: x - 0.01*x**2) # detector effects</span>
<span class="sd">            ... im_list.append(im)</span>
<span class="sd">        &gt;&gt;&gt; img = galsim.utilities.interleaveImages(im_list=im_list,N=(n,1),offsets=offsets)</span>

<span class="sd">    Parameters:</span>
<span class="sd">        im_list:                A list containing the `galsim.Image` instances to be interleaved.</span>
<span class="sd">        N:                      Number of images to interleave in either directions. It can be of</span>
<span class="sd">                                type ``int`` if equal number of images are interleaved in both</span>
<span class="sd">                                directions or a list or tuple of two integers, containing the number</span>
<span class="sd">                                of images in x and y directions respectively.</span>
<span class="sd">        offsets:                A list containing the offsets as galsim.PositionD instances</span>
<span class="sd">                                corresponding to every image in ``im_list``. The offsets must be</span>
<span class="sd">                                spaced equally and must span an entire pixel area. The offset</span>
<span class="sd">                                values must be symmetric around zero, hence taking positive and</span>
<span class="sd">                                negative values, with upper and lower limits of +0.5 and -0.5</span>
<span class="sd">                                (limit values excluded).</span>
<span class="sd">        add_flux:               Should the routine add the fluxes of all the images (True) or</span>
<span class="sd">                                average them (False)? [default: True]</span>
<span class="sd">        suppress_warnings:      Suppresses the warnings about the pixel scale of the output, if</span>
<span class="sd">                                True.  [default: False]</span>
<span class="sd">        catch_offset_errors:    Checks for the consistency of ``offsets`` with ``N`` and raises</span>
<span class="sd">                                errors if inconsistencies found (True). Recommended, but could slow</span>
<span class="sd">                                down the routine a little. [default: True]</span>

<span class="sd">    Returns:</span>
<span class="sd">        the interleaved `Image`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">.position</span> <span class="k">import</span> <span class="n">PositionD</span>
    <span class="kn">from</span> <span class="nn">.image</span> <span class="k">import</span> <span class="n">Image</span>
    <span class="kn">from</span> <span class="nn">.wcs</span> <span class="k">import</span> <span class="n">PixelScale</span><span class="p">,</span> <span class="n">JacobianWCS</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="nb">int</span><span class="p">):</span>
        <span class="n">n1</span><span class="p">,</span><span class="n">n2</span> <span class="o">=</span> <span class="n">N</span><span class="p">,</span><span class="n">N</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">n1</span><span class="p">,</span><span class="n">n2</span> <span class="o">=</span> <span class="n">N</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;N must be an integer or a tuple of two integers&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">im_list</span><span class="p">)</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">GalSimValueError</span><span class="p">(</span><span class="s2">&quot;im_list must have at least two instances of galsim.Image&quot;</span><span class="p">,</span> <span class="n">im_list</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">n1</span><span class="o">*</span><span class="n">n2</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">im_list</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="n">GalSimIncompatibleValuesError</span><span class="p">(</span>
            <span class="s2">&quot;N is incompatible with the number of images in im_list&quot;</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="n">N</span><span class="p">,</span> <span class="n">im_list</span><span class="o">=</span><span class="n">im_list</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">im_list</span><span class="p">)</span><span class="o">!=</span><span class="nb">len</span><span class="p">(</span><span class="n">offsets</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">GalSimIncompatibleValuesError</span><span class="p">(</span>
            <span class="s2">&quot;im_list and offsets must be lists of same length&quot;</span><span class="p">,</span> <span class="n">im_list</span><span class="o">=</span><span class="n">im_list</span><span class="p">,</span> <span class="n">offsets</span><span class="o">=</span><span class="n">offsets</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">offset</span> <span class="ow">in</span> <span class="n">offsets</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="n">PositionD</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;offsets must be a list of galsim.PositionD instances&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">im_list</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Image</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;im_list must be a list of galsim.Image instances&quot;</span><span class="p">)</span>

    <span class="c1"># These should be the same for all images in im_list.</span>
    <span class="n">y_size</span><span class="p">,</span> <span class="n">x_size</span> <span class="o">=</span> <span class="n">im_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">wcs</span> <span class="o">=</span> <span class="n">im_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">wcs</span>

    <span class="k">for</span> <span class="n">im</span> <span class="ow">in</span> <span class="n">im_list</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">Image</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;im_list must be a list of galsim.Image instances&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">im</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="n">y_size</span><span class="p">,</span><span class="n">x_size</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">GalSimIncompatibleValuesError</span><span class="p">(</span>
                <span class="s2">&quot;All galsim.Image instances in im_list must be of the same size&quot;</span><span class="p">,</span> <span class="n">im_list</span><span class="o">=</span><span class="n">im_list</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">im</span><span class="o">.</span><span class="n">wcs</span> <span class="o">!=</span> <span class="n">wcs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">GalSimIncompatibleValuesError</span><span class="p">(</span>
                <span class="s2">&quot;All galsim.Image instances in im_list must have the same WCS&quot;</span><span class="p">,</span> <span class="n">im_list</span><span class="o">=</span><span class="n">im_list</span><span class="p">)</span>

    <span class="n">img_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n2</span><span class="o">*</span><span class="n">y_size</span><span class="p">,</span><span class="n">n1</span><span class="o">*</span><span class="n">x_size</span><span class="p">))</span>
    <span class="c1"># The tricky part - going from (x,y) Image coordinates to array indices</span>
    <span class="c1"># DX[i&#39;] = -(i+0.5)/n+0.5 = -i/n + 0.5*(n-1)/n</span>
    <span class="c1">#    i  = -n DX[i&#39;] + 0.5*(n-1)</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">offsets</span><span class="p">)):</span>
        <span class="n">dx</span><span class="p">,</span> <span class="n">dy</span> <span class="o">=</span> <span class="n">offsets</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">offsets</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">y</span>

        <span class="n">i</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">((</span><span class="n">n1</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="mf">0.5</span><span class="o">-</span><span class="n">n1</span><span class="o">*</span><span class="n">dx</span><span class="p">))</span>
        <span class="n">j</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">((</span><span class="n">n2</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="mf">0.5</span><span class="o">-</span><span class="n">n2</span><span class="o">*</span><span class="n">dy</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">catch_offset_errors</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">err_i</span> <span class="o">=</span> <span class="p">(</span><span class="n">n1</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="mf">0.5</span><span class="o">-</span><span class="n">n1</span><span class="o">*</span><span class="n">dx</span> <span class="o">-</span> <span class="nb">round</span><span class="p">((</span><span class="n">n1</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="mf">0.5</span><span class="o">-</span><span class="n">n1</span><span class="o">*</span><span class="n">dx</span><span class="p">)</span>
            <span class="n">err_j</span> <span class="o">=</span> <span class="p">(</span><span class="n">n2</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="mf">0.5</span><span class="o">-</span><span class="n">n2</span><span class="o">*</span><span class="n">dy</span> <span class="o">-</span> <span class="nb">round</span><span class="p">((</span><span class="n">n2</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="mf">0.5</span><span class="o">-</span><span class="n">n2</span><span class="o">*</span><span class="n">dy</span><span class="p">)</span>
            <span class="n">tol</span> <span class="o">=</span> <span class="mf">1.e-6</span>
            <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">err_i</span><span class="p">)</span><span class="o">&gt;</span><span class="n">tol</span> <span class="ow">or</span> <span class="nb">abs</span><span class="p">(</span><span class="n">err_j</span><span class="p">)</span><span class="o">&gt;</span><span class="n">tol</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">GalSimIncompatibleValuesError</span><span class="p">(</span>
                    <span class="s2">&quot;offsets must be a list of galsim.PositionD instances with x values &quot;</span>
                    <span class="s2">&quot;spaced by 1/</span><span class="si">{0}</span><span class="s2"> and y values by 1/</span><span class="si">{1}</span><span class="s2"> around 0.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">n1</span><span class="p">,</span><span class="n">n2</span><span class="p">),</span>
                    <span class="n">N</span><span class="o">=</span><span class="n">N</span><span class="p">,</span> <span class="n">offsets</span><span class="o">=</span><span class="n">offsets</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">0</span> <span class="ow">or</span> <span class="n">j</span><span class="o">&lt;</span><span class="mi">0</span> <span class="ow">or</span> <span class="n">i</span><span class="o">&gt;=</span><span class="n">n1</span> <span class="ow">or</span> <span class="n">j</span><span class="o">&gt;=</span><span class="n">n2</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">GalSimIncompatibleValuesError</span><span class="p">(</span>
                    <span class="s2">&quot;offsets must be a list of galsim.PositionD instances with x values &quot;</span>
                    <span class="s2">&quot;spaced by 1/</span><span class="si">{0}</span><span class="s2"> and y values by 1/</span><span class="si">{1}</span><span class="s2"> around 0.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">n1</span><span class="p">,</span><span class="n">n2</span><span class="p">),</span>
                    <span class="n">N</span><span class="o">=</span><span class="n">N</span><span class="p">,</span> <span class="n">offsets</span><span class="o">=</span><span class="n">offsets</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># If we&#39;re told to just trust the offsets, at least make sure the slice will be</span>
            <span class="c1"># the right shape.</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">i</span><span class="o">%</span><span class="n">n1</span>
            <span class="n">j</span> <span class="o">=</span> <span class="n">j</span><span class="o">%</span><span class="n">n2</span>

        <span class="n">img_array</span><span class="p">[</span><span class="n">j</span><span class="p">::</span><span class="n">n2</span><span class="p">,</span><span class="n">i</span><span class="p">::</span><span class="n">n1</span><span class="p">]</span> <span class="o">=</span> <span class="n">im_list</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">array</span>

    <span class="n">img</span> <span class="o">=</span> <span class="n">Image</span><span class="p">(</span><span class="n">img_array</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">add_flux</span><span class="p">:</span>
        <span class="c1"># Fix the flux normalization</span>
        <span class="n">img</span> <span class="o">/=</span> <span class="mf">1.0</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">im_list</span><span class="p">)</span>

    <span class="c1"># Assign an appropriate WCS for the output</span>
    <span class="k">if</span> <span class="n">wcs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">wcs</span><span class="o">.</span><span class="n">isUniform</span><span class="p">():</span>
        <span class="n">jac</span> <span class="o">=</span> <span class="n">wcs</span><span class="o">.</span><span class="n">jacobian</span><span class="p">()</span>
        <span class="n">dudx</span><span class="p">,</span> <span class="n">dudy</span><span class="p">,</span> <span class="n">dvdx</span><span class="p">,</span> <span class="n">dvdy</span> <span class="o">=</span> <span class="n">jac</span><span class="o">.</span><span class="n">dudx</span><span class="p">,</span> <span class="n">jac</span><span class="o">.</span><span class="n">dudy</span><span class="p">,</span> <span class="n">jac</span><span class="o">.</span><span class="n">dvdx</span><span class="p">,</span> <span class="n">jac</span><span class="o">.</span><span class="n">dvdy</span>
        <span class="n">img_wcs</span> <span class="o">=</span> <span class="n">JacobianWCS</span><span class="p">(</span><span class="mf">1.</span><span class="o">*</span><span class="n">dudx</span><span class="o">/</span><span class="n">n1</span><span class="p">,</span><span class="mf">1.</span><span class="o">*</span><span class="n">dudy</span><span class="o">/</span><span class="n">n2</span><span class="p">,</span><span class="mf">1.</span><span class="o">*</span><span class="n">dvdx</span><span class="o">/</span><span class="n">n1</span><span class="p">,</span><span class="mf">1.</span><span class="o">*</span><span class="n">dvdy</span><span class="o">/</span><span class="n">n2</span><span class="p">)</span>
        <span class="c1">## Since pixel scale WCS is not equal to its jacobian, checking if img_wcs is a pixel scale</span>
        <span class="n">img_wcs_decomp</span> <span class="o">=</span> <span class="n">img_wcs</span><span class="o">.</span><span class="n">getDecomposition</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">img_wcs_decomp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">g</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span> <span class="c1">## getDecomposition returns scale,shear,angle,flip</span>
            <span class="n">img</span><span class="o">.</span><span class="n">wcs</span> <span class="o">=</span> <span class="n">PixelScale</span><span class="p">(</span><span class="n">img_wcs_decomp</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">img</span><span class="o">.</span><span class="n">wcs</span> <span class="o">=</span> <span class="n">img_wcs</span>

    <span class="k">elif</span> <span class="n">suppress_warnings</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
        <span class="n">galsim_warn</span><span class="p">(</span><span class="s2">&quot;Interleaved image could not be assigned a WCS automatically.&quot;</span><span class="p">)</span>

    <span class="c1"># Assign a possibly non-trivial origin and warn if individual image have different origins.</span>
    <span class="n">orig</span> <span class="o">=</span> <span class="n">im_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">origin</span>
    <span class="n">img</span><span class="o">.</span><span class="n">setOrigin</span><span class="p">(</span><span class="n">orig</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">im</span> <span class="ow">in</span> <span class="n">im_list</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">im</span><span class="o">.</span><span class="n">origin</span><span class="o">==</span><span class="n">orig</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
            <span class="n">galsim_warn</span><span class="p">(</span><span class="s2">&quot;Images in im_list have multiple values for origin. Assigning the &quot;</span>
                        <span class="s2">&quot;origin of the first Image instance in im_list to the interleaved image.&quot;</span><span class="p">)</span>
            <span class="k">break</span>

    <span class="k">return</span> <span class="n">img</span></div>

<div class="viewcode-block" id="LRU_Cache"><a class="viewcode-back" href="../../misc.html#galsim.utilities.LRU_Cache">[docs]</a><span class="k">class</span> <span class="nc">LRU_Cache</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Simplified Least Recently Used Cache.</span>

<span class="sd">    Mostly stolen from http://code.activestate.com/recipes/577970-simplified-lru-cache/,</span>
<span class="sd">    but added a method for dynamic resizing.  The least recently used cached item is</span>
<span class="sd">    overwritten on a cache miss.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        user_function:  A python function to cache.</span>
<span class="sd">        maxsize:        Maximum number of inputs to cache.  [Default: 1024]</span>

<span class="sd">    Example::</span>

<span class="sd">        &gt;&gt;&gt; def slow_function(*args) # A slow-to-evaluate python function</span>
<span class="sd">        &gt;&gt;&gt;    ...</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; v1 = slow_function(*k1)  # Calling function is slow</span>
<span class="sd">        &gt;&gt;&gt; v1 = slow_function(*k1)  # Calling again with same args is still slow</span>
<span class="sd">        &gt;&gt;&gt; cache = galsim.utilities.LRU_Cache(slow_function)</span>
<span class="sd">        &gt;&gt;&gt; v1 = cache(*k1)  # Returns slow_function(*k1), slowly the first time</span>
<span class="sd">        &gt;&gt;&gt; v1 = cache(*k1)  # Returns slow_function(*k1) again, but fast this time.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">user_function</span><span class="p">,</span> <span class="n">maxsize</span><span class="o">=</span><span class="mi">1024</span><span class="p">):</span>
        <span class="c1"># Link layout:     [PREV, NEXT, KEY, RESULT]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">root</span> <span class="o">=</span> <span class="n">root</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">user_function</span> <span class="o">=</span> <span class="n">user_function</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cache</span> <span class="o">=</span> <span class="n">cache</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="n">last</span> <span class="o">=</span> <span class="n">root</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">maxsize</span><span class="p">):</span>
            <span class="n">key</span> <span class="o">=</span> <span class="nb">object</span><span class="p">()</span>
            <span class="n">cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">last</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">last</span> <span class="o">=</span> <span class="p">[</span><span class="n">last</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>
        <span class="n">root</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">last</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">key</span><span class="p">):</span>
        <span class="n">cache</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache</span>
        <span class="n">root</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">root</span>
        <span class="n">link</span> <span class="o">=</span> <span class="n">cache</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">link</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Cache hit: move link to last position</span>
            <span class="n">link_prev</span><span class="p">,</span> <span class="n">link_next</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">result</span> <span class="o">=</span> <span class="n">link</span>
            <span class="n">link_prev</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">link_next</span>
            <span class="n">link_next</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">link_prev</span>
            <span class="n">last</span> <span class="o">=</span> <span class="n">root</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">last</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">root</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">link</span>
            <span class="n">link</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">last</span>
            <span class="n">link</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">root</span>
            <span class="k">return</span> <span class="n">result</span>
        <span class="c1"># Cache miss: evaluate and insert new key/value at root, then increment root</span>
        <span class="c1">#             so that just-evaluated value is in last position.</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">user_function</span><span class="p">(</span><span class="o">*</span><span class="n">key</span><span class="p">)</span>
        <span class="n">root</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">root</span>  <span class="c1"># re-establish root in case user_function modified it due to recursion</span>
        <span class="n">root</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">key</span>
        <span class="n">root</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span>
        <span class="n">oldroot</span> <span class="o">=</span> <span class="n">root</span>
        <span class="n">root</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">root</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">oldkey</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">root</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">root</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">oldvalue</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">root</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
        <span class="k">del</span> <span class="n">cache</span><span class="p">[</span><span class="n">oldkey</span><span class="p">]</span>
        <span class="n">cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">oldroot</span>
        <span class="k">return</span> <span class="n">result</span>

<div class="viewcode-block" id="LRU_Cache.resize"><a class="viewcode-back" href="../../misc.html#galsim.utilities.LRU_Cache.resize">[docs]</a>    <span class="k">def</span> <span class="nf">resize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">maxsize</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Resize the cache.</span>

<span class="sd">        Increasing the size of the cache is non-destructive, i.e., previously cached inputs remain</span>
<span class="sd">        in the cache.  Decreasing the size of the cache will necessarily remove items from the</span>
<span class="sd">        cache if the cache is already filled.  Items are removed in least recently used order.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            maxsize:    The new maximum number of inputs to cache.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">oldsize</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">maxsize</span> <span class="o">==</span> <span class="n">oldsize</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">root</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">root</span>
            <span class="n">cache</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache</span>
            <span class="k">if</span> <span class="n">maxsize</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">GalSimValueError</span><span class="p">(</span><span class="s2">&quot;Invalid maxsize&quot;</span><span class="p">,</span> <span class="n">maxsize</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">maxsize</span> <span class="o">&lt;</span> <span class="n">oldsize</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">oldsize</span> <span class="o">-</span> <span class="n">maxsize</span><span class="p">):</span>
                    <span class="c1"># Delete root.next</span>
                    <span class="n">current_next_link</span> <span class="o">=</span> <span class="n">root</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">new_next_link</span> <span class="o">=</span> <span class="n">root</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">root</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">new_next_link</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">root</span>
                    <span class="k">del</span> <span class="n">cache</span><span class="p">[</span><span class="n">current_next_link</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>
            <span class="k">else</span><span class="p">:</span> <span class="c1">#  maxsize &gt; oldsize:</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">maxsize</span> <span class="o">-</span> <span class="n">oldsize</span><span class="p">):</span>
                    <span class="c1"># Insert between root and root.next</span>
                    <span class="n">key</span> <span class="o">=</span> <span class="nb">object</span><span class="p">()</span>
                    <span class="n">cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">link</span> <span class="o">=</span> <span class="p">[</span><span class="n">root</span><span class="p">,</span> <span class="n">root</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">key</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>
                    <span class="n">root</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">link</span>
                    <span class="n">root</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">link</span></div></div>


<div class="viewcode-block" id="printoptions"><a class="viewcode-back" href="../../misc.html#galsim.utilities.printoptions">[docs]</a><span class="nd">@contextmanager</span>
<span class="k">def</span> <span class="nf">printoptions</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A context manager for using different numpy printoptions temporarily</span>

<span class="sd">    From http://stackoverflow.com/questions/2891790/pretty-printing-of-numpy-array</span>

<span class="sd">    Usage::</span>

<span class="sd">        with printoptions(threshold=len(long_arr)):</span>
<span class="sd">            print(long_arr)  # Doesn&#39;t omit values in the middle of the array</span>
<span class="sd">        print(long_arr)  # If the array is long enough, will use ... in the middle.</span>

<span class="sd">    .. note::</span>
<span class="sd">        It seems Numpy finally added this feature in version 1.15.  So this is probably</span>
<span class="sd">        equivalent to using ``numpy.prinoptions`` instead of ``galsim.utilities.printoptions``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">original</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">get_printoptions</span><span class="p">()</span>
    <span class="n">np</span><span class="o">.</span><span class="n">set_printoptions</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="c1"># contextmanager exception handling is tricky.  Don&#39;t forget to wrap the yield:</span>
    <span class="c1"># http://preshing.com/20110920/the-python-with-statement-by-example/</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">yield</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="n">np</span><span class="o">.</span><span class="n">set_printoptions</span><span class="p">(</span><span class="o">**</span><span class="n">original</span><span class="p">)</span></div>


<div class="viewcode-block" id="listify"><a class="viewcode-back" href="../../misc.html#galsim.utilities.listify">[docs]</a><span class="k">def</span> <span class="nf">listify</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Turn argument into a list if not already iterable.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        arg:        An argument that may be a lit or a single item</span>

<span class="sd">    Returns:</span>
<span class="sd">        [arg] if arg was not already a list, otherwise arg.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">arg</span><span class="p">]</span> <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="s1">&#39;__iter__&#39;</span><span class="p">)</span> <span class="k">else</span> <span class="n">arg</span></div>


<div class="viewcode-block" id="dol_to_lod"><a class="viewcode-back" href="../../misc.html#galsim.utilities.dol_to_lod">[docs]</a><span class="k">def</span> <span class="nf">dol_to_lod</span><span class="p">(</span><span class="n">dol</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">scalar_string</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Generate list of dicts from dict of lists (with broadcasting).</span>
<span class="sd">    Specifically, generate &quot;scalar-valued&quot; kwargs dictionaries from a kwarg dictionary with values</span>
<span class="sd">    that are length-N lists, or possibly length-1 lists or scalars that should be broadcasted up to</span>
<span class="sd">    length-N lists.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        dol:            A dict of lists</span>
<span class="sd">        N:              The length of the lists if known in advance. [default: None, which will</span>
<span class="sd">                        determine the maximum length of the lists for you]</span>
<span class="sd">        scalar_string:  Whether strings in the input list should be treated as scalars (and thus</span>
<span class="sd">                        broadcast to each item in the output) or not (in which case, they will</span>
<span class="sd">                        be treated as lists of characters) [default: True]</span>

<span class="sd">    Returns:</span>
<span class="sd">        A list of dicts</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">N</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">scalar_string</span><span class="p">:</span>
            <span class="n">lens</span> <span class="o">=</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">dol</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
                           <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="s1">&#39;__len__&#39;</span><span class="p">)</span>
                           <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="nb">str</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">lens</span> <span class="o">=</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">dol</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
                           <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="s1">&#39;__len__&#39;</span><span class="p">)]</span>
        <span class="n">N</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">lens</span><span class="p">)</span> <span class="k">if</span> <span class="n">lens</span> <span class="o">!=</span> <span class="p">[]</span> <span class="k">else</span> <span class="mi">1</span>
    <span class="c1"># Loop through broadcast range</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
        <span class="n">out</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">iteritems</span><span class="p">(</span><span class="n">dol</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">scalar_string</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">out</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
                <span class="k">continue</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">out</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>  <span class="c1"># It&#39;s list-like, but too short.</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">GalSimIncompatibleValuesError</span><span class="p">(</span>
                        <span class="s2">&quot;Cannot broadcast kwargs of different non-length-1 lengths.&quot;</span><span class="p">,</span> <span class="n">dol</span><span class="o">=</span><span class="n">dol</span><span class="p">)</span>
                <span class="n">out</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>  <span class="c1"># Value is not list-like, so broadcast it in its entirety.</span>
                <span class="n">out</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
            <span class="k">except</span> <span class="ne">KeyboardInterrupt</span><span class="p">:</span>
                <span class="k">raise</span>
            <span class="k">except</span><span class="p">:</span> <span class="c1"># pragma: no cover</span>
                <span class="k">raise</span> <span class="n">GalSimIncompatibleValuesError</span><span class="p">(</span>
                    <span class="s2">&quot;Cannot broadcast kwarg </span><span class="si">{0}</span><span class="s2">=</span><span class="si">{1}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">),</span> <span class="n">dol</span><span class="o">=</span><span class="n">dol</span><span class="p">)</span>
        <span class="k">yield</span> <span class="n">out</span></div>

<div class="viewcode-block" id="structure_function"><a class="viewcode-back" href="../../misc.html#galsim.utilities.structure_function">[docs]</a><span class="k">def</span> <span class="nf">structure_function</span><span class="p">(</span><span class="n">image</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Estimate the angularly-averaged structure function of a 2D random field.</span>

<span class="sd">    The angularly-averaged structure function D(r) of the 2D field phi is defined as:</span>

<span class="sd">    .. math::</span>
<span class="sd">        D(|r|) = \langle |phi(x) - phi(x+r)|^2 \rangle</span>

<span class="sd">    where the x and r on the RHS are 2D vectors, but the :math:`|r|` on the LHS is just a scalar</span>
<span class="sd">    length.</span>

<span class="sd">    The image must have its ``scale`` attribute defined.  It will be used in the calculations to</span>
<span class="sd">    set the scale of the radial distances.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        image:  `Image` containing random field realization.</span>

<span class="sd">    Returns:</span>
<span class="sd">        A python callable mapping a separation length r to the estimate of the structure</span>
<span class="sd">        function D(r).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">.table</span> <span class="k">import</span> <span class="n">LookupTable2D</span>
    <span class="n">array</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">array</span>
    <span class="n">nx</span><span class="p">,</span> <span class="n">ny</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">scale</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">scale</span>

    <span class="c1"># The structure function can be derived from the correlation function B(r) as:</span>
    <span class="c1"># D(r) = 2 * [B(0) - B(r)]</span>

    <span class="n">corr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifft2</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft2</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span><span class="n">array</span><span class="p">)))</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">real</span> <span class="o">/</span> <span class="p">(</span><span class="n">nx</span> <span class="o">*</span> <span class="n">ny</span><span class="p">)</span>
    <span class="c1"># Check that the zero-lag correlation function is equal to the variance before doing the</span>
    <span class="c1"># ifftshift.</span>
    <span class="c1">#assert (corr[0, 0] / np.var(array) - 1.0) &lt; 1e-6</span>
    <span class="n">corr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifftshift</span><span class="p">(</span><span class="n">corr</span><span class="p">)</span>

    <span class="n">x</span> <span class="o">=</span> <span class="n">scale</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nx</span><span class="p">)</span> <span class="o">-</span> <span class="n">nx</span><span class="o">//</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">scale</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">ny</span><span class="p">)</span> <span class="o">-</span> <span class="n">ny</span><span class="o">//</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">tab</span> <span class="o">=</span> <span class="n">LookupTable2D</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">corr</span><span class="p">)</span>
    <span class="n">thetas</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">0.</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>  <span class="c1"># Average over these angles.</span>

    <span class="k">return</span> <span class="k">lambda</span> <span class="n">r</span><span class="p">:</span> <span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">tab</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">tab</span><span class="p">(</span><span class="n">r</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">thetas</span><span class="p">),</span> <span class="n">r</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">thetas</span><span class="p">))))</span></div>

<div class="viewcode-block" id="combine_wave_list"><a class="viewcode-back" href="../../misc.html#galsim.utilities.combine_wave_list">[docs]</a><span class="k">def</span> <span class="nf">combine_wave_list</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Combine wave_list attributes of all objects in obj_list while respecting blue_limit and</span>
<span class="sd">    red_limit attributes.  Should work with any combination of `SED`, `Bandpass`, and</span>
<span class="sd">    `ChromaticObject` instances.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        obj_list:   List of `SED`, `Bandpass`, or `ChromaticObject` instances.</span>

<span class="sd">    Returns:</span>
<span class="sd">        wave_list, blue_limit, red_limit</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">.sed</span> <span class="k">import</span> <span class="n">SED</span>
    <span class="kn">from</span> <span class="nn">.bandpass</span> <span class="k">import</span> <span class="n">Bandpass</span>
    <span class="kn">from</span> <span class="nn">.gsobject</span> <span class="k">import</span> <span class="n">GSObject</span>
    <span class="kn">from</span> <span class="nn">.chromatic</span> <span class="k">import</span> <span class="n">ChromaticObject</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                      <span class="p">(</span><span class="n">SED</span><span class="p">,</span> <span class="n">Bandpass</span><span class="p">,</span> <span class="n">ChromaticObject</span><span class="p">,</span> <span class="n">GSObject</span><span class="p">)):</span>
            <span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
            <span class="n">args</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Single input argument must be an SED, Bandpass, GSObject, &quot;</span>
                            <span class="s2">&quot;ChromaticObject or a (possibly mixed) list of them.&quot;</span><span class="p">)</span>

    <span class="n">blue_limit</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="n">red_limit</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
    <span class="n">wave_list</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s1">&#39;blue_limit&#39;</span><span class="p">):</span>
            <span class="n">blue_limit</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">blue_limit</span><span class="p">,</span> <span class="n">obj</span><span class="o">.</span><span class="n">blue_limit</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s1">&#39;red_limit&#39;</span><span class="p">):</span>
            <span class="n">red_limit</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">red_limit</span><span class="p">,</span> <span class="n">obj</span><span class="o">.</span><span class="n">red_limit</span><span class="p">)</span>
        <span class="n">wave_list</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">union1d</span><span class="p">(</span><span class="n">wave_list</span><span class="p">,</span> <span class="n">obj</span><span class="o">.</span><span class="n">wave_list</span><span class="p">)</span>
    <span class="n">wave_list</span> <span class="o">=</span> <span class="n">wave_list</span><span class="p">[(</span><span class="n">wave_list</span> <span class="o">&gt;=</span> <span class="n">blue_limit</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">wave_list</span> <span class="o">&lt;=</span> <span class="n">red_limit</span><span class="p">)]</span>
    <span class="k">if</span> <span class="n">blue_limit</span> <span class="o">&gt;</span> <span class="n">red_limit</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">GalSimError</span><span class="p">(</span><span class="s2">&quot;Empty wave_list intersection.&quot;</span><span class="p">)</span>
    <span class="c1"># Make sure both limits are included.</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">wave_list</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="p">(</span><span class="n">wave_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">blue_limit</span> <span class="ow">or</span> <span class="n">wave_list</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">red_limit</span><span class="p">):</span>
        <span class="n">wave_list</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">union1d</span><span class="p">([</span><span class="n">blue_limit</span><span class="p">,</span> <span class="n">red_limit</span><span class="p">],</span> <span class="n">wave_list</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">wave_list</span><span class="p">,</span> <span class="n">blue_limit</span><span class="p">,</span> <span class="n">red_limit</span></div>

<div class="viewcode-block" id="functionize"><a class="viewcode-back" href="../../misc.html#galsim.utilities.functionize">[docs]</a><span class="k">def</span> <span class="nf">functionize</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Decorate a function ``f`` which accepts scalar positional or keyword arguments, to accept</span>
<span class="sd">    arguments that can be either scalars or _functions_.  If the arguments include univariate</span>
<span class="sd">    (N-variate) functions, then the output will be a univariate (N-variate) function.  While it&#39;s</span>
<span class="sd">    okay to mix scalar and N-variate function arguments, it is an error to mix N-variate and</span>
<span class="sd">    M-variate function arguments.</span>

<span class="sd">    Example::</span>

<span class="sd">        &gt;&gt;&gt; def f(x, y):      # Function of two scalars.</span>
<span class="sd">        ...     return x + y</span>
<span class="sd">        &gt;&gt;&gt; decorated = functionize(f)   # Function of two scalars, functions, or a mix.</span>
<span class="sd">        &gt;&gt;&gt; result = f(2, 3)  # 5</span>
<span class="sd">        &gt;&gt;&gt; result = f(2, lambda u: u)  # Generates a TypeError</span>
<span class="sd">        &gt;&gt;&gt; result = decorated(2, 3)  # Scalar args returns a scalar</span>
<span class="sd">        &gt;&gt;&gt; result = decorated(2, lambda u: u)  # Univariate argument leads to a univariate output.</span>
<span class="sd">        &gt;&gt;&gt; print(result(5))  # 7</span>
<span class="sd">        &gt;&gt;&gt; result = decorated(2, lambda u,v: u*v)  # Bivariate argument leads to a bivariate output.</span>
<span class="sd">        &gt;&gt;&gt; print(result(5, 7))  # 2 + (5*7) = 37</span>

<span class="sd">    We can use arguments that accept keyword arguments too::</span>

<span class="sd">        &gt;&gt;&gt; def f2(u, v=None):</span>
<span class="sd">        ...    if v is None:</span>
<span class="sd">        ...        v = 6.0</span>
<span class="sd">        ...    return u / v</span>
<span class="sd">        &gt;&gt;&gt; result = decorated(2, f2)</span>
<span class="sd">        &gt;&gt;&gt; print(result(12))  # 2 + (12./6) = 4.0</span>
<span class="sd">        &gt;&gt;&gt; print(result(12, v=4))  # 2 + (12/4) = 5</span>

<span class="sd">    Note that you can also use python&#39;s decorator syntax::</span>

<span class="sd">        &gt;&gt;&gt; @functionize</span>
<span class="sd">        &gt;&gt;&gt; def f(x, y):</span>
<span class="sd">        ...     return x + y</span>

<span class="sd">    Parameters:</span>
<span class="sd">        f:      The function to be decorated.</span>

<span class="sd">    Returns:</span>
<span class="sd">        The decorated function.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nd">@functools</span><span class="o">.</span><span class="n">wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">ff</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># First check if any of the arguments are callable...</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="nb">hasattr</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="s1">&#39;__call__&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span><span class="o">+</span><span class="nb">tuple</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">values</span><span class="p">())):</span>
            <span class="k">return</span> <span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>  <span class="c1"># ... if not, then keep output type a scalar ...</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">def</span> <span class="nf">fff</span><span class="p">(</span><span class="o">*</span><span class="n">inner_args</span><span class="p">,</span> <span class="o">**</span><span class="n">inner_kwargs</span><span class="p">):</span> <span class="c1"># ...else the output type is a function: fff.</span>
                <span class="n">new_args</span> <span class="o">=</span> <span class="p">[</span><span class="n">arg</span>
                            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="s1">&#39;__call__&#39;</span><span class="p">)</span>
                            <span class="k">else</span> <span class="n">arg</span><span class="p">(</span><span class="o">*</span><span class="n">inner_args</span><span class="p">,</span> <span class="o">**</span><span class="n">inner_kwargs</span><span class="p">)</span>
                            <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span><span class="p">]</span>
                <span class="n">new_kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
                                   <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="s1">&#39;__call__&#39;</span><span class="p">)</span>
                                   <span class="k">else</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">(</span><span class="o">*</span><span class="n">inner_args</span><span class="p">,</span> <span class="o">**</span><span class="n">inner_kwargs</span><span class="p">))</span>
                                   <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">iteritems</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)])</span>
                <span class="k">return</span> <span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="n">new_args</span><span class="p">,</span> <span class="o">**</span><span class="n">new_kwargs</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">fff</span>
    <span class="k">return</span> <span class="n">ff</span></div>

<div class="viewcode-block" id="math_eval"><a class="viewcode-back" href="../../misc.html#galsim.utilities.math_eval">[docs]</a><span class="k">def</span> <span class="nf">math_eval</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">other_modules</span><span class="o">=</span><span class="p">()):</span>
    <span class="sd">&quot;&quot;&quot;Evaluate a string that may include numpy, np, or math commands.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        str:            The string to evaluate</span>
<span class="sd">        other_modules.  Other modules in addition to numpy, np, math to import as well.</span>
<span class="sd">                        Should be given as a list of strings.  [default: None]</span>

<span class="sd">    Returns:</span>
<span class="sd">        Whatever the string evaluates to.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Python 2 and 3 have a different syntax for exec with globals() dict.</span>
    <span class="c1"># The exec_ function lets us use the Python 3 syntax even in Python 2.</span>
    <span class="kn">from</span> <span class="nn">future.utils</span> <span class="k">import</span> <span class="n">exec_</span>
    <span class="n">gdict</span> <span class="o">=</span> <span class="nb">globals</span><span class="p">()</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">exec_</span><span class="p">(</span><span class="s1">&#39;import galsim&#39;</span><span class="p">,</span> <span class="n">gdict</span><span class="p">)</span>
    <span class="n">exec_</span><span class="p">(</span><span class="s1">&#39;import numpy&#39;</span><span class="p">,</span> <span class="n">gdict</span><span class="p">)</span>
    <span class="n">exec_</span><span class="p">(</span><span class="s1">&#39;import numpy as np&#39;</span><span class="p">,</span> <span class="n">gdict</span><span class="p">)</span>
    <span class="n">exec_</span><span class="p">(</span><span class="s1">&#39;import math&#39;</span><span class="p">,</span> <span class="n">gdict</span><span class="p">)</span>
    <span class="n">exec_</span><span class="p">(</span><span class="s1">&#39;import coord&#39;</span><span class="p">,</span> <span class="n">gdict</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">other_modules</span><span class="p">:</span>  <span class="c1"># pragma: no cover  (We don&#39;t use this.)</span>
        <span class="n">exec_</span><span class="p">(</span><span class="s1">&#39;import &#39;</span> <span class="o">+</span> <span class="n">m</span><span class="p">,</span> <span class="n">gdict</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">eval</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">gdict</span><span class="p">)</span></div>

<div class="viewcode-block" id="binomial"><a class="viewcode-back" href="../../misc.html#galsim.utilities.binomial">[docs]</a><span class="k">def</span> <span class="nf">binomial</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return xy coefficients of (ax + by)^n ordered by descending powers of a.</span>

<span class="sd">    Example::</span>

<span class="sd">        # (x + y)^3 = 1 x^3 + 3 x^2 y + 3 x y^2 + 1 y^3</span>
<span class="sd">        &gt;&gt;&gt;  print(binomial(1, 1, 3))</span>
<span class="sd">        array([ 1.,  3.,  3.,  1.])</span>


<span class="sd">        # (2 x + y)^3 = 8 x^3 + 12 x^2 y + 6 x y^2 + 1 y^3</span>
<span class="sd">        &gt;&gt;&gt;  print(binomial(2, 1, 3))</span>
<span class="sd">        array([ 8.,  12.,  6.,  1.])</span>

<span class="sd">    Parameters:</span>
<span class="sd">        a:      First scalar in binomial to be expanded.</span>
<span class="sd">        b:      Second scalar in binomial to be expanded.</span>
<span class="sd">        n:      Exponent of expansion.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Array of coefficients in expansion.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">b_over_a</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">generate</span><span class="p">():</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">a</span><span class="o">**</span><span class="n">n</span>
        <span class="k">yield</span> <span class="n">c</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>  <span class="c1"># pragma: no branch  (It never actually gets past the last yield.)</span>
            <span class="n">c</span> <span class="o">*=</span> <span class="n">b_over_a</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="n">i</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">yield</span> <span class="n">c</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">fromiter</span><span class="p">(</span><span class="n">generate</span><span class="p">(),</span> <span class="nb">float</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span></div>

<div class="viewcode-block" id="unweighted_moments"><a class="viewcode-back" href="../../misc.html#galsim.utilities.unweighted_moments">[docs]</a><span class="k">def</span> <span class="nf">unweighted_moments</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Computes unweighted 0th, 1st, and 2nd moments in image coordinates.  Respects image bounds,</span>
<span class="sd">    but ignores any scale or wcs.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        image:      `Image` from which to compute moments</span>
<span class="sd">        origin:     Optional origin in image coordinates used to compute Mx and My</span>
<span class="sd">                    [default: galsim.PositionD(0, 0)].</span>

<span class="sd">    Returns:</span>
<span class="sd">        Dict with entries for [M0, Mx, My, Mxx, Myy, Mxy]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">.position</span> <span class="k">import</span> <span class="n">PositionD</span>
    <span class="k">if</span> <span class="n">origin</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">origin</span> <span class="o">=</span> <span class="n">PositionD</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">offset</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">origin</span> <span class="o">-</span> <span class="n">origin</span>
    <span class="n">xgrid</span><span class="p">,</span> <span class="n">ygrid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">offset</span><span class="o">.</span><span class="n">x</span><span class="p">,</span>
                               <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="n">offset</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
    <span class="n">M0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">Mx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">xgrid</span> <span class="o">*</span> <span class="n">a</span><span class="p">)</span> <span class="o">/</span> <span class="n">M0</span>
    <span class="n">My</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ygrid</span> <span class="o">*</span> <span class="n">a</span><span class="p">)</span> <span class="o">/</span> <span class="n">M0</span>
    <span class="n">Mxx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(((</span><span class="n">xgrid</span><span class="o">-</span><span class="n">Mx</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">a</span><span class="p">)</span> <span class="o">/</span> <span class="n">M0</span>
    <span class="n">Myy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(((</span><span class="n">ygrid</span><span class="o">-</span><span class="n">My</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">a</span><span class="p">)</span> <span class="o">/</span> <span class="n">M0</span>
    <span class="n">Mxy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">xgrid</span><span class="o">-</span><span class="n">Mx</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">ygrid</span><span class="o">-</span><span class="n">My</span><span class="p">)</span> <span class="o">*</span> <span class="n">a</span><span class="p">)</span> <span class="o">/</span> <span class="n">M0</span>
    <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="n">M0</span><span class="o">=</span><span class="n">M0</span><span class="p">,</span> <span class="n">Mx</span><span class="o">=</span><span class="n">Mx</span><span class="p">,</span> <span class="n">My</span><span class="o">=</span><span class="n">My</span><span class="p">,</span> <span class="n">Mxx</span><span class="o">=</span><span class="n">Mxx</span><span class="p">,</span> <span class="n">Myy</span><span class="o">=</span><span class="n">Myy</span><span class="p">,</span> <span class="n">Mxy</span><span class="o">=</span><span class="n">Mxy</span><span class="p">)</span></div>

<div class="viewcode-block" id="unweighted_shape"><a class="viewcode-back" href="../../misc.html#galsim.utilities.unweighted_shape">[docs]</a><span class="k">def</span> <span class="nf">unweighted_shape</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Computes unweighted second moment size and ellipticity given either an image or a dict of</span>
<span class="sd">    unweighted moments.</span>

<span class="sd">    The size is:</span>
<span class="sd">        rsqr = Mxx+Myy</span>
<span class="sd">    The ellipticities are:</span>
<span class="sd">        e1 = (Mxx-Myy) / rsqr</span>
<span class="sd">        e2 = 2*Mxy / rsqr</span>

<span class="sd">    Parameters:</span>
<span class="sd">        arg:    Either a `galsim.Image` or the output of unweighted_moments(image).</span>

<span class="sd">    Returns:</span>
<span class="sd">        Dict with entries for [rsqr, e1, e2]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">.image</span> <span class="k">import</span> <span class="n">Image</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">Image</span><span class="p">):</span>
        <span class="n">arg</span> <span class="o">=</span> <span class="n">unweighted_moments</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
    <span class="n">rsqr</span> <span class="o">=</span> <span class="n">arg</span><span class="p">[</span><span class="s1">&#39;Mxx&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">arg</span><span class="p">[</span><span class="s1">&#39;Myy&#39;</span><span class="p">]</span>
    <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="n">rsqr</span><span class="o">=</span><span class="n">rsqr</span><span class="p">,</span> <span class="n">e1</span><span class="o">=</span><span class="p">(</span><span class="n">arg</span><span class="p">[</span><span class="s1">&#39;Mxx&#39;</span><span class="p">]</span><span class="o">-</span><span class="n">arg</span><span class="p">[</span><span class="s1">&#39;Myy&#39;</span><span class="p">])</span><span class="o">/</span><span class="n">rsqr</span><span class="p">,</span> <span class="n">e2</span><span class="o">=</span><span class="mi">2</span><span class="o">*</span><span class="n">arg</span><span class="p">[</span><span class="s1">&#39;Mxy&#39;</span><span class="p">]</span><span class="o">/</span><span class="n">rsqr</span><span class="p">)</span></div>

<div class="viewcode-block" id="rand_with_replacement"><a class="viewcode-back" href="../../misc.html#galsim.utilities.rand_with_replacement">[docs]</a><span class="k">def</span> <span class="nf">rand_with_replacement</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">n_choices</span><span class="p">,</span> <span class="n">rng</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">_n_rng_calls</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Select some number of random choices from a list, with replacement, using a supplied RNG.</span>

<span class="sd">    ``n`` random choices with replacement are made assuming that those choices should range from 0</span>
<span class="sd">    to ``n_choices-1``, so they can be used as indices in a list/array.  If ``weight`` is supplied,</span>
<span class="sd">    then it should be an array of length ``n_choices`` that ranges from 0-1, and can be used to</span>
<span class="sd">    make weighted choices from the list.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        n:          Number of random selections to make.</span>
<span class="sd">        n_choices:  Number of entries from which to choose.</span>
<span class="sd">        rng:        RNG to use.  Must a `galsim.BaseDeviate` instance.</span>
<span class="sd">        weight:     Optional list of weight factors to use for weighting the selection of</span>
<span class="sd">                    random indices.</span>

<span class="sd">    Returns:</span>
<span class="sd">        a NumPy array of length n containing the integer-valued indices that were selected.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">.random</span> <span class="k">import</span> <span class="n">BaseDeviate</span><span class="p">,</span> <span class="n">UniformDeviate</span>
    <span class="c1"># Make sure we got a proper RNG.</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">rng</span><span class="p">,</span> <span class="n">BaseDeviate</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;The rng provided to rand_with_replacement() must be a BaseDeviate&quot;</span><span class="p">)</span>
    <span class="n">ud</span> <span class="o">=</span> <span class="n">UniformDeviate</span><span class="p">(</span><span class="n">rng</span><span class="p">)</span>

    <span class="c1"># Sanity check the requested number of random indices.</span>
    <span class="c1"># Note: we do not require that the type be an int, as long as the value is consistent with</span>
    <span class="c1"># an integer value (i.e., it could be a float 1.0 or 1).</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">!=</span> <span class="nb">int</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="ow">or</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">GalSimValueError</span><span class="p">(</span><span class="s2">&quot;n must be an integer &gt;= 1.&quot;</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">n_choices</span> <span class="o">!=</span> <span class="nb">int</span><span class="p">(</span><span class="n">n_choices</span><span class="p">)</span> <span class="ow">or</span> <span class="n">n_choices</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">GalSimValueError</span><span class="p">(</span><span class="s2">&quot;n_choices must be an integer &gt;= 1.&quot;</span><span class="p">,</span> <span class="n">n_choices</span><span class="p">)</span>

    <span class="c1"># Sanity check the input weight.</span>
    <span class="k">if</span> <span class="n">weight</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># We need some sanity checks here in case people passed in weird values.</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">weight</span><span class="p">)</span> <span class="o">!=</span> <span class="n">n_choices</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">GalSimIncompatibleValuesError</span><span class="p">(</span>
                <span class="s2">&quot;Array of weights has wrong length&quot;</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="n">weight</span><span class="p">,</span> <span class="n">n_choices</span><span class="o">=</span><span class="n">n_choices</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">weight</span><span class="p">))</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">weight</span><span class="p">))</span> <span class="ow">or</span>
            <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">weight</span><span class="p">)</span><span class="o">&lt;</span><span class="mi">0</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">weight</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">GalSimRangeError</span><span class="p">(</span><span class="s2">&quot;Supplied weights include values outside [0,1] or inf/NaN.&quot;</span><span class="p">,</span>
                                   <span class="n">weight</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">)</span>

    <span class="c1"># We first make a random list of integer indices.</span>
    <span class="n">index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="n">ud</span><span class="o">.</span><span class="n">generate</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">_n_rng_calls</span><span class="p">:</span>
        <span class="c1"># Here we use the undocumented kwarg (for internal use by config) to track the number of</span>
        <span class="c1"># RNG calls.</span>
        <span class="n">n_rng_calls</span> <span class="o">=</span> <span class="n">n</span>
    <span class="n">index</span> <span class="o">=</span> <span class="p">(</span><span class="n">n_choices</span><span class="o">*</span><span class="n">index</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

    <span class="c1"># Then we account for the weights, if possible.</span>
    <span class="k">if</span> <span class="n">weight</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># If weight factors are available, make sure the random selection uses the weights.</span>
        <span class="n">test_vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="c1"># Note that the weight values by definition have a maximum of 1, as enforced above.</span>
        <span class="n">ud</span><span class="o">.</span><span class="n">generate</span><span class="p">(</span><span class="n">test_vals</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">_n_rng_calls</span><span class="p">:</span>
            <span class="n">n_rng_calls</span> <span class="o">+=</span> <span class="n">n</span>
        <span class="c1"># The ones with mask==True are the ones we should replace.</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">test_vals</span> <span class="o">&gt;</span> <span class="n">weight</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
        <span class="k">while</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">mask</span><span class="p">):</span>
            <span class="c1"># Update the index and test values for those that failed. We have to do this by</span>
            <span class="c1"># generating random numbers into new arrays, because ud.generate() does not enable</span>
            <span class="c1"># us to directly populate a sub-array like index[mask] or test_vals[mask].</span>
            <span class="n">n_fail</span> <span class="o">=</span> <span class="n">mask</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
            <span class="c1"># First update the indices that failed.</span>
            <span class="n">new_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_fail</span><span class="p">)</span>
            <span class="n">ud</span><span class="o">.</span><span class="n">generate</span><span class="p">(</span><span class="n">new_arr</span><span class="p">)</span>
            <span class="n">index</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">n_choices</span><span class="o">*</span><span class="n">new_arr</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
            <span class="c1"># Then update the test values that failed.</span>
            <span class="n">new_test_vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_fail</span><span class="p">)</span>
            <span class="n">ud</span><span class="o">.</span><span class="n">generate</span><span class="p">(</span><span class="n">new_test_vals</span><span class="p">)</span>
            <span class="n">test_vals</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_test_vals</span>
            <span class="k">if</span> <span class="n">_n_rng_calls</span><span class="p">:</span>
                <span class="n">n_rng_calls</span> <span class="o">+=</span> <span class="mi">2</span><span class="o">*</span><span class="n">n_fail</span>
            <span class="c1"># Finally, update the test array used to determine whether any galaxies failed.</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">test_vals</span> <span class="o">&gt;</span> <span class="n">weight</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">_n_rng_calls</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">index</span><span class="p">,</span> <span class="n">n_rng_calls</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">index</span></div>


<div class="viewcode-block" id="check_share_file"><a class="viewcode-back" href="../../misc.html#galsim.utilities.check_share_file">[docs]</a><span class="k">def</span> <span class="nf">check_share_file</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">subdir</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Find `SED` or `Bandpass` file, possibly adding share_dir/subdir.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        filename:       The file name to look for</span>
<span class="sd">        subdir:         The subdirectory of `galsim.meta_data.share_dir` where this file might be.</span>

<span class="sd">    Returns:</span>
<span class="sd">        True, correct_filename      if the file was found</span>
<span class="sd">        False, &#39;&#39;                   if not</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">meta_data</span>
    <span class="kn">import</span> <span class="nn">os</span>

    <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">True</span><span class="p">,</span> <span class="n">filename</span>

    <span class="n">new_filename</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">meta_data</span><span class="o">.</span><span class="n">share_dir</span><span class="p">,</span> <span class="n">subdir</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">new_filename</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">True</span><span class="p">,</span> <span class="n">new_filename</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span><span class="p">,</span> <span class="s1">&#39;&#39;</span></div>


<div class="viewcode-block" id="lazy_property"><a class="viewcode-back" href="../../misc.html#galsim.utilities.lazy_property">[docs]</a><span class="k">class</span> <span class="nc">lazy_property</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This decorator will act similarly to @property, but will be efficient for multiple access</span>
<span class="sd">    to values that require some significant calculation.</span>

<span class="sd">    It works by replacing the attribute with the computed value, so after the first access,</span>
<span class="sd">    the property (an attribute of the class) is superseded by the new attribute of the instance.</span>

<span class="sd">    Note that is should only be used for non-mutable data, since the calculation will not be</span>
<span class="sd">    repeated if anything about the instance changes.</span>

<span class="sd">    Usage::</span>

<span class="sd">        @lazy_property</span>
<span class="sd">        def slow_function_to_be_used_as_a_property(self):</span>
<span class="sd">            x =  ...  # Some slow calculation.</span>
<span class="sd">            return x</span>

<span class="sd">    Base on an answer from http://stackoverflow.com/a/6849299</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fget</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fget</span> <span class="o">=</span> <span class="n">fget</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">func_name</span> <span class="o">=</span> <span class="n">fget</span><span class="o">.</span><span class="vm">__name__</span>

    <span class="k">def</span> <span class="nf">__get__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="bp">cls</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">obj</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fget</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
        <span class="nb">setattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">func_name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">value</span></div>

<div class="viewcode-block" id="doc_inherit"><a class="viewcode-back" href="../../misc.html#galsim.utilities.doc_inherit">[docs]</a><span class="k">class</span> <span class="nc">doc_inherit</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    This decorator will grab a doc string from a base class version of a method.</span>
<span class="sd">    Useful if the subclass doesn&#39;t change anything about the method API, but just has</span>
<span class="sd">    a specialized implementation.  This lets the documentation live only in one place.</span>

<span class="sd">    Usage::</span>

<span class="sd">        class Base(object):</span>
<span class="sd">            def some_method(self):</span>
<span class="sd">                &quot;&quot;&quot;A nice description of the functionality</span>
<span class="sd">                &quot;&quot;&quot;</span>
<span class="sd">                pass</span>

<span class="sd">        class Sub(Base):</span>

<span class="sd">            @doc_inherit</span>
<span class="sd">            def some_method(self):</span>
<span class="sd">                # Don&#39;t bother with any doc string here.</span>
<span class="sd">                pass</span>

<span class="sd">    Based on the Docstring Inheritance Decorator at:</span>

<span class="sd">    https://github.com/ActiveState/code/wiki/Python_index_1</span>

<span class="sd">    Although I (MJ) modified it slightly, since the original recipe there had a bug that made it</span>
<span class="sd">    not work properly with 2 levels of sub-classing (e.g. Pixel &lt;- Box &lt;- GSObject).</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mthd</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mthd</span> <span class="o">=</span> <span class="n">mthd</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">mthd</span><span class="o">.</span><span class="vm">__name__</span>

    <span class="k">def</span> <span class="nf">__get__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="bp">cls</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">parent</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__bases__</span><span class="p">:</span> <span class="c1"># pragma: no branch</span>
            <span class="n">parfunc</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">parfunc</span> <span class="ow">and</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">parfunc</span><span class="p">,</span> <span class="s1">&#39;__doc__&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">):</span> <span class="c1"># pragma: no branch</span>
                <span class="k">break</span>

        <span class="k">if</span> <span class="n">obj</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_with_inst</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="bp">cls</span><span class="p">,</span> <span class="n">parfunc</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_no_inst</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">parfunc</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_with_inst</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="bp">cls</span><span class="p">,</span> <span class="n">parfunc</span><span class="p">):</span>
        <span class="nd">@functools</span><span class="o">.</span><span class="n">wraps</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mthd</span><span class="p">,</span> <span class="n">assigned</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;__name__&#39;</span><span class="p">,</span><span class="s1">&#39;__module__&#39;</span><span class="p">))</span>
        <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">mthd</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_parent_doc</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">parfunc</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_no_inst</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">cls</span><span class="p">,</span> <span class="n">parfunc</span><span class="p">):</span>
        <span class="nd">@functools</span><span class="o">.</span><span class="n">wraps</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mthd</span><span class="p">,</span> <span class="n">assigned</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;__name__&#39;</span><span class="p">,</span><span class="s1">&#39;__module__&#39;</span><span class="p">))</span>
        <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span> <span class="c1"># pragma: no cover (without inst, this is not normally called.)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">mthd</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_parent_doc</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">parfunc</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">use_parent_doc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">source</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">source</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="c1"># pragma: no cover</span>
            <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="s2">&quot;Can&#39;t find &#39;</span><span class="si">%s</span><span class="s2">&#39; in parents&quot;</span><span class="o">%</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="n">func</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">source</span><span class="o">.</span><span class="vm">__doc__</span>
        <span class="k">return</span> <span class="n">func</span></div>

<div class="viewcode-block" id="OrderedWeakRef"><a class="viewcode-back" href="../../misc.html#galsim.utilities.OrderedWeakRef">[docs]</a><span class="k">class</span> <span class="nc">OrderedWeakRef</span><span class="p">(</span><span class="n">weakref</span><span class="o">.</span><span class="n">ref</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Assign an arbitrary ordering to weakref.ref so that it can be part of a heap.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">id</span><span class="p">(</span><span class="n">other</span><span class="p">)</span></div>


<div class="viewcode-block" id="nCr"><a class="viewcode-back" href="../../misc.html#galsim.utilities.nCr">[docs]</a><span class="k">def</span> <span class="nf">nCr</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Combinations.  I.e., the number of ways to choose ``r`` distiguishable things from ``n``</span>
<span class="sd">    distinguishable things.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        n       The number of options to choose from.</span>
<span class="sd">        r       The number of items to choose</span>

<span class="sd">    Returns:</span>
<span class="sd">        nCr, the (n,r) binomial coefficient.</span>

<span class="sd">    .. note::</span>
<span class="sd">        In Python 3, the factorial function was improved such that doing this the direct way</span>
<span class="sd">        of calculating n! / (r! (n-r)!) seems to be the fastest algorith.  In Python 2, for</span>
<span class="sd">        largish values of n, a more complicated algorithm that avoided large integers was</span>
<span class="sd">        faster.  This function uses the direct method for both -- we don&#39;t bother to check the</span>
<span class="sd">        version of Python to potentially select a different algorithm in the two cases.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">math</span> <span class="k">import</span> <span class="n">factorial</span>
    <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">r</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">factorial</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">//</span> <span class="p">(</span><span class="n">factorial</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="o">*</span> <span class="n">factorial</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="n">r</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span></div>

<div class="viewcode-block" id="WeakMethod"><a class="viewcode-back" href="../../misc.html#galsim.utilities.WeakMethod">[docs]</a><span class="k">class</span> <span class="nc">WeakMethod</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Wrap a method in a weakref.</span>

<span class="sd">    This is useful if you want to specialize a function if certain conditions hold.</span>
<span class="sd">    You can check those conditions and return one of several possible implementations as</span>
<span class="sd">    a `lazy_property`.</span>

<span class="sd">    Using just a normal ``weakref`` doesn&#39;t work, but this class will work.</span>

<span class="sd">    From http://code.activestate.com/recipes/81253-weakmethod/</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">f</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="vm">__func__</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">c</span> <span class="o">=</span> <span class="n">weakref</span><span class="o">.</span><span class="n">ref</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="vm">__self__</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">()</span> <span class="ow">is</span> <span class="kc">None</span> <span class="p">:</span>  <span class="c1"># pragma: no cover</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Method called on dead object&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">(),</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span></div>

<div class="viewcode-block" id="ensure_dir"><a class="viewcode-back" href="../../misc.html#galsim.utilities.ensure_dir">[docs]</a><span class="k">def</span> <span class="nf">ensure_dir</span><span class="p">(</span><span class="n">target</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Make sure the directory for the target location exists, watching for a race condition</span>

<span class="sd">    In particular check if the OS reported that the directory already exists when running</span>
<span class="sd">    makedirs, which can happen if another process creates it before this one can</span>

<span class="sd">    Parameter:</span>
<span class="sd">        target:     The file name for which to ensure that all necessary directories exist.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_ERR_FILE_EXISTS</span><span class="o">=</span><span class="mi">17</span>
    <span class="nb">dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">dir</span> <span class="o">==</span> <span class="s1">&#39;&#39;</span><span class="p">:</span> <span class="k">return</span>

    <span class="n">exists</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="nb">dir</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">exists</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="nb">dir</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">OSError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
            <span class="c1"># check if the file now exists, which can happen if some other</span>
            <span class="c1"># process created the directory between the os.path.exists call</span>
            <span class="c1"># above and the time of the makedirs attempt.  This is OK</span>
            <span class="k">if</span> <span class="n">err</span><span class="o">.</span><span class="n">errno</span> <span class="o">!=</span> <span class="n">_ERR_FILE_EXISTS</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">err</span>

    <span class="k">elif</span> <span class="n">exists</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="nb">dir</span><span class="p">):</span>  <span class="c1"># pragma: no cover</span>
        <span class="k">raise</span> <span class="ne">OSError</span><span class="p">(</span><span class="s2">&quot;tried to make directory &#39;</span><span class="si">%s</span><span class="s2">&#39; &quot;</span>
                      <span class="s2">&quot;but a non-directory file of that &quot;</span>
                      <span class="s2">&quot;name already exists&quot;</span> <span class="o">%</span> <span class="nb">dir</span><span class="p">)</span></div>


<div class="viewcode-block" id="find_out_of_bounds_position"><a class="viewcode-back" href="../../misc.html#galsim.utilities.find_out_of_bounds_position">[docs]</a><span class="k">def</span> <span class="nf">find_out_of_bounds_position</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">bounds</span><span class="p">,</span> <span class="n">grid</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Given arrays of x and y values that are known to contain at least one</span>
<span class="sd">    position that is out-of-bounds of the given bounds instance, return one</span>
<span class="sd">    such PositionD.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        x:          Array of x values</span>
<span class="sd">        y:          Array of y values</span>
<span class="sd">        bounds:     `Bounds` instance</span>
<span class="sd">        grid:       Bool indicating whether to check the outer product of x and y</span>
<span class="sd">                    (grid=True), or each sequential pair of x and y (grid=False).</span>
<span class="sd">                    If the latter, then x and y should have the same shape.</span>

<span class="sd">    Returns:</span>
<span class="sd">        a `PositionD` from x and y that is out-of-bounds of bounds.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">.position</span> <span class="k">import</span> <span class="n">PositionD</span>
    <span class="k">if</span> <span class="n">grid</span><span class="p">:</span>
        <span class="c1"># It&#39;s enough to check corners for grid input</span>
        <span class="k">for</span> <span class="n">x_</span> <span class="ow">in</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">x</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">y_</span> <span class="ow">in</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">y</span><span class="p">)):</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">x_</span> <span class="o">&lt;</span> <span class="n">bounds</span><span class="o">.</span><span class="n">xmin</span> <span class="ow">or</span> <span class="n">x_</span> <span class="o">&gt;</span> <span class="n">bounds</span><span class="o">.</span><span class="n">xmax</span> <span class="ow">or</span>
                    <span class="n">y_</span> <span class="o">&lt;</span> <span class="n">bounds</span><span class="o">.</span><span class="n">ymin</span> <span class="ow">or</span> <span class="n">y_</span> <span class="o">&gt;</span> <span class="n">bounds</span><span class="o">.</span><span class="n">ymax</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">PositionD</span><span class="p">(</span><span class="n">x_</span><span class="p">,</span> <span class="n">y_</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Faster to check all points than to iterate through them one-by-one?</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">x</span> <span class="o">&lt;</span> <span class="n">bounds</span><span class="o">.</span><span class="n">xmin</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;</span> <span class="n">bounds</span><span class="o">.</span><span class="n">xmax</span><span class="p">)</span> <span class="o">|</span>
                     <span class="p">(</span><span class="n">y</span> <span class="o">&lt;</span> <span class="n">bounds</span><span class="o">.</span><span class="n">ymin</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">y</span> <span class="o">&gt;</span> <span class="n">bounds</span><span class="o">.</span><span class="n">ymax</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">w</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">PositionD</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">w</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]],</span> <span class="n">y</span><span class="p">[</span><span class="n">w</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]])</span>
    <span class="k">raise</span> <span class="n">GalSimError</span><span class="p">(</span><span class="s2">&quot;No out-of-bounds position&quot;</span><span class="p">)</span></div>

<span class="k">def</span> <span class="nf">set_omp_threads</span><span class="p">(</span><span class="n">num_threads</span><span class="p">,</span> <span class="n">logger</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Set the number of OpenMP threads to use in the C++ layer.</span>

<span class="sd">    :param num_threads: The target number of threads to use (If None or &lt;=0, then try to use the</span>
<span class="sd">                        numer of cpus.)</span>
<span class="sd">    :param logger:      If desired, a logger object for logging any warnings here. (default: None)</span>

<span class="sd">    :returns:           The  number of threads OpenMP reports that it will use.  Typically this</span>
<span class="sd">                        matches the input, but OpenMP reserves the right not to comply with</span>
<span class="sd">                        the requested number of threads.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># This function was copied shamelessly from TreeCorr&#39;s function of the same name.</span>

    <span class="n">input_num_threads</span> <span class="o">=</span> <span class="n">num_threads</span>  <span class="c1"># Save the input value.</span>

    <span class="c1"># If num_threads is auto, get it from cpu_count</span>
    <span class="k">if</span> <span class="n">num_threads</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">num_threads</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="kn">import</span> <span class="nn">multiprocessing</span>
        <span class="n">num_threads</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">cpu_count</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">logger</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;multiprocessing.cpu_count() = </span><span class="si">%d</span><span class="s1">&#39;</span><span class="p">,</span><span class="n">num_threads</span><span class="p">)</span>

    <span class="c1"># Tell OpenMP to use this many threads</span>
    <span class="k">if</span> <span class="n">logger</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Telling OpenMP to use </span><span class="si">%d</span><span class="s1"> threads&#39;</span><span class="p">,</span><span class="n">num_threads</span><span class="p">)</span>
    <span class="n">num_threads</span> <span class="o">=</span> <span class="n">_galsim</span><span class="o">.</span><span class="n">SetOMPThreads</span><span class="p">(</span><span class="n">num_threads</span><span class="p">)</span>

    <span class="c1"># Report back appropriately.</span>
    <span class="k">if</span> <span class="n">logger</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;OpenMP reports that it will use </span><span class="si">%d</span><span class="s1"> threads&#39;</span><span class="p">,</span><span class="n">num_threads</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">num_threads</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Using </span><span class="si">%d</span><span class="s1"> threads.&#39;</span><span class="p">,</span><span class="n">num_threads</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">input_num_threads</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">input_num_threads</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># Only warn if the user specifically asked for num_threads != 1.</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Unable to use multiple threads, since OpenMP is not enabled.&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">num_threads</span>

</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, GalSim-developers

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>