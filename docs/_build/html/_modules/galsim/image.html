

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>galsim.image &mdash; GalSim 2.2.2 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../_static/language_data.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home"> GalSim
          

          
          </a>

          
            
            
              <div class="version">
                2.2
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../overview.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../install.html">Installation Instructions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tutorials.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../image.html">Images and Related Concepts</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../sb.html">Surface Brightness Profiles</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../chromatic.html">Wavelength-dependent Profiles</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../units.html">Units</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../wcs.html">World Coordinate Systems</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../random.html">Noise and Random Values</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../wl.html">Weak Lensing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../photon.html">Photon Shooting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../utilities.html">Helper Functions and Classes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../errors.html">Errors and Warnings</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../config.html">The Config Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../hsm.html">The HSM Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../des.html">The DES Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../wfirst.html">The WFIRST Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../shared.html">Shared Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../history.html">Revision History</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">GalSim</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
      <li>galsim.image</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for galsim.image</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright (c) 2012-2019 by the GalSim developers team on GitHub</span>
<span class="c1"># https://github.com/GalSim-developers</span>
<span class="c1">#</span>
<span class="c1"># This file is part of GalSim: The modular galaxy image simulation toolkit.</span>
<span class="c1"># https://github.com/GalSim-developers/GalSim</span>
<span class="c1">#</span>
<span class="c1"># GalSim is free software: redistribution and use in source and binary forms,</span>
<span class="c1"># with or without modification, are permitted provided that the following</span>
<span class="c1"># conditions are met:</span>
<span class="c1">#</span>
<span class="c1"># 1. Redistributions of source code must retain the above copyright notice, this</span>
<span class="c1">#    list of conditions, and the disclaimer given in the accompanying LICENSE</span>
<span class="c1">#    file.</span>
<span class="c1"># 2. Redistributions in binary form must reproduce the above copyright notice,</span>
<span class="c1">#    this list of conditions, and the disclaimer given in the documentation</span>
<span class="c1">#    and/or other materials provided with the distribution.</span>
<span class="c1">#</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">division</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">_galsim</span>
<span class="kn">from</span> <span class="nn">.position</span> <span class="k">import</span> <span class="n">PositionI</span><span class="p">,</span> <span class="n">PositionD</span>
<span class="kn">from</span> <span class="nn">.bounds</span> <span class="k">import</span> <span class="n">BoundsI</span><span class="p">,</span> <span class="n">BoundsD</span>
<span class="kn">from</span> <span class="nn">.wcs</span> <span class="k">import</span> <span class="n">BaseWCS</span><span class="p">,</span> <span class="n">PixelScale</span><span class="p">,</span> <span class="n">JacobianWCS</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">utilities</span>
<span class="kn">from</span> <span class="nn">.errors</span> <span class="k">import</span> <span class="n">GalSimError</span><span class="p">,</span> <span class="n">GalSimBoundsError</span><span class="p">,</span> <span class="n">GalSimValueError</span><span class="p">,</span> <span class="n">GalSimImmutableError</span>
<span class="kn">from</span> <span class="nn">.errors</span> <span class="k">import</span> <span class="n">GalSimUndefinedBoundsError</span><span class="p">,</span> <span class="n">GalSimIncompatibleValuesError</span><span class="p">,</span> <span class="n">convert_cpp_errors</span>

<span class="c1"># Sometimes (on 32-bit systems) there are two numpy.int32 types.  This can lead to some confusion</span>
<span class="c1"># when doing arithmetic with images.  So just make sure both of them point to ImageViewI in the</span>
<span class="c1"># _cpp_type dict.  One of them is what you get when you just write numpy.int32.  The other is</span>
<span class="c1"># what numpy decides an int16 + int32 is.</span>
<span class="c1"># For more information regarding this rather unexpected behaviour for numpy.int32 types, see</span>
<span class="c1"># the following (closed, marked &quot;wontfix&quot;) ticket on the numpy issue tracker:</span>
<span class="c1"># http://projects.scipy.org/numpy/ticket/1246</span>

<span class="n">alt_int32</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">))</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span>


<div class="viewcode-block" id="Image"><a class="viewcode-back" href="../../image_class.html#galsim.Image">[docs]</a><span class="k">class</span> <span class="nc">Image</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A class for storing image data along with the pixel scale or WCS information</span>

<span class="sd">    The Image class encapsulates all the relevant information about an image including a NumPy array</span>
<span class="sd">    for the pixel values, a bounding box, and some kind of WCS that converts between pixel</span>
<span class="sd">    coordinates and world coordinates.  The NumPy array may be constructed by the Image class</span>
<span class="sd">    itself, or an existing array can be provided by the user.</span>

<span class="sd">    This class creates shallow copies unless a deep copy is explicitly requested using the `copy`</span>
<span class="sd">    method.  The main reason for this is that it allows users to work directly with and modify</span>
<span class="sd">    subimages of larger images (for example, to successively draw many galaxies into one large</span>
<span class="sd">    image).  For other implications of this convention, see the description of initialization</span>
<span class="sd">    instructions below.</span>

<span class="sd">    In most applications with images, we will use (x,y) to refer to the coordinates.  We adopt</span>
<span class="sd">    the same meaning for these coordinates as most astronomy applications do: ds9, SAOImage,</span>
<span class="sd">    SExtractor, etc. all treat x as the column number and y as the row number.  However, this</span>
<span class="sd">    is different from the default convention used by numpy.  In numpy, the access is by</span>
<span class="sd">    [row_num,col_num], which means this is really [y,x] in terms of the normal x,y values.</span>
<span class="sd">    Users are typically insulated from this concern by the Image API, but if you access the</span>
<span class="sd">    numpy array directly via the ``array`` attribute, you will need to be careful about this</span>
<span class="sd">    difference.</span>

<span class="sd">    There are 6 data types that the Image can use for the data values.  These are ``numpy.uint16``,</span>
<span class="sd">    ``numpy.uint32``, ``numpy.int16``, ``numpy.int32``, ``numpy.float32``, and ``numpy.float64``.</span>
<span class="sd">    If you are constructing a new Image from scratch, the default is ``numpy.float32``, but you</span>
<span class="sd">    can specify one of the other data types.</span>

<span class="sd">    There are several ways to construct an Image:</span>
<span class="sd">    (Optional arguments are shown with their default values after the = sign.)</span>

<span class="sd">        ``Image(ncol, nrow, dtype=numpy.float32, init_value=0, xmin=1, ymin=1, ...)``</span>

<span class="sd">                This constructs a new image, allocating memory for the pixel values according to</span>
<span class="sd">                the number of columns and rows.  You can specify the data type as ``dtype`` if you</span>
<span class="sd">                want.  The default is ``numpy.float32`` if you don&#39;t specify it.  You can also</span>
<span class="sd">                optionally provide an initial value for the pixels, which defaults to 0.</span>
<span class="sd">                The optional ``xmin,ymin`` allow you to specify the location of the lower-left</span>
<span class="sd">                pixel, which defaults to (1,1).  Reminder, with our convention for x,y coordinates</span>
<span class="sd">                described above, ncol is the number of pixels in the x direction, and nrow is the</span>
<span class="sd">                number of pixels in the y direction.</span>

<span class="sd">        ``Image(bounds, dtype=numpy.float32, init_value=0, ...)``</span>

<span class="sd">                This constructs a new image, allocating memory for the pixel values according to a</span>
<span class="sd">                given `Bounds` object.  Particularly, the bounds should be a `BoundsI` instance.</span>
<span class="sd">                You can specify the data type as ``dtype`` if you want.  The default is</span>
<span class="sd">                ``numpy.float32`` if you don&#39;t specify it.  You can also optionally provide an</span>
<span class="sd">                initial value for the pixels, which defaults to 0.</span>

<span class="sd">        ``Image(array, xmin=1, ymin=1, make_const=False, copy=False ...)``</span>

<span class="sd">                This views an existing NumPy array as an Image, where updates to either the image</span>
<span class="sd">                or the original array will affect the other one.  The data type is taken from</span>
<span class="sd">                ``array.dtype``, which must be one of the allowed types listed above.  You can also</span>
<span class="sd">                optionally set the origin ``xmin, ymin`` if you want it to be something other than</span>
<span class="sd">                (1,1).</span>

<span class="sd">                You can also optionally force the Image to be read-only with ``make_const=True``,</span>
<span class="sd">                though if the original NumPy array is modified then the contents of ``Image.array``</span>
<span class="sd">                will change.</span>

<span class="sd">                If you want to make a copy of the input array, rather than just view the existing</span>
<span class="sd">                array, you can force a copy with::</span>

<span class="sd">                    &gt;&gt;&gt; image = galsim.Image(array, copy=True)</span>

<span class="sd">        ``Image(image, dtype=image.dtype, copy=True)``</span>

<span class="sd">                This creates a copy of an Image, possibly changing the type.  e.g.::</span>

<span class="sd">                    &gt;&gt;&gt; image_float = galsim.Image(64, 64) # default dtype=numpy.float32</span>
<span class="sd">                    &gt;&gt;&gt; image_double = galsim.Image(image_float, dtype=numpy.float64)</span>

<span class="sd">                You can see a list of valid values for dtype in ``galsim.Image.valid_dtypes``.</span>
<span class="sd">                Without the ``dtype`` argument, this is equivalent to ``image.copy()``, which makes</span>
<span class="sd">                a deep copy.  If you want a copy that shares data with the original, see</span>
<span class="sd">                the `view` method.</span>

<span class="sd">                If you only want to enforce the image to have a given type and not make a copy</span>
<span class="sd">                if the array is already the correct type, you can use, e.g.::</span>

<span class="sd">                    &gt;&gt;&gt; image_double = galsim.Image(image, dtype=numpy.float64, copy=False)</span>

<span class="sd">    You can specify the ``ncol``, ``nrow``, ``bounds``, ``array``, or ``image``  parameters by</span>
<span class="sd">    keyword argument if you want, or you can pass them as simple arg as shown aboves, and the</span>
<span class="sd">    constructor will figure out what they are.</span>

<span class="sd">    The other keyword arguments (shown as ... above) relate to the conversion between sky</span>
<span class="sd">    coordinates, which is how all the GalSim objects are defined, and the pixel coordinates.</span>
<span class="sd">    There are three options for this:</span>

<span class="sd">        scale</span>
<span class="sd">                    You can optionally specify a pixel scale to use.  This would normally have</span>
<span class="sd">                    units arcsec/pixel, but it doesn&#39;t have to be arcsec.  If you want to</span>
<span class="sd">                    use different units for the physical scale of your galsim objects, then</span>
<span class="sd">                    the same unit would be used here.</span>
<span class="sd">        wcs</span>
<span class="sd">                    A WCS object that provides a non-trivial mapping between sky units and</span>
<span class="sd">                    pixel units.  The ``scale`` parameter is equivalent to</span>
<span class="sd">                    ``wcs=PixelScale(scale)``.  But there are a number of more complicated options.</span>
<span class="sd">                    See the WCS class for more details.</span>
<span class="sd">        None</span>
<span class="sd">                    If you do not provide either of the above, then the conversion is undefined.</span>
<span class="sd">                    When drawing onto such an image, a suitable pixel scale will be automatically</span>
<span class="sd">                    set according to the Nyquist scale of the object being drawn.</span>

<span class="sd">    After construction, you can set or change the scale or wcs with::</span>

<span class="sd">        &gt;&gt;&gt; image.scale = new_scale</span>
<span class="sd">        &gt;&gt;&gt; image.wcs = new_wcs</span>

<span class="sd">    Note that ``image.scale`` will only work if the WCS is a `PixelScale`.  Once you set the</span>
<span class="sd">    wcs to be something non-trivial, then you must interact with it via the ``wcs`` attribute.</span>
<span class="sd">    The ``image.scale`` syntax will raise an exception.</span>

<span class="sd">    There are also two read-only attributes::</span>

<span class="sd">        &gt;&gt;&gt; image.bounds</span>
<span class="sd">        &gt;&gt;&gt; image.array</span>

<span class="sd">    The ``array`` attribute is a NumPy array of the Image&#39;s pixels.  The individual elements in the</span>
<span class="sd">    array attribute are accessed as ``image.array[y,x]``, matching the standard NumPy convention,</span>
<span class="sd">    while the Image class&#39;s own accessor uses either ``(x,y)`` or ``[x,y]``.</span>

<span class="sd">    That is, the following are equivalent::</span>

<span class="sd">        &gt;&gt;&gt; ixy = image(x,y)</span>
<span class="sd">        &gt;&gt;&gt; ixy = image[x,y]</span>
<span class="sd">        &gt;&gt;&gt; ixy = image.array[y,x]</span>
<span class="sd">        &gt;&gt;&gt; ixy = image.getValue(x,y)</span>

<span class="sd">    Similarly, for setting individual pixel values, the following are equivalent::</span>

<span class="sd">        &gt;&gt;&gt; image[x,y] = new_ixy</span>
<span class="sd">        &gt;&gt;&gt; image.array[y,x] = new_ixy</span>
<span class="sd">        &gt;&gt;&gt; image.setValue(x,y,new_ixy)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_cpp_type</span> <span class="o">=</span> <span class="p">{</span> <span class="n">np</span><span class="o">.</span><span class="n">uint16</span> <span class="p">:</span> <span class="n">_galsim</span><span class="o">.</span><span class="n">ImageViewUS</span><span class="p">,</span>
                  <span class="n">np</span><span class="o">.</span><span class="n">uint32</span> <span class="p">:</span> <span class="n">_galsim</span><span class="o">.</span><span class="n">ImageViewUI</span><span class="p">,</span>
                  <span class="n">np</span><span class="o">.</span><span class="n">int16</span> <span class="p">:</span> <span class="n">_galsim</span><span class="o">.</span><span class="n">ImageViewS</span><span class="p">,</span>
                  <span class="n">np</span><span class="o">.</span><span class="n">int32</span> <span class="p">:</span> <span class="n">_galsim</span><span class="o">.</span><span class="n">ImageViewI</span><span class="p">,</span>
                  <span class="n">np</span><span class="o">.</span><span class="n">float32</span> <span class="p">:</span> <span class="n">_galsim</span><span class="o">.</span><span class="n">ImageViewF</span><span class="p">,</span>
                  <span class="n">np</span><span class="o">.</span><span class="n">float64</span> <span class="p">:</span> <span class="n">_galsim</span><span class="o">.</span><span class="n">ImageViewD</span><span class="p">,</span>
                  <span class="n">np</span><span class="o">.</span><span class="n">complex64</span> <span class="p">:</span> <span class="n">_galsim</span><span class="o">.</span><span class="n">ImageViewCF</span><span class="p">,</span>
                  <span class="n">np</span><span class="o">.</span><span class="n">complex128</span> <span class="p">:</span> <span class="n">_galsim</span><span class="o">.</span><span class="n">ImageViewCD</span><span class="p">,</span>
                <span class="p">}</span>
    <span class="n">_cpp_valid_dtypes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">_cpp_type</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

    <span class="n">_alias_dtypes</span> <span class="o">=</span> <span class="p">{</span>
        <span class="nb">int</span> <span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span>          <span class="c1"># So that user gets what they would expect</span>
        <span class="nb">float</span> <span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span>      <span class="c1"># if using dtype=int or float or complex</span>
        <span class="nb">complex</span> <span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">,</span>
        <span class="n">np</span><span class="o">.</span><span class="n">int64</span> <span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span>          <span class="c1"># Not equivalent, but will convert</span>
    <span class="p">}</span>
    <span class="c1"># Note: Numpy uses int64 for int on 64 bit machines.  We don&#39;t implement int64 at all,</span>
    <span class="c1"># so we cannot quite match up to the numpy convention for dtype=int.  e.g. via</span>
    <span class="c1">#     int : numpy.zeros(1,dtype=int).dtype.type</span>
    <span class="c1"># If this becomes too confusing, we might need to add an ImageL class that uses int64.</span>
    <span class="c1"># Hard to imagine a use case where this would be required though...</span>

    <span class="c1"># This one is in the public API.  (No leading underscore.)</span>
    <span class="n">valid_dtypes</span> <span class="o">=</span> <span class="n">_cpp_valid_dtypes</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">_alias_dtypes</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># Parse the args, kwargs</span>
        <span class="n">ncol</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">nrow</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">bounds</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">array</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">image</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Error, too many unnamed arguments to Image constructor&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">ncol</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">nrow</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">xmin</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;xmin&#39;</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">ymin</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;ymin&#39;</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                <span class="n">array</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">array</span><span class="p">,</span> <span class="n">xmin</span><span class="p">,</span> <span class="n">ymin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_xmin_ymin</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>
                <span class="n">make_const</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;make_const&#39;</span><span class="p">,</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">BoundsI</span><span class="p">):</span>
                <span class="n">bounds</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
                <span class="n">array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">array</span><span class="p">,</span> <span class="n">xmin</span><span class="p">,</span> <span class="n">ymin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_xmin_ymin</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>
                <span class="n">make_const</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;make_const&#39;</span><span class="p">,</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Image</span><span class="p">):</span>
                <span class="n">image</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Unable to parse </span><span class="si">%s</span><span class="s2"> as an array, bounds, or image.&quot;</span><span class="o">%</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="s1">&#39;array&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="n">array</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;array&#39;</span><span class="p">)</span>
                <span class="n">array</span><span class="p">,</span> <span class="n">xmin</span><span class="p">,</span> <span class="n">ymin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_xmin_ymin</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>
                <span class="n">make_const</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;make_const&#39;</span><span class="p">,</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">elif</span> <span class="s1">&#39;bounds&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="n">bounds</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;bounds&#39;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="s1">&#39;image&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="n">image</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;image&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ncol</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;ncol&#39;</span><span class="p">,</span><span class="kc">None</span><span class="p">)</span>
                <span class="n">nrow</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;nrow&#39;</span><span class="p">,</span><span class="kc">None</span><span class="p">)</span>
                <span class="n">xmin</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;xmin&#39;</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">ymin</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;ymin&#39;</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Pop off the other valid kwargs:</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;dtype&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">init_value</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;init_value&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">scale</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;scale&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">wcs</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;wcs&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">copy</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;copy&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="c1"># Check that we got them all</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Image constructor got unexpected keyword arguments: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Figure out what dtype we want:</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="n">Image</span><span class="o">.</span><span class="n">_alias_dtypes</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">dtype</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">Image</span><span class="o">.</span><span class="n">valid_dtypes</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">GalSimValueError</span><span class="p">(</span><span class="s2">&quot;Invlid dtype.&quot;</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">Image</span><span class="o">.</span><span class="n">valid_dtypes</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">array</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">copy</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">copy</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">dtype</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span>
                <span class="k">if</span> <span class="n">dtype</span> <span class="ow">in</span> <span class="n">Image</span><span class="o">.</span><span class="n">_alias_dtypes</span><span class="p">:</span>
                    <span class="n">dtype</span> <span class="o">=</span> <span class="n">Image</span><span class="o">.</span><span class="n">_alias_dtypes</span><span class="p">[</span><span class="n">dtype</span><span class="p">]</span>
                    <span class="n">array</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">dtype</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">Image</span><span class="o">.</span><span class="n">_cpp_valid_dtypes</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">GalSimValueError</span><span class="p">(</span><span class="s2">&quot;Invalid dtype of provided array.&quot;</span><span class="p">,</span> <span class="n">array</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
                                           <span class="n">Image</span><span class="o">.</span><span class="n">_cpp_valid_dtypes</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">copy</span><span class="p">:</span>
                    <span class="n">array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">array</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">)</span>
            <span class="c1"># Be careful here: we have to watch out for little-endian / big-endian issues.</span>
            <span class="c1"># The path of least resistance is to check whether the array.dtype is equal to the</span>
            <span class="c1"># native one (using the dtype.isnative flag), and if not, make a new array that has a</span>
            <span class="c1"># type equal to the same one but with the appropriate endian-ness.</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">array</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">isnative</span><span class="p">:</span>
                <span class="n">array</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">array</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">newbyteorder</span><span class="p">(</span><span class="s1">&#39;=&#39;</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_dtype</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span>
        <span class="k">elif</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_dtype</span> <span class="o">=</span> <span class="n">dtype</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span>

        <span class="c1"># Construct the image attribute</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ncol</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">nrow</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">ncol</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">nrow</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">GalSimIncompatibleValuesError</span><span class="p">(</span>
                    <span class="s2">&quot;Both nrow and ncol must be provided&quot;</span><span class="p">,</span> <span class="n">ncol</span><span class="o">=</span><span class="n">ncol</span><span class="p">,</span> <span class="n">nrow</span><span class="o">=</span><span class="n">nrow</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ncol</span> <span class="o">!=</span> <span class="nb">int</span><span class="p">(</span><span class="n">ncol</span><span class="p">)</span> <span class="ow">or</span> <span class="n">nrow</span> <span class="o">!=</span> <span class="nb">int</span><span class="p">(</span><span class="n">nrow</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;nrow, ncol must be integers&quot;</span><span class="p">)</span>
            <span class="n">ncol</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">ncol</span><span class="p">)</span>
            <span class="n">nrow</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">nrow</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_array</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_make_empty</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">nrow</span><span class="p">,</span><span class="n">ncol</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_dtype</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_bounds</span> <span class="o">=</span> <span class="n">BoundsI</span><span class="p">(</span><span class="n">xmin</span><span class="p">,</span> <span class="n">xmin</span><span class="o">+</span><span class="n">ncol</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">ymin</span><span class="p">,</span> <span class="n">ymin</span><span class="o">+</span><span class="n">nrow</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">init_value</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">init_value</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">bounds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bounds</span><span class="p">,</span> <span class="n">BoundsI</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;bounds must be a galsim.BoundsI instance&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_array</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_make_empty</span><span class="p">(</span><span class="n">bounds</span><span class="o">.</span><span class="n">numpyShape</span><span class="p">(),</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_dtype</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_bounds</span> <span class="o">=</span> <span class="n">bounds</span>
            <span class="k">if</span> <span class="n">init_value</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">init_value</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">array</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_array</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">view</span><span class="p">()</span>
            <span class="n">nrow</span><span class="p">,</span><span class="n">ncol</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">shape</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_bounds</span> <span class="o">=</span> <span class="n">BoundsI</span><span class="p">(</span><span class="n">xmin</span><span class="p">,</span> <span class="n">xmin</span><span class="o">+</span><span class="n">ncol</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">ymin</span><span class="p">,</span> <span class="n">ymin</span><span class="o">+</span><span class="n">nrow</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">make_const</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">array</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">writeable</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_array</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">writeable</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="n">init_value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">GalSimIncompatibleValuesError</span><span class="p">(</span>
                    <span class="s2">&quot;Cannot specify init_value with array&quot;</span><span class="p">,</span> <span class="n">init_value</span><span class="o">=</span><span class="n">init_value</span><span class="p">,</span> <span class="n">array</span><span class="o">=</span><span class="n">array</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">image</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">Image</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;image must be an Image&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">init_value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">GalSimIncompatibleValuesError</span><span class="p">(</span>
                    <span class="s2">&quot;Cannot specify init_value with image&quot;</span><span class="p">,</span> <span class="n">init_value</span><span class="o">=</span><span class="n">init_value</span><span class="p">,</span> <span class="n">image</span><span class="o">=</span><span class="n">image</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">wcs</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">scale</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">wcs</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">wcs</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_bounds</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">bounds</span>
            <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_dtype</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">dtype</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Allow dtype to force a retyping of the provided image</span>
                <span class="c1"># e.g. im = ImageF(...)</span>
                <span class="c1">#      im2 = ImageD(im)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_dtype</span> <span class="o">=</span> <span class="n">dtype</span>
            <span class="k">if</span> <span class="n">copy</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_array</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_array</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_make_empty</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">image</span><span class="o">.</span><span class="n">bounds</span><span class="o">.</span><span class="n">numpyShape</span><span class="p">(),</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_dtype</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_array</span><span class="p">[:,:]</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">array</span><span class="p">[:,:]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_dtype</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_bounds</span> <span class="o">=</span> <span class="n">BoundsI</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">init_value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">GalSimIncompatibleValuesError</span><span class="p">(</span>
                    <span class="s2">&quot;Cannot specify init_value without setting an initial size&quot;</span><span class="p">,</span>
                    <span class="n">init_value</span><span class="o">=</span><span class="n">init_value</span><span class="p">,</span> <span class="n">ncol</span><span class="o">=</span><span class="n">ncol</span><span class="p">,</span> <span class="n">nrow</span><span class="o">=</span><span class="n">nrow</span><span class="p">,</span> <span class="n">bounds</span><span class="o">=</span><span class="n">bounds</span><span class="p">)</span>

        <span class="c1"># Construct the wcs attribute</span>
        <span class="k">if</span> <span class="n">scale</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">wcs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">GalSimIncompatibleValuesError</span><span class="p">(</span>
                    <span class="s2">&quot;Cannot provide both scale and wcs to Image constructor&quot;</span><span class="p">,</span> <span class="n">wcs</span><span class="o">=</span><span class="n">wcs</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">wcs</span> <span class="o">=</span> <span class="n">PixelScale</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">scale</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">wcs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">wcs</span><span class="p">,</span><span class="n">BaseWCS</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;wcs parameters must be a galsim.BaseWCS instance&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">wcs</span> <span class="o">=</span> <span class="n">wcs</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_get_xmin_ymin</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;A helper function for parsing xmin, ymin, bounds options with a given array</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;array must be a numpy.ndarray instance&quot;</span><span class="p">)</span>
        <span class="n">xmin</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;xmin&#39;</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">ymin</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;ymin&#39;</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="s1">&#39;bounds&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">b</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;bounds&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">BoundsI</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;bounds must be a galsim.BoundsI instance&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">b</span><span class="o">.</span><span class="n">xmax</span><span class="o">-</span><span class="n">b</span><span class="o">.</span><span class="n">xmin</span><span class="o">+</span><span class="mi">1</span> <span class="o">!=</span> <span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="n">GalSimIncompatibleValuesError</span><span class="p">(</span>
                    <span class="s2">&quot;Shape of array is inconsistent with provided bounds&quot;</span><span class="p">,</span> <span class="n">array</span><span class="o">=</span><span class="n">array</span><span class="p">,</span> <span class="n">bounds</span><span class="o">=</span><span class="n">b</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">b</span><span class="o">.</span><span class="n">ymax</span><span class="o">-</span><span class="n">b</span><span class="o">.</span><span class="n">ymin</span><span class="o">+</span><span class="mi">1</span> <span class="o">!=</span> <span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="n">GalSimIncompatibleValuesError</span><span class="p">(</span>
                    <span class="s2">&quot;Shape of array is inconsistent with provided bounds&quot;</span><span class="p">,</span> <span class="n">array</span><span class="o">=</span><span class="n">array</span><span class="p">,</span> <span class="n">bounds</span><span class="o">=</span><span class="n">b</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">b</span><span class="o">.</span><span class="n">isDefined</span><span class="p">():</span>
                <span class="n">xmin</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">xmin</span>
                <span class="n">ymin</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">ymin</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Indication that array is formally undefined, even though provided.</span>
                <span class="k">if</span> <span class="s1">&#39;dtype&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;dtype&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span>
                <span class="n">array</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="n">xmin</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="n">ymin</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">elif</span> <span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Another way to indicate that we don&#39;t have a defined image.</span>
            <span class="k">if</span> <span class="s1">&#39;dtype&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;dtype&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span>
            <span class="n">array</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">xmin</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">ymin</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">array</span><span class="p">,</span> <span class="n">xmin</span><span class="p">,</span> <span class="n">ymin</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">s</span> <span class="o">=</span> <span class="s1">&#39;galsim.Image(bounds=</span><span class="si">%r</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="o">.</span><span class="n">isDefined</span><span class="p">():</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="s1">&#39;, array=</span><span class="se">\n</span><span class="si">%r</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">array</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="s1">&#39;, wcs=</span><span class="si">%r</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">wcs</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">isconst</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="s1">&#39;, make_const=True&#39;</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="s1">&#39;)&#39;</span>
        <span class="k">return</span> <span class="n">s</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Get the type name without the &lt;type &#39;...&#39;&gt; part.</span>
        <span class="n">t</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;&#39;&quot;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">wcs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">wcs</span><span class="o">.</span><span class="n">isPixelScale</span><span class="p">():</span>
            <span class="k">return</span> <span class="s1">&#39;galsim.Image(bounds=</span><span class="si">%s</span><span class="s1">, scale=</span><span class="si">%s</span><span class="s1">, dtype=</span><span class="si">%s</span><span class="s1">)&#39;</span><span class="o">%</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;galsim.Image(bounds=</span><span class="si">%s</span><span class="s1">, wcs=</span><span class="si">%s</span><span class="s1">, dtype=</span><span class="si">%s</span><span class="s1">)&#39;</span><span class="o">%</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">wcs</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>

    <span class="c1"># Pickling almost works out of the box, but numpy arrays lose their non-writeable flag</span>
    <span class="c1"># when pickled, so make sure to set it to preserve const Images.</span>
    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">isconst</span>

    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
        <span class="n">d</span><span class="p">,</span> <span class="n">isconst</span> <span class="o">=</span> <span class="n">args</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span> <span class="o">=</span> <span class="n">d</span>
        <span class="k">if</span> <span class="n">isconst</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_array</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">writeable</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="c1"># Read-only attributes:</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dtype</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The dtype of the underlying numpy array.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dtype</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The bounds of the `Image`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bounds</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">array</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The underlying numpy array.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_array</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">isconst</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Whether the `Image` is constant.  I.e. modifying its values is an error.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_array</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">writeable</span> <span class="o">==</span> <span class="kc">False</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">iscomplex</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Whether the `Image` values are complex.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_array</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;c&#39;</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">isinteger</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Whether the `Image` values are integral.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_array</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;i&#39;</span><span class="p">,</span><span class="s1">&#39;u&#39;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">iscontiguous</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Indicates whether each row of the image is contiguous in memory.</span>

<span class="sd">        Note: it is ok for the end of one row to not be contiguous with the start of the</span>
<span class="sd">        next row.  This just checks that each individual row has a stride of 1.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_array</span><span class="o">.</span><span class="n">strides</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">//</span><span class="bp">self</span><span class="o">.</span><span class="n">_array</span><span class="o">.</span><span class="n">itemsize</span> <span class="o">==</span> <span class="mi">1</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_image</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">cls</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cpp_type</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_array</span><span class="o">.</span><span class="n">ctypes</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
                   <span class="bp">self</span><span class="o">.</span><span class="n">_array</span><span class="o">.</span><span class="n">strides</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">//</span><span class="bp">self</span><span class="o">.</span><span class="n">_array</span><span class="o">.</span><span class="n">itemsize</span><span class="p">,</span>
                   <span class="bp">self</span><span class="o">.</span><span class="n">_array</span><span class="o">.</span><span class="n">strides</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">//</span><span class="bp">self</span><span class="o">.</span><span class="n">_array</span><span class="o">.</span><span class="n">itemsize</span><span class="p">,</span>
                   <span class="bp">self</span><span class="o">.</span><span class="n">_bounds</span><span class="o">.</span><span class="n">_b</span><span class="p">)</span>

    <span class="c1"># Allow scale to work as a PixelScale wcs.</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">scale</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The pixel scale of the `Image`.  Only valid if the wcs is a `PixelScale`.</span>

<span class="sd">        If the WCS is either not set (i.e. it is ``None``) or it is a `PixelScale`, then</span>
<span class="sd">        it is permissible to change the scale with::</span>

<span class="sd">            &gt;&gt;&gt; image.scale = new_pixel_scale</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">wcs</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">wcs</span><span class="o">.</span><span class="n">isPixelScale</span><span class="p">():</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">wcs</span><span class="o">.</span><span class="n">scale</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">GalSimError</span><span class="p">(</span><span class="s2">&quot;image.wcs is not a simple PixelScale; scale is undefined.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

    <span class="nd">@scale</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">scale</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">wcs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">wcs</span><span class="o">.</span><span class="n">isPixelScale</span><span class="p">():</span>
            <span class="k">raise</span> <span class="n">GalSimError</span><span class="p">(</span><span class="s2">&quot;image.wcs is not a simple PixelScale; scale is undefined.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">wcs</span> <span class="o">=</span> <span class="n">PixelScale</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

    <span class="c1"># Convenience functions</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">xmin</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Alias for self.bounds.xmin.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bounds</span><span class="o">.</span><span class="n">xmin</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">xmax</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Alias for self.bounds.xmax.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bounds</span><span class="o">.</span><span class="n">xmax</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ymin</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Alias for self.bounds.ymin.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bounds</span><span class="o">.</span><span class="n">ymin</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ymax</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Alias for self.bounds.ymax.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bounds</span><span class="o">.</span><span class="n">ymax</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">outer_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The bounds of the outer edge of the pixels.</span>

<span class="sd">        Equivalent to galsim.BoundsD(im.xmin-0.5, im.xmax+0.5, im.ymin-0.5, im.ymax+0.5)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">BoundsD</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xmin</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">xmax</span><span class="o">+</span><span class="mf">0.5</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ymin</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ymax</span><span class="o">+</span><span class="mf">0.5</span><span class="p">)</span>

    <span class="c1"># real, imag for everything, even real images.</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">real</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the real part of an image.</span>

<span class="sd">        This is a property, not a function.  So write ``im.real``, not ``im.real()``.</span>

<span class="sd">        This works for real or complex.  For real images, it acts the same as `view`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_Image</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">real</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">wcs</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">imag</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the imaginary part of an image.</span>

<span class="sd">        This is a property, not a function.  So write ``im.imag``, not ``im.imag()``.</span>

<span class="sd">        This works for real or complex.  For real images, the returned array is read-only and</span>
<span class="sd">        all elements are 0.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_Image</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">imag</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">wcs</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">conjugate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the complex conjugate of an image.</span>

<span class="sd">        This works for real or complex.  For real images, it acts the same as `view`.</span>

<span class="sd">        Note that for complex images, this is not a conjugate view into the original image.</span>
<span class="sd">        So changing the original image does not change the conjugate (or vice versa).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_Image</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">conjugate</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">wcs</span><span class="p">)</span>

<div class="viewcode-block" id="Image.copy"><a class="viewcode-back" href="../../image_class.html#galsim.Image.copy">[docs]</a>    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Make a copy of the `Image`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_Image</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">wcs</span><span class="p">)</span></div>

<div class="viewcode-block" id="Image.get_pixel_centers"><a class="viewcode-back" href="../../image_class.html#galsim.Image.get_pixel_centers">[docs]</a>    <span class="k">def</span> <span class="nf">get_pixel_centers</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;A convenience function to get the x and y values at the centers of the image pixels.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (x, y), each of which is a numpy array the same shape as ``self.array``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x</span><span class="p">,</span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">),</span>
                          <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">))</span>
        <span class="n">x</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="o">.</span><span class="n">xmin</span>
        <span class="n">y</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="o">.</span><span class="n">ymin</span>
        <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span></div>

    <span class="k">def</span> <span class="nf">_make_empty</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Helper function to make an empty numpy array of the given shape, making sure that</span>
<span class="sd">        the array is 16-btye aligned so it is usable by FFTW.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># cf. http://stackoverflow.com/questions/9895787/memory-alignment-for-fast-fft-in-python-using-shared-arrrays</span>
        <span class="n">nbytes</span> <span class="o">=</span> <span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">itemsize</span>
        <span class="k">if</span> <span class="n">nbytes</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Make degenerate images have 1 element.  Otherwise things get weird.</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_dtype</span><span class="p">)</span>
        <span class="n">buf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nbytes</span> <span class="o">+</span> <span class="mi">16</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
        <span class="n">start_index</span> <span class="o">=</span> <span class="o">-</span><span class="n">buf</span><span class="o">.</span><span class="n">ctypes</span><span class="o">.</span><span class="n">data</span> <span class="o">%</span> <span class="mi">16</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">buf</span><span class="p">[</span><span class="n">start_index</span><span class="p">:</span><span class="n">start_index</span> <span class="o">+</span> <span class="n">nbytes</span><span class="p">]</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
        <span class="c1">#assert a.ctypes.data % 16 == 0</span>
        <span class="k">return</span> <span class="n">a</span>

<div class="viewcode-block" id="Image.resize"><a class="viewcode-back" href="../../image_class.html#galsim.Image.resize">[docs]</a>    <span class="k">def</span> <span class="nf">resize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bounds</span><span class="p">,</span> <span class="n">wcs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Resize the image to have a new bounds (must be a `BoundsI` instance)</span>

<span class="sd">        Note that the resized image will have uninitialized data.  If you want to preserve</span>
<span class="sd">        the existing data values, you should either use `subImage` (if you want a smaller</span>
<span class="sd">        portion of the current `Image`) or make a new `Image` and copy over the current values</span>
<span class="sd">        into a portion of the new image (if you are resizing to a larger `Image`).</span>

<span class="sd">        Parameters:</span>
<span class="sd">            bounds:     The new bounds to resize to.</span>
<span class="sd">            wcs:        If provided, also update the wcs to the given value. [default: None,</span>
<span class="sd">                        which means keep the existing wcs]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">isconst</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">GalSimImmutableError</span><span class="p">(</span><span class="s2">&quot;Cannot modify an immutable Image&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bounds</span><span class="p">,</span> <span class="n">BoundsI</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;bounds must be a galsim.BoundsI instance&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_array</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_make_empty</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">bounds</span><span class="o">.</span><span class="n">numpyShape</span><span class="p">(),</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_bounds</span> <span class="o">=</span> <span class="n">bounds</span>
        <span class="k">if</span> <span class="n">wcs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">wcs</span> <span class="o">=</span> <span class="n">wcs</span></div>

<div class="viewcode-block" id="Image.subImage"><a class="viewcode-back" href="../../image_class.html#galsim.Image.subImage">[docs]</a>    <span class="k">def</span> <span class="nf">subImage</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bounds</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a view of a portion of the full image</span>

<span class="sd">        This is equivalent to self[bounds]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bounds</span><span class="p">,</span> <span class="n">BoundsI</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;bounds must be a galsim.BoundsI instance&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="o">.</span><span class="n">isDefined</span><span class="p">():</span>
            <span class="k">raise</span> <span class="n">GalSimUndefinedBoundsError</span><span class="p">(</span><span class="s2">&quot;Attempt to access subImage of undefined image&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="o">.</span><span class="n">includes</span><span class="p">(</span><span class="n">bounds</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">GalSimBoundsError</span><span class="p">(</span><span class="s2">&quot;Attempt to access subImage not (fully) in image&quot;</span><span class="p">,</span>
                                    <span class="n">bounds</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="p">)</span>
        <span class="n">i1</span> <span class="o">=</span> <span class="n">bounds</span><span class="o">.</span><span class="n">ymin</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">ymin</span>
        <span class="n">i2</span> <span class="o">=</span> <span class="n">bounds</span><span class="o">.</span><span class="n">ymax</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">ymin</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">j1</span> <span class="o">=</span> <span class="n">bounds</span><span class="o">.</span><span class="n">xmin</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">xmin</span>
        <span class="n">j2</span> <span class="o">=</span> <span class="n">bounds</span><span class="o">.</span><span class="n">xmax</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">xmin</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">subarray</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">array</span><span class="p">[</span><span class="n">i1</span><span class="p">:</span><span class="n">i2</span><span class="p">,</span> <span class="n">j1</span><span class="p">:</span><span class="n">j2</span><span class="p">]</span>
        <span class="c1"># NB. The wcs is still accurate, since the sub-image uses the same (x,y) values</span>
        <span class="c1"># as the original image did for those pixels.  It&#39;s only once you recenter or</span>
        <span class="c1"># reorigin that you need to update the wcs.  So that&#39;s taken care of in im.shift.</span>
        <span class="k">return</span> <span class="n">_Image</span><span class="p">(</span><span class="n">subarray</span><span class="p">,</span> <span class="n">bounds</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">wcs</span><span class="p">)</span></div>

<div class="viewcode-block" id="Image.setSubImage"><a class="viewcode-back" href="../../image_class.html#galsim.Image.setSubImage">[docs]</a>    <span class="k">def</span> <span class="nf">setSubImage</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bounds</span><span class="p">,</span> <span class="n">rhs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set a portion of the full image to the values in another image</span>

<span class="sd">        This is equivalent to self[bounds] = rhs</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">isconst</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">GalSimImmutableError</span><span class="p">(</span><span class="s2">&quot;Cannot modify the values of an immutable Image&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">subImage</span><span class="p">(</span><span class="n">bounds</span><span class="p">)</span><span class="o">.</span><span class="n">copyFrom</span><span class="p">(</span><span class="n">rhs</span><span class="p">)</span></div>

<div class="viewcode-block" id="Image.__getitem__"><a class="viewcode-back" href="../../image_class.html#galsim.Image.__getitem__">[docs]</a>    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return either a subimage or a single pixel value.</span>

<span class="sd">        For example,::</span>

<span class="sd">            &gt;&gt;&gt; subimage = im[galsim.BoundsI(3,7,3,7)]</span>
<span class="sd">            &gt;&gt;&gt; value = im[galsim.PositionI(5,5)]</span>
<span class="sd">            &gt;&gt;&gt; value = im[5,5]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">BoundsI</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">subImage</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">PositionI</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">self</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">tuple</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">getValue</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;image[index] only accepts BoundsI or PositionI for the index&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;image[..] requires either 1 or 2 args&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Image.__setitem__"><a class="viewcode-back" href="../../image_class.html#galsim.Image.__setitem__">[docs]</a>    <span class="k">def</span> <span class="nf">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set either a subimage or a single pixel to new values.</span>

<span class="sd">        For example,::</span>

<span class="sd">            &gt;&gt;&gt; im[galsim.BoundsI(3,7,3,7)] = im2</span>
<span class="sd">            &gt;&gt;&gt; im[galsim.PositionI(5,5)] = 17.</span>
<span class="sd">            &gt;&gt;&gt; im[5,5] = 17.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">BoundsI</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">setSubImage</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">PositionI</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">setValue</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">tuple</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">setValue</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;image[index] only accepts BoundsI or PositionI for the index&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">setValue</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;image[..] requires either 1 or 2 args&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Image.wrap"><a class="viewcode-back" href="../../image_class.html#galsim.Image.wrap">[docs]</a>    <span class="k">def</span> <span class="nf">wrap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bounds</span><span class="p">,</span> <span class="n">hermitian</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Wrap the values in a image onto a given subimage and return the subimage.</span>

<span class="sd">        This would typically be used on a k-space image where you initially draw a larger image</span>
<span class="sd">        than you want for the FFT and then wrap it onto a smaller subset.  This will cause</span>
<span class="sd">        aliasing of course, but this is often preferable to just using the smaller image</span>
<span class="sd">        without wrapping.</span>

<span class="sd">        For complex images of FFTs, one often only stores half the image plane with the</span>
<span class="sd">        implicit understanding that the function is Hermitian, so im(-x,-y) == im(x,y).conjugate().</span>
<span class="sd">        In this case, the wrapping needs to work slightly differently, so you can specify</span>
<span class="sd">        that your image is implicitly Hermitian with the ``hermitian`` argument.  Options are:</span>

<span class="sd">        hermitian=False</span>
<span class="sd">                        (default) Normal non-Hermitian image.</span>

<span class="sd">        hermitian=&#39;x&#39;</span>
<span class="sd">                        Only x&gt;=0 values are stored with x&lt;0 values being implicitly Hermitian.</span>
<span class="sd">                        In this case im.bounds.xmin and bounds.xmin must be 0.</span>

<span class="sd">        hermitian=&#39;y&#39;</span>
<span class="sd">                        Only y&gt;=0 values are stored with y&lt;0 values being implicitly Hermitian.</span>
<span class="sd">                        In this case im.bounds.ymin and bounds.ymin must be 0.</span>

<span class="sd">        Also, in the two Hermitian cases, the direction that is not implicitly Hermitian must be</span>
<span class="sd">        symmetric in the image&#39;s bounds.  The wrap bounds must be almost symmetric, but missing</span>
<span class="sd">        the most negative value.  For example,::</span>

<span class="sd">            &gt;&gt;&gt; N = 100</span>
<span class="sd">            &gt;&gt;&gt; im_full = galsim.ImageCD(bounds=galsim.BoundsI(0,N/2,-N/2,N/2), scale=dk)</span>
<span class="sd">            &gt;&gt;&gt; # ... fill with im[i,j] = FT(kx=i*dk, ky=j*dk)</span>
<span class="sd">            &gt;&gt;&gt; N2 = 64</span>
<span class="sd">            &gt;&gt;&gt; im_wrap = im_full.wrap(galsim.BoundsI(0,N/2,-N2/2,N2/2-1, hermitian=&#39;x&#39;)</span>

<span class="sd">        This sets up im_wrap to be the properly Hermitian version of the data appropriate for</span>
<span class="sd">        passing to an FFT.</span>

<span class="sd">        Note that this routine modifies the original image (and not just the subimage onto which</span>
<span class="sd">        it is wrapped), so if you want to keep the original pristine, you should call</span>
<span class="sd">        ``wrapped_image = image.copy().wrap(bounds)``.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            bounds:         The bounds of the subimage onto which to wrap the full image.</span>
<span class="sd">            hermitian:      Whether the image is implicitly Hermitian and if so, whether it is the</span>
<span class="sd">                            x or y values that are not stored.  [default: False]</span>

<span class="sd">        Returns:</span>
<span class="sd">            the subimage, image[bounds], after doing the wrapping.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bounds</span><span class="p">,</span> <span class="n">BoundsI</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;bounds must be a galsim.BoundsI instance&quot;</span><span class="p">)</span>
        <span class="c1"># Get this at the start to check for invalid bounds and raise the exception before</span>
        <span class="c1"># possibly writing data past the edge of the image.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">hermitian</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrap</span><span class="p">(</span><span class="n">bounds</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">hermitian</span> <span class="o">==</span> <span class="s1">&#39;x&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="o">.</span><span class="n">xmin</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">GalSimIncompatibleValuesError</span><span class="p">(</span>
                    <span class="s2">&quot;hermitian == &#39;x&#39; requires self.bounds.xmin == 0&quot;</span><span class="p">,</span>
                    <span class="n">hermitian</span><span class="o">=</span><span class="n">hermitian</span><span class="p">,</span> <span class="n">bounds</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">bounds</span><span class="o">.</span><span class="n">xmin</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># pragma: no cover (This is covered, but codecov says it&#39;s not.)</span>
                <span class="k">raise</span> <span class="n">GalSimIncompatibleValuesError</span><span class="p">(</span>
                    <span class="s2">&quot;hermitian == &#39;x&#39; requires bounds.xmin == 0&quot;</span><span class="p">,</span>
                    <span class="n">hermitian</span><span class="o">=</span><span class="n">hermitian</span><span class="p">,</span> <span class="n">bounds</span><span class="o">=</span><span class="n">bounds</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrap</span><span class="p">(</span><span class="n">bounds</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">hermitian</span> <span class="o">==</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="o">.</span><span class="n">ymin</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">GalSimIncompatibleValuesError</span><span class="p">(</span>
                    <span class="s2">&quot;hermitian == &#39;y&#39; requires self.bounds.ymin == 0&quot;</span><span class="p">,</span>
                    <span class="n">hermitian</span><span class="o">=</span><span class="n">hermitian</span><span class="p">,</span> <span class="n">bounds</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">bounds</span><span class="o">.</span><span class="n">ymin</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># pragma: no cover (This is covered, but codecov says it&#39;s not.)</span>
                <span class="k">raise</span> <span class="n">GalSimIncompatibleValuesError</span><span class="p">(</span>
                    <span class="s2">&quot;hermitian == &#39;y&#39; requires bounds.ymin == 0&quot;</span><span class="p">,</span>
                    <span class="n">hermitian</span><span class="o">=</span><span class="n">hermitian</span><span class="p">,</span> <span class="n">bounds</span><span class="o">=</span><span class="n">bounds</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrap</span><span class="p">(</span><span class="n">bounds</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">GalSimValueError</span><span class="p">(</span><span class="s2">&quot;Invalid value for hermitian&quot;</span><span class="p">,</span> <span class="n">hermitian</span><span class="p">,</span> <span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">))</span></div>

<div class="viewcode-block" id="Image._wrap"><a class="viewcode-back" href="../../image_class.html#galsim.Image._wrap">[docs]</a>    <span class="k">def</span> <span class="nf">_wrap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bounds</span><span class="p">,</span> <span class="n">hermx</span><span class="p">,</span> <span class="n">hermy</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;A version of `wrap` without the sanity checks.</span>

<span class="sd">        Equivalent to ``image.wrap(bounds, hermitian==&#39;x&#39;, hermitian==&#39;y&#39;)``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">subImage</span><span class="p">(</span><span class="n">bounds</span><span class="p">)</span>
        <span class="k">with</span> <span class="n">convert_cpp_errors</span><span class="p">():</span>
            <span class="n">_galsim</span><span class="o">.</span><span class="n">wrapImage</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_image</span><span class="p">,</span> <span class="n">bounds</span><span class="o">.</span><span class="n">_b</span><span class="p">,</span> <span class="n">hermx</span><span class="p">,</span> <span class="n">hermy</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ret</span></div>

<div class="viewcode-block" id="Image.bin"><a class="viewcode-back" href="../../image_class.html#galsim.Image.bin">[docs]</a>    <span class="k">def</span> <span class="nf">bin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Bin the image pixels in blocks of nx x ny pixels.</span>

<span class="sd">        This returns a new image that is a binned version of the current image.</span>
<span class="sd">        Adjacent pixel values in nx x ny blocks are added together to produce the flux in each</span>
<span class="sd">        output pixel.</span>

<span class="sd">        If the current number of pixels in each direction is not a multiple of nx, ny, then the</span>
<span class="sd">        last pixel in each direction will be the sum of fewer than nx or ny pixels as needed.</span>

<span class="sd">        See also subsample, which is the opposite of this.</span>

<span class="sd">        If the wcs is a Jacobian (or simpler), the output image will have its wcs set properly.</span>
<span class="sd">        But if the wcs is more complicated, the output wcs would be fairly complicated to figure</span>
<span class="sd">        out properly, so we leave it as None.  The user should set it themselves if required.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            nx:     The number of adjacent pixels in the x direction to add together into each</span>
<span class="sd">                    output pixel.</span>
<span class="sd">            ny:     The number of adjacent pixels in the y direction to add together into each</span>
<span class="sd">                    output pixel.</span>

<span class="sd">        Returns:</span>
<span class="sd">            a new `Image`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.wcs</span> <span class="k">import</span> <span class="n">JacobianWCS</span>
        <span class="n">ncol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xmax</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">xmin</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">nrow</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ymax</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">ymin</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">nbins_x</span> <span class="o">=</span> <span class="p">(</span><span class="n">ncol</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="n">nx</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">nbins_y</span> <span class="o">=</span> <span class="p">(</span><span class="n">nrow</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="n">ny</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">nbins</span> <span class="o">=</span> <span class="n">nbins_x</span> <span class="o">*</span> <span class="n">nbins_y</span>

        <span class="c1"># target_bins just provides a number from 0..nbins for each target pixel</span>
        <span class="n">target_bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nbins</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">nbins_y</span><span class="p">,</span> <span class="n">nbins_x</span><span class="p">)</span>
        <span class="c1"># current_bins is the same number for each pixel in the current image.</span>
        <span class="n">current_bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">target_bins</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="n">nx</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">current_bins</span> <span class="o">=</span> <span class="n">current_bins</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">nrow</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">ncol</span><span class="p">]</span>

        <span class="c1"># bincount with weights is a tricky way to do the sum over the bins</span>
        <span class="n">target_ar</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span><span class="n">current_bins</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="n">weights</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span>
        <span class="n">target_ar</span> <span class="o">=</span> <span class="n">target_ar</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">target_bins</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">wcs</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">wcs</span><span class="o">.</span><span class="n">isUniform</span><span class="p">():</span>
            <span class="n">target_wcs</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">wcs</span><span class="o">.</span><span class="n">isPixelScale</span><span class="p">()</span> <span class="ow">and</span> <span class="n">nx</span> <span class="o">==</span> <span class="n">ny</span><span class="p">:</span>
                <span class="n">target_wcs</span> <span class="o">=</span> <span class="n">PixelScale</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scale</span> <span class="o">*</span> <span class="n">nx</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">dudx</span><span class="p">,</span> <span class="n">dudy</span><span class="p">,</span> <span class="n">dvdx</span><span class="p">,</span> <span class="n">dvdy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wcs</span><span class="o">.</span><span class="n">jacobian</span><span class="p">()</span><span class="o">.</span><span class="n">getMatrix</span><span class="p">()</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
                <span class="n">dudx</span> <span class="o">*=</span> <span class="n">nx</span>
                <span class="n">dvdx</span> <span class="o">*=</span> <span class="n">nx</span>
                <span class="n">dudy</span> <span class="o">*=</span> <span class="n">ny</span>
                <span class="n">dvdy</span> <span class="o">*=</span> <span class="n">ny</span>
                <span class="n">target_wcs</span> <span class="o">=</span> <span class="n">JacobianWCS</span><span class="p">(</span><span class="n">dudx</span><span class="p">,</span> <span class="n">dudy</span><span class="p">,</span> <span class="n">dvdx</span><span class="p">,</span> <span class="n">dvdy</span><span class="p">)</span>

            <span class="c1"># Set the origin so that corresponding image positions correspond to the same world_pos</span>
            <span class="n">x0</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wcs</span><span class="o">.</span><span class="n">origin</span><span class="o">.</span><span class="n">x</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">xmin</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">/</span> <span class="n">nx</span> <span class="o">+</span> <span class="mf">0.5</span>
            <span class="n">y0</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wcs</span><span class="o">.</span><span class="n">origin</span><span class="o">.</span><span class="n">y</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">ymin</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">/</span> <span class="n">ny</span> <span class="o">+</span> <span class="mf">0.5</span>
            <span class="n">target_wcs</span> <span class="o">=</span> <span class="n">target_wcs</span><span class="o">.</span><span class="n">withOrigin</span><span class="p">(</span><span class="n">PositionD</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span><span class="n">y0</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">wcs</span><span class="o">.</span><span class="n">world_origin</span><span class="p">)</span>

        <span class="n">target_bounds</span> <span class="o">=</span> <span class="n">BoundsI</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nbins_x</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">nbins_y</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">_Image</span><span class="p">(</span><span class="n">target_ar</span><span class="p">,</span> <span class="n">target_bounds</span><span class="p">,</span> <span class="n">target_wcs</span><span class="p">)</span></div>

<div class="viewcode-block" id="Image.subsample"><a class="viewcode-back" href="../../image_class.html#galsim.Image.subsample">[docs]</a>    <span class="k">def</span> <span class="nf">subsample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Subdivide the image pixels into nx x ny sub-pixels.</span>

<span class="sd">        This returns a new image that is a subsampled version of the current image.</span>
<span class="sd">        Each pixel&#39;s flux is split (uniformly) into nx x ny smaller pixels.</span>

<span class="sd">        See also bin, which is the opposite of this.  Note that subsample(nx,ny) followed by</span>
<span class="sd">        bin(nx,ny) is essentially a no op.</span>

<span class="sd">        If the wcs is a Jacobian (or simpler), the output image will have its wcs set properly.</span>
<span class="sd">        But if the wcs is more complicated, the output wcs would be fairly complicated to figure</span>
<span class="sd">        out properly, so we leave it as None.  The user should set it themselves if required.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            nx:     The number of sub-pixels in the x direction for each original pixel.</span>
<span class="sd">            ny:     The number of sub-pixels in the y direction for each original pixel.</span>
<span class="sd">            dtype:  Optionally provide a dtype for the return image. [default: None, which</span>
<span class="sd">                    means to use the same dtype as the original image]</span>

<span class="sd">        Returns:</span>
<span class="sd">            a new `Image`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ncol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xmax</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">xmin</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">nrow</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ymax</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">ymin</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">npix_x</span> <span class="o">=</span> <span class="n">ncol</span> <span class="o">*</span> <span class="n">nx</span>
        <span class="n">npix_y</span> <span class="o">=</span> <span class="n">nrow</span> <span class="o">*</span> <span class="n">ny</span>
        <span class="n">flux_factor</span> <span class="o">=</span> <span class="n">nx</span> <span class="o">*</span> <span class="n">ny</span>

        <span class="n">target_ar</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="n">nx</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">target_ar</span> <span class="o">=</span> <span class="n">target_ar</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>  <span class="c1"># Cute. This is a no op if dtype=None</span>
        <span class="n">target_ar</span> <span class="o">/=</span> <span class="n">flux_factor</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">wcs</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">wcs</span><span class="o">.</span><span class="n">isUniform</span><span class="p">():</span>
            <span class="n">target_wcs</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">wcs</span><span class="o">.</span><span class="n">isPixelScale</span><span class="p">()</span> <span class="ow">and</span> <span class="n">nx</span> <span class="o">==</span> <span class="n">ny</span><span class="p">:</span>
                <span class="n">target_wcs</span> <span class="o">=</span> <span class="n">PixelScale</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scale</span> <span class="o">/</span> <span class="n">nx</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">dudx</span><span class="p">,</span> <span class="n">dudy</span><span class="p">,</span> <span class="n">dvdx</span><span class="p">,</span> <span class="n">dvdy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wcs</span><span class="o">.</span><span class="n">jacobian</span><span class="p">()</span><span class="o">.</span><span class="n">getMatrix</span><span class="p">()</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
                <span class="n">dudx</span> <span class="o">/=</span> <span class="n">nx</span>
                <span class="n">dvdx</span> <span class="o">/=</span> <span class="n">nx</span>
                <span class="n">dudy</span> <span class="o">/=</span> <span class="n">ny</span>
                <span class="n">dvdy</span> <span class="o">/=</span> <span class="n">ny</span>
                <span class="n">target_wcs</span> <span class="o">=</span> <span class="n">JacobianWCS</span><span class="p">(</span><span class="n">dudx</span><span class="p">,</span> <span class="n">dudy</span><span class="p">,</span> <span class="n">dvdx</span><span class="p">,</span> <span class="n">dvdy</span><span class="p">)</span>

            <span class="c1"># Set the origin so that corresponding image positions correspond to the same world_pos</span>
            <span class="n">x0</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wcs</span><span class="o">.</span><span class="n">origin</span><span class="o">.</span><span class="n">x</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">xmin</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">*</span> <span class="n">nx</span> <span class="o">+</span> <span class="mf">0.5</span>
            <span class="n">y0</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wcs</span><span class="o">.</span><span class="n">origin</span><span class="o">.</span><span class="n">y</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">ymin</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">*</span> <span class="n">ny</span> <span class="o">+</span> <span class="mf">0.5</span>
            <span class="n">target_wcs</span> <span class="o">=</span> <span class="n">target_wcs</span><span class="o">.</span><span class="n">withOrigin</span><span class="p">(</span><span class="n">PositionD</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span><span class="n">y0</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">wcs</span><span class="o">.</span><span class="n">world_origin</span><span class="p">)</span>

        <span class="n">target_bounds</span> <span class="o">=</span> <span class="n">BoundsI</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">npix_x</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">npix_y</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">_Image</span><span class="p">(</span><span class="n">target_ar</span><span class="p">,</span> <span class="n">target_bounds</span><span class="p">,</span> <span class="n">target_wcs</span><span class="p">)</span></div>

<div class="viewcode-block" id="Image.calculate_fft"><a class="viewcode-back" href="../../image_class.html#galsim.Image.calculate_fft">[docs]</a>    <span class="k">def</span> <span class="nf">calculate_fft</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Performs an FFT of an `Image` in real space to produce a k-space `Image`.</span>

<span class="sd">        Note: the image will be padded with zeros as needed to make an image with bounds that</span>
<span class="sd">        look like ``BoundsI(-N/2, N/2-1, -N/2, N/2-1)``.</span>

<span class="sd">        The input image must have a `PixelScale` wcs.  The output image will be complex (an</span>
<span class="sd">        `ImageCF` or `ImageCD` instance) and its scale will be 2pi / (N dx), where dx is the scale</span>
<span class="sd">        of the input image.</span>

<span class="sd">        Returns:</span>
<span class="sd">            an `Image` instance with the k-space image.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">wcs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">GalSimError</span><span class="p">(</span><span class="s2">&quot;calculate_fft requires that the scale be set.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">wcs</span><span class="o">.</span><span class="n">isPixelScale</span><span class="p">():</span>
            <span class="k">raise</span> <span class="n">GalSimError</span><span class="p">(</span><span class="s2">&quot;calculate_fft requires that the image has a PixelScale wcs.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="o">.</span><span class="n">isDefined</span><span class="p">():</span>
            <span class="k">raise</span> <span class="n">GalSimUndefinedBoundsError</span><span class="p">(</span>
                    <span class="s2">&quot;calculate_fft requires that the image have defined bounds.&quot;</span><span class="p">)</span>

        <span class="n">No2</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="o">.</span><span class="n">xmin</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="o">.</span><span class="n">xmax</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="o">.</span><span class="n">ymin</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="o">.</span><span class="n">ymax</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">full_bounds</span> <span class="o">=</span> <span class="n">BoundsI</span><span class="p">(</span><span class="o">-</span><span class="n">No2</span><span class="p">,</span> <span class="n">No2</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="n">No2</span><span class="p">,</span> <span class="n">No2</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span> <span class="o">==</span> <span class="n">full_bounds</span><span class="p">:</span>
            <span class="c1"># Then the image is already in the shape we need.</span>
            <span class="n">ximage</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Then we pad out with zeros</span>
            <span class="n">ximage</span> <span class="o">=</span> <span class="n">Image</span><span class="p">(</span><span class="n">full_bounds</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">init_value</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">ximage</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="p">]</span>

        <span class="n">dx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span>
        <span class="c1"># dk = 2pi / (N dk)</span>
        <span class="n">dk</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="p">(</span><span class="n">No2</span> <span class="o">*</span> <span class="n">dx</span><span class="p">)</span>

        <span class="n">out</span> <span class="o">=</span> <span class="n">Image</span><span class="p">(</span><span class="n">BoundsI</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">No2</span><span class="p">,</span><span class="o">-</span><span class="n">No2</span><span class="p">,</span><span class="n">No2</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">dk</span><span class="p">)</span>
        <span class="k">with</span> <span class="n">convert_cpp_errors</span><span class="p">():</span>
            <span class="n">_galsim</span><span class="o">.</span><span class="n">rfft</span><span class="p">(</span><span class="n">ximage</span><span class="o">.</span><span class="n">_image</span><span class="p">,</span> <span class="n">out</span><span class="o">.</span><span class="n">_image</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">*=</span> <span class="n">dx</span><span class="o">*</span><span class="n">dx</span>
        <span class="n">out</span><span class="o">.</span><span class="n">setOrigin</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="n">No2</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span></div>

<div class="viewcode-block" id="Image.calculate_inverse_fft"><a class="viewcode-back" href="../../image_class.html#galsim.Image.calculate_inverse_fft">[docs]</a>    <span class="k">def</span> <span class="nf">calculate_inverse_fft</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Performs an inverse FFT of an `Image` in k-space to produce a real-space `Image`.</span>

<span class="sd">        The starting image is typically an `ImageCD`, although if the Fourier function is real</span>
<span class="sd">        valued, then you could get away with using an `ImageD` or `ImageF`.</span>

<span class="sd">        The image is assumed to be Hermitian.  In fact, only the portion with x &gt;= 0 needs to</span>
<span class="sd">        be defined, with f(-x,-y) taken to be conj(f(x,y)).</span>

<span class="sd">        Note: the k-space image will be padded with zeros and/or wrapped as needed to make an</span>
<span class="sd">        image with bounds that look like ``BoundsI(0, N/2, -N/2, N/2-1)``.  If you are building a</span>
<span class="sd">        larger k-space image and then wrapping, you should wrap directly into an image of</span>
<span class="sd">        this shape.</span>

<span class="sd">        The input image must have a `PixelScale` wcs.  The output image will be real (an `ImageD`</span>
<span class="sd">        instance) and its scale will be 2pi / (N dk), where dk is the scale of the input image.</span>

<span class="sd">        Returns:</span>
<span class="sd">            an `Image` instance with the real-space image.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">wcs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">GalSimError</span><span class="p">(</span><span class="s2">&quot;calculate_inverse_fft requires that the scale be set.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">wcs</span><span class="o">.</span><span class="n">isPixelScale</span><span class="p">():</span>
            <span class="k">raise</span> <span class="n">GalSimError</span><span class="p">(</span><span class="s2">&quot;calculate_inverse_fft requires that the image has a PixelScale wcs.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="o">.</span><span class="n">isDefined</span><span class="p">():</span>
            <span class="k">raise</span> <span class="n">GalSimUndefinedBoundsError</span><span class="p">(</span><span class="s2">&quot;calculate_inverse_fft requires that the image have &quot;</span>
                                             <span class="s2">&quot;defined bounds.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="o">.</span><span class="n">includes</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">GalSimBoundsError</span><span class="p">(</span><span class="s2">&quot;calculate_inverse_fft requires that the image includes (0,0)&quot;</span><span class="p">,</span>
                                    <span class="n">PositionI</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="p">)</span>

        <span class="n">No2</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="o">.</span><span class="n">xmax</span><span class="p">,</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="o">.</span><span class="n">ymin</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="o">.</span><span class="n">ymax</span><span class="p">)</span>

        <span class="n">target_bounds</span> <span class="o">=</span> <span class="n">BoundsI</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">No2</span><span class="p">,</span> <span class="o">-</span><span class="n">No2</span><span class="p">,</span> <span class="n">No2</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span> <span class="o">==</span> <span class="n">target_bounds</span><span class="p">:</span>
            <span class="c1"># Then the image is already in the shape we need.</span>
            <span class="n">kimage</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Then we can pad out with zeros and wrap to get this in the form we need.</span>
            <span class="n">full_bounds</span> <span class="o">=</span> <span class="n">BoundsI</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">No2</span><span class="p">,</span> <span class="o">-</span><span class="n">No2</span><span class="p">,</span> <span class="n">No2</span><span class="p">)</span>
            <span class="n">kimage</span> <span class="o">=</span> <span class="n">Image</span><span class="p">(</span><span class="n">full_bounds</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">init_value</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">posx_bounds</span> <span class="o">=</span> <span class="n">BoundsI</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="o">.</span><span class="n">xmax</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="o">.</span><span class="n">ymin</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="o">.</span><span class="n">ymax</span><span class="p">)</span>
            <span class="n">kimage</span><span class="p">[</span><span class="n">posx_bounds</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">posx_bounds</span><span class="p">]</span>
            <span class="n">kimage</span> <span class="o">=</span> <span class="n">kimage</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="n">target_bounds</span><span class="p">,</span> <span class="n">hermitian</span> <span class="o">=</span> <span class="s1">&#39;x&#39;</span><span class="p">)</span>

        <span class="n">dk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span>
        <span class="c1"># dx = 2pi / (N dk)</span>
        <span class="n">dx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="p">(</span><span class="n">No2</span> <span class="o">*</span> <span class="n">dk</span><span class="p">)</span>

        <span class="c1"># For the inverse, we need a bit of extra space for the fft.</span>
        <span class="n">out_extra</span> <span class="o">=</span> <span class="n">Image</span><span class="p">(</span><span class="n">BoundsI</span><span class="p">(</span><span class="o">-</span><span class="n">No2</span><span class="p">,</span><span class="n">No2</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="n">No2</span><span class="p">,</span><span class="n">No2</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">dx</span><span class="p">)</span>
        <span class="k">with</span> <span class="n">convert_cpp_errors</span><span class="p">():</span>
            <span class="n">_galsim</span><span class="o">.</span><span class="n">irfft</span><span class="p">(</span><span class="n">kimage</span><span class="o">.</span><span class="n">_image</span><span class="p">,</span> <span class="n">out_extra</span><span class="o">.</span><span class="n">_image</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="c1"># Now cut off the bit we don&#39;t need.</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">out_extra</span><span class="o">.</span><span class="n">subImage</span><span class="p">(</span><span class="n">BoundsI</span><span class="p">(</span><span class="o">-</span><span class="n">No2</span><span class="p">,</span><span class="n">No2</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="n">No2</span><span class="p">,</span><span class="n">No2</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">out</span> <span class="o">*=</span> <span class="p">(</span><span class="n">dk</span> <span class="o">*</span> <span class="n">No2</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">out</span><span class="o">.</span><span class="n">setCenter</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span></div>

<div class="viewcode-block" id="Image.good_fft_size"><a class="viewcode-back" href="../../image_class.html#galsim.Image.good_fft_size">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">good_fft_size</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">input_size</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Round the given input size up to the next higher power of 2 or 3 times a power of 2.</span>

<span class="sd">        This rounds up to the next higher value that is either 2^k or 3*2^k.  If you are</span>
<span class="sd">        going to be performing FFTs on an image, these will tend to be faster at performing</span>
<span class="sd">        the FFT.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="n">convert_cpp_errors</span><span class="p">():</span>
            <span class="k">return</span> <span class="n">_galsim</span><span class="o">.</span><span class="n">goodFFTSize</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">input_size</span><span class="p">))</span></div>

<div class="viewcode-block" id="Image.copyFrom"><a class="viewcode-back" href="../../image_class.html#galsim.Image.copyFrom">[docs]</a>    <span class="k">def</span> <span class="nf">copyFrom</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rhs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Copy the contents of another image</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">isconst</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">GalSimImmutableError</span><span class="p">(</span><span class="s2">&quot;Cannot modify the values of an immutable Image&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">rhs</span><span class="p">,</span> <span class="n">Image</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Trying to copyFrom a non-image&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="o">.</span><span class="n">numpyShape</span><span class="p">()</span> <span class="o">!=</span> <span class="n">rhs</span><span class="o">.</span><span class="n">bounds</span><span class="o">.</span><span class="n">numpyShape</span><span class="p">():</span>
            <span class="k">raise</span> <span class="n">GalSimIncompatibleValuesError</span><span class="p">(</span>
                <span class="s2">&quot;Trying to copy images that are not the same shape&quot;</span><span class="p">,</span> <span class="n">self_image</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">rhs</span><span class="o">=</span><span class="n">rhs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_array</span><span class="p">[:,:]</span> <span class="o">=</span> <span class="n">rhs</span><span class="o">.</span><span class="n">array</span><span class="p">[:,:]</span></div>

<div class="viewcode-block" id="Image.view"><a class="viewcode-back" href="../../image_class.html#galsim.Image.view">[docs]</a>    <span class="k">def</span> <span class="nf">view</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">wcs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">make_const</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Make a view of this image, which lets you change the scale, wcs, origin, etc.</span>
<span class="sd">        but view the same underlying data as the original image.</span>

<span class="sd">        If you do not provide either ``scale`` or ``wcs``, the view will keep the same wcs</span>
<span class="sd">        as the current `Image` object.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            scale:      If provided, use this as the pixel scale for the image. [default: None]</span>
<span class="sd">            wcs:        If provided, use this as the wcs for the image. [default: None]</span>
<span class="sd">            origin:     If profided, use this as the origin position of the view.</span>
<span class="sd">                        [default: None]</span>
<span class="sd">            center:     If profided, use this as the center position of the view.</span>
<span class="sd">                        [default: None]</span>
<span class="sd">            make_const: Make the view&#39;s data array immutable. [default: False]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">origin</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">center</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">GalSimIncompatibleValuesError</span><span class="p">(</span>
                <span class="s2">&quot;Cannot provide both center and origin&quot;</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="n">center</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="n">origin</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">scale</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">wcs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">GalSimIncompatibleValuesError</span><span class="p">(</span>
                    <span class="s2">&quot;Cannot provide both scale and wcs&quot;</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">,</span> <span class="n">wcs</span><span class="o">=</span><span class="n">wcs</span><span class="p">)</span>
            <span class="n">wcs</span> <span class="o">=</span> <span class="n">PixelScale</span><span class="p">(</span><span class="n">scale</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">wcs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">wcs</span><span class="p">,</span><span class="n">BaseWCS</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;wcs parameters must be a galsim.BaseWCS instance&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">wcs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wcs</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="o">.</span><span class="n">isDefined</span><span class="p">():</span>
            <span class="k">return</span> <span class="n">Image</span><span class="p">(</span><span class="n">wcs</span><span class="o">=</span><span class="n">wcs</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">make_const</span><span class="p">:</span>
            <span class="n">array</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">view</span><span class="p">()</span>
            <span class="n">array</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">writeable</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">_Image</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="p">,</span> <span class="n">wcs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">_Image</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="p">,</span> <span class="n">wcs</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">origin</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">setOrigin</span><span class="p">(</span><span class="n">origin</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">center</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">setCenter</span><span class="p">(</span><span class="n">center</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">ret</span></div>

<div class="viewcode-block" id="Image._view"><a class="viewcode-back" href="../../image_class.html#galsim.Image._view">[docs]</a>    <span class="k">def</span> <span class="nf">_view</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Equivalent to `view`, but without some of the sanity checks and extra options.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_Image</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">view</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">wcs</span><span class="p">)</span></div>

<div class="viewcode-block" id="Image.shift"><a class="viewcode-back" href="../../image_class.html#galsim.Image.shift">[docs]</a>    <span class="k">def</span> <span class="nf">shift</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Shift the pixel coordinates by some (integral) dx,dy.</span>

<span class="sd">        The arguments here may be either (dx, dy) or a PositionI instance.</span>
<span class="sd">        Or you can provide dx, dy as named kwargs.</span>

<span class="sd">        In terms of columns and rows, dx means a shift in the x value of each column in the</span>
<span class="sd">        array, and dy means a shift in the y value of each row.  In other words, the following</span>
<span class="sd">        will return the same value for ixy.  The shift function just changes the coordinates (x,y)</span>
<span class="sd">        used for that pixel::</span>

<span class="sd">            &gt;&gt;&gt; ixy = im(x,y)</span>
<span class="sd">            &gt;&gt;&gt; im.shift(3,9)</span>
<span class="sd">            &gt;&gt;&gt; ixy = im(x+3, y+9)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">delta</span> <span class="o">=</span> <span class="n">utilities</span><span class="o">.</span><span class="n">parse_pos_args</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">,</span> <span class="s1">&#39;dx&#39;</span><span class="p">,</span> <span class="s1">&#39;dy&#39;</span><span class="p">,</span> <span class="n">integer</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_shift</span><span class="p">(</span><span class="n">delta</span><span class="p">)</span></div>

<div class="viewcode-block" id="Image._shift"><a class="viewcode-back" href="../../image_class.html#galsim.Image._shift">[docs]</a>    <span class="k">def</span> <span class="nf">_shift</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">delta</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Equivalent to `shift`, but without some of the sanity checks and ``delta`` must</span>
<span class="sd">        be a `PositionI` instance.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            delta:  The amount to shift as a `PositionI`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># The parse_pos_args function is a bit slow, so go directly to this point when we</span>
        <span class="c1"># call shift from setCenter or setOrigin.</span>
        <span class="k">if</span> <span class="n">delta</span><span class="o">.</span><span class="n">x</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">delta</span><span class="o">.</span><span class="n">y</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_bounds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bounds</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span><span class="n">delta</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">wcs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">wcs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wcs</span><span class="o">.</span><span class="n">withOrigin</span><span class="p">(</span><span class="n">delta</span><span class="p">)</span></div>

<div class="viewcode-block" id="Image.setCenter"><a class="viewcode-back" href="../../image_class.html#galsim.Image.setCenter">[docs]</a>    <span class="k">def</span> <span class="nf">setCenter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the center of the image to the given (integral) (xcen, ycen)</span>

<span class="sd">        The arguments here may be either (xcen, ycen) or a PositionI instance.</span>
<span class="sd">        Or you can provide xcen, ycen as named kwargs.</span>

<span class="sd">        In terms of the rows and columns, xcen is the new x value for the central column, and ycen</span>
<span class="sd">        is the new y value of the central row.  For even-sized arrays, there is no central column</span>
<span class="sd">        or row, so the convention we adopt in this case is to round up.  For example::</span>

<span class="sd">            &gt;&gt;&gt; im = galsim.Image(numpy.array(range(16),dtype=float).reshape((4,4)))</span>
<span class="sd">            &gt;&gt;&gt; im(1,1)</span>
<span class="sd">            0.0</span>
<span class="sd">            &gt;&gt;&gt; im(4,1)</span>
<span class="sd">            3.0</span>
<span class="sd">            &gt;&gt;&gt; im(4,4)</span>
<span class="sd">            15.0</span>
<span class="sd">            &gt;&gt;&gt; im(3,3)</span>
<span class="sd">            10.0</span>
<span class="sd">            &gt;&gt;&gt; im.setCenter(0,0)</span>
<span class="sd">            &gt;&gt;&gt; im(0,0)</span>
<span class="sd">            10.0</span>
<span class="sd">            &gt;&gt;&gt; im(-2,-2)</span>
<span class="sd">            0.0</span>
<span class="sd">            &gt;&gt;&gt; im(1,-2)</span>
<span class="sd">            3.0</span>
<span class="sd">            &gt;&gt;&gt; im(1,1)</span>
<span class="sd">            15.0</span>
<span class="sd">            &gt;&gt;&gt; im.setCenter(234,456)</span>
<span class="sd">            &gt;&gt;&gt; im(234,456)</span>
<span class="sd">            10.0</span>
<span class="sd">            &gt;&gt;&gt; im.bounds</span>
<span class="sd">            galsim.BoundsI(xmin=232, xmax=235, ymin=454, ymax=457)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cen</span> <span class="o">=</span> <span class="n">utilities</span><span class="o">.</span><span class="n">parse_pos_args</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">,</span> <span class="s1">&#39;xcen&#39;</span><span class="p">,</span> <span class="s1">&#39;ycen&#39;</span><span class="p">,</span> <span class="n">integer</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_shift</span><span class="p">(</span><span class="n">cen</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">center</span><span class="p">)</span></div>

<div class="viewcode-block" id="Image.setOrigin"><a class="viewcode-back" href="../../image_class.html#galsim.Image.setOrigin">[docs]</a>    <span class="k">def</span> <span class="nf">setOrigin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the origin of the image to the given (integral) (x0, y0)</span>

<span class="sd">        The arguments here may be either (x0, y0) or a PositionI instance.</span>
<span class="sd">        Or you can provide x0, y0 as named kwargs.</span>

<span class="sd">        In terms of the rows and columns, x0 is the new x value for the first column,</span>
<span class="sd">        and y0 is the new y value of the first row.  For example::</span>

<span class="sd">            &gt;&gt;&gt; im = galsim.Image(numpy.array(range(16),dtype=float).reshape((4,4)))</span>
<span class="sd">            &gt;&gt;&gt; im(1,1)</span>
<span class="sd">            0.0</span>
<span class="sd">            &gt;&gt;&gt; im(4,1)</span>
<span class="sd">            3.0</span>
<span class="sd">            &gt;&gt;&gt; im(1,4)</span>
<span class="sd">            12.0</span>
<span class="sd">            &gt;&gt;&gt; im(4,4)</span>
<span class="sd">            15.0</span>
<span class="sd">            &gt;&gt;&gt; im.setOrigin(0,0)</span>
<span class="sd">            &gt;&gt;&gt; im(0,0)</span>
<span class="sd">            0.0</span>
<span class="sd">            &gt;&gt;&gt; im(3,0)</span>
<span class="sd">            3.0</span>
<span class="sd">            &gt;&gt;&gt; im(0,3)</span>
<span class="sd">            12.0</span>
<span class="sd">            &gt;&gt;&gt; im(3,3)</span>
<span class="sd">            15.0</span>
<span class="sd">            &gt;&gt;&gt; im.setOrigin(234,456)</span>
<span class="sd">            &gt;&gt;&gt; im(234,456)</span>
<span class="sd">            0.0</span>
<span class="sd">            &gt;&gt;&gt; im.bounds</span>
<span class="sd">            galsim.BoundsI(xmin=234, xmax=237, ymin=456, ymax=459)</span>
<span class="sd">         &quot;&quot;&quot;</span>
        <span class="n">origin</span> <span class="o">=</span> <span class="n">utilities</span><span class="o">.</span><span class="n">parse_pos_args</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">,</span> <span class="s1">&#39;x0&#39;</span><span class="p">,</span> <span class="s1">&#39;y0&#39;</span><span class="p">,</span> <span class="n">integer</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_shift</span><span class="p">(</span><span class="n">origin</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">origin</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">center</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The current nominal center (xcen,ycen) of the image as a PositionI instance.</span>

<span class="sd">        In terms of the rows and columns, xcen is the x value for the central column, and ycen</span>
<span class="sd">        is the y value of the central row.  For even-sized arrays, there is no central column</span>
<span class="sd">        or row, so the convention we adopt in this case is to round up.  For example::</span>

<span class="sd">            &gt;&gt;&gt; im = galsim.Image(numpy.array(range(16),dtype=float).reshape((4,4)))</span>
<span class="sd">            &gt;&gt;&gt; im.center</span>
<span class="sd">            galsim.PositionI(x=3, y=3)</span>
<span class="sd">            &gt;&gt;&gt; im(im.center)</span>
<span class="sd">            10.0</span>
<span class="sd">            &gt;&gt;&gt; im.setCenter(56,72)</span>
<span class="sd">            &gt;&gt;&gt; im.center</span>
<span class="sd">            galsim.PositionI(x=56, y=72)</span>
<span class="sd">            &gt;&gt;&gt; im(im.center)</span>
<span class="sd">            10.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="o">.</span><span class="n">center</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">true_center</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The current true center of the image as a PositionD instance.</span>

<span class="sd">        Unline the nominal center returned by im.center, this value may be half-way between</span>
<span class="sd">        two pixels if the image has an even number of rows or columns.  It gives the position</span>
<span class="sd">        (x,y) at the exact center of the image, regardless of whether this is at the center of</span>
<span class="sd">        a pixel (integer value) or halfway between two (half-integer).  For example::</span>

<span class="sd">            &gt;&gt;&gt; im = galsim.Image(numpy.array(range(16),dtype=float).reshape((4,4)))</span>
<span class="sd">            &gt;&gt;&gt; im.center</span>
<span class="sd">            galsim.PositionI(x=3, y=3)</span>
<span class="sd">            &gt;&gt;&gt; im.true_center</span>
<span class="sd">            galsim.PositionI(x=2.5, y=2.5)</span>
<span class="sd">            &gt;&gt;&gt; im.setCenter(56,72)</span>
<span class="sd">            &gt;&gt;&gt; im.center</span>
<span class="sd">            galsim.PositionI(x=56, y=72)</span>
<span class="sd">            &gt;&gt;&gt; im.true_center</span>
<span class="sd">            galsim.PositionD(x=55.5, y=71.5)</span>
<span class="sd">            &gt;&gt;&gt; im.setOrigin(0,0)</span>
<span class="sd">            &gt;&gt;&gt; im.true_center</span>
<span class="sd">            galsim.PositionD(x=1.5, y=1.5)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="o">.</span><span class="n">true_center</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">origin</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the origin of the image.  i.e. the (x,y) position of the lower-left pixel.</span>

<span class="sd">        In terms of the rows and columns, this is the (x,y) coordinate of the first column, and</span>
<span class="sd">        first row of the array.  For example::</span>

<span class="sd">            &gt;&gt;&gt; im = galsim.Image(numpy.array(range(16),dtype=float).reshape((4,4)))</span>
<span class="sd">            &gt;&gt;&gt; im.origin</span>
<span class="sd">            galsim.PositionI(x=1, y=1)</span>
<span class="sd">            &gt;&gt;&gt; im(im.origin)</span>
<span class="sd">            0.0</span>
<span class="sd">            &gt;&gt;&gt; im.setOrigin(23,45)</span>
<span class="sd">            &gt;&gt;&gt; im.origin</span>
<span class="sd">            galsim.PositionI(x=23, y=45)</span>
<span class="sd">            &gt;&gt;&gt; im(im.origin)</span>
<span class="sd">            0.0</span>
<span class="sd">            &gt;&gt;&gt; im(23,45)</span>
<span class="sd">            0.0</span>
<span class="sd">            &gt;&gt;&gt; im.bounds</span>
<span class="sd">            galsim.BoundsI(xmin=23, xmax=26, ymin=45, ymax=48)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="o">.</span><span class="n">origin</span>

<div class="viewcode-block" id="Image.__call__"><a class="viewcode-back" href="../../image_class.html#galsim.Image.__call__">[docs]</a>    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the pixel value at given position</span>

<span class="sd">        The arguments here may be either (x, y) or a PositionI instance.</span>
<span class="sd">        Or you can provide x, y as named kwargs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="n">utilities</span><span class="o">.</span><span class="n">parse_pos_args</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="n">integer</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">getValue</span><span class="p">(</span><span class="n">pos</span><span class="o">.</span><span class="n">x</span><span class="p">,</span><span class="n">pos</span><span class="o">.</span><span class="n">y</span><span class="p">)</span></div>

<div class="viewcode-block" id="Image.getValue"><a class="viewcode-back" href="../../image_class.html#galsim.Image.getValue">[docs]</a>    <span class="k">def</span> <span class="nf">getValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This method is a synonym for im(x,y).  It is a bit faster than im(x,y), since GalSim</span>
<span class="sd">        does not have to parse the different options available for __call__.  (i.e. im(x,y) or</span>
<span class="sd">        im(pos) or im(x=x,y=y))</span>

<span class="sd">        Parameters:</span>
<span class="sd">            x:      The x coordinate of the pixel to get.</span>
<span class="sd">            y:      The y coordinate of the pixel to get.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="o">.</span><span class="n">isDefined</span><span class="p">():</span>
            <span class="k">raise</span> <span class="n">GalSimUndefinedBoundsError</span><span class="p">(</span><span class="s2">&quot;Attempt to access values of an undefined image&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="o">.</span><span class="n">includes</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">GalSimBoundsError</span><span class="p">(</span><span class="s2">&quot;Attempt to access position not in bounds of image.&quot;</span><span class="p">,</span>
                                    <span class="n">PositionI</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getValue</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span></div>

<div class="viewcode-block" id="Image._getValue"><a class="viewcode-back" href="../../image_class.html#galsim.Image._getValue">[docs]</a>    <span class="k">def</span> <span class="nf">_getValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Equivalent to `getValue`, except there are no checks that the values fall</span>
<span class="sd">        within the bounds of the image.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_array</span><span class="p">[</span><span class="n">y</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">ymin</span><span class="p">,</span> <span class="n">x</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">xmin</span><span class="p">]</span></div>

<div class="viewcode-block" id="Image.setValue"><a class="viewcode-back" href="../../image_class.html#galsim.Image.setValue">[docs]</a>    <span class="k">def</span> <span class="nf">setValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the pixel value at given (x,y) position</span>

<span class="sd">        The arguments here may be either (x, y, value) or (pos, value) where pos is a PositionI.</span>
<span class="sd">        Or you can provide x, y, value as named kwargs.</span>

<span class="sd">        This is equivalent to self[x,y] = rhs</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">isconst</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">GalSimImmutableError</span><span class="p">(</span><span class="s2">&quot;Cannot modify the values of an immutable Image&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="o">.</span><span class="n">isDefined</span><span class="p">():</span>
            <span class="k">raise</span> <span class="n">GalSimUndefinedBoundsError</span><span class="p">(</span><span class="s2">&quot;Attempt to set value of an undefined image&quot;</span><span class="p">)</span>
        <span class="n">pos</span><span class="p">,</span> <span class="n">value</span> <span class="o">=</span> <span class="n">utilities</span><span class="o">.</span><span class="n">parse_pos_args</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="n">integer</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                     <span class="n">others</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;value&#39;</span><span class="p">])</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="o">.</span><span class="n">includes</span><span class="p">(</span><span class="n">pos</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">GalSimBoundsError</span><span class="p">(</span><span class="s2">&quot;Attempt to set position not in bounds of image&quot;</span><span class="p">,</span>
                                    <span class="n">pos</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_setValue</span><span class="p">(</span><span class="n">pos</span><span class="o">.</span><span class="n">x</span><span class="p">,</span><span class="n">pos</span><span class="o">.</span><span class="n">y</span><span class="p">,</span><span class="n">value</span><span class="p">)</span></div>

<div class="viewcode-block" id="Image._setValue"><a class="viewcode-back" href="../../image_class.html#galsim.Image._setValue">[docs]</a>    <span class="k">def</span> <span class="nf">_setValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Equivalent to `setValue` except that there are no checks that the values</span>
<span class="sd">        fall within the bounds of the image, and the coordinates must be given as ``x``, ``y``.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            x:      The x coordinate of the pixel to set.</span>
<span class="sd">            y:      The y coordinate of the pixel to set.</span>
<span class="sd">            value:  The value to set the pixel to.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_array</span><span class="p">[</span><span class="n">y</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">ymin</span><span class="p">,</span> <span class="n">x</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">xmin</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span></div>

<div class="viewcode-block" id="Image.addValue"><a class="viewcode-back" href="../../image_class.html#galsim.Image.addValue">[docs]</a>    <span class="k">def</span> <span class="nf">addValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add some amount to the pixel value at given (x,y) position</span>

<span class="sd">        The arguments here may be either (x, y, value) or (pos, value) where pos is a PositionI.</span>
<span class="sd">        Or you can provide x, y, value as named kwargs.</span>

<span class="sd">        This is equivalent to self[x,y] += rhs</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">isconst</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">GalSimImmutableError</span><span class="p">(</span><span class="s2">&quot;Cannot modify the values of an immutable Image&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="o">.</span><span class="n">isDefined</span><span class="p">():</span>
            <span class="k">raise</span> <span class="n">GalSimUndefinedBoundsError</span><span class="p">(</span><span class="s2">&quot;Attempt to set value of an undefined image&quot;</span><span class="p">)</span>
        <span class="n">pos</span><span class="p">,</span> <span class="n">value</span> <span class="o">=</span> <span class="n">utilities</span><span class="o">.</span><span class="n">parse_pos_args</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="n">integer</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                     <span class="n">others</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;value&#39;</span><span class="p">])</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="o">.</span><span class="n">includes</span><span class="p">(</span><span class="n">pos</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">GalSimBoundsError</span><span class="p">(</span><span class="s2">&quot;Attempt to set position not in bounds of image&quot;</span><span class="p">,</span>
                                    <span class="n">pos</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_addValue</span><span class="p">(</span><span class="n">pos</span><span class="o">.</span><span class="n">x</span><span class="p">,</span><span class="n">pos</span><span class="o">.</span><span class="n">y</span><span class="p">,</span><span class="n">value</span><span class="p">)</span></div>

<div class="viewcode-block" id="Image._addValue"><a class="viewcode-back" href="../../image_class.html#galsim.Image._addValue">[docs]</a>    <span class="k">def</span> <span class="nf">_addValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Equivalent to `addValue` except that there are no checks that the values</span>
<span class="sd">        fall within the bounds of the image, and the coordinates must be given as ``x``, ``y``.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            x:      The x coordinate of the pixel to add to.</span>
<span class="sd">            y:      The y coordinate of the pixel to add to.</span>
<span class="sd">            value:  The value to add to this pixel.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_array</span><span class="p">[</span><span class="n">y</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">ymin</span><span class="p">,</span> <span class="n">x</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">xmin</span><span class="p">]</span> <span class="o">+=</span> <span class="n">value</span></div>

<div class="viewcode-block" id="Image.fill"><a class="viewcode-back" href="../../image_class.html#galsim.Image.fill">[docs]</a>    <span class="k">def</span> <span class="nf">fill</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set all pixel values to the given ``value``</span>

<span class="sd">        Parameter:</span>
<span class="sd">            value:  The value to set all the pixels to.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">isconst</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">GalSimImmutableError</span><span class="p">(</span><span class="s2">&quot;Cannot modify the values of an immutable Image&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="o">.</span><span class="n">isDefined</span><span class="p">():</span>
            <span class="k">raise</span> <span class="n">GalSimUndefinedBoundsError</span><span class="p">(</span><span class="s2">&quot;Attempt to set values of an undefined image&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fill</span><span class="p">(</span><span class="n">value</span><span class="p">)</span></div>

<div class="viewcode-block" id="Image._fill"><a class="viewcode-back" href="../../image_class.html#galsim.Image._fill">[docs]</a>    <span class="k">def</span> <span class="nf">_fill</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Equivalent to `fill`, except that there are no checks that the bounds are defined.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_array</span><span class="p">[:,:]</span> <span class="o">=</span> <span class="n">value</span></div>

<div class="viewcode-block" id="Image.setZero"><a class="viewcode-back" href="../../image_class.html#galsim.Image.setZero">[docs]</a>    <span class="k">def</span> <span class="nf">setZero</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set all pixel values to zero.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">isconst</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">GalSimImmutableError</span><span class="p">(</span><span class="s2">&quot;Cannot modify the values of an immutable Image&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fill</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># This might be made faster with a C++ call to use memset</span></div>

<div class="viewcode-block" id="Image.invertSelf"><a class="viewcode-back" href="../../image_class.html#galsim.Image.invertSelf">[docs]</a>    <span class="k">def</span> <span class="nf">invertSelf</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set all pixel values to their inverse: x -&gt; 1/x.</span>

<span class="sd">        Note: any pixels whose value is 0 originally are ignored.  They remain equal to 0</span>
<span class="sd">        on the output, rather than turning into inf.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">isconst</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">GalSimImmutableError</span><span class="p">(</span><span class="s2">&quot;Cannot modify the values of an immutable Image&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="o">.</span><span class="n">isDefined</span><span class="p">():</span>
            <span class="k">raise</span> <span class="n">GalSimUndefinedBoundsError</span><span class="p">(</span><span class="s2">&quot;Attempt to set values of an undefined image&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_invertSelf</span><span class="p">()</span></div>

<div class="viewcode-block" id="Image._invertSelf"><a class="viewcode-back" href="../../image_class.html#galsim.Image._invertSelf">[docs]</a>    <span class="k">def</span> <span class="nf">_invertSelf</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Equivalent to `invertSelf`, except that there are no checks that the bounds are defined.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># C++ version skips 0&#39;s to 1/0 -&gt; 0 instead of inf.</span>
        <span class="k">with</span> <span class="n">convert_cpp_errors</span><span class="p">():</span>
            <span class="n">_galsim</span><span class="o">.</span><span class="n">invertImage</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_image</span><span class="p">)</span></div>

<div class="viewcode-block" id="Image.replaceNegative"><a class="viewcode-back" href="../../image_class.html#galsim.Image.replaceNegative">[docs]</a>    <span class="k">def</span> <span class="nf">replaceNegative</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">replace_value</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Replace any negative values currently in the image with 0 (or some other value).</span>

<span class="sd">        Sometimes FFT drawing can result in tiny negative values, which may be undesirable for</span>
<span class="sd">        some purposes.  This method replaces those values with 0 or some other value if desired.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            replace_value:  The value with which to replace any negative pixels. [default: 0]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">array</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">array</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">replace_value</span></div>

<div class="viewcode-block" id="Image.calculateHLR"><a class="viewcode-back" href="../../image_class.html#galsim.Image.calculateHLR">[docs]</a>    <span class="k">def</span> <span class="nf">calculateHLR</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">flux</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">flux_frac</span><span class="o">=</span><span class="mf">0.5</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the half-light radius of a drawn object.</span>

<span class="sd">        This method is equivalent to `GSObject.calculateHLR` when the object has already been</span>
<span class="sd">        been drawn onto an image.  Note that the profile should be drawn using a method that</span>
<span class="sd">        integrates over pixels and does not add noise. (The default method=&#39;auto&#39; is acceptable.)</span>

<span class="sd">        If the image has a wcs other than a `PixelScale`, an AttributeError will be raised.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            center:     The position in pixels to use for the center, r=0.</span>
<span class="sd">                        [default: self.true_center]</span>
<span class="sd">            flux:       The total flux.  [default: sum(self.array)]</span>
<span class="sd">            flux_frac:  The fraction of light to be enclosed by the returned radius.</span>
<span class="sd">                        [default: 0.5]</span>

<span class="sd">        Returns:</span>
<span class="sd">            an estimate of the half-light radius in physical units defined by the pixel scale.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">center</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">center</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">true_center</span>

        <span class="k">if</span> <span class="n">flux</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">flux</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

        <span class="c1"># Use radii at centers of pixels as approximation to the radial integral</span>
        <span class="n">x</span><span class="p">,</span><span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_pixel_centers</span><span class="p">()</span>
        <span class="n">x</span> <span class="o">-=</span> <span class="n">center</span><span class="o">.</span><span class="n">x</span>
        <span class="n">y</span> <span class="o">-=</span> <span class="n">center</span><span class="o">.</span><span class="n">y</span>
        <span class="n">rsq</span> <span class="o">=</span> <span class="n">x</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="o">*</span><span class="n">y</span>

        <span class="c1"># Sort by radius</span>
        <span class="n">indx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">rsq</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span>
        <span class="n">rsqf</span> <span class="o">=</span> <span class="n">rsq</span><span class="o">.</span><span class="n">ravel</span><span class="p">()[</span><span class="n">indx</span><span class="p">]</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">ravel</span><span class="p">()[</span><span class="n">indx</span><span class="p">]</span>
        <span class="n">cumflux</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

        <span class="c1"># Find the first value with cumflux &gt; 0.5 * flux</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">cumflux</span> <span class="o">&gt;</span> <span class="n">flux_frac</span> <span class="o">*</span> <span class="n">flux</span><span class="p">)</span>
        <span class="n">flux_k</span> <span class="o">=</span> <span class="n">cumflux</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">/</span> <span class="n">flux</span>  <span class="c1"># normalize to unit total flux</span>

        <span class="c1"># Interpolate (linearly) between this and the previous value.</span>
        <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">hlrsq</span> <span class="o">=</span> <span class="n">rsqf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">flux_frac</span> <span class="o">/</span> <span class="n">flux_k</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fkm1</span> <span class="o">=</span> <span class="n">cumflux</span><span class="p">[</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">flux</span>
            <span class="c1"># For brevity in the next formula:</span>
            <span class="n">fk</span> <span class="o">=</span> <span class="n">flux_k</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">flux_frac</span>
            <span class="n">hlrsq</span> <span class="o">=</span> <span class="p">(</span><span class="n">rsqf</span><span class="p">[</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">fk</span><span class="o">-</span><span class="n">f</span><span class="p">)</span> <span class="o">+</span> <span class="n">rsqf</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">f</span><span class="o">-</span><span class="n">fkm1</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="n">fk</span><span class="o">-</span><span class="n">fkm1</span><span class="p">)</span>

        <span class="c1"># This has all been done in pixels.  So normalize according to the pixel scale.</span>
        <span class="n">hlr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">hlrsq</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span>

        <span class="k">return</span> <span class="n">hlr</span></div>


<div class="viewcode-block" id="Image.calculateMomentRadius"><a class="viewcode-back" href="../../image_class.html#galsim.Image.calculateMomentRadius">[docs]</a>    <span class="k">def</span> <span class="nf">calculateMomentRadius</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">flux</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rtype</span><span class="o">=</span><span class="s1">&#39;det&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns an estimate of the radius based on unweighted second moments of a drawn object.</span>

<span class="sd">        This method is equivalent to `GSObject.calculateMomentRadius` when the object has already</span>
<span class="sd">        been drawn onto an image.  Note that the profile should be drawn using a method that</span>
<span class="sd">        integrates over pixels and does not add noise. (The default method=&#39;auto&#39; is acceptable.)</span>

<span class="sd">        If the image has a wcs other than a `PixelScale`, an AttributeError will be raised.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            center:     The position in pixels to use for the center, r=0.</span>
<span class="sd">                        [default: self.true_center]</span>
<span class="sd">            flux:       The total flux.  [default: sum(self.array)]</span>
<span class="sd">            rtype:      There are three options for this parameter:</span>

<span class="sd">                        - &#39;trace&#39; means return sqrt(T/2)</span>
<span class="sd">                        - &#39;det&#39; means return det(Q)^1/4</span>
<span class="sd">                        - &#39;both&#39; means return both: (sqrt(T/2), det(Q)^1/4)</span>

<span class="sd">                        [default: &#39;det&#39;]</span>

<span class="sd">        Returns:</span>
<span class="sd">            an estimate of the radius in physical units defined by the pixel scale</span>
<span class="sd">            (or both estimates if rtype == &#39;both&#39;).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">rtype</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;trace&#39;</span><span class="p">,</span> <span class="s1">&#39;det&#39;</span><span class="p">,</span> <span class="s1">&#39;both&#39;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">GalSimValueError</span><span class="p">(</span><span class="s2">&quot;Invalid rtype.&quot;</span><span class="p">,</span> <span class="n">rtype</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;trace&#39;</span><span class="p">,</span> <span class="s1">&#39;det&#39;</span><span class="p">,</span> <span class="s1">&#39;both&#39;</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">center</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">center</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">true_center</span>

        <span class="k">if</span> <span class="n">flux</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">flux</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

        <span class="c1"># Use radii at centers of pixels as approximation to the radial integral</span>
        <span class="n">x</span><span class="p">,</span><span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_pixel_centers</span><span class="p">()</span>
        <span class="n">x</span> <span class="o">-=</span> <span class="n">center</span><span class="o">.</span><span class="n">x</span>
        <span class="n">y</span> <span class="o">-=</span> <span class="n">center</span><span class="o">.</span><span class="n">y</span>

        <span class="k">if</span> <span class="n">rtype</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;trace&#39;</span><span class="p">,</span> <span class="s1">&#39;both&#39;</span><span class="p">):</span>
            <span class="c1"># Calculate trace measure:</span>
            <span class="n">rsq</span> <span class="o">=</span> <span class="n">x</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="o">*</span><span class="n">y</span>
            <span class="n">Irr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">rsq</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span> <span class="o">/</span> <span class="n">flux</span>

            <span class="c1"># This has all been done in pixels.  So normalize according to the pixel scale.</span>
            <span class="n">sigma_trace</span> <span class="o">=</span> <span class="p">(</span><span class="n">Irr</span><span class="o">/</span><span class="mf">2.</span><span class="p">)</span><span class="o">**</span><span class="mf">0.5</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span>

        <span class="k">if</span> <span class="n">rtype</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;det&#39;</span><span class="p">,</span> <span class="s1">&#39;both&#39;</span><span class="p">):</span>
            <span class="c1"># Calculate det measure:</span>
            <span class="n">Ixx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">x</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span> <span class="o">/</span> <span class="n">flux</span>
            <span class="n">Iyy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">y</span><span class="o">*</span><span class="n">y</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span> <span class="o">/</span> <span class="n">flux</span>
            <span class="n">Ixy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">y</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span> <span class="o">/</span> <span class="n">flux</span>

            <span class="c1"># This has all been done in pixels.  So normalize according to the pixel scale.</span>
            <span class="n">sigma_det</span> <span class="o">=</span> <span class="p">(</span><span class="n">Ixx</span><span class="o">*</span><span class="n">Iyy</span><span class="o">-</span><span class="n">Ixy</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mf">0.25</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span>

        <span class="k">if</span> <span class="n">rtype</span> <span class="o">==</span> <span class="s1">&#39;trace&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">sigma_trace</span>
        <span class="k">elif</span> <span class="n">rtype</span> <span class="o">==</span> <span class="s1">&#39;det&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">sigma_det</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">sigma_trace</span><span class="p">,</span> <span class="n">sigma_det</span></div>


<div class="viewcode-block" id="Image.calculateFWHM"><a class="viewcode-back" href="../../image_class.html#galsim.Image.calculateFWHM">[docs]</a>    <span class="k">def</span> <span class="nf">calculateFWHM</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">Imax</span><span class="o">=</span><span class="mf">0.</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the full-width half-maximum (FWHM) of a drawn object.</span>

<span class="sd">        This method is equivalent to `GSObject.calculateFWHM` when the object has already</span>
<span class="sd">        been drawn onto an image.  Note that the profile should be drawn using a method that</span>
<span class="sd">        does not integrate over pixels, so either &#39;sb&#39; or &#39;no_pixel&#39;.  Also, if there is a</span>
<span class="sd">        significant amount of noise in the image, this method may not work well.</span>

<span class="sd">        If the image has a wcs other than a `PixelScale`, an AttributeError will be raised.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            center:     The position in pixels to use for the center, r=0.</span>
<span class="sd">                        [default: self.true_center]</span>
<span class="sd">            Imax:       The maximum surface brightness.  [default: max(self.array)]</span>
<span class="sd">                        Note: If Imax is provided, and the maximum pixel value is larger than</span>
<span class="sd">                        this value, Imax will be updated to use the larger value.</span>

<span class="sd">        Returns:</span>
<span class="sd">            an estimate of the full-width half-maximum in physical units defined by the pixel scale.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">center</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">center</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">true_center</span>

        <span class="c1"># If the full image has a larger maximum, use that.</span>
        <span class="n">Imax2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">array</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">Imax2</span> <span class="o">&gt;</span> <span class="n">Imax</span><span class="p">:</span> <span class="n">Imax</span> <span class="o">=</span> <span class="n">Imax2</span>

        <span class="c1"># Use radii at centers of pixels.</span>
        <span class="n">x</span><span class="p">,</span><span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_pixel_centers</span><span class="p">()</span>
        <span class="n">x</span> <span class="o">-=</span> <span class="n">center</span><span class="o">.</span><span class="n">x</span>
        <span class="n">y</span> <span class="o">-=</span> <span class="n">center</span><span class="o">.</span><span class="n">y</span>
        <span class="n">rsq</span> <span class="o">=</span> <span class="n">x</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="o">*</span><span class="n">y</span>

        <span class="c1"># Sort by radius</span>
        <span class="n">indx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">rsq</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span>
        <span class="n">rsqf</span> <span class="o">=</span> <span class="n">rsq</span><span class="o">.</span><span class="n">ravel</span><span class="p">()[</span><span class="n">indx</span><span class="p">]</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">ravel</span><span class="p">()[</span><span class="n">indx</span><span class="p">]</span>

        <span class="c1"># Find the first value with I &lt; 0.5 * Imax</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">data</span> <span class="o">&lt;</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">Imax</span><span class="p">)</span>
        <span class="n">Ik</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">/</span> <span class="n">Imax</span>

        <span class="c1"># Interpolate (linearly) between this and the previous value.</span>
        <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">rsqhm</span> <span class="o">=</span> <span class="n">rsqf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="mf">0.5</span> <span class="o">/</span> <span class="n">Ik</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Ikm1</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">Imax</span>
            <span class="n">rsqhm</span> <span class="o">=</span> <span class="p">(</span><span class="n">rsqf</span><span class="p">[</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">Ik</span><span class="o">-</span><span class="mf">0.5</span><span class="p">)</span> <span class="o">+</span> <span class="n">rsqf</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="mf">0.5</span><span class="o">-</span><span class="n">Ikm1</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="n">Ik</span><span class="o">-</span><span class="n">Ikm1</span><span class="p">)</span>

        <span class="c1"># This has all been done in pixels.  So normalize according to the pixel scale.</span>
        <span class="n">fwhm</span> <span class="o">=</span> <span class="mf">2.</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">rsqhm</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span>

        <span class="k">return</span> <span class="n">fwhm</span></div>

    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="c1"># Note that numpy.array_equal can return True if the dtypes of the two arrays involved are</span>
        <span class="c1"># different, as long as the contents of the two arrays are logically the same.  For example:</span>
        <span class="c1">#</span>
        <span class="c1"># &gt;&gt;&gt; double_array = np.arange(1024).reshape(32, 32)*np.pi</span>
        <span class="c1"># &gt;&gt;&gt; int_array = np.arange(1024).reshape(32, 32)</span>
        <span class="c1"># &gt;&gt;&gt; assert galsim.ImageD(int_array) == galsim.ImageF(int_array) # passes</span>
        <span class="c1"># &gt;&gt;&gt; assert galsim.ImageD(double_array) == galsim.ImageF(double_array) # fails</span>

        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span> <span class="ow">is</span> <span class="n">other</span> <span class="ow">or</span>
                <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Image</span><span class="p">)</span> <span class="ow">and</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">bounds</span> <span class="ow">and</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">wcs</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">wcs</span> <span class="ow">and</span>
                 <span class="p">(</span><span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="o">.</span><span class="n">isDefined</span><span class="p">()</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">array</span><span class="p">,</span><span class="n">other</span><span class="o">.</span><span class="n">array</span><span class="p">))</span> <span class="ow">and</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">isconst</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">isconst</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span> <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__eq__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="c1"># Not immutable object.  So shouldn&#39;t be used as a hash.</span>
    <span class="fm">__hash__</span> <span class="o">=</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="_Image"><a class="viewcode-back" href="../../image_class.html#galsim._Image">[docs]</a><span class="k">def</span> <span class="nf">_Image</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">bounds</span><span class="p">,</span> <span class="n">wcs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Equivalent to ``Image(array, bounds, wcs)``, but without the overhead of sanity checks,</span>
<span class="sd">    and the other options for how to provide the arguments.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">Image</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="n">Image</span><span class="p">)</span>
    <span class="n">ret</span><span class="o">.</span><span class="n">wcs</span> <span class="o">=</span> <span class="n">wcs</span>
    <span class="n">ret</span><span class="o">.</span><span class="n">_dtype</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span>
    <span class="k">if</span> <span class="n">ret</span><span class="o">.</span><span class="n">_dtype</span> <span class="ow">in</span> <span class="n">Image</span><span class="o">.</span><span class="n">_alias_dtypes</span><span class="p">:</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">_dtype</span> <span class="o">=</span> <span class="n">Image</span><span class="o">.</span><span class="n">_alias_dtypes</span><span class="p">[</span><span class="n">ret</span><span class="o">.</span><span class="n">_dtype</span><span class="p">]</span>
        <span class="n">array</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">ret</span><span class="o">.</span><span class="n">_dtype</span><span class="p">)</span>
    <span class="n">ret</span><span class="o">.</span><span class="n">_array</span> <span class="o">=</span> <span class="n">array</span>
    <span class="n">ret</span><span class="o">.</span><span class="n">_bounds</span> <span class="o">=</span> <span class="n">bounds</span>
    <span class="k">return</span> <span class="n">ret</span></div>

<span class="c1"># These are essentially aliases for the regular Image with the correct dtype</span>
<div class="viewcode-block" id="ImageUS"><a class="viewcode-back" href="../../image_class.html#galsim.ImageUS">[docs]</a><span class="k">def</span> <span class="nf">ImageUS</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Alias for galsim.Image(..., dtype=numpy.uint16)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;dtype&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">uint16</span>
    <span class="k">return</span> <span class="n">Image</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="ImageUI"><a class="viewcode-back" href="../../image_class.html#galsim.ImageUI">[docs]</a><span class="k">def</span> <span class="nf">ImageUI</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Alias for galsim.Image(..., dtype=numpy.uint32)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;dtype&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">uint32</span>
    <span class="k">return</span> <span class="n">Image</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="ImageS"><a class="viewcode-back" href="../../image_class.html#galsim.ImageS">[docs]</a><span class="k">def</span> <span class="nf">ImageS</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Alias for galsim.Image(..., dtype=numpy.int16)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;dtype&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int16</span>
    <span class="k">return</span> <span class="n">Image</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="ImageI"><a class="viewcode-back" href="../../image_class.html#galsim.ImageI">[docs]</a><span class="k">def</span> <span class="nf">ImageI</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Alias for galsim.Image(..., dtype=numpy.int32)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;dtype&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span>
    <span class="k">return</span> <span class="n">Image</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="ImageF"><a class="viewcode-back" href="../../image_class.html#galsim.ImageF">[docs]</a><span class="k">def</span> <span class="nf">ImageF</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Alias for galsim.Image(..., dtype=numpy.float32)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;dtype&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span>
    <span class="k">return</span> <span class="n">Image</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="ImageD"><a class="viewcode-back" href="../../image_class.html#galsim.ImageD">[docs]</a><span class="k">def</span> <span class="nf">ImageD</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Alias for galsim.Image(..., dtype=numpy.float64)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;dtype&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span>
    <span class="k">return</span> <span class="n">Image</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="ImageCF"><a class="viewcode-back" href="../../image_class.html#galsim.ImageCF">[docs]</a><span class="k">def</span> <span class="nf">ImageCF</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Alias for galsim.Image(..., dtype=numpy.complex64)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;dtype&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">complex64</span>
    <span class="k">return</span> <span class="n">Image</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="ImageCD"><a class="viewcode-back" href="../../image_class.html#galsim.ImageCD">[docs]</a><span class="k">def</span> <span class="nf">ImageCD</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Alias for galsim.Image(..., dtype=numpy.complex128)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;dtype&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">complex128</span>
    <span class="k">return</span> <span class="n">Image</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<span class="c1">################################################################################################</span>
<span class="c1">#</span>
<span class="c1"># Now we have to make some modifications to the C++ layer objects.  Mostly adding some</span>
<span class="c1"># arithmetic functions, so they work more intuitively.</span>
<span class="c1">#</span>

<span class="c1"># Define a utility function to be used by the arithmetic functions below</span>
<span class="k">def</span> <span class="nf">check_image_consistency</span><span class="p">(</span><span class="n">im1</span><span class="p">,</span> <span class="n">im2</span><span class="p">,</span> <span class="n">integer</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">integer</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">im1</span><span class="o">.</span><span class="n">isinteger</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">GalSimValueError</span><span class="p">(</span><span class="s2">&quot;Image must have integer values.&quot;</span><span class="p">,</span><span class="n">im1</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">im2</span><span class="p">,</span> <span class="n">Image</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">im1</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">im2</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span> <span class="c1"># pragma: no cover  (covered, but codecov says it&#39;s not.)</span>
            <span class="k">raise</span> <span class="n">GalSimIncompatibleValuesError</span><span class="p">(</span> <span class="s2">&quot;Image shapes are inconsistent&quot;</span><span class="p">,</span> <span class="n">im1</span><span class="o">=</span><span class="n">im1</span><span class="p">,</span> <span class="n">im2</span><span class="o">=</span><span class="n">im2</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">integer</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">im2</span><span class="o">.</span><span class="n">isinteger</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">GalSimValueError</span><span class="p">(</span><span class="s2">&quot;Image must have integer values.&quot;</span><span class="p">,</span><span class="n">im2</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">Image_add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="n">check_image_consistency</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">array</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">other</span>
    <span class="k">return</span> <span class="n">_Image</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">array</span> <span class="o">+</span> <span class="n">a</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">wcs</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">Image_iadd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="n">check_image_consistency</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">array</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">dtype</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">other</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">dt</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">dtype</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">array</span><span class="p">[:,:]</span> <span class="o">+=</span> <span class="n">a</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">array</span><span class="p">[:,:]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">array</span> <span class="o">+</span> <span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">return</span> <span class="bp">self</span>

<span class="k">def</span> <span class="nf">Image_sub</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="n">check_image_consistency</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">array</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">other</span>
    <span class="k">return</span> <span class="n">_Image</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">array</span> <span class="o">-</span> <span class="n">a</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">wcs</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">Image_rsub</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">_Image</span><span class="p">(</span><span class="n">other</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">wcs</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">Image_isub</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="n">check_image_consistency</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">array</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">dtype</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">other</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">dt</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">dtype</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">array</span><span class="p">[:,:]</span> <span class="o">-=</span> <span class="n">a</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">array</span><span class="p">[:,:]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">array</span> <span class="o">-</span> <span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">return</span> <span class="bp">self</span>

<span class="k">def</span> <span class="nf">Image_mul</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="n">check_image_consistency</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">array</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">other</span>
    <span class="k">return</span> <span class="n">_Image</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">array</span> <span class="o">*</span> <span class="n">a</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">wcs</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">Image_imul</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="n">check_image_consistency</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">array</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">dtype</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">other</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">dt</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">dtype</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">array</span><span class="p">[:,:]</span> <span class="o">*=</span> <span class="n">a</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">array</span><span class="p">[:,:]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">array</span> <span class="o">*</span> <span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">return</span> <span class="bp">self</span>

<span class="k">def</span> <span class="nf">Image_div</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="n">check_image_consistency</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">array</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">other</span>
    <span class="k">return</span> <span class="n">_Image</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">array</span> <span class="o">/</span> <span class="n">a</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">wcs</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">Image_rdiv</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">_Image</span><span class="p">(</span><span class="n">other</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">wcs</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">Image_idiv</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="n">check_image_consistency</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">array</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">dtype</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">other</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">dt</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">dtype</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">isinteger</span><span class="p">:</span>
        <span class="c1"># if dtype is an integer type, then numpy doesn&#39;t allow true division /= to assign</span>
        <span class="c1"># back to an integer array.  So for integers (or mixed types), don&#39;t use /=.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">array</span><span class="p">[:,:]</span> <span class="o">/=</span> <span class="n">a</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">array</span><span class="p">[:,:]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">array</span> <span class="o">/</span> <span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">return</span> <span class="bp">self</span>

<span class="k">def</span> <span class="nf">Image_floordiv</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="n">check_image_consistency</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">integer</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">array</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">other</span>
    <span class="k">return</span> <span class="n">_Image</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">array</span> <span class="o">//</span> <span class="n">a</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">wcs</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">Image_rfloordiv</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="n">check_image_consistency</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">integer</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_Image</span><span class="p">(</span><span class="n">other</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">wcs</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">Image_ifloordiv</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="n">check_image_consistency</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">integer</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">array</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">dtype</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">other</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">dt</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">dtype</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">array</span><span class="p">[:,:]</span> <span class="o">//=</span> <span class="n">a</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">array</span><span class="p">[:,:]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">array</span> <span class="o">//</span> <span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">return</span> <span class="bp">self</span>

<span class="k">def</span> <span class="nf">Image_mod</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="n">check_image_consistency</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">integer</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">array</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">other</span>
    <span class="k">return</span> <span class="n">_Image</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">array</span> <span class="o">%</span> <span class="n">a</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">wcs</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">Image_rmod</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="n">check_image_consistency</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">integer</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_Image</span><span class="p">(</span><span class="n">other</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">wcs</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">Image_imod</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="n">check_image_consistency</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">integer</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">array</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">dtype</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">other</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">dt</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">dtype</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">array</span><span class="p">[:,:]</span> <span class="o">%=</span> <span class="n">a</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">array</span><span class="p">[:,:]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">array</span> <span class="o">%</span> <span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">return</span> <span class="bp">self</span>

<span class="k">def</span> <span class="nf">Image_pow</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">result</span> <span class="o">**=</span> <span class="n">other</span>
    <span class="k">return</span> <span class="n">result</span>

<span class="k">def</span> <span class="nf">Image_ipow</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Can only raise an image to a float or int power!&quot;</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">array</span><span class="p">[:,:]</span> <span class="o">**=</span> <span class="n">other</span>
    <span class="k">return</span> <span class="bp">self</span>

<span class="k">def</span> <span class="nf">Image_neg</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">result</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="k">return</span> <span class="n">result</span>

<span class="c1"># Define &amp;, ^ and | only for integer-type images</span>
<span class="k">def</span> <span class="nf">Image_and</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="n">check_image_consistency</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">integer</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">array</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">other</span>
    <span class="k">return</span> <span class="n">_Image</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">array</span> <span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">wcs</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">Image_iand</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="n">check_image_consistency</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">integer</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">array</span><span class="p">[:,:]</span> <span class="o">&amp;=</span> <span class="n">other</span><span class="o">.</span><span class="n">array</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">array</span><span class="p">[:,:]</span> <span class="o">&amp;=</span> <span class="n">other</span>
    <span class="k">return</span> <span class="bp">self</span>

<span class="k">def</span> <span class="nf">Image_xor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="n">check_image_consistency</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">integer</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">array</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">other</span>
    <span class="k">return</span> <span class="n">_Image</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">array</span> <span class="o">^</span> <span class="n">a</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">wcs</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">Image_ixor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="n">check_image_consistency</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">integer</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">array</span><span class="p">[:,:]</span> <span class="o">^=</span> <span class="n">other</span><span class="o">.</span><span class="n">array</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">array</span><span class="p">[:,:]</span> <span class="o">^=</span> <span class="n">other</span>
    <span class="k">return</span> <span class="bp">self</span>

<span class="k">def</span> <span class="nf">Image_or</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="n">check_image_consistency</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">integer</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">array</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">other</span>
    <span class="k">return</span> <span class="n">_Image</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">array</span> <span class="o">|</span> <span class="n">a</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">wcs</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">Image_ior</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="n">check_image_consistency</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">integer</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">array</span><span class="p">[:,:]</span> <span class="o">|=</span> <span class="n">other</span><span class="o">.</span><span class="n">array</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">array</span><span class="p">[:,:]</span> <span class="o">|=</span> <span class="n">other</span>
    <span class="k">return</span> <span class="bp">self</span>

<span class="c1"># inject the arithmetic operators as methods of the Image class:</span>
<span class="n">Image</span><span class="o">.</span><span class="fm">__add__</span> <span class="o">=</span> <span class="n">Image_add</span>
<span class="n">Image</span><span class="o">.</span><span class="fm">__radd__</span> <span class="o">=</span> <span class="n">Image_add</span>
<span class="n">Image</span><span class="o">.</span><span class="fm">__iadd__</span> <span class="o">=</span> <span class="n">Image_iadd</span>
<span class="n">Image</span><span class="o">.</span><span class="fm">__sub__</span> <span class="o">=</span> <span class="n">Image_sub</span>
<span class="n">Image</span><span class="o">.</span><span class="fm">__rsub__</span> <span class="o">=</span> <span class="n">Image_rsub</span>
<span class="n">Image</span><span class="o">.</span><span class="fm">__isub__</span> <span class="o">=</span> <span class="n">Image_isub</span>
<span class="n">Image</span><span class="o">.</span><span class="fm">__mul__</span> <span class="o">=</span> <span class="n">Image_mul</span>
<span class="n">Image</span><span class="o">.</span><span class="fm">__rmul__</span> <span class="o">=</span> <span class="n">Image_mul</span>
<span class="n">Image</span><span class="o">.</span><span class="fm">__imul__</span> <span class="o">=</span> <span class="n">Image_imul</span>
<span class="n">Image</span><span class="o">.</span><span class="n">__div__</span> <span class="o">=</span> <span class="n">Image_div</span>
<span class="n">Image</span><span class="o">.</span><span class="n">__rdiv__</span> <span class="o">=</span> <span class="n">Image_rdiv</span>
<span class="n">Image</span><span class="o">.</span><span class="fm">__truediv__</span> <span class="o">=</span> <span class="n">Image_div</span>
<span class="n">Image</span><span class="o">.</span><span class="fm">__rtruediv__</span> <span class="o">=</span> <span class="n">Image_rdiv</span>
<span class="n">Image</span><span class="o">.</span><span class="n">__idiv__</span> <span class="o">=</span> <span class="n">Image_idiv</span>
<span class="n">Image</span><span class="o">.</span><span class="fm">__itruediv__</span> <span class="o">=</span> <span class="n">Image_idiv</span>
<span class="n">Image</span><span class="o">.</span><span class="fm">__mod__</span> <span class="o">=</span> <span class="n">Image_mod</span>
<span class="n">Image</span><span class="o">.</span><span class="fm">__rmod__</span> <span class="o">=</span> <span class="n">Image_rmod</span>
<span class="n">Image</span><span class="o">.</span><span class="fm">__imod__</span> <span class="o">=</span> <span class="n">Image_imod</span>
<span class="n">Image</span><span class="o">.</span><span class="fm">__floordiv__</span> <span class="o">=</span> <span class="n">Image_floordiv</span>
<span class="n">Image</span><span class="o">.</span><span class="fm">__rfloordiv__</span> <span class="o">=</span> <span class="n">Image_rfloordiv</span>
<span class="n">Image</span><span class="o">.</span><span class="fm">__ifloordiv__</span> <span class="o">=</span> <span class="n">Image_ifloordiv</span>
<span class="n">Image</span><span class="o">.</span><span class="fm">__ipow__</span> <span class="o">=</span> <span class="n">Image_ipow</span>
<span class="n">Image</span><span class="o">.</span><span class="fm">__pow__</span> <span class="o">=</span> <span class="n">Image_pow</span>
<span class="n">Image</span><span class="o">.</span><span class="fm">__neg__</span> <span class="o">=</span> <span class="n">Image_neg</span>
<span class="n">Image</span><span class="o">.</span><span class="fm">__and__</span> <span class="o">=</span> <span class="n">Image_and</span>
<span class="n">Image</span><span class="o">.</span><span class="fm">__xor__</span> <span class="o">=</span> <span class="n">Image_xor</span>
<span class="n">Image</span><span class="o">.</span><span class="fm">__or__</span> <span class="o">=</span> <span class="n">Image_or</span>
<span class="n">Image</span><span class="o">.</span><span class="fm">__rand__</span> <span class="o">=</span> <span class="n">Image_and</span>
<span class="n">Image</span><span class="o">.</span><span class="fm">__rxor__</span> <span class="o">=</span> <span class="n">Image_xor</span>
<span class="n">Image</span><span class="o">.</span><span class="fm">__ror__</span> <span class="o">=</span> <span class="n">Image_or</span>
<span class="n">Image</span><span class="o">.</span><span class="fm">__iand__</span> <span class="o">=</span> <span class="n">Image_iand</span>
<span class="n">Image</span><span class="o">.</span><span class="fm">__ixor__</span> <span class="o">=</span> <span class="n">Image_ixor</span>
<span class="n">Image</span><span class="o">.</span><span class="fm">__ior__</span> <span class="o">=</span> <span class="n">Image_ior</span>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, GalSim-developers

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>