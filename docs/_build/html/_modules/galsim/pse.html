<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>galsim.pse &mdash; GalSim 2.6.3 documentation</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/sphinx_highlight.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            GalSim
          </a>
              <div class="version">
                2.6
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../overview.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../install.html">Installation Instructions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tutorials.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../image.html">Images and Related Concepts</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../sb.html">Surface Brightness Profiles</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../chromatic.html">Wavelength-dependent Profiles</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../units.html">Units</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../wcs.html">World Coordinate Systems</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../random.html">Noise and Random Values</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../wl.html">Weak Lensing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../photon.html">Photon Shooting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../utilities.html">Helper Functions and Classes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../errors.html">Errors and Warnings</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../config.html">The Config Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../hsm.html">The HSM Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../des.html">The DES Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../roman.html">The Roman Space Telescope Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../cpp.html">C++ Layer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../shared.html">Shared Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../history.html">Revision History</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">GalSim</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">galsim.pse</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for galsim.pse</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright (c) 2012-2023 by the GalSim developers team on GitHub</span>
<span class="c1"># https://github.com/GalSim-developers</span>
<span class="c1">#</span>
<span class="c1"># This file is part of GalSim: The modular galaxy image simulation toolkit.</span>
<span class="c1"># https://github.com/GalSim-developers/GalSim</span>
<span class="c1">#</span>
<span class="c1"># GalSim is free software: redistribution and use in source and binary forms,</span>
<span class="c1"># with or without modification, are permitted provided that the following</span>
<span class="c1"># conditions are met:</span>
<span class="c1">#</span>
<span class="c1"># 1. Redistributions of source code must retain the above copyright notice, this</span>
<span class="c1">#    list of conditions, and the disclaimer given in the accompanying LICENSE</span>
<span class="c1">#    file.</span>
<span class="c1"># 2. Redistributions in binary form must reproduce the above copyright notice,</span>
<span class="c1">#    this list of conditions, and the disclaimer given in the documentation</span>
<span class="c1">#    and/or other materials provided with the distribution.</span>
<span class="c1">#</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Module containing code for estimating shear power spectra from shears at gridded positions.</span>

<span class="sd">The code below was developed largely by Joe Zuntz and tweaked by assorted GalSim</span>
<span class="sd">developers.  This development and testing took place in a separate (private) repository before the</span>
<span class="sd">code was moved into the GalSim repository, but there are some demonstrations of the performance of</span>
<span class="sd">this code in devel/modules/lensing_engine.pdf</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">sys</span>

<span class="kn">from</span> <span class="nn">.errors</span> <span class="kn">import</span> <span class="n">GalSimError</span><span class="p">,</span> <span class="n">GalSimValueError</span><span class="p">,</span> <span class="n">GalSimIncompatibleValuesError</span>
<span class="kn">from</span> <span class="nn">.table</span> <span class="kn">import</span> <span class="n">LookupTable</span>


<div class="viewcode-block" id="PowerSpectrumEstimator"><a class="viewcode-back" href="../../pse.html#galsim.pse.PowerSpectrumEstimator">[docs]</a><span class="k">class</span> <span class="nc">PowerSpectrumEstimator</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Class for estimating the shear power spectrum from gridded shears.</span>

<span class="sd">    This class stores all the data used in power spectrum estimation that is fixed with the geometry</span>
<span class="sd">    of the problem - the binning and spin weighting factors.</span>

<span class="sd">    The only public method is estimate(), which is called with 2D ``g1`` and ``g2`` arrays on a</span>
<span class="sd">    square grid.  It assumes the flat sky approximation (where ``ell`` and ``k`` are</span>
<span class="sd">    interchangeable), and rebins the observed ell modes into a user-defined number of logarithimic</span>
<span class="sd">    bins in ell.  Given that the grid parameters are precomputed and stored when the</span>
<span class="sd">    `PowerSpectrumEstimator` is initialized, computation of the PS for multiple sets of shears</span>
<span class="sd">    corresponding to the same grid setup can proceed more rapidly than if everything had to be</span>
<span class="sd">    recomputed each time.</span>

<span class="sd">    Below is an example of how to use this code (relying on GalSim to provide the arrays of g1 and</span>
<span class="sd">    g2, though that is by no means required, and assuming that the user is sitting in the examples/</span>
<span class="sd">    directory)::</span>

<span class="sd">        &gt;&gt;&gt; grid_size = 10.  # Define the total grid extent, in degrees</span>
<span class="sd">        &gt;&gt;&gt; ngrid = 100      # Define the number of grid points in each dimension: (ngrid x ngrid)</span>
<span class="sd">        &gt;&gt;&gt; n_ell = 15       # Choose the number of logarithmic bins in ell or k for outputs</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Define a lookup-table for the power spectrum as a function of k based on the outputs</span>
<span class="sd">        &gt;&gt;&gt; # of iCosmo (see demo11.py for more description of how this was generated).</span>
<span class="sd">        &gt;&gt;&gt; my_tab = galsim.LookupTable(file=&#39;data/cosmo-fid.zmed1.00.out&#39;)</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Generate a galsim.PowerSpectrum with this P(k), noting the units.</span>
<span class="sd">        &gt;&gt;&gt; my_ps = galsim.PowerSpectrum(my_tab, units=galsim.radians)</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Build a grid of shear values with the desired parameters.</span>
<span class="sd">        &gt;&gt;&gt; g1, g2 = my_ps.buildGrid(grid_spacing=grid_size/ngrid, ngrid=ngrid,</span>
<span class="sd">        ...                          units=galsim.degrees)</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Initialize a PowerSpectrumEstimator with the chosen grid geometry and number of ell</span>
<span class="sd">        &gt;&gt;&gt; # bins. Note that these values are actually the default, so we didn&#39;t technically have</span>
<span class="sd">        &gt;&gt;&gt; # to specifythem.</span>
<span class="sd">        &gt;&gt;&gt; my_pse = galsim.pse.PowerSpectrumEstimator(ngrid, grid_size, n_ell)</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Estimate the power based on this set of g1, g2.  If we get another set of shears for</span>
<span class="sd">        &gt;&gt;&gt; # the same grid geometry, we can reuse the same PowerSpectrumEstimator object.</span>
<span class="sd">        &gt;&gt;&gt; ell, P_e, P_b, P_eb = my_pse.estimate(g1, g2)</span>

<span class="sd">    The output NumPy arrays ``ell``, ``P_e``, ``P_b``, and ``P_eb`` contain the effective ell</span>
<span class="sd">    value, the E-mode auto-power spectrum, the B-mode auto-power spectrum, and the EB cross-power</span>
<span class="sd">    spectrum.  The units are inverse radians for ell, and radians^2 for the output power spectra.</span>

<span class="sd">    Some important notes:</span>

<span class="sd">    1) Power spectrum estimation requires a weight function which decides how the averaging is done</span>
<span class="sd">       across ell within each bin.  By default that weighting is flat in ell using an analytic</span>
<span class="sd">       calculation of the area in ell space, but this is easy to change with the ``_bin_power``</span>
<span class="sd">       function.  (Note this area averaged bin weighting is only approximate for the higher</span>
<span class="sd">       frequency bins in which the lower ``ell`` edge is greater than ``pi * ngrid / grid_size``,</span>
<span class="sd">       due to the annular ``ell`` region being cut off by the square grid edges beyond this value.)</span>
<span class="sd">       A keyword allows for weighting by the power itself.</span>
<span class="sd">    2) This is the power spectrum of the gridded *data*, not the underlying field - we do not</span>
<span class="sd">       account for the effects of the finite grid (basically, ignoring all the reasons why power</span>
<span class="sd">       spectrum estimation is hard - see devel/modules/lensing_engine.pdf in the GalSim repository).</span>
<span class="sd">       Users must account for the contribution of noise in ``g1``, ``g2`` and any masking.</span>
<span class="sd">    3) The binning is currently fixed as uniform in log(ell).</span>
<span class="sd">    4) The code for this class uses the notation of the GREAT10 handbook (Kitching et al. 2011,</span>
<span class="sd">       http://dx.doi.org/10.1214/11-AOAS484), equations 17-21.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">sky_size_deg</span><span class="o">=</span><span class="mf">10.</span><span class="p">,</span> <span class="n">nbin</span><span class="o">=</span><span class="mi">15</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a PowerSpectrumEstimator object given some grid parameters.</span>

<span class="sd">        This constructor precomputes some numbers related to the grid geometry, so the same</span>
<span class="sd">        PowerSpectrumEstimator can be used to estimate the power spectrum quickly for many sets of</span>
<span class="sd">        shears at gridded positions.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            N:              The number of pixels along each side of the grid. [default: 100]</span>
<span class="sd">            sky_size_deg:   The total grid width (in one dimension) in degrees. [default: 10]</span>
<span class="sd">            nbin:           The number of evenly-spaced logarithmic ``ell`` bins to use for</span>
<span class="sd">                            estimating the power spectrum. [default: 15]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Set up the scales of the sky and pixels</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">=</span> <span class="n">N</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sky_size_deg</span> <span class="o">=</span> <span class="n">sky_size_deg</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nbin</span> <span class="o">=</span> <span class="n">nbin</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sky_size</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">sky_size_deg</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sky_size</span> <span class="o">/</span> <span class="n">N</span>

        <span class="c1"># Define the possible ell range, the bin edges and effective ell values.</span>
        <span class="c1"># This is necessary for binning the power spectrum in ell.</span>
        <span class="n">lmin</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">sky_size</span>
        <span class="n">lmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">2.</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">dx</span> <span class="c1"># in 2 dimensions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bin_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logspace</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">lmin</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">lmax</span><span class="p">),</span> <span class="n">nbin</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1"># By default, report an area-averaged value of ell, which should be fine if there is</span>
        <span class="c1"># no weighting (in which case it&#39;s recomputed) and if there are many ell modes in</span>
        <span class="c1"># each bin.  The latter assumption is most likely to break down at low ell.  Note also that</span>
        <span class="c1"># at high ell when the lower ell edge is greater than pi * ngrid / grid_size, due to the</span>
        <span class="c1"># annular ell region being cut off by the square grid edges beyond this value, this annular</span>
        <span class="c1"># average is only approximate.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ell</span> <span class="o">=</span> <span class="p">(</span><span class="mf">2.</span><span class="o">/</span><span class="mf">3.</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">**</span><span class="mi">3</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span> \
                                   <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

        <span class="c1"># Precompute and store two useful factors, both in the form of 2D grids in Fourier space.</span>
        <span class="c1"># These are the lengths of the wavevector |ell| for each point in the space, and the complex</span>
        <span class="c1"># valued spin-weighting that takes the complex shear fields -&gt; E,B</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">l_abs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">eb_rot</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_generate_eb_rotation</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;galsim.pse.PowerSpectrumEstimator(N=</span><span class="si">%r</span><span class="s2">, sky_size_deg=</span><span class="si">%r</span><span class="s2">, nbin=</span><span class="si">%r</span><span class="s2">)&quot;</span><span class="o">%</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sky_size_deg</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nbin</span><span class="p">)</span>
    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span> <span class="ow">is</span> <span class="n">other</span> <span class="ow">or</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="nb">repr</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
    <span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span> <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__eq__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="nb">hash</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_generate_eb_rotation</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Set up the Fourier space grid lx, ly.</span>
        <span class="n">ell</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftfreq</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dx</span><span class="p">)</span>
        <span class="n">lx</span><span class="p">,</span> <span class="n">ly</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">ell</span><span class="p">,</span><span class="n">ell</span><span class="p">)</span>

        <span class="c1"># Now compute the lengths and angles of the ell vectors.</span>
        <span class="n">l_sq</span> <span class="o">=</span> <span class="n">lx</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">ly</span><span class="o">**</span><span class="mi">2</span>

        <span class="c1"># Compute exp(-2i psi) where psi = atan2(ly,lx)</span>
        <span class="n">l_sq</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># Avoid division by 0</span>
        <span class="n">expm2ipsi</span> <span class="o">=</span> <span class="p">(</span><span class="n">lx</span> <span class="o">-</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">ly</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="n">l_sq</span>
        <span class="n">l_abs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">l_sq</span><span class="p">)</span>
        <span class="n">l_abs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># Go back to correct value at 0,0.</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">lx</span> <span class="o">=</span> <span class="n">lx</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ly</span> <span class="o">=</span> <span class="n">ly</span>

        <span class="k">return</span> <span class="n">l_abs</span><span class="p">,</span> <span class="n">expm2ipsi</span>

    <span class="k">def</span> <span class="nf">_bin_power</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">ell_weight</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1"># This little utility function bins a 2D C^{E/B, E/B}_{ell} based on |ell|.  The use of</span>
        <span class="c1"># histogram is a little hack, but is quite convenient since it means everything is done in C</span>
        <span class="c1"># so it is very fast. The first call to `histogram` just returns an array over the</span>
        <span class="c1"># logarithmic ell bins of</span>
        <span class="c1"># sum_{|ell| in bin} weight(|ell|)*C_{ell_x,ell_y}</span>
        <span class="c1"># and the second call returns</span>
        <span class="c1"># sum_{|ell| in bin} weight(|ell|).</span>
        <span class="c1"># Thus, the ratio is just the mean power in the bin.  If `ell_weight` is None, then weight=1</span>
        <span class="c1"># for all ell, corresponding to a simple averaging process.  If `ell_weight` is not None,</span>
        <span class="c1"># then some non-flat weighting scheme is used for averaging over the ell values within a</span>
        <span class="c1"># bin.</span>
        <span class="k">if</span> <span class="n">ell_weight</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ell_weight</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">ell_weight</span><span class="p">)</span>
            <span class="n">P</span><span class="p">,</span><span class="n">_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">l_abs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">C</span><span class="o">*</span><span class="n">ell_weight</span><span class="p">)</span>
            <span class="n">count</span><span class="p">,</span><span class="n">_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">l_abs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">ell_weight</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">P</span><span class="p">,</span><span class="n">_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">l_abs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">C</span><span class="p">)</span>
            <span class="n">count</span><span class="p">,</span><span class="n">_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">l_abs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="k">raise</span> <span class="n">GalSimError</span><span class="p">(</span><span class="s2">&quot;Logarithmic bin definition resulted in &gt;=1 empty bin!&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">P</span><span class="o">/</span><span class="n">count</span>

<div class="viewcode-block" id="PowerSpectrumEstimator.estimate"><a class="viewcode-back" href="../../pse.html#galsim.pse.PowerSpectrumEstimator.estimate">[docs]</a>    <span class="k">def</span> <span class="nf">estimate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">g1</span><span class="p">,</span> <span class="n">g2</span><span class="p">,</span> <span class="n">weight_EE</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">weight_BB</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">theory_func</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute the EE, BB, and EB power spectra of two 2D arrays ``g1`` and ``g2``.</span>

<span class="sd">        For example usage, see the docstring for the `PowerSpectrumEstimator` class.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            g1:             The shear component g1 as a square 2D NumPy array.</span>
<span class="sd">            g2:             The shear component g2 as a square 2D NumPy array.</span>
<span class="sd">            weight_EE:      If True, then the E auto-power spectrum is re-computed weighting by</span>
<span class="sd">                            the power within each logarithmically-spaced ell bin. [default: False]</span>
<span class="sd">            weight_BB:      If True, then the B auto-power spectrum is re-computed weighting by</span>
<span class="sd">                            the power within each logarithmically-spaced ell bin. [default: False]</span>
<span class="sd">            theory_func:    An optional callable function that can be used to get an idealized</span>
<span class="sd">                            value of power at each point on the grid, and then see what results</span>
<span class="sd">                            it gives for our chosen ell binning. [default: None]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Check for the expected square geometry consistent with the previously-defined grid size.</span>
        <span class="k">if</span> <span class="n">g1</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">g2</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">GalSimIncompatibleValuesError</span><span class="p">(</span>
                <span class="s2">&quot;g1 and g2 grids do not have the same shape.&quot;</span><span class="p">,</span> <span class="n">g1</span><span class="o">=</span><span class="n">g1</span><span class="p">,</span> <span class="n">g2</span><span class="o">=</span><span class="n">g2</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">g1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">g1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="n">GalSimValueError</span><span class="p">(</span><span class="s2">&quot;Input shear arrays must be square.&quot;</span><span class="p">,</span> <span class="n">g1</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">g1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">GalSimValueError</span><span class="p">(</span><span class="s2">&quot;Input shear array size is not correct!&quot;</span><span class="p">,</span> <span class="n">g1</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">weight_EE</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">weight_BB</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Input weight flags must be bools!&quot;</span><span class="p">)</span>

        <span class="c1"># Transform g1+j*g2 into Fourier space and rotate into E-B, then separate into E and B.</span>
        <span class="n">EB</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifft2</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eb_rot</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft2</span><span class="p">(</span><span class="n">g1</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">g2</span><span class="p">))</span>
        <span class="n">E</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft2</span><span class="p">(</span><span class="n">EB</span><span class="o">.</span><span class="n">real</span><span class="p">)</span>
        <span class="n">B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft2</span><span class="p">(</span><span class="n">EB</span><span class="o">.</span><span class="n">imag</span><span class="p">)</span>

        <span class="c1"># Use the internal function above to bin, and account for the normalization of the FFT.</span>
        <span class="c1"># Recall that power has units of angle^2, which is the reason why we need a self.dx^2 in the</span>
        <span class="c1"># equations below in addition to the standard 1/N^2 coming from the FFTs.</span>
        <span class="n">C_EE</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bin_power</span><span class="p">(</span><span class="n">E</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">conjugate</span><span class="p">(</span><span class="n">E</span><span class="p">))</span><span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dx</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">C_BB</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bin_power</span><span class="p">(</span><span class="n">B</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">conjugate</span><span class="p">(</span><span class="n">B</span><span class="p">))</span><span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dx</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">C_EB</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bin_power</span><span class="p">(</span><span class="n">E</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">conjugate</span><span class="p">(</span><span class="n">B</span><span class="p">))</span><span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dx</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>

        <span class="k">if</span> <span class="n">theory_func</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># theory_func needs to be a callable function</span>
            <span class="n">C_theory_ell</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">l_abs</span><span class="p">)</span>
            <span class="n">C_theory_ell</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">l_abs</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">theory_func</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">l_abs</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">l_abs</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">C_theory</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bin_power</span><span class="p">(</span><span class="n">C_theory_ell</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">weight_EE</span> <span class="ow">or</span> <span class="n">weight_BB</span><span class="p">:</span>
            <span class="c1"># Need to interpolate C_EE to values of self.l_abs.  A bit of kludginess as we go off</span>
            <span class="c1"># the end of our final ell grid...</span>
            <span class="n">new_ell</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ell</span><span class="p">)</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">new_ell</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ell</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ell</span>
            <span class="n">new_ell</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ell</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">10.</span><span class="o">*</span><span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ell</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">theory_func</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">C_theory</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bin_power</span><span class="p">(</span><span class="n">C_theory_ell</span><span class="p">,</span> <span class="n">ell_weight</span><span class="o">=</span><span class="n">C_theory_ell</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">weight_EE</span><span class="p">:</span>
            <span class="n">new_CEE</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">new_ell</span><span class="p">)</span>
            <span class="n">new_CEE</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ell</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">C_EE</span><span class="p">)</span>
            <span class="n">new_CEE</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ell</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_CEE</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ell</span><span class="p">)]</span>
            <span class="n">EE_table</span> <span class="o">=</span> <span class="n">LookupTable</span><span class="p">(</span><span class="n">new_ell</span><span class="p">,</span> <span class="n">new_CEE</span><span class="p">)</span>
            <span class="n">ell_weight</span> <span class="o">=</span> <span class="n">EE_table</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">l_abs</span><span class="p">)</span>
            <span class="n">C_EE</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bin_power</span><span class="p">(</span><span class="n">E</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">conjugate</span><span class="p">(</span><span class="n">E</span><span class="p">),</span> <span class="n">ell_weight</span><span class="o">=</span><span class="n">ell_weight</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dx</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>

        <span class="k">if</span> <span class="n">weight_BB</span><span class="p">:</span>
            <span class="n">new_CBB</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">new_ell</span><span class="p">)</span>
            <span class="n">new_CBB</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ell</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">C_BB</span><span class="p">)</span>
            <span class="n">new_CBB</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ell</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_CBB</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ell</span><span class="p">)]</span>
            <span class="n">BB_table</span> <span class="o">=</span> <span class="n">LookupTable</span><span class="p">(</span><span class="n">new_ell</span><span class="p">,</span> <span class="n">new_CBB</span><span class="p">)</span>
            <span class="n">ell_weight</span> <span class="o">=</span> <span class="n">BB_table</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">l_abs</span><span class="p">)</span>
            <span class="n">C_BB</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bin_power</span><span class="p">(</span><span class="n">B</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">conjugate</span><span class="p">(</span><span class="n">B</span><span class="p">),</span> <span class="n">ell_weight</span><span class="o">=</span><span class="n">ell_weight</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dx</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>

        <span class="c1"># For convenience, return ell (copied in case the user messes with it) and the three power</span>
        <span class="c1"># spectra. If the user requested a binned theoretical spectrum, return that as well.</span>
        <span class="k">if</span> <span class="n">theory_func</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ell</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">C_EE</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">C_BB</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">C_EB</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ell</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">C_EE</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">C_BB</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">C_EB</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">C_theory</span><span class="p">)</span></div></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, GalSim-developers.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>