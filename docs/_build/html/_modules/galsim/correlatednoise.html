<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>galsim.correlatednoise &mdash; GalSim 2.6.0 documentation</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/sphinx_highlight.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            GalSim
          </a>
              <div class="version">
                2.6
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../overview.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../install.html">Installation Instructions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tutorials.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../image.html">Images and Related Concepts</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../sb.html">Surface Brightness Profiles</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../chromatic.html">Wavelength-dependent Profiles</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../units.html">Units</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../wcs.html">World Coordinate Systems</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../random.html">Noise and Random Values</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../wl.html">Weak Lensing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../photon.html">Photon Shooting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../utilities.html">Helper Functions and Classes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../errors.html">Errors and Warnings</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../config.html">The Config Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../hsm.html">The HSM Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../des.html">The DES Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../roman.html">The Roman Space Telescope Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../cpp.html">C++ Layer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../shared.html">Shared Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../history.html">Revision History</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">GalSim</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">galsim.correlatednoise</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for galsim.correlatednoise</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright (c) 2012-2023 by the GalSim developers team on GitHub</span>
<span class="c1"># https://github.com/GalSim-developers</span>
<span class="c1">#</span>
<span class="c1"># This file is part of GalSim: The modular galaxy image simulation toolkit.</span>
<span class="c1"># https://github.com/GalSim-developers/GalSim</span>
<span class="c1">#</span>
<span class="c1"># GalSim is free software: redistribution and use in source and binary forms,</span>
<span class="c1"># with or without modification, are permitted provided that the following</span>
<span class="c1"># conditions are met:</span>
<span class="c1">#</span>
<span class="c1"># 1. Redistributions of source code must retain the above copyright notice, this</span>
<span class="c1">#    list of conditions, and the disclaimer given in the accompanying LICENSE</span>
<span class="c1">#    file.</span>
<span class="c1"># 2. Redistributions in binary form must reproduce the above copyright notice,</span>
<span class="c1">#    this list of conditions, and the disclaimer given in the documentation</span>
<span class="c1">#    and/or other materials provided with the distribution.</span>
<span class="c1">#</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span> <span class="s1">&#39;BaseCorrelatedNoise&#39;</span><span class="p">,</span> <span class="s1">&#39;CorrelatedNoise&#39;</span><span class="p">,</span> <span class="s1">&#39;UncorrelatedNoise&#39;</span><span class="p">,</span>
            <span class="s1">&#39;getCOSMOSNoise&#39;</span><span class="p">,</span> <span class="s1">&#39;CovarianceSpectrum&#39;</span><span class="p">,</span> <span class="p">]</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">math</span>

<span class="kn">from</span> <span class="nn">.image</span> <span class="kn">import</span> <span class="n">Image</span>
<span class="kn">from</span> <span class="nn">.random</span> <span class="kn">import</span> <span class="n">BaseDeviate</span>
<span class="kn">from</span> <span class="nn">.gsparams</span> <span class="kn">import</span> <span class="n">GSParams</span>
<span class="kn">from</span> <span class="nn">.wcs</span> <span class="kn">import</span> <span class="n">PixelScale</span><span class="p">,</span> <span class="n">BaseWCS</span><span class="p">,</span> <span class="n">compatible</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">utilities</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">fits</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">meta_data</span>
<span class="kn">from</span> <span class="nn">.errors</span> <span class="kn">import</span> <span class="n">GalSimError</span><span class="p">,</span> <span class="n">GalSimValueError</span><span class="p">,</span> <span class="n">GalSimRangeError</span><span class="p">,</span> <span class="n">GalSimUndefinedBoundsError</span>
<span class="kn">from</span> <span class="nn">.errors</span> <span class="kn">import</span> <span class="n">GalSimIncompatibleValuesError</span><span class="p">,</span> <span class="n">galsim_warn</span>
<span class="kn">from</span> <span class="nn">.interpolant</span> <span class="kn">import</span> <span class="n">Linear</span>
<span class="kn">from</span> <span class="nn">.position</span> <span class="kn">import</span> <span class="n">_PositionD</span>
<span class="kn">from</span> <span class="nn">.angle</span> <span class="kn">import</span> <span class="n">radians</span>
<span class="kn">from</span> <span class="nn">.random</span> <span class="kn">import</span> <span class="n">GaussianDeviate</span>
<span class="kn">from</span> <span class="nn">.box</span> <span class="kn">import</span> <span class="n">Pixel</span>
<span class="kn">from</span> <span class="nn">.convolve</span> <span class="kn">import</span> <span class="n">Convolve</span><span class="p">,</span> <span class="n">AutoCorrelate</span><span class="p">,</span> <span class="n">AutoConvolve</span>
<span class="kn">from</span> <span class="nn">.interpolatedimage</span> <span class="kn">import</span> <span class="n">InterpolatedImage</span><span class="p">,</span> <span class="n">InterpolatedKImage</span>


<span class="k">def</span> <span class="nf">whitenNoise</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">noise</span><span class="p">):</span>
    <span class="c1"># This will be inserted into the Image class as a method.  So self = image.</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Whiten the noise in the image assuming that the noise currently in the image can be described</span>
<span class="sd">    by the `BaseCorrelatedNoise` object ``noise``.  See `BaseCorrelatedNoise.whitenImage` for more</span>
<span class="sd">    details of how this method works.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        noise:      The `BaseCorrelatedNoise` model to use when figuring out how much noise to add</span>
<span class="sd">                    to make the final noise white.</span>

<span class="sd">    Returns:</span>
<span class="sd">        the theoretically calculated variance of the combined noise fields in the updated image.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">noise</span><span class="o">.</span><span class="n">whitenImage</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">symmetrizeNoise</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">noise</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">4</span><span class="p">):</span>
    <span class="c1"># This will be inserted into the Image class as a method.  So self = image.</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Impose N-fold symmetry (where N=``order`` is an even integer &gt;=4) on the noise in a square</span>
<span class="sd">    image assuming that the noise currently in the image can be described by the</span>
<span class="sd">    `BaseCorrelatedNoise` object ``noise``.  See `BaseCorrelatedNoise.symmetrizeImage` for more</span>
<span class="sd">    details of how this method works.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        noise:      The `BaseCorrelatedNoise` model to use when figuring out how much noise to add</span>
<span class="sd">                    to make the final noise have symmetry at the desired order.</span>
<span class="sd">        order:      Desired symmetry order.  Must be an even integer larger than 2.</span>
<span class="sd">                    [default: 4]</span>

<span class="sd">    Returns:</span>
<span class="sd">        the theoretically calculated variance of the combined noise fields in the updated image.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">noise</span><span class="o">.</span><span class="n">symmetrizeImage</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">)</span>

<span class="c1"># Now inject whitenNoise and symmetrizeNoise as methods of the Image class.</span>
<span class="n">Image</span><span class="o">.</span><span class="n">whitenNoise</span> <span class="o">=</span> <span class="n">whitenNoise</span>
<span class="n">Image</span><span class="o">.</span><span class="n">symmetrizeNoise</span> <span class="o">=</span> <span class="n">symmetrizeNoise</span>

<div class="viewcode-block" id="BaseCorrelatedNoise"><a class="viewcode-back" href="../../corr_noise.html#galsim.BaseCorrelatedNoise">[docs]</a><span class="k">class</span> <span class="nc">BaseCorrelatedNoise</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A Base Class describing 2D correlated Gaussian random noise fields.</span>

<span class="sd">    A BaseCorrelatedNoise will not generally be instantiated directly.  This is recommended as the</span>
<span class="sd">    current ``BaseCorrelatedNoise.__init__`` interface does not provide any guarantee that the input</span>
<span class="sd">    `GSObject` represents a physical correlation function, e.g. a profile that is an even function</span>
<span class="sd">    (two-fold rotationally symmetric in the plane) and peaked at the origin.  The proposed pattern</span>
<span class="sd">    is that users instead instantiate derived classes, such as the `CorrelatedNoise`, which are</span>
<span class="sd">    able to guarantee the above.</span>

<span class="sd">    If you have the correlation function as an image on file, you can use the class  method</span>
<span class="sd">    `from_file`, which does confirm that the file has the appropriate symmetry.</span>

<span class="sd">    The BaseCorrelatedNoise is therefore here primarily to define the way in which derived classes</span>
<span class="sd">    (currently only `CorrelatedNoise` and `UncorrelatedNoise`) store the random deviate, noise</span>
<span class="sd">    correlation function profile and allow operations with it, generate images containing noise with</span>
<span class="sd">    these correlation properties, and generate covariance matrices according to the correlation</span>
<span class="sd">    function.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        rng:        A `BaseDeviate` instance to use for generating the random numbers.</span>
<span class="sd">        gsobject:   The `GSObject` defining the correlation function.</span>

<span class="sd">                    .. warning:</span>

<span class="sd">                        The user is responsible for ensuring this profile is 2-fold rotationally</span>
<span class="sd">                        symmetric.  This is **not** checked.</span>

<span class="sd">        wcs:        The wcs for the image to define the phyical relationship between the pixels.</span>
<span class="sd">                    [default: PixelScale(1.0)]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rng</span><span class="p">,</span> <span class="n">gsobject</span><span class="p">,</span> <span class="n">wcs</span><span class="o">=</span><span class="n">PixelScale</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">rng</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">rng</span><span class="p">,</span> <span class="n">BaseDeviate</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;Supplied rng argument not a galsim.BaseDeviate or derived class instance.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">rng</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">rng</span> <span class="o">=</span> <span class="n">BaseDeviate</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_rng</span> <span class="o">=</span> <span class="n">rng</span>
        <span class="c1"># Act as a container for the GSObject used to represent the correlation funcion.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_profile</span> <span class="o">=</span> <span class="n">gsobject</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">wcs</span> <span class="o">=</span> <span class="n">wcs</span>

        <span class="c1"># When applying normal or whitening noise to an image, we normally do calculations.</span>
        <span class="c1"># If _profile_for_cached is profile, then it means that we can use the stored values in</span>
        <span class="c1"># _rootps_cache, _rootps_whitening_cache, and/or _rootps_symmetrizing_cache and avoid having</span>
        <span class="c1"># to redo the calculations.</span>
        <span class="c1"># So for now, we start out with _profile_for_cached = None, and _rootps_cache,</span>
        <span class="c1"># _rootps_whitening_cache, _rootps_symmetrizing_cache empty.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_profile_for_cache</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_rootps_cache</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_rootps_whitening_cache</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_rootps_symmetrizing_cache</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># Also set up the cache for a stored value of the variance, needed for efficiency once the</span>
        <span class="c1"># noise field can get convolved with other GSObjects making is_analytic_x False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_variance_cached</span> <span class="o">=</span> <span class="kc">None</span>

<div class="viewcode-block" id="BaseCorrelatedNoise.from_file"><a class="viewcode-back" href="../../corr_noise.html#galsim.BaseCorrelatedNoise.from_file">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_file</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">file_name</span><span class="p">,</span> <span class="n">pixel_scale</span><span class="p">,</span> <span class="n">rng</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">variance</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span> <span class="n">x_interpolant</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                  <span class="n">gsparams</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Read a correlated noise profile from a file.</span>

<span class="sd">        The file should contain an image of the correlation.</span>

<span class="sd">            * The image should be square with odd size in each direction.</span>
<span class="sd">            * The central pixel corresponds to the zero-lag correlation, i.e. the variance.</span>
<span class="sd">              Call this pixel element (0,0).</span>
<span class="sd">            * The other pixels (i,j) give the cross-correlation of the noise for pixels separated</span>
<span class="sd">              by i pixels in the x direction (columns) and j pixels in the y direction (rows).</span>
<span class="sd">            * The image therefore must be 180 degree rotationally symmetric.  i.e. the value at</span>
<span class="sd">              (i,j) must be the same as at (-i,-j).</span>

<span class="sd">        The pixel_scale is also required and defines the pixel scale of the original image.</span>

<span class="sd">        The default ``x_interpolant`` is a ``galsim.Linear()``, which uses bilinear interpolation.</span>
<span class="sd">        The use of this interpolant is an approximation that gives good empirical results without</span>
<span class="sd">        requiring internal convolution of the correlation function profile by a `Pixel` object when</span>
<span class="sd">        applying correlated noise to images: such an internal convolution has been found to be</span>
<span class="sd">        computationally costly in practice, requiring the Fourier transform of very large arrays.</span>

<span class="sd">        The use of the bilinear interpolants means that the representation of correlated noise will</span>
<span class="sd">        be noticeably inaccurate in at least the following two regimes:</span>

<span class="sd">        1. If the pixel scale of the desired final output (e.g. the target image of</span>
<span class="sd">           `BaseCorrelatedNoise.drawImage`, `BaseCorrelatedNoise.applyTo` or</span>
<span class="sd">           `BaseCorrelatedNoise.whitenImage`) is small relative to the separation between pixels in</span>
<span class="sd">           the ``image`` used to instantiate ``cn`` as shown above.</span>
<span class="sd">        2. If the `BaseCorrelatedNoise` instance ``cn`` was instantiated with an image of scale</span>
<span class="sd">           comparable to that in the final output, and ``cn`` has been rotated or otherwise</span>
<span class="sd">           transformed (e.g.  via the `BaseCorrelatedNoise.rotate`, `BaseCorrelatedNoise.shear`</span>
<span class="sd">           methods; see below).</span>

<span class="sd">        Conversely, the approximation will work best in the case where the correlated noise used to</span>
<span class="sd">        instantiate the ``cn`` is taken from an input image for which ``image.scale`` is smaller</span>
<span class="sd">        than that in the desired output.  This is the most common use case in the practical</span>
<span class="sd">        treatment of correlated noise when simulating galaxies from space as observed in</span>
<span class="sd">        ground-based surveys.</span>

<span class="sd">        Changing from the default bilinear interpolant is made possible, but not recommended.</span>
<span class="sd">        In our validation tests, we found that the Linear interpolant usually gave the most</span>
<span class="sd">        accurate results.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            file_name:      The name of the file to read.</span>
<span class="sd">            pixel_scale:    The pixel scale of the original image.</span>
<span class="sd">            rng:            If provided, a random number generator to use as the random number</span>
<span class="sd">                            generator of the resulting noise object. (may be any kind of</span>
<span class="sd">                            `BaseDeviate` object) [default: None, in which case, one will be</span>
<span class="sd">                            automatically created, using the time as a seed.]</span>
<span class="sd">            variance:       Scales the correlation function so that its point variance, equivalent</span>
<span class="sd">                            to its value at zero separation distance, matches this value.</span>
<span class="sd">                            [default: 0., which means to use the variance in the original file.]</span>
<span class="sd">            x_interpolant:  Forces use of a non-default interpolant for interpolation of the</span>
<span class="sd">                            internal lookup table in real space.  See below for more details.</span>
<span class="sd">                            [default: galsim.Linear()]</span>
<span class="sd">            gsparams:       An optional `GSParams` argument. [default: None]</span>

<span class="sd">        Returns:</span>
<span class="sd">            a `BaseCorrelatedNoise` instance</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">file_name</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">OSError</span><span class="p">(</span><span class="s2">&quot;The file </span><span class="si">%r</span><span class="s2"> does not exist.&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">file_name</span><span class="p">))</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">cfimage</span> <span class="o">=</span> <span class="n">fits</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">file_name</span><span class="p">)</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">OSError</span><span class="p">,</span> <span class="ne">AttributeError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">)</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">OSError</span><span class="p">(</span><span class="s2">&quot;Unable to read file </span><span class="si">%s</span><span class="s2">.</span><span class="se">\n</span><span class="si">%r</span><span class="s2">&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">file_name</span><span class="p">,</span><span class="n">e</span><span class="p">))</span>

        <span class="c1"># Check for invalid images:</span>
        <span class="k">if</span> <span class="n">cfimage</span><span class="o">.</span><span class="n">nrow</span> <span class="o">!=</span> <span class="n">cfimage</span><span class="o">.</span><span class="n">ncol</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">GalSimError</span><span class="p">(</span><span class="s2">&quot;Input image is not square.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">cfimage</span><span class="o">.</span><span class="n">nrow</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">GalSimError</span><span class="p">(</span><span class="s2">&quot;Input image does not have odd size.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">((</span><span class="n">cfimage</span> <span class="o">-</span> <span class="n">cfimage</span><span class="o">.</span><span class="n">rot_180</span><span class="p">())</span><span class="o">.</span><span class="n">array</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mf">1.e-12</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">GalSimError</span><span class="p">(</span><span class="s2">&quot;Input image does not have 180 degree rotational symmetry.&quot;</span><span class="p">)</span>
        <span class="n">center_val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">cfimage</span><span class="p">[</span><span class="n">cfimage</span><span class="o">.</span><span class="n">center</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">cfimage</span><span class="o">.</span><span class="n">array</span><span class="o">/</span><span class="n">center_val</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mf">1.</span> <span class="o">+</span> <span class="mf">1.e-12</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">GalSimError</span><span class="p">(</span><span class="s2">&quot;Input image central value is not the maximum&quot;</span><span class="p">)</span>

        <span class="c1"># Also check for invalid negative variance</span>
        <span class="k">if</span> <span class="n">variance</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">GalSimRangeError</span><span class="p">(</span><span class="s2">&quot;Specified variance must be zero or positive.&quot;</span><span class="p">,</span>
                                   <span class="n">variance</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="c1"># If x_interpolant not specified on input, use bilinear</span>
        <span class="k">if</span> <span class="n">x_interpolant</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">x_interpolant</span> <span class="o">=</span> <span class="n">Linear</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">x_interpolant</span> <span class="o">=</span> <span class="n">utilities</span><span class="o">.</span><span class="n">convert_interpolant</span><span class="p">(</span><span class="n">x_interpolant</span><span class="p">)</span>

        <span class="c1"># Build the cf profile.</span>
        <span class="n">ii</span> <span class="o">=</span> <span class="n">InterpolatedImage</span><span class="p">(</span><span class="n">cfimage</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">pixel_scale</span><span class="p">,</span> <span class="n">normalization</span><span class="o">=</span><span class="s2">&quot;sb&quot;</span><span class="p">,</span>
                               <span class="n">calculate_stepk</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">calculate_maxk</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                               <span class="n">x_interpolant</span><span class="o">=</span><span class="n">x_interpolant</span><span class="p">,</span> <span class="n">gsparams</span><span class="o">=</span><span class="n">gsparams</span><span class="p">)</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">BaseCorrelatedNoise</span><span class="p">(</span><span class="n">rng</span><span class="p">,</span> <span class="n">ii</span><span class="p">,</span> <span class="n">PixelScale</span><span class="p">(</span><span class="n">pixel_scale</span><span class="p">))</span>
        <span class="c1"># If the input keyword variance is non-zero, scale the correlation function to have this</span>
        <span class="c1"># variance</span>
        <span class="k">if</span> <span class="n">variance</span> <span class="o">&gt;</span> <span class="mf">0.</span><span class="p">:</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">ret</span><span class="o">.</span><span class="n">withVariance</span><span class="p">(</span><span class="n">variance</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ret</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">rng</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The `BaseDeviate` for this object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rng</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">gsparams</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The `GSParams` for this object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_profile</span><span class="o">.</span><span class="n">gsparams</span>

<div class="viewcode-block" id="BaseCorrelatedNoise.withGSParams"><a class="viewcode-back" href="../../corr_noise.html#galsim.BaseCorrelatedNoise.withGSParams">[docs]</a>    <span class="k">def</span> <span class="nf">withGSParams</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gsparams</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a version of the current object with the given `GSParams`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">gsparams</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">gsparams</span><span class="p">:</span> <span class="k">return</span> <span class="bp">self</span>
        <span class="k">return</span> <span class="n">BaseCorrelatedNoise</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rng</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_profile</span><span class="o">.</span><span class="n">withGSParams</span><span class="p">(</span><span class="n">gsparams</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">),</span>
                                   <span class="bp">self</span><span class="o">.</span><span class="n">wcs</span><span class="p">)</span></div>

    <span class="c1"># Make &quot;+&quot; work in the intuitive sense (variances being additive, correlation functions add as</span>
    <span class="c1"># you would expect)</span>
    <span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">compatible</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wcs</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">wcs</span><span class="p">):</span>
            <span class="n">galsim_warn</span><span class="p">(</span><span class="s2">&quot;Adding two CorrelatedNoise objects with incompatible WCS. &quot;</span>
                        <span class="s2">&quot;The result will have the WCS of the first object.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">BaseCorrelatedNoise</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rng</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_profile</span> <span class="o">+</span> <span class="n">other</span><span class="o">.</span><span class="n">_profile</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">wcs</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__sub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">compatible</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wcs</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">wcs</span><span class="p">):</span>
            <span class="n">galsim_warn</span><span class="p">(</span><span class="s2">&quot;Subtracting two CorrelatedNoise objects with incompatible WCS. &quot;</span>
                        <span class="s2">&quot;The result will have the WCS of the first object.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">BaseCorrelatedNoise</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rng</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_profile</span> <span class="o">-</span> <span class="n">other</span><span class="o">.</span><span class="n">_profile</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">wcs</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">variance_ratio</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">withScaledVariance</span><span class="p">(</span><span class="n">variance_ratio</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__div__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">variance_ratio</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">withScaledVariance</span><span class="p">(</span><span class="mf">1.</span><span class="o">/</span><span class="n">variance_ratio</span><span class="p">)</span>
    <span class="fm">__truediv__</span> <span class="o">=</span> <span class="n">__div__</span>

<div class="viewcode-block" id="BaseCorrelatedNoise.copy"><a class="viewcode-back" href="../../corr_noise.html#galsim.BaseCorrelatedNoise.copy">[docs]</a>    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rng</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a copy of the correlated noise model.</span>

<span class="sd">        By default, the copy will share the `BaseDeviate` random number generator with the parent</span>
<span class="sd">        instance.  However, you can provide a new rng to use in the copy if you want with::</span>

<span class="sd">            &gt;&gt;&gt; cn_copy = cn.copy(rng=new_rng)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">rng</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">rng</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rng</span>
        <span class="k">return</span> <span class="n">BaseCorrelatedNoise</span><span class="p">(</span><span class="n">rng</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_profile</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">wcs</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;galsim.BaseCorrelatedNoise(</span><span class="si">%r</span><span class="s2">,</span><span class="si">%r</span><span class="s2">,</span><span class="si">%r</span><span class="s2">)&quot;</span><span class="o">%</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">rng</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_profile</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">wcs</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;galsim.BaseCorrelatedNoise(</span><span class="si">%s</span><span class="s2">,</span><span class="si">%s</span><span class="s2">)&quot;</span><span class="o">%</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_profile</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">wcs</span><span class="p">)</span>

    <span class="c1"># Quick and dirty.  Just check reprs are equal.</span>
    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span> <span class="ow">is</span> <span class="n">other</span> <span class="ow">or</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="nb">repr</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
    <span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span> <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__eq__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="nb">hash</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_clear_cache</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Check if the profile has changed and clear caches if appropriate.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_profile_for_cache</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_profile</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_rootps_cache</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_rootps_whitening_cache</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_rootps_symmetrizing_cache</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_variance_cached</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># Set profile_for_cache for next time.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_profile_for_cache</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_profile</span>

<div class="viewcode-block" id="BaseCorrelatedNoise.applyTo"><a class="viewcode-back" href="../../corr_noise.html#galsim.BaseCorrelatedNoise.applyTo">[docs]</a>    <span class="k">def</span> <span class="nf">applyTo</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">image</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Apply this correlated Gaussian random noise field to an input `Image`.</span>

<span class="sd">        To add deviates to every element of an image, the syntax::</span>

<span class="sd">            &gt;&gt;&gt; image.addNoise(correlated_noise)</span>

<span class="sd">        is preferred.  However, this is equivalent to calling this instance&#39;s `applyTo` method as</span>
<span class="sd">        follows::</span>

<span class="sd">            &gt;&gt;&gt; correlated_noise.applyTo(image)</span>

<span class="sd">        On output the `Image` instance ``image`` will have been given additional noise according to</span>
<span class="sd">        the given `BaseCorrelatedNoise` instance ``correlated_noise``.  Normally, ``image.scale``</span>
<span class="sd">        is used to determine the input pixel separation, and if ``image.scale &lt;= 0`` a pixel scale</span>
<span class="sd">        of 1 is assumed.  If the image has a non-uniform WCS, the local uniform approximation at</span>
<span class="sd">        the center of the image will be used.</span>

<span class="sd">        Note that the correlations defined in a correlated_noise object are defined in terms of</span>
<span class="sd">        world coordinates (i.e. typically arcsec on the sky).  Some care is thus required if you</span>
<span class="sd">        apply correlated noise to an image with a non-trivial WCS.  The correlations will have a</span>
<span class="sd">        specific direction and scale in world coordinates, so if you apply them to an image with</span>
<span class="sd">        a WCS that has a rotation or a different pixel scale than the original, the resulting</span>
<span class="sd">        correlations will have the correct direction and scale in world coordinates, but a</span>
<span class="sd">        different direction and/or scale in image coordinates.</span>

<span class="sd">        If you want to override this behavior, you can view your image with the WCS of the</span>
<span class="sd">        correlation function and apply the noise to that.  For example::</span>

<span class="sd">            &gt;&gt;&gt; image = galsim.Image(nx, ny, wcs=complicated_wcs)</span>
<span class="sd">            &gt;&gt;&gt; noise = galsim.getCOSMOSNoise(rng=rng)</span>
<span class="sd">            &gt;&gt;&gt; image.view(wcs=noise.wcs).addNoise(noise)</span>

<span class="sd">        This will create noise whose pixel-to-pixel correlations match those of the original</span>
<span class="sd">        correlated noise image (in this case, the COSMOS images).  If the input image has no WCS</span>
<span class="sd">        set, then it will be treated as having the same WCS as the noise.</span>

<span class="sd">        Note that the correlated noise field in ``image`` will be periodic across its boundaries:</span>
<span class="sd">        this is due to the fact that the internals of the `BaseCorrelatedNoise` currently use a</span>
<span class="sd">        relatively simple implementation of noise generation using the Fast Fourier Transform.</span>
<span class="sd">        If you wish to avoid this property being present in your final ``image`` you should add the</span>
<span class="sd">        noise to an ``image`` of greater extent than you need, and take a subset.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            image:      The input `Image` object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Note that this uses the (fast) method of going via the power spectrum and FFTs to generate</span>
        <span class="c1"># noise according to the correlation function represented by this instance.  An alternative</span>
        <span class="c1"># would be to use the covariance matrices and eigendecomposition.  However, it is O(N^6)</span>
        <span class="c1"># operations for an NxN image!  FFT-based noise realization is O(2 N^2 log[N]) so we use it</span>
        <span class="c1"># for noise generation applications.</span>

        <span class="c1"># Check that the input has defined bounds</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">Image</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Input image argument must be a galsim.Image.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">image</span><span class="o">.</span><span class="n">bounds</span><span class="o">.</span><span class="n">isDefined</span><span class="p">():</span>
            <span class="k">raise</span> <span class="n">GalSimUndefinedBoundsError</span><span class="p">(</span><span class="s2">&quot;Input image argument must have defined bounds.&quot;</span><span class="p">)</span>

        <span class="c1"># If the profile has changed since last time (or if we have never been here before),</span>
        <span class="c1"># clear out the stored values.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_clear_cache</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">image</span><span class="o">.</span><span class="n">wcs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">wcs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wcs</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">wcs</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">wcs</span><span class="o">.</span><span class="n">local</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">true_center</span><span class="p">)</span>

        <span class="c1"># Then retrieve or redraw the sqrt(power spectrum) needed for making the noise field</span>
        <span class="n">rootps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_update_rootps</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">wcs</span><span class="p">)</span>

        <span class="c1"># Finally generate a random field in Fourier space with the right PS</span>
        <span class="n">noise_array</span> <span class="o">=</span> <span class="n">_generate_noise_from_rootps</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rng</span><span class="p">,</span> <span class="n">image</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">rootps</span><span class="p">)</span>

        <span class="c1"># Add it to the image</span>
        <span class="n">image</span><span class="o">.</span><span class="n">array</span><span class="p">[:,:]</span> <span class="o">+=</span> <span class="n">noise_array</span>
        <span class="k">return</span> <span class="n">image</span></div>

<div class="viewcode-block" id="BaseCorrelatedNoise.whitenImage"><a class="viewcode-back" href="../../corr_noise.html#galsim.BaseCorrelatedNoise.whitenImage">[docs]</a>    <span class="k">def</span> <span class="nf">whitenImage</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">image</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Apply noise designed to whiten correlated Gaussian random noise in an input `Image`.</span>

<span class="sd">        On input, The `Image`, ``image``, is assumed to have correlated noise described by this</span>
<span class="sd">        `BaseCorrelatedNoise` instance.</span>

<span class="sd">        On output ``image`` will have been given additional (correlated) noise designed to whiten</span>
<span class="sd">        the noise profile.</span>

<span class="sd">        Note: the syntax ``image.whitenNoise(noise)`` is normally preferred, but it is equivalent</span>
<span class="sd">        to::</span>

<span class="sd">            &gt;&gt;&gt; correlated_noise.whitenImage(image)</span>

<span class="sd">        If the ``image`` originally contained noise with a correlation function described by the</span>
<span class="sd">        ``correlated_noise`` instance, the combined noise after using the whitenImage() method</span>
<span class="sd">        will be approximately uncorrelated.  Tests using COSMOS noise fields suggest ~0.3% residual</span>
<span class="sd">        off-diagonal covariances after whitening, relative to the variance, although results may</span>
<span class="sd">        vary depending on the precise correlation function of the noise field.</span>
<span class="sd">        (See ``devel/external/hst/compare_whitening_subtraction.py`` for the COSMOS tests.)</span>

<span class="sd">        Note that the code doesn&#39;t check that the &quot;if&quot; above is true: the user MUST make sure this</span>
<span class="sd">        is the case for the final noise to be uncorrelated.</span>

<span class="sd">        Normally, ``image.scale`` is used to determine the input `Image` pixel separation, and if</span>
<span class="sd">        ``image.wcs`` is None, it will use the wcs of the noise.  If the image has a non-uniform</span>
<span class="sd">        WCS, the local uniform approximation at the center of the image will be used.</span>

<span class="sd">        If you are interested in a theoretical calculation of the variance in the final noise field</span>
<span class="sd">        after whitening, the whitenImage() method in fact returns this variance.  For example::</span>

<span class="sd">            &gt;&gt;&gt; variance = correlated_noise.whitenImage(image)</span>

<span class="sd">        **Example**:</span>

<span class="sd">        To see noise whitening in action, let us use a model of the correlated noise in COSMOS</span>
<span class="sd">        as returned by the `getCOSMOSNoise` function.  Let&#39;s initialize and add noise to an image::</span>

<span class="sd">            &gt;&gt;&gt; cn = galsim.getCOSMOSNoise()</span>
<span class="sd">            &gt;&gt;&gt; image = galsim.ImageD(256, 256, scale=0.03)</span>
<span class="sd">            &gt;&gt;&gt; # The scale should match the COSMOS default since didn&#39;t specify another</span>
<span class="sd">            &gt;&gt;&gt; image.addNoise(cn)</span>

<span class="sd">        The ``image`` will then contain a realization of a random noise field with COSMOS-like</span>
<span class="sd">        correlation.  Using the whitenImage() method, we can now add more noise to ``image``</span>
<span class="sd">        with a power spectrum specifically designed to make the combined noise fields uncorrelated::</span>

<span class="sd">            &gt;&gt;&gt; cn.whitenImage(image)</span>

<span class="sd">        Of course, this whitening comes at the cost of adding further noise to the image, but</span>
<span class="sd">        the algorithm is designed to make this additional noise (nearly) as small as possible.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            image:      The input `Image` object.</span>

<span class="sd">        Returns:</span>
<span class="sd">            the theoretically calculated variance of the combined noise fields in the updated image.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Note that this uses the (fast) method of going via the power spectrum and FFTs to generate</span>
        <span class="c1"># noise according to the correlation function represented by this instance.  An alternative</span>
        <span class="c1"># would be to use the covariance matrices and eigendecomposition.  However, it is O(N^6)</span>
        <span class="c1"># operations for an NxN image!  FFT-based noise realization is O(2 N^2 log[N]) so we use it</span>
        <span class="c1"># for noise generation applications.</span>

        <span class="c1"># Check that the input has defined bounds</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">Image</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Input image not a galsim.Image object&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">image</span><span class="o">.</span><span class="n">bounds</span><span class="o">.</span><span class="n">isDefined</span><span class="p">():</span>
            <span class="k">raise</span> <span class="n">GalSimUndefinedBoundsError</span><span class="p">(</span><span class="s2">&quot;Input image argument must have defined bounds.&quot;</span><span class="p">)</span>

        <span class="c1"># If the profile has changed since last time (or if we have never been here before),</span>
        <span class="c1"># clear out the stored values.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_clear_cache</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">image</span><span class="o">.</span><span class="n">wcs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">wcs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wcs</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">wcs</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">wcs</span><span class="o">.</span><span class="n">local</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">true_center</span><span class="p">)</span>

        <span class="c1"># Then retrieve or redraw the sqrt(power spectrum) needed for making the whitening noise,</span>
        <span class="c1"># and the total variance of the combination</span>
        <span class="n">rootps_whitening</span><span class="p">,</span> <span class="n">variance</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_update_rootps_whitening</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">wcs</span><span class="p">)</span>

        <span class="c1"># Finally generate a random field in Fourier space with the right PS and add to image</span>
        <span class="n">noise_array</span> <span class="o">=</span> <span class="n">_generate_noise_from_rootps</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rng</span><span class="p">,</span> <span class="n">image</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">rootps_whitening</span><span class="p">)</span>
        <span class="n">image</span> <span class="o">+=</span> <span class="n">Image</span><span class="p">(</span><span class="n">noise_array</span><span class="p">)</span>

        <span class="c1"># Return the variance to the interested user</span>
        <span class="k">return</span> <span class="n">variance</span></div>

<div class="viewcode-block" id="BaseCorrelatedNoise.symmetrizeImage"><a class="viewcode-back" href="../../corr_noise.html#galsim.BaseCorrelatedNoise.symmetrizeImage">[docs]</a>    <span class="k">def</span> <span class="nf">symmetrizeImage</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">4</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Apply noise designed to impose N-fold symmetry on the existing noise in a (square) input</span>
<span class="sd">        `Image`.</span>

<span class="sd">        On input, The `Image`, ``image``, is assumed to have correlated noise described by this</span>
<span class="sd">        `BaseCorrelatedNoise` instance.</span>

<span class="sd">        On output ``image`` will have been given additional (correlated) noise designed to</span>
<span class="sd">        symmetrize the noise profile.</span>

<span class="sd">        When called for a non-square image, this method will raise an exception, unlike the noise</span>
<span class="sd">        whitening routines.</span>

<span class="sd">        The ``order`` of the symmetry can be supplied as a keyword argument, with the default being</span>
<span class="sd">        4 because this is presumably the minimum required for the anisotropy of noise correlations</span>
<span class="sd">        to not affect shear statistics.</span>

<span class="sd">        Note: the syntax ``image.symmetrizeNoise(noise, order)`` is preferred, but it is equivalent</span>
<span class="sd">        to::</span>

<span class="sd">            &gt;&gt;&gt; correlated_noise.symmetrizeImage(image, order=order)</span>

<span class="sd">        If the ``image`` originally contained noise with a correlation function described by the</span>
<span class="sd">        ``correlated_noise`` instance, the combined noise after using the symmetrizeImage() method</span>
<span class="sd">        will have a noise correlation function with N-fold symmetry, where ``N=order``.</span>

<span class="sd">        Note that the code doesn&#39;t check that the &quot;if&quot; above is true: the user MUST make sure this</span>
<span class="sd">        is the case for the final noise correlation function to be symmetric in the requested way.</span>

<span class="sd">        Normally, ``image.scale`` is used to determine the input pixel separation, and if</span>
<span class="sd">        ``image.wcs`` is None, it will use the wcs of the noise.  If the image has a non-uniform</span>
<span class="sd">        WCS, the local uniform approximation at the center of the image will be used.</span>

<span class="sd">        If you are interested in a theoretical calculation of the variance in the final noise field</span>
<span class="sd">        after imposing symmetry, the symmetrizeImage() method in fact returns this variance.</span>
<span class="sd">        For example::</span>

<span class="sd">            &gt;&gt;&gt; variance = correlated_noise.symmetrizeImage(image, order=order)</span>

<span class="sd">        For context, in comparison with the `whitenImage` method for the case of noise</span>
<span class="sd">        correlation functions that are roughly like those in the COSMOS HST data, the amount of</span>
<span class="sd">        noise added to impose N-fold symmetry is usually much less than what is added to fully</span>
<span class="sd">        whiten the noise.  The usage of symmetrizeImage() is totally analogous to the usage of</span>
<span class="sd">        `whitenImage`.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            image:      The square input `Image` object.</span>
<span class="sd">            order:      The order at which to require the noise to be symmetric.  All noise fields</span>
<span class="sd">                        are already 2-fold symmetric, so ``order`` should be an even integer &gt;2.</span>
<span class="sd">                        [default: 4].</span>

<span class="sd">        Returns:</span>
<span class="sd">            the theoretically calculated variance of the combined noise fields in the updated image.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Check that the input has defined bounds</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">Image</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Input image not a galsim.Image object&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">image</span><span class="o">.</span><span class="n">bounds</span><span class="o">.</span><span class="n">isDefined</span><span class="p">():</span>
            <span class="k">raise</span> <span class="n">GalSimUndefinedBoundsError</span><span class="p">(</span><span class="s2">&quot;Input image argument must have defined bounds.&quot;</span><span class="p">)</span>

        <span class="c1"># Check that the input is square in shape.</span>
        <span class="k">if</span> <span class="n">image</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">image</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="n">GalSimValueError</span><span class="p">(</span><span class="s2">&quot;Input image must be square.&quot;</span><span class="p">,</span> <span class="n">image</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

        <span class="c1"># Check that the input order is an allowed value.</span>
        <span class="k">if</span> <span class="n">order</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">order</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">GalSimValueError</span><span class="p">(</span><span class="s2">&quot;Order must be an even number &gt;=4.&quot;</span><span class="p">,</span> <span class="n">order</span><span class="p">)</span>

        <span class="c1"># If the profile has changed since last time (or if we have never been here before),</span>
        <span class="c1"># clear out the stored values.  Note that this cache is not the same as the one used for</span>
        <span class="c1"># whitening.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_clear_cache</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">image</span><span class="o">.</span><span class="n">wcs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">wcs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wcs</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">wcs</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">wcs</span><span class="o">.</span><span class="n">local</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">true_center</span><span class="p">)</span>

        <span class="c1"># Then retrieve or redraw the sqrt(power spectrum) needed for making the symmetrizing noise,</span>
        <span class="c1"># and the total variance of the combination.</span>
        <span class="n">rootps_symmetrizing</span><span class="p">,</span> <span class="n">variance</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_update_rootps_symmetrizing</span><span class="p">(</span>
            <span class="n">image</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">wcs</span><span class="p">,</span> <span class="n">order</span><span class="p">)</span>

        <span class="c1"># Finally generate a random field in Fourier space with the right PS and add to image.</span>
        <span class="n">noise_array</span> <span class="o">=</span> <span class="n">_generate_noise_from_rootps</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rng</span><span class="p">,</span> <span class="n">image</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">rootps_symmetrizing</span><span class="p">)</span>
        <span class="n">image</span> <span class="o">+=</span> <span class="n">Image</span><span class="p">(</span><span class="n">noise_array</span><span class="p">)</span>

        <span class="c1"># Return the variance to the interested user</span>
        <span class="k">return</span> <span class="n">variance</span></div>

<div class="viewcode-block" id="BaseCorrelatedNoise.expand"><a class="viewcode-back" href="../../corr_noise.html#galsim.BaseCorrelatedNoise.expand">[docs]</a>    <span class="k">def</span> <span class="nf">expand</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scale</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Scale the linear scale of correlations in this noise model by ``scale``.</span>

<span class="sd">        Scales the linear dimensions of the image by the factor ``scale``, e.g.</span>
<span class="sd">        ``half_light_radius`` &lt;-- ``half_light_radius * scale``.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            scale:      The linear rescaling factor to apply.</span>

<span class="sd">        Returns:</span>
<span class="sd">            a new `BaseCorrelatedNoise` object with the specified expansion.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">BaseCorrelatedNoise</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rng</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_profile</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="n">scale</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">wcs</span><span class="p">)</span></div>

<div class="viewcode-block" id="BaseCorrelatedNoise.dilate"><a class="viewcode-back" href="../../corr_noise.html#galsim.BaseCorrelatedNoise.dilate">[docs]</a>    <span class="k">def</span> <span class="nf">dilate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scale</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Apply the appropriate changes to the scale and variance for when the object has</span>
<span class="sd">        an applied dilation.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            scale:  The linear dilation scale factor.</span>

<span class="sd">        Returns:</span>
<span class="sd">            a new `BaseCorrelatedNoise` object with the specified dilation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Expansion changes the flux by scale**2, dilate reverses that to conserve flux,</span>
        <span class="c1"># so the variance needs to change by scale**-4.</span>
        <span class="k">return</span> <span class="n">BaseCorrelatedNoise</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rng</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_profile</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="n">scale</span><span class="p">)</span> <span class="o">/</span> <span class="n">scale</span><span class="o">**</span><span class="mi">4</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">wcs</span><span class="p">)</span></div>

<div class="viewcode-block" id="BaseCorrelatedNoise.magnify"><a class="viewcode-back" href="../../corr_noise.html#galsim.BaseCorrelatedNoise.magnify">[docs]</a>    <span class="k">def</span> <span class="nf">magnify</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mu</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Apply the appropriate changes to the scale and variance for when the object has</span>
<span class="sd">        an applied magnification ``mu``.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            mu:     The lensing magnification</span>

<span class="sd">        Returns:</span>
<span class="sd">            a new `BaseCorrelatedNoise` object with the specified magnification.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">BaseCorrelatedNoise</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rng</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_profile</span><span class="o">.</span><span class="n">magnify</span><span class="p">(</span><span class="n">mu</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">wcs</span><span class="p">)</span></div>

<div class="viewcode-block" id="BaseCorrelatedNoise.lens"><a class="viewcode-back" href="../../corr_noise.html#galsim.BaseCorrelatedNoise.lens">[docs]</a>    <span class="k">def</span> <span class="nf">lens</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">g1</span><span class="p">,</span> <span class="n">g2</span><span class="p">,</span> <span class="n">mu</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Apply the appropriate changes for when the object has an applied shear and magnification.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            g1:     First component of lensing (reduced) shear to apply to the object.</span>
<span class="sd">            g2:     Second component of lensing (reduced) shear to apply to the object.</span>
<span class="sd">            mu:     Lensing magnification to apply to the object.</span>

<span class="sd">        Returns:</span>
<span class="sd">            a new `BaseCorrelatedNoise` object with the specified shear and magnification.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">BaseCorrelatedNoise</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rng</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_profile</span><span class="o">.</span><span class="n">lens</span><span class="p">(</span><span class="n">g1</span><span class="p">,</span><span class="n">g2</span><span class="p">,</span><span class="n">mu</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">wcs</span><span class="p">)</span></div>

<div class="viewcode-block" id="BaseCorrelatedNoise.rotate"><a class="viewcode-back" href="../../corr_noise.html#galsim.BaseCorrelatedNoise.rotate">[docs]</a>    <span class="k">def</span> <span class="nf">rotate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theta</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Apply a rotation ``theta`` to this correlated noise model.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            theta:  Rotation angle (`Angle` object, positive means anticlockwise).</span>

<span class="sd">        Returns:</span>
<span class="sd">            a new `BaseCorrelatedNoise` object with the specified rotation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">BaseCorrelatedNoise</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rng</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_profile</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="n">theta</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">wcs</span><span class="p">)</span></div>

<div class="viewcode-block" id="BaseCorrelatedNoise.shear"><a class="viewcode-back" href="../../corr_noise.html#galsim.BaseCorrelatedNoise.shear">[docs]</a>    <span class="k">def</span> <span class="nf">shear</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Apply a shear to this correlated noise model, where arguments are either a `Shear`,</span>
<span class="sd">        or arguments that will be used to initialize one.</span>

<span class="sd">        For more details about the allowed keyword arguments, see the `Shear` docstring.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            shear:  The shear to be applied. Or, as described above, you may instead supply</span>
<span class="sd">                    parameters do construct a shear directly.  eg. ``corr.shear(g1=g1,g2=g2)``.</span>

<span class="sd">        Returns:</span>
<span class="sd">            a new `BaseCorrelatedNoise` object with the specified shear.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">BaseCorrelatedNoise</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rng</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_profile</span><span class="o">.</span><span class="n">shear</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">wcs</span><span class="p">)</span></div>

<div class="viewcode-block" id="BaseCorrelatedNoise.transform"><a class="viewcode-back" href="../../corr_noise.html#galsim.BaseCorrelatedNoise.transform">[docs]</a>    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dudx</span><span class="p">,</span> <span class="n">dudy</span><span class="p">,</span> <span class="n">dvdx</span><span class="p">,</span> <span class="n">dvdy</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Apply an arbitrary jacobian transformation to this correlated noise model.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            dudx:   du/dx, where (x,y) are the current coords, and (u,v) are the new coords.</span>
<span class="sd">            dudy:   du/dy, where (x,y) are the current coords, and (u,v) are the new coords.</span>
<span class="sd">            dvdx:   dv/dx, where (x,y) are the current coords, and (u,v) are the new coords.</span>
<span class="sd">            dvdy:   dv/dy, where (x,y) are the current coords, and (u,v) are the new coords.</span>

<span class="sd">        Returns:</span>
<span class="sd">            a new `BaseCorrelatedNoise` object with the specified transformation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">BaseCorrelatedNoise</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rng</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_profile</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">dudx</span><span class="p">,</span><span class="n">dudy</span><span class="p">,</span><span class="n">dvdx</span><span class="p">,</span><span class="n">dvdy</span><span class="p">),</span>
                                   <span class="bp">self</span><span class="o">.</span><span class="n">wcs</span><span class="p">)</span></div>

<div class="viewcode-block" id="BaseCorrelatedNoise.getVariance"><a class="viewcode-back" href="../../corr_noise.html#galsim.BaseCorrelatedNoise.getVariance">[docs]</a>    <span class="k">def</span> <span class="nf">getVariance</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the point variance of this noise field, equal to its correlation function value at</span>
<span class="sd">        zero distance.</span>

<span class="sd">        This is the variance of values in an image filled with noise according to this model.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Test whether we can simply return the zero-lag correlation function value, which gives the</span>
        <span class="c1"># variance of an image of noise generated according to this model</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_profile</span><span class="o">.</span><span class="n">is_analytic_x</span><span class="p">:</span>
            <span class="n">variance</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_profile</span><span class="o">.</span><span class="n">xValue</span><span class="p">(</span><span class="n">_PositionD</span><span class="p">(</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># If the profile has changed since last time (or if we have never been here before),</span>
            <span class="c1"># clear out the stored values.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_clear_cache</span><span class="p">()</span>

            <span class="c1"># Then use cached version or rebuild if necessary</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_variance_cached</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">variance</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_variance_cached</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">imtmp</span> <span class="o">=</span> <span class="n">Image</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
                <span class="c1"># GalSim internals handle this correctly w/out folding</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">drawImage</span><span class="p">(</span><span class="n">imtmp</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mf">1.</span><span class="p">)</span>
                <span class="n">variance</span> <span class="o">=</span> <span class="n">imtmp</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_variance_cached</span> <span class="o">=</span> <span class="n">variance</span> <span class="c1"># Store variance for next time</span>
        <span class="k">return</span> <span class="n">variance</span></div>

<div class="viewcode-block" id="BaseCorrelatedNoise.withVariance"><a class="viewcode-back" href="../../corr_noise.html#galsim.BaseCorrelatedNoise.withVariance">[docs]</a>    <span class="k">def</span> <span class="nf">withVariance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">variance</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set the point variance of the noise field, equal to its correlation function value at</span>
<span class="sd">        zero distance, to an input ``variance``.  The rest of the correlated noise field is scaled</span>
<span class="sd">        proportionally.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            variance:   The desired point variance in the noise.</span>

<span class="sd">        Returns:</span>
<span class="sd">            a `BaseCorrelatedNoise` object with the new variance.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">variance</span> <span class="o">&lt;=</span> <span class="mf">0.</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">GalSimValueError</span><span class="p">(</span><span class="s2">&quot;variance must be &gt; 0 in withVariance&quot;</span><span class="p">,</span> <span class="n">variance</span><span class="p">)</span>
        <span class="n">variance_ratio</span> <span class="o">=</span> <span class="n">variance</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">getVariance</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span> <span class="o">*</span> <span class="n">variance_ratio</span></div>

<div class="viewcode-block" id="BaseCorrelatedNoise.withScaledVariance"><a class="viewcode-back" href="../../corr_noise.html#galsim.BaseCorrelatedNoise.withScaledVariance">[docs]</a>    <span class="k">def</span> <span class="nf">withScaledVariance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">variance_ratio</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Scale the entire correlated noise field by the given factor.</span>

<span class="sd">        This is equivalent to cn * variance_ratio.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            variance_ratio:     The factor by which to scale the variance of the correlation</span>
<span class="sd">                                function profile.</span>

<span class="sd">        Returns:</span>
<span class="sd">            a `BaseCorrelatedNoise` object whose variance and covariances have been scaled up by</span>
<span class="sd">            the given factor.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">BaseCorrelatedNoise</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rng</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_profile</span> <span class="o">*</span> <span class="n">variance_ratio</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">wcs</span><span class="p">)</span></div>

<div class="viewcode-block" id="BaseCorrelatedNoise.convolvedWith"><a class="viewcode-back" href="../../corr_noise.html#galsim.BaseCorrelatedNoise.convolvedWith">[docs]</a>    <span class="k">def</span> <span class="nf">convolvedWith</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gsobject</span><span class="p">,</span> <span class="n">gsparams</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Convolve the correlated noise model with an input `GSObject`.</span>

<span class="sd">        The resulting correlated noise model will then give a statistical description of the noise</span>
<span class="sd">        field that would result from convolving noise generated according to the initial correlated</span>
<span class="sd">        noise with a kernel represented by ``gsobject`` (e.g. a PSF).</span>

<span class="sd">        The practical purpose of this method is that it allows us to model what is happening to</span>
<span class="sd">        noise in the images from Hubble Space Telescope that we use for simulating PSF convolved</span>
<span class="sd">        galaxies with the `RealGalaxy` class.</span>

<span class="sd">        This modifies the representation of the correlation function, but leaves the random number</span>
<span class="sd">        generator unchanged.</span>

<span class="sd">        **Examples**:</span>

<span class="sd">        The following command simply applies a Moffat PSF with slope parameter beta=3. and</span>
<span class="sd">        FWHM=0.7::</span>

<span class="sd">            &gt;&gt;&gt; cn = cn.convolvedWith(galsim.Moffat(beta=3., fwhm=0.7))</span>

<span class="sd">        Often we will want to convolve with more than one function.  For example, if we wanted to</span>
<span class="sd">        simulate how a noise field would look if convolved with a ground-based PSF (such as the</span>
<span class="sd">        Moffat above) and then rendered onto a new (typically larger) pixel grid, the following</span>
<span class="sd">        example command demonstrates the syntax::</span>

<span class="sd">            &gt;&gt;&gt; cn = cn.convolvedWith(</span>
<span class="sd">            ...    galsim.Convolve([galsim.Deconvolve(galsim.Pixel(0.03)),</span>
<span class="sd">            ...                     galsim.Pixel(0.2), galsim.Moffat(3., fwhm=0.7),</span>

<span class="sd">        Note, we also deconvolve by the original pixel, which should be the pixel size of the</span>
<span class="sd">        image from which the ``correlated_noise`` was made.  This command above is functionally</span>
<span class="sd">        equivalent to::</span>

<span class="sd">            &gt;&gt;&gt; cn = cn.convolvedWith(galsim.Deconvolve(galsim.Pixel(0.03)))</span>
<span class="sd">            &gt;&gt;&gt; cn = cn.convolvedWith(galsim.Pixel(0.2))</span>
<span class="sd">            &gt;&gt;&gt; cn = cn.convolvedWith(galsim.Moffat(beta=3., fwhm=0.7))</span>

<span class="sd">        as is demanded for a linear operation such as convolution.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            gsobject:   A `GSObject` or derived class instance representing the function</span>
<span class="sd">                        with which the user wants to convolve the correlated noise model.</span>
<span class="sd">            gsparams:   An optional `GSParams` argument. [default: None]</span>

<span class="sd">        Returns:</span>
<span class="sd">            the new `BaseCorrelatedNoise` of the convolved profile.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">conv</span> <span class="o">=</span> <span class="n">Convolve</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">_profile</span><span class="p">,</span> <span class="n">AutoCorrelate</span><span class="p">(</span><span class="n">gsobject</span><span class="p">,</span><span class="n">gsparams</span><span class="o">=</span><span class="n">gsparams</span><span class="p">)],</span>
                        <span class="n">gsparams</span><span class="o">=</span><span class="n">gsparams</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">BaseCorrelatedNoise</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rng</span><span class="p">,</span> <span class="n">conv</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">wcs</span><span class="p">)</span></div>

<div class="viewcode-block" id="BaseCorrelatedNoise.drawImage"><a class="viewcode-back" href="../../corr_noise.html#galsim.BaseCorrelatedNoise.drawImage">[docs]</a>    <span class="k">def</span> <span class="nf">drawImage</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">image</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">wcs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">add_to_image</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;A method for drawing profiles storing correlation functions.</span>

<span class="sd">        This is a mild reimplementation of the `GSObject.drawImage` method.  The ``method`` is</span>
<span class="sd">        automatically set to &#39;sb&#39; and cannot be changed, and the ``gain`` is set to unity.</span>
<span class="sd">        Also, not all the normal parameters of the `GSObject` method are available.</span>

<span class="sd">        If ``scale`` and ``wcs`` are not set, and the ``image`` has no ``wcs`` attribute, then this</span>
<span class="sd">        will use the wcs of the `BaseCorrelatedNoise` object.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            image:          If provided, this will be the image on which to draw the profile.</span>
<span class="sd">                            If ``image`` is None, then an automatically-sized `Image` will be</span>
<span class="sd">                            created.  If ``image`` is given, but its bounds are undefined (e.g. if</span>
<span class="sd">                            it was constructed with ``image = galsim.Image()``), then it will be</span>
<span class="sd">                            resized appropriately based on the profile&#39;s size [default: None].</span>
<span class="sd">            scale:          If provided, use this as the pixel scale for the image.  [default: None]</span>
<span class="sd">            wcs:            If provided, use this as the wcs for the image (possibly overriding any</span>
<span class="sd">                            existing ``image.wcs``).  At most one of ``scale`` or ``wcs`` may be</span>
<span class="sd">                            provided.  [default: None]  Note: If no WCS is provided either via</span>
<span class="sd">                            ``scale``, ``wcs`` or ``image.wcs``, then the noise object&#39;s wcs will</span>
<span class="sd">                            be used.</span>
<span class="sd">            dtype:          The data type to use for an automatically constructed image.  Only</span>
<span class="sd">                            valid if ``image`` is None. [default: None, which means to use</span>
<span class="sd">                            numpy.float32]</span>
<span class="sd">            add_to_image:   Whether to add flux to the existing image rather than clear out</span>
<span class="sd">                            anything in the image before drawing.</span>
<span class="sd">                            Note: This requires that ``image`` be provided and that it have defined</span>
<span class="sd">                            bounds. [default: False]</span>

<span class="sd">        Returns:</span>
<span class="sd">            an `Image` of the correlation function.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">wcs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_profile</span><span class="o">.</span><span class="n">_determine_wcs</span><span class="p">(</span><span class="n">scale</span><span class="p">,</span> <span class="n">wcs</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">wcs</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_profile</span><span class="o">.</span><span class="n">drawImage</span><span class="p">(</span>
            <span class="n">image</span><span class="o">=</span><span class="n">image</span><span class="p">,</span> <span class="n">wcs</span><span class="o">=</span><span class="n">wcs</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;sb&#39;</span><span class="p">,</span> <span class="n">gain</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span>
            <span class="n">add_to_image</span><span class="o">=</span><span class="n">add_to_image</span><span class="p">,</span> <span class="n">use_true_center</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="BaseCorrelatedNoise.drawKImage"><a class="viewcode-back" href="../../corr_noise.html#galsim.BaseCorrelatedNoise.drawKImage">[docs]</a>    <span class="k">def</span> <span class="nf">drawKImage</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">image</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ny</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">bounds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                   <span class="n">add_to_image</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;A method for drawing profiles storing correlation functions (i.e., power spectra) in</span>
<span class="sd">        Fourier space.</span>

<span class="sd">        This is a mild reimplementation of the `GSObject.drawKImage` method.  The ``gain`` is</span>
<span class="sd">        automatically set to unity and cannot be changed.  Also, not all the normal parameters of</span>
<span class="sd">        the `GSObject` method are available.</span>

<span class="sd">        If ``scale`` is not set, and ``image`` has no ``wcs`` attribute, then this will use the</span>
<span class="sd">        wcs of the `BaseCorrelatedNoise` object, which must be a `PixelScale`.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            image:          If provided, this will be the `Image` onto which to draw the k-space</span>
<span class="sd">                            image.  If ``image`` is None, then an automatically-sized image will be</span>
<span class="sd">                            created.  If ``image`` is given, but its bounds are undefined, then it</span>
<span class="sd">                            will be resized appropriately based on the profile&#39;s size.</span>
<span class="sd">                            [default: None]</span>
<span class="sd">            nx:             If provided and ``image`` is None, use to set the x-direction size of</span>
<span class="sd">                            the image.  Must be accompanied by ``ny``.</span>
<span class="sd">            ny:             If provided and ``image`` is None, use to set the y-direction size of</span>
<span class="sd">                            the image.  Must be accompanied by ``nx``.</span>
<span class="sd">            bounds:         If provided and ``image`` is None, use to set the bounds of the image.</span>
<span class="sd">            scale:          If provided, use this as the pixel scale, dk, for the images.</span>
<span class="sd">                            If ``scale`` is None and ``image`` is given, then take the provided</span>
<span class="sd">                            images&#39; pixel scale (which must be equal).</span>
<span class="sd">                            If ``scale`` is None and ``image`` is None, then use the Nyquist scale.</span>
<span class="sd">                            If ``scale &lt;= 0`` (regardless of ``image``), then use the Nyquist scale.</span>
<span class="sd">                            [default: None]</span>
<span class="sd">            add_to_image:   Whether to add to the existing images rather than clear out</span>
<span class="sd">                            anything in the image before drawing.</span>
<span class="sd">                            Note: This requires that ``image`` be provided and that it has defined</span>
<span class="sd">                            bounds. [default: False]</span>

<span class="sd">        Returns:</span>
<span class="sd">            the tuple of `Image` instances, ``(re, im)`` (created if necessary)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_profile</span><span class="o">.</span><span class="n">drawKImage</span><span class="p">(</span>
                <span class="n">image</span><span class="o">=</span><span class="n">image</span><span class="p">,</span> <span class="n">nx</span><span class="o">=</span><span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="o">=</span><span class="n">ny</span><span class="p">,</span> <span class="n">bounds</span><span class="o">=</span><span class="n">bounds</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">,</span> <span class="n">add_to_image</span><span class="o">=</span><span class="n">add_to_image</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_get_update_rootps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">wcs</span><span class="p">):</span>
        <span class="c1"># Internal utility function for querying the rootps cache, used by applyTo(),</span>
        <span class="c1"># whitenImage(), and symmetrizeImage() methods.</span>

        <span class="c1"># Query using the rfft2/irfft2 half-sized shape (shape[0], shape[1] // 2 + 1)</span>
        <span class="n">half_shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="n">half_shape</span><span class="p">,</span> <span class="n">wcs</span><span class="p">)</span>

        <span class="c1"># Use the cached value if possible.</span>
        <span class="n">rootps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rootps_cache</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="c1"># If not, draw the correlation function to the desired size and resolution, then DFT to</span>
        <span class="c1"># generate the required array of the square root of the power spectrum</span>
        <span class="k">if</span> <span class="n">rootps</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Draw this correlation function into an array.  If this is not done at the same wcs as</span>
            <span class="c1"># the original image from which the CF derives, even if the image is rotated, then this</span>
            <span class="c1"># step requires interpolation and the newcf (used to generate the PS below) is thus</span>
            <span class="c1"># approximate at some level</span>
            <span class="n">newcf</span> <span class="o">=</span> <span class="n">Image</span><span class="p">(</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">wcs</span><span class="o">=</span><span class="n">wcs</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">drawImage</span><span class="p">(</span><span class="n">newcf</span><span class="p">)</span>

            <span class="c1"># Since we just drew it, save the variance value for posterity.</span>
            <span class="n">var</span> <span class="o">=</span> <span class="n">newcf</span><span class="p">(</span><span class="n">newcf</span><span class="o">.</span><span class="n">bounds</span><span class="o">.</span><span class="n">center</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_variance_cached</span> <span class="o">=</span> <span class="n">var</span>

            <span class="k">if</span> <span class="n">var</span> <span class="o">&lt;=</span> <span class="mf">0.</span><span class="p">:</span>  <span class="c1"># pragma: no cover   This should be impossible...</span>
                <span class="k">raise</span> <span class="n">GalSimError</span><span class="p">(</span><span class="s2">&quot;CorrelatedNoise found to have negative variance.&quot;</span><span class="p">)</span>

            <span class="c1"># Then calculate the sqrt(PS) that will be used to generate the actual noise.  First do</span>
            <span class="c1"># the power spectrum (PS)</span>
            <span class="n">ps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">rfft2</span><span class="p">(</span><span class="n">newcf</span><span class="o">.</span><span class="n">array</span><span class="p">)</span>

            <span class="c1"># The PS we expect should be *purely* +ve, but there are reasons why this is not the</span>
            <span class="c1"># case.  One is that the PS is calculated from a correlation function CF that has not</span>
            <span class="c1"># been rolled to be centred on the [0, 0] array element.  Another reason is due to the</span>
            <span class="c1"># approximate nature of the CF rendered above.  Thus an abs(ps) will be necessary when</span>
            <span class="c1"># calculating the sqrt().</span>
            <span class="c1"># This all means that the performance of correlated noise fields should always be tested</span>
            <span class="c1"># for any given scientific application that requires high precision output.  An example</span>
            <span class="c1"># of such a test is the generation of noise whitened images of sheared RealGalaxies in</span>
            <span class="c1"># Section 9.2 of the GalSim paper (Rowe, Jarvis, Mandelbaum et al. 2014)</span>

            <span class="c1"># Given all the above, it might make sense to warn the user if we do detect a PS that</span>
            <span class="c1"># doesn&#39;t &quot;look right&quot; (i.e. has strongly negative values where these are not expected).</span>
            <span class="c1"># This is the subject of Issue #587 on GalSim&#39;s GitHub repository page (see</span>
            <span class="c1"># https://github.com/GalSim-developers/GalSim/issues/587)</span>

            <span class="c1"># For now we just take the sqrt(abs(PS)):</span>
            <span class="n">rootps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">ps</span><span class="p">))</span>

            <span class="c1"># Save this in the cache</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_rootps_cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">rootps</span>

        <span class="k">return</span> <span class="n">rootps</span>

    <span class="k">def</span> <span class="nf">_get_update_rootps_whitening</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">wcs</span><span class="p">,</span> <span class="n">headroom</span><span class="o">=</span><span class="mf">1.05</span><span class="p">):</span>
        <span class="c1"># Internal utility function for querying the rootps_whitening cache, used by the</span>
        <span class="c1"># whitenImage() method, and calculate and update it if not present.</span>

        <span class="c1"># Returns: rootps_whitening, variance</span>

        <span class="c1"># Query using the rfft2/irfft2 half-sized shape (shape[0], shape[1] // 2 + 1)</span>
        <span class="n">half_shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

        <span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="n">half_shape</span><span class="p">,</span> <span class="n">wcs</span><span class="p">)</span>

        <span class="c1"># Use the cached values if possible.</span>
        <span class="n">rootps_whitening</span><span class="p">,</span> <span class="n">variance</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rootps_whitening_cache</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">))</span>

        <span class="c1"># If not, calculate the whitening power spectrum as (almost) the smallest power spectrum</span>
        <span class="c1"># that when added to rootps**2 gives a flat resultant power that is nowhere negative.</span>
        <span class="c1"># Note that rootps = sqrt(power spectrum), and this procedure therefore works since power</span>
        <span class="c1"># spectra add (rather like variances).  The resulting power spectrum will be all positive</span>
        <span class="c1"># (and thus physical).</span>
        <span class="k">if</span> <span class="n">rootps_whitening</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>

            <span class="n">rootps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_update_rootps</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">wcs</span><span class="p">)</span>
            <span class="n">ps_whitening</span> <span class="o">=</span> <span class="o">-</span><span class="n">rootps</span> <span class="o">*</span> <span class="n">rootps</span>
            <span class="n">ps_whitening</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">ps_whitening</span><span class="p">))</span> <span class="o">*</span> <span class="n">headroom</span> <span class="c1"># Headroom adds a little extra</span>
            <span class="n">rootps_whitening</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">ps_whitening</span><span class="p">)</span>                <span class="c1"># variance, for &quot;safety&quot;</span>

            <span class="c1"># Finally calculate the theoretical combined variance to output alongside the image</span>
            <span class="c1"># to be generated with the rootps_whitening.  Note that although we use the [0, 0]</span>
            <span class="c1"># element we could use any as the PS should be flat.</span>
            <span class="n">variance</span> <span class="o">=</span> <span class="n">rootps</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">ps_whitening</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>

            <span class="c1"># Then add all this and the relevant wcs to the _rootps_whitening_cache</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_rootps_whitening_cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">rootps_whitening</span><span class="p">,</span> <span class="n">variance</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">rootps_whitening</span><span class="p">,</span> <span class="n">variance</span>

    <span class="k">def</span> <span class="nf">_get_update_rootps_symmetrizing</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">wcs</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">headroom</span><span class="o">=</span><span class="mf">1.02</span><span class="p">):</span>
        <span class="c1"># Internal utility function for querying the ``rootps_symmetrizing`` cache, used by the</span>
        <span class="c1"># symmetrizeImage() method, and calculate and update it if not present.</span>

        <span class="c1"># Returns: rootps_symmetrizing, variance</span>

        <span class="c1"># Query using the rfft2/irfft2 half-sized shape (shape[0], shape[1] // 2 + 1)</span>
        <span class="n">half_shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

        <span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="n">half_shape</span><span class="p">,</span> <span class="n">wcs</span><span class="p">,</span> <span class="n">order</span><span class="p">)</span>

        <span class="c1"># Use the cached values if possible.</span>
        <span class="n">rootps_symmetrizing</span><span class="p">,</span> <span class="n">variance</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rootps_symmetrizing_cache</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">))</span>

        <span class="c1"># If not, calculate the symmetrizing power spectrum as (almost) the smallest power spectrum</span>
        <span class="c1"># that when added to rootps**2 gives a power that has N-fold symmetry, where `N=order`.</span>
        <span class="c1"># Note that rootps = sqrt(power spectrum), and this procedure therefore works since power</span>
        <span class="c1"># spectra add (rather like variances).  The resulting power spectrum will be all positive</span>
        <span class="c1"># (and thus physical).</span>
        <span class="k">if</span> <span class="n">rootps_symmetrizing</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>

            <span class="n">rootps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_update_rootps</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">wcs</span><span class="p">)</span>
            <span class="n">ps_actual</span> <span class="o">=</span> <span class="n">rootps</span> <span class="o">*</span> <span class="n">rootps</span>
            <span class="c1"># This routine will get a PS that is a symmetrized version of `ps_actual` at the desired</span>
            <span class="c1"># order, that also satisfies the requirement of being &gt;= ps_actual for all k values.</span>
            <span class="n">ps_symmetrized</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_symmetrized_ps</span><span class="p">(</span><span class="n">ps_actual</span><span class="p">,</span> <span class="n">order</span><span class="p">)</span>
            <span class="n">ps_symmetrizing</span> <span class="o">=</span> <span class="n">ps_symmetrized</span> <span class="o">*</span> <span class="n">headroom</span> <span class="o">-</span> <span class="n">ps_actual</span> <span class="c1"># add a little extra variance</span>
            <span class="n">rootps_symmetrizing</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">ps_symmetrizing</span><span class="p">)</span>

            <span class="c1"># Finally calculate the theoretical combined variance to output alongside the image to</span>
            <span class="c1"># be generated with the rootps_symmetrizing.</span>
            <span class="c1"># Here, unlike in _get_update_rootps_whitening, the final power spectrum is not flat, so</span>
            <span class="c1"># we have to take the mean power instead of just using the [0, 0] element.</span>
            <span class="c1"># Note that the mean of the power spectrum (fourier space) is the zero lag value in</span>
            <span class="c1"># real space, which is the desired variance.</span>
            <span class="n">variance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">rootps</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">ps_symmetrizing</span><span class="p">)</span>

            <span class="c1"># Then add all this and the relevant wcs to the _rootps_symmetrizing_cache</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_rootps_symmetrizing_cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">rootps_symmetrizing</span><span class="p">,</span> <span class="n">variance</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">rootps_symmetrizing</span><span class="p">,</span> <span class="n">variance</span>

    <span class="k">def</span> <span class="nf">_get_symmetrized_ps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ps</span><span class="p">,</span> <span class="n">order</span><span class="p">):</span>
        <span class="c1"># Internal utility function for taking an input power spectrum and generating a version of</span>
        <span class="c1"># it with symmetry at a given order.</span>

        <span class="c1"># We make an image of the PS and turn it into an galsim.InterpolatedImage in order to carry</span>
        <span class="c1"># out the necessary rotations using well-tested interpolation routines.  We will also</span>
        <span class="c1"># require the output to be strictly &gt;= the input noise power spectrum, so that it should be</span>
        <span class="c1"># possible to generate noise with power equal to the difference between the two power</span>
        <span class="c1"># spectra.</span>

        <span class="c1"># Initialize a temporary copy of the original PS array, expanded to full size rather than</span>
        <span class="c1"># the compact halfcomplex format that the PS is supplied in, which we will turn into an</span>
        <span class="c1"># InterpolatedImage</span>
        <span class="c1"># Check for an input ps which was even-sized along the y axis, which needs special treatment</span>
        <span class="n">do_expansion</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">ps</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">do_expansion</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="c1"># Then roll the PS by half its size in the leading dimension, centering it in that dimension</span>
        <span class="c1"># (we will construct the expanded array to be centred in the other dimension)</span>
        <span class="n">ps_rolled</span> <span class="o">=</span> <span class="n">utilities</span><span class="o">.</span><span class="n">roll2d</span><span class="p">(</span><span class="n">ps</span><span class="p">,</span> <span class="p">(</span><span class="n">ps</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">//</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
        <span class="c1"># Then create and fill an expanded-size tmp_arr with this PS</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">do_expansion</span><span class="p">:</span>
            <span class="n">tmp_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">ps_rolled</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">ps_rolled</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="c1"># Both dims now odd</span>
            <span class="c1"># Fill the first half, the RHS...</span>
            <span class="n">tmp_arr</span><span class="p">[:,</span> <span class="n">ps</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">ps_rolled</span>
            <span class="c1"># Then do the LHS of tmp_arr, straightforward enough, fill with the inverted RHS</span>
            <span class="n">tmp_arr</span><span class="p">[:,</span> <span class="p">:</span><span class="n">ps</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">ps_rolled</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:][::</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># For the even-sized leading dimension ps, we have to do a tiny bit more work than</span>
            <span class="c1"># the odd case...</span>
            <span class="n">tmp_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">ps_rolled</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">ps_rolled</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
            <span class="n">tmp_arr</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">ps_rolled</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">ps_rolled</span>
            <span class="n">tmp_arr</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="p">:</span><span class="n">ps_rolled</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">ps_rolled</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:][::</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="c1"># Then one tiny element breaks the symmetry of the above, so fix this</span>
            <span class="n">tmp_arr</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">tmp_arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">//</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp_arr</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">tmp_arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">//</span> <span class="mi">2</span><span class="p">]</span>

        <span class="c1"># Also initialize the array in which to build up the symmetrized PS.</span>
        <span class="n">final_arr</span> <span class="o">=</span> <span class="n">tmp_arr</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">tmp_im</span> <span class="o">=</span> <span class="n">Image</span><span class="p">(</span><span class="n">tmp_arr</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">tmp_obj</span> <span class="o">=</span> <span class="n">InterpolatedImage</span><span class="p">(</span><span class="n">tmp_im</span><span class="p">,</span> <span class="n">calculate_maxk</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">calculate_stepk</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># Now loop over the rotations by 2pi/order.</span>
        <span class="k">for</span> <span class="n">i_rot</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">order</span><span class="p">):</span>
            <span class="c1"># For the first one, we don&#39;t rotate at all.</span>
            <span class="k">if</span> <span class="n">i_rot</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># For later ones, rotate by 2pi/order, and draw it back into a new image.</span>
                <span class="n">tmp_obj</span> <span class="o">=</span> <span class="n">tmp_obj</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">radians</span><span class="o">/</span><span class="n">order</span><span class="p">)</span>
                <span class="n">tmp_im</span> <span class="o">=</span> <span class="n">Image</span><span class="p">(</span><span class="n">tmp_arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">tmp_arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">scale</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">tmp_obj</span><span class="o">.</span><span class="n">drawImage</span><span class="p">(</span><span class="n">tmp_im</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;sb&#39;</span><span class="p">)</span>
                <span class="n">final_arr</span><span class="p">[</span><span class="n">tmp_im</span><span class="o">.</span><span class="n">array</span> <span class="o">&gt;</span> <span class="n">final_arr</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp_im</span><span class="o">.</span><span class="n">array</span><span class="p">[</span><span class="n">tmp_im</span><span class="o">.</span><span class="n">array</span> <span class="o">&gt;</span> <span class="n">final_arr</span><span class="p">]</span>

        <span class="c1"># Now simply take the halfcomplex, compact stored part that we are interested in,</span>
        <span class="c1"># remembering that the kx=ky=0 element is still in the centre</span>
        <span class="n">final_arr</span> <span class="o">=</span> <span class="n">final_arr</span><span class="p">[:,</span> <span class="n">final_arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">//</span><span class="mi">2</span><span class="p">:]</span>
        <span class="c1"># If we extended the array to be odd-sized along y, we have to go back to an even subarray</span>
        <span class="k">if</span> <span class="n">do_expansion</span><span class="p">:</span> <span class="n">final_arr</span> <span class="o">=</span> <span class="n">final_arr</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>
        <span class="c1"># Finally roll back the leading dimension</span>
        <span class="n">final_arr</span> <span class="o">=</span> <span class="n">utilities</span><span class="o">.</span><span class="n">roll2d</span><span class="p">(</span><span class="n">final_arr</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">final_arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">//</span> <span class="mi">2</span><span class="p">),</span> <span class="mi">0</span><span class="p">))</span>
        <span class="c1"># final_arr now contains the halfcomplex compact format PS of the maximum of the set of PS</span>
        <span class="c1"># images rotated by 2pi/order, which (a) should be symmetric at the required order and</span>
        <span class="c1"># (b) be the minimal array that is symmetric at that order and &gt;= the original PS.  So we do</span>
        <span class="c1"># not have to add any more noise to ensure that the target symmetrized PS is always &gt;= the</span>
        <span class="c1"># original one.</span>
        <span class="k">return</span> <span class="n">final_arr</span></div>

<span class="c1">###</span>
<span class="c1"># Now a standalone utility function for generating noise according to an input (square rooted)</span>
<span class="c1"># Power Spectrum</span>
<span class="c1">#</span>
<span class="k">def</span> <span class="nf">_generate_noise_from_rootps</span><span class="p">(</span><span class="n">rng</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">rootps</span><span class="p">):</span>
    <span class="c1"># Utility function for generating a NumPy array containing a Gaussian random noise field with</span>
    <span class="c1"># a user-specified power spectrum also supplied as a NumPy array.</span>

    <span class="c1"># shape is the shape of the output array, needed because of the use of Hermitian symmetry to</span>
    <span class="c1">#       increase inverse FFT efficiency using the np.fft.irfft2 function (gets sent</span>
    <span class="c1">#       to the kwarg s of np.fft.irfft2)</span>
    <span class="c1"># rootps is a NumPy array containing the square root of the discrete power spectrum ordered</span>
    <span class="c1">#        in two dimensions according to the usual DFT pattern for np.fft.rfft2 output</span>

    <span class="c1"># Returns a NumPy array (contiguous) of the requested shape, filled with the noise field.</span>

    <span class="c1"># Quickest to create Gaussian rng each time needed, so do that here...</span>
    <span class="c1"># Note sigma scaling: 1/sqrt(2) needed so &lt;|gaussvec|**2&gt; = product(shape)</span>
    <span class="c1"># shape needed because of the asymmetry in the 1/N^2 division in the NumPy FFT/iFFT</span>
    <span class="n">gd</span> <span class="o">=</span> <span class="n">GaussianDeviate</span><span class="p">(</span><span class="n">rng</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">.5</span> <span class="o">*</span> <span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>

    <span class="c1"># Fill a couple of arrays with this noise</span>
    <span class="n">gvec_real</span> <span class="o">=</span> <span class="n">utilities</span><span class="o">.</span><span class="n">rand_arr</span><span class="p">((</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">//</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="n">gd</span><span class="p">)</span>
    <span class="n">gvec_imag</span> <span class="o">=</span> <span class="n">utilities</span><span class="o">.</span><span class="n">rand_arr</span><span class="p">((</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">//</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="n">gd</span><span class="p">)</span>
    <span class="c1"># Prepare a complex vector upon which to impose Hermitian symmetry</span>
    <span class="n">gvec</span> <span class="o">=</span> <span class="n">gvec_real</span> <span class="o">+</span> <span class="mi">1</span><span class="n">J</span> <span class="o">*</span> <span class="n">gvec_imag</span>
    <span class="c1"># Now impose requirements of Hermitian symmetry on random Gaussian halfcomplex array, and ensure</span>
    <span class="c1"># self-conjugate elements (e.g. [0, 0]) are purely real and multiplied by sqrt(2) to compensate</span>
    <span class="c1"># for lost variance, see https://github.com/GalSim-developers/GalSim/issues/563</span>
    <span class="c1"># First do the bits necessary for both odd and even shapes:</span>
    <span class="n">gvec</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">//</span><span class="mi">2</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">gvec</span><span class="p">[</span><span class="mi">1</span><span class="p">:(</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
    <span class="n">rt2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">2.</span><span class="p">)</span>
    <span class="n">gvec</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">rt2</span> <span class="o">*</span> <span class="n">gvec</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">real</span>
    <span class="c1"># Then make the changes necessary for even sized arrays</span>
    <span class="k">if</span> <span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="c1"># x dimension even</span>
        <span class="n">gvec</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">//</span><span class="mi">2</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">//</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">gvec</span><span class="p">[</span><span class="mi">1</span><span class="p">:(</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span><span class="p">,</span> <span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">//</span><span class="mi">2</span><span class="p">])</span>
        <span class="n">gvec</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">//</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">rt2</span> <span class="o">*</span> <span class="n">gvec</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">//</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">real</span>
    <span class="k">if</span> <span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="c1"># y dimension even</span>
        <span class="n">gvec</span><span class="p">[</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">//</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">rt2</span> <span class="o">*</span> <span class="n">gvec</span><span class="p">[</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">//</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">real</span>
        <span class="c1"># Both dimensions even</span>
        <span class="k">if</span> <span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">gvec</span><span class="p">[</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">//</span><span class="mi">2</span><span class="p">,</span> <span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">//</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">rt2</span> <span class="o">*</span> <span class="n">gvec</span><span class="p">[</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">//</span><span class="mi">2</span><span class="p">,</span> <span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">//</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">real</span>
    <span class="c1"># Finally generate and return noise using the irfft</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">irfft2</span><span class="p">(</span><span class="n">gvec</span> <span class="o">*</span> <span class="n">rootps</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">shape</span><span class="p">)</span>


<span class="c1">###</span>
<span class="c1"># Then we define the CorrelatedNoise, which generates a correlation function by estimating it</span>
<span class="c1"># directly from images:</span>
<span class="c1">#</span>
<div class="viewcode-block" id="CorrelatedNoise"><a class="viewcode-back" href="../../corr_noise.html#galsim.CorrelatedNoise">[docs]</a><span class="k">class</span> <span class="nc">CorrelatedNoise</span><span class="p">(</span><span class="n">BaseCorrelatedNoise</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A class that represents 2D correlated noise fields calculated from an input `Image`.</span>

<span class="sd">    This class stores an internal representation of a 2D, discrete correlation function, and allows</span>
<span class="sd">    a number of subsequent operations including interpolation, shearing, magnification and rendering</span>
<span class="sd">    of the correlation function profile into an output `Image`.</span>

<span class="sd">    The class also allows correlated Gaussian noise fields to be generated according to the</span>
<span class="sd">    correlation function, and added to an `Image`: see `BaseCorrelatedNoise.applyTo`.</span>

<span class="sd">    It also provides methods for whitening or imposing N-fold symmetry on pre-existing noise that</span>
<span class="sd">    shares the same spatial correlations: see `BaseCorrelatedNoise.whitenImage` and</span>
<span class="sd">    `BaseCorrelatedNoise.symmetrizeImage`, respectively.</span>

<span class="sd">    It also allows the combination of multiple correlation functions by addition, and for the</span>
<span class="sd">    scaling of the total variance they represent by scalar factors.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        image:              The image from which to derive the correlated noise profile</span>
<span class="sd">        rng:                A `BaseDeviate` instance to use for generating the random numbers.</span>
<span class="sd">        scale:              If provided, use this as the pixel scale.  Normally, the scale (or wcs)</span>
<span class="sd">                            is taken from the image.wcs field, but you may override that by</span>
<span class="sd">                            providing either scale or wcs.  [default: use image.wcs if defined,</span>
<span class="sd">                            else 1.0, unless ``wcs`` is provided]</span>
<span class="sd">        wcs:                If provided, use this as the wcs for the image.  At most one of</span>
<span class="sd">                            ``scale`` or ``wcs`` may be provided. [default: None]</span>
<span class="sd">        x_interpolant:      The interpolant to use for interpolating the image of the correlation</span>
<span class="sd">                            function. (See below.) [default: galsim.Linear()]</span>
<span class="sd">        correct_periodicity: Whether to correct for the effects of periodicity.  (See below.)</span>
<span class="sd">                            [default: True]</span>
<span class="sd">        subtract_mean:      Whether to subtract off the mean value from the image before computing</span>
<span class="sd">                            the correlation function. [default: False]</span>
<span class="sd">        gsparams:           An optional `GSParams` argument. [default: None]</span>

<span class="sd">    **Basic example**::</span>

<span class="sd">        &gt;&gt;&gt; cn = galsim.CorrelatedNoise(image, rng=rng)</span>

<span class="sd">    Instantiates a CorrelatedNoise using the pixel scale information contained in ``image.scale``</span>
<span class="sd">    (assumes the scale is unity if ``image.scale &lt;= 0.``) by calculating the correlation function</span>
<span class="sd">    in the input ``image``.  The input ``rng`` must be a `BaseDeviate` or derived class instance,</span>
<span class="sd">    setting the random number generation for the noise.</span>

<span class="sd">    **Optional Inputs**::</span>

<span class="sd">        &gt;&gt;&gt; cn = galsim.CorrelatedNoise(image, rng=rng, scale=0.2)</span>

<span class="sd">    The example above instantiates a CorrelatedNoise, but forces the use of the pixel scale</span>
<span class="sd">    ``scale`` to set the units of the internal lookup table.::</span>

<span class="sd">        &gt;&gt;&gt; cn = galsim.CorrelatedNoise(image, rng=rng, x_interpolant=galsim.Lanczos(5))</span>

<span class="sd">    The example above instantiates a CorrelatedNoise, but forces use of a non-default interpolant</span>
<span class="sd">    for interpolation of the internal lookup table in real space.</span>

<span class="sd">    The default ``x_interpolant`` is ``galsim.Linear()``, which uses bilinear interpolation.</span>
<span class="sd">    The use of this interpolant is an approximation that gives good empirical results without</span>
<span class="sd">    requiring internal convolution of the correlation function profile by a `Pixel` object when</span>
<span class="sd">    applying correlated noise to images: such an internal convolution has been found to be</span>
<span class="sd">    computationally costly in practice, requiring the Fourier transform of very large arrays.</span>

<span class="sd">    The use of the bilinear interpolants means that the representation of correlated noise will be</span>
<span class="sd">    noticeably inaccurate in at least the following two regimes:</span>

<span class="sd">      i)  If the pixel scale of the desired final output (e.g. the target image of</span>
<span class="sd">          `BaseCorrelatedNoise.drawImage`, `BaseCorrelatedNoise.applyTo` or</span>
<span class="sd">          `BaseCorrelatedNoise.whitenImage`) is small relative to the separation between pixels</span>
<span class="sd">          in the ``image`` used to instantiate ``cn`` as shown above.</span>
<span class="sd">      ii) If the CorrelatedNoise instance ``cn`` was instantiated with an image of scale comparable</span>
<span class="sd">          to that in the final output, and ``cn`` has been rotated or otherwise transformed (e.g.</span>
<span class="sd">          via the `BaseCorrelatedNoise.rotate`, `BaseCorrelatedNoise.shear` methods; see below).</span>

<span class="sd">    Conversely, the approximation will work best in the case where the correlated noise used to</span>
<span class="sd">    instantiate the ``cn`` is taken from an input image for which ``image.scale`` is smaller than</span>
<span class="sd">    that in the desired output.  This is the most common use case in the practical treatment of</span>
<span class="sd">    correlated noise when simulating galaxies from space telescopes, such as COSMOS.</span>

<span class="sd">    Changing from the default bilinear interpolant is made possible, but not recommended.</span>
<span class="sd">    In our validation tests, we found that the Linear interpolant usually gave the most</span>
<span class="sd">    accurate results.</span>

<span class="sd">    There is also an option to switch off an internal correction for assumptions made about the</span>
<span class="sd">    periodicity in the input noise image.  If you wish to turn this off you may, e.g.::</span>

<span class="sd">        &gt;&gt;&gt; cn = galsim.CorrelatedNoise(image, rng=rng, correct_periodicity=False)</span>

<span class="sd">    The default and generally recommended setting is ``correct_periodicity=True``.</span>

<span class="sd">    Users should note that the internal calculation of the discrete correlation function in</span>
<span class="sd">    ``image`` will assume that ``image`` is periodic across its boundaries, introducing a dilution</span>
<span class="sd">    bias in the estimate of inter-pixel correlations that increases with separation.  Unless you</span>
<span class="sd">    know that the noise in ``image`` is indeed periodic (perhaps because you generated it to be so),</span>
<span class="sd">    you will not generally wish to use the ``correct_periodicity=False`` option.</span>

<span class="sd">    By default, the image is not mean subtracted before the correlation function is estimated.  To</span>
<span class="sd">    do an internal mean subtraction, you can set the ``subtract_mean`` keyword to ``True``, e.g.::</span>

<span class="sd">        &gt;&gt;&gt; cn = galsim.CorrelatedNoise(image, rng=rng, subtract_mean=True)</span>

<span class="sd">    Using the ``subtract_mean`` option will introduce a small underestimation of variance and other</span>
<span class="sd">    correlation function values due to a bias on the square of the sample mean.  This bias reduces</span>
<span class="sd">    as the input image becomes larger, and in the limit of uncorrelated noise tends to the constant</span>
<span class="sd">    term ``variance/N**2`` for an N x N sized ``image``.</span>

<span class="sd">    It is therefore recommended that a background/sky subtraction is applied to the ``image`` before</span>
<span class="sd">    it is given as an input to the `CorrelatedNoise`, allowing the default ``subtract_mean=False``.</span>
<span class="sd">    If such a background model is global or based on large regions on sky then assuming that the</span>
<span class="sd">    image has a zero population mean will be reasonable, and won&#39;t introduce a bias in covariances</span>
<span class="sd">    from an imperfectly-estimated sample mean subtraction.  If this is not possible, just be aware</span>
<span class="sd">    that ``subtract_mean=True`` will bias the correlation function low to some level.</span>

<span class="sd">    You may also specify a gsparams argument.  See the docstring for `GSParams` for more</span>
<span class="sd">    information about this option.</span>

<span class="sd">    **Methods**:</span>

<span class="sd">    The main way that a CorrelatedNoise is used is to add correlated noise to an image.</span>
<span class="sd">    The syntax::</span>

<span class="sd">        &gt;&gt;&gt; image.addNoise(cn)</span>

<span class="sd">    is preferred, although::</span>

<span class="sd">        &gt;&gt;&gt; cn.applyTo(image)</span>

<span class="sd">    is equivalent.  See the `Image.addNoise` method docstring for more information.  The</span>
<span class="sd">    ``image.scale`` is used to get the pixel scale of the input image unless this is &lt;= 0, in which</span>
<span class="sd">    case a scale of 1 is assumed.</span>

<span class="sd">    A number of methods familiar from `GSObject` instances have also been implemented directly as</span>
<span class="sd">    ``cn`` methods, so that the following commands are all legal::</span>

<span class="sd">        &gt;&gt;&gt; image = cn.drawImage(im, scale)</span>
<span class="sd">        &gt;&gt;&gt; cn = cn.shear(s)</span>
<span class="sd">        &gt;&gt;&gt; cn = cn.expand(m)</span>
<span class="sd">        &gt;&gt;&gt; cn = cn.rotate(theta * galsim.degrees)</span>
<span class="sd">        &gt;&gt;&gt; cn = cn.transform(dudx, dudy, dvdx, dvdy)</span>

<span class="sd">    See the individual method docstrings for more details.  The ``shift`` method is not available</span>
<span class="sd">    since a correlation function must always be centred and peaked at the origin.</span>

<span class="sd">    The methods::</span>

<span class="sd">        &gt;&gt;&gt; var = cn.getVariance()</span>
<span class="sd">        &gt;&gt;&gt; cn1 = cn.withVariance(variance)</span>
<span class="sd">        &gt;&gt;&gt; cn2 = cn.withScaledVariance(variance_ratio)</span>

<span class="sd">    can be used to get and set the point variance of the correlated noise, equivalent to the zero</span>
<span class="sd">    separation distance correlation function value.</span>

<span class="sd">    The `BaseCorrelatedNoise.withVariance` method scales the whole internal correlation function so</span>
<span class="sd">    that its point variance matches ``variance``.</span>

<span class="sd">    Similarly, `BaseCorrelatedNoise.withScaledVariance` scales the entire function by the given</span>
<span class="sd">    factor.</span>

<span class="sd">    **Arithmetic Operators**:</span>

<span class="sd">    Addition, multiplication and division operators are defined to work in an intuitive way for</span>
<span class="sd">    correlation functions.</span>

<span class="sd">    Addition works simply to add the internally-stored correlation functions, so that::</span>

<span class="sd">        &gt;&gt;&gt; cn3 = cn2 + cn1</span>
<span class="sd">        &gt;&gt;&gt; cn4 += cn5</span>

<span class="sd">    provides a representation of the correlation function of two linearly summed fields represented</span>
<span class="sd">    by the individual correlation function operands.</span>

<span class="sd">    What happens to the internally stored random number generators in the examples above?  For all</span>
<span class="sd">    addition operations it is the `BaseDeviate` belonging to the instance on the *left-hand side*</span>
<span class="sd">    of the operator that is retained.</span>

<span class="sd">    In the example above therefore, it is the random number generator from ``cn2`` that will be</span>
<span class="sd">    stored and used by ``cn3``, and ``cn4`` will retain its random number generator after in-place</span>
<span class="sd">    addition of ``cn5``.  The random number generator of ``cn5`` is not affected by the operation.</span>

<span class="sd">    The multiplication and division operators, e.g.::</span>

<span class="sd">        &gt;&gt;&gt; cn1 /= 3.</span>
<span class="sd">        &gt;&gt;&gt; cn2 = cn1 * 3</span>

<span class="sd">    scale the overall correlation function by a scalar operand.  The random number generators are</span>
<span class="sd">    not affected by these scaling operations.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span> <span class="n">rng</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">wcs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">x_interpolant</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">correct_periodicity</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">subtract_mean</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">gsparams</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="c1"># Check that the input image is in fact a galsim.ImageSIFD class instance</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">Image</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Input image not a galsim.Image object&quot;</span><span class="p">)</span>
        <span class="c1"># Build a noise correlation function (CF) from the input image, using DFTs</span>
        <span class="c1"># Calculate the power spectrum then a (preliminary) CF</span>
        <span class="n">ft_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">rfft2</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">array</span><span class="p">)</span>
        <span class="n">ps_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">ft_array</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="c1"># Using timeit abs() seems to have the slight speed edge over</span>
                                       <span class="c1"># all other options tried, cf. results described by MJ in</span>
                                       <span class="c1"># the optics.psf() function in optics.py</span>

        <span class="c1"># Need to normalize ps due to one-directional 1/N^2 in FFT conventions and the fact that</span>
        <span class="c1"># we *squared* the ft_array to get ps_array:</span>
        <span class="n">ps_array</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">subtract_mean</span><span class="p">:</span> <span class="c1"># Quickest non-destructive way to make the PS correspond to the</span>
                          <span class="c1"># mean-subtracted case</span>
            <span class="n">ps_array</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.</span>

        <span class="c1"># Then calculate the CF by inverse DFT</span>
        <span class="n">cf_array_prelim</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">irfft2</span><span class="p">(</span><span class="n">ps_array</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">image</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

        <span class="n">store_rootps</span> <span class="o">=</span> <span class="kc">True</span> <span class="c1"># Currently the ps_array above corresponds to cf, but this may change...</span>

        <span class="c1"># Apply a correction for the DFT assumption of periodicity unless user requests otherwise</span>
        <span class="k">if</span> <span class="n">correct_periodicity</span><span class="p">:</span>
            <span class="n">cf_array_prelim</span> <span class="o">*=</span> <span class="n">_cf_periodicity_dilution_correction</span><span class="p">(</span><span class="n">cf_array_prelim</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="n">store_rootps</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># Roll CF array to put the centre in image centre.  Remember that numpy stores data [y,x]</span>
        <span class="n">cf_array_prelim</span> <span class="o">=</span> <span class="n">utilities</span><span class="o">.</span><span class="n">roll2d</span><span class="p">(</span>
            <span class="n">cf_array_prelim</span><span class="p">,</span> <span class="p">(</span><span class="n">cf_array_prelim</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">//</span> <span class="mi">2</span><span class="p">,</span> <span class="n">cf_array_prelim</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">//</span> <span class="mi">2</span><span class="p">))</span>

        <span class="c1"># The underlying C++ object is expecting the CF to be represented by an odd-dimensioned</span>
        <span class="c1"># array with the central pixel denoting the zero-distance correlation (variance), even</span>
        <span class="c1"># even if the input image was even-dimensioned on one or both sides.</span>
        <span class="c1"># We therefore copy-paste and zero pad the CF calculated above to ensure that these</span>
        <span class="c1"># expectations are met.</span>
        <span class="c1">#</span>
        <span class="c1"># Determine the largest dimension of the input image, and use it to generate an empty CF</span>
        <span class="c1"># array for final output, padding by one to make odd if necessary:</span>
        <span class="n">cf_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span>
            <span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">cf_array_prelim</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">//</span> <span class="mi">2</span><span class="p">),</span>
            <span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">cf_array_prelim</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)))</span> <span class="c1"># using integer division</span>

        <span class="c1"># Then put the data from the prelim CF into this array</span>
        <span class="n">cf_array</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">cf_array_prelim</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">:</span><span class="n">cf_array_prelim</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">cf_array_prelim</span>
        <span class="c1"># Then copy-invert-paste data from the leftmost column to the rightmost column, and lowest</span>
        <span class="c1"># row to the uppermost row, if the original CF had even dimensions in the x and y</span>
        <span class="c1"># directions, respectively (remembering again that NumPy stores data [y,x] in arrays)</span>
        <span class="k">if</span> <span class="n">cf_array_prelim</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="c1"># first do x</span>
            <span class="n">lhs_column</span> <span class="o">=</span> <span class="n">cf_array</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">cf_array</span><span class="p">[:,</span> <span class="n">cf_array_prelim</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">lhs_column</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="c1"># inverts order as required</span>
        <span class="k">if</span> <span class="n">cf_array_prelim</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="c1"># then do y</span>
            <span class="n">bottom_row</span> <span class="o">=</span> <span class="n">cf_array</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span>
            <span class="n">cf_array</span><span class="p">[</span><span class="n">cf_array_prelim</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">bottom_row</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="c1"># inverts order as required</span>

        <span class="c1"># Wrap correlation function in an image</span>
        <span class="n">cf_image</span> <span class="o">=</span> <span class="n">Image</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">cf_array</span><span class="p">))</span>

        <span class="c1"># Set the wcs if necessary</span>
        <span class="k">if</span> <span class="n">wcs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">scale</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">GalSimIncompatibleValuesError</span><span class="p">(</span><span class="s2">&quot;Cannot provide both wcs and scale&quot;</span><span class="p">,</span>
                                                    <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">,</span> <span class="n">wcs</span><span class="o">=</span><span class="n">scale</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">wcs</span><span class="p">,</span> <span class="n">BaseWCS</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;wcs must be a BaseWCS instance&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">wcs</span><span class="o">.</span><span class="n">_isUniform</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">GalSimValueError</span><span class="p">(</span><span class="s2">&quot;Cannot provide non-uniform wcs&quot;</span><span class="p">,</span> <span class="n">wcs</span><span class="p">)</span>
            <span class="n">cf_image</span><span class="o">.</span><span class="n">wcs</span> <span class="o">=</span> <span class="n">wcs</span>
        <span class="k">elif</span> <span class="n">scale</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">cf_image</span><span class="o">.</span><span class="n">scale</span> <span class="o">=</span> <span class="n">scale</span>
        <span class="k">elif</span> <span class="n">image</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">image</span><span class="o">.</span><span class="n">wcs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">cf_image</span><span class="o">.</span><span class="n">wcs</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">wcs</span><span class="o">.</span><span class="n">local</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">true_center</span><span class="p">)</span>

        <span class="c1"># If wcs is still None at this point or is a PixelScale &lt;= 0., use scale=1.</span>
        <span class="k">if</span> <span class="n">cf_image</span><span class="o">.</span><span class="n">wcs</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="p">(</span><span class="n">cf_image</span><span class="o">.</span><span class="n">wcs</span><span class="o">.</span><span class="n">_isPixelScale</span> <span class="ow">and</span> <span class="n">cf_image</span><span class="o">.</span><span class="n">wcs</span><span class="o">.</span><span class="n">scale</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">):</span>
            <span class="n">cf_image</span><span class="o">.</span><span class="n">scale</span> <span class="o">=</span> <span class="mf">1.</span>

        <span class="c1"># If x_interpolant not specified on input, use bilinear</span>
        <span class="k">if</span> <span class="n">x_interpolant</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">x_interpolant</span> <span class="o">=</span> <span class="n">Linear</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">x_interpolant</span> <span class="o">=</span> <span class="n">utilities</span><span class="o">.</span><span class="n">convert_interpolant</span><span class="p">(</span><span class="n">x_interpolant</span><span class="p">)</span>

        <span class="c1"># Then initialize...</span>
        <span class="n">cf_object</span> <span class="o">=</span> <span class="n">InterpolatedImage</span><span class="p">(</span>
            <span class="n">cf_image</span><span class="p">,</span> <span class="n">x_interpolant</span><span class="o">=</span><span class="n">x_interpolant</span><span class="p">,</span> <span class="n">normalization</span><span class="o">=</span><span class="s2">&quot;sb&quot;</span><span class="p">,</span>
            <span class="n">calculate_stepk</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">calculate_maxk</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="c1">#&lt;-these internal calculations do not seem</span>
            <span class="n">gsparams</span><span class="o">=</span><span class="n">gsparams</span><span class="p">)</span>                           <span class="c1">#  to do very well with often sharp-peaked</span>
                                                         <span class="c1">#  correlation function images...</span>
        <span class="n">BaseCorrelatedNoise</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rng</span><span class="p">,</span> <span class="n">cf_object</span><span class="p">,</span> <span class="n">cf_image</span><span class="o">.</span><span class="n">wcs</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">store_rootps</span><span class="p">:</span>
            <span class="c1"># If it corresponds to the CF above, store in the cache</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_profile_for_cached</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_profile</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="n">ps_array</span><span class="o">.</span><span class="n">shape</span>
            <span class="n">half_shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="n">half_shape</span><span class="p">,</span> <span class="n">cf_image</span><span class="o">.</span><span class="n">wcs</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_rootps_cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">ps_array</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_image</span> <span class="o">=</span> <span class="n">image</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;galsim.CorrelatedNoise(</span><span class="si">%s</span><span class="s2">, wcs=</span><span class="si">%s</span><span class="s2">)&quot;</span><span class="o">%</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_image</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">wcs</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">_cf_periodicity_dilution_correction</span><span class="p">(</span><span class="n">cf_shape</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return an array containing the correction factor required for wrongly assuming periodicity</span>
<span class="sd">    around noise field edges in an DFT estimate of the discrete correlation function.</span>

<span class="sd">    Uses the result calculated by MJ on GalSim Pull Request #366.</span>
<span class="sd">    See https://github.com/GalSim-developers/GalSim/pull/366.</span>

<span class="sd">    Returns a 2D NumPy array with the same shape as the input parameter tuple ``cf_shape``.  This</span>
<span class="sd">    array contains the correction factor by which elements in the naive CorrelatedNoise estimate of</span>
<span class="sd">    the discrete correlation function should be multiplied to correct for the erroneous assumption</span>
<span class="sd">    of periodic boundaries in an input noise field.</span>

<span class="sd">    Note this should be applied only to correlation functions that have *not* been rolled to place</span>
<span class="sd">    the origin at the array centre.  The convention used here is that the lower left corner is the</span>
<span class="sd">    [0, 0] origin, following standard FFT conventions (see e.g numpy.fft.fftfreq).  You should</span>
<span class="sd">    therefore only apply this correction before using galsim.utilities.roll2d() to recentre the</span>
<span class="sd">    image of the correlation function.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># First calculate the Delta_x, Delta_y</span>
    <span class="n">deltax</span><span class="p">,</span> <span class="n">deltay</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span> <span class="c1"># Remember NumPy array shapes are [y, x]</span>
        <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftfreq</span><span class="p">(</span><span class="n">cf_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="nb">float</span><span class="p">(</span><span class="n">cf_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
        <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftfreq</span><span class="p">(</span><span class="n">cf_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="nb">float</span><span class="p">(</span><span class="n">cf_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
    <span class="c1"># Then get the dilution correction</span>
    <span class="n">correction</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">cf_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">cf_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="n">cf_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">deltax</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="n">cf_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">deltay</span><span class="p">)))</span>
    <span class="k">return</span> <span class="n">correction</span>


<span class="c1"># Free function for returning a COSMOS noise field correlation function</span>
<div class="viewcode-block" id="getCOSMOSNoise"><a class="viewcode-back" href="../../corr_noise.html#galsim.getCOSMOSNoise">[docs]</a><span class="k">def</span> <span class="nf">getCOSMOSNoise</span><span class="p">(</span><span class="n">file_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rng</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cosmos_scale</span><span class="o">=</span><span class="mf">0.03</span><span class="p">,</span> <span class="n">variance</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span> <span class="n">x_interpolant</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                   <span class="n">gsparams</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Returns a representation of correlated noise in the HST COSMOS F814W unrotated science coadd</span>
<span class="sd">    images.</span>

<span class="sd">    See http://cosmos.astro.caltech.edu/astronomer/hst.html for information about the COSMOS survey,</span>
<span class="sd">    and Leauthaud et al (2007) for detailed information about the unrotated F814W coadds used for</span>
<span class="sd">    weak lensing science.</span>

<span class="sd">    This function uses a stacked estimate of the correlation function in COSMOS noise fields.</span>
<span class="sd">    The correlation function was computed by the GalSim team as described in::</span>

<span class="sd">        GalSim/devel/external/hst/make_cosmos_cfimage.py</span>

<span class="sd">    The resulting file is distributed with GalSim as::</span>

<span class="sd">        os.path.join(&#39;galsim.meta_data.share_dir&#39;, &#39;acs_I_unrot_sci_20_cf.fits&#39;)</span>

<span class="sd">    Parameters:</span>
<span class="sd">        file_name:      If provided, override the usual location of the file with the given</span>
<span class="sd">                        file name.  [default: None]</span>
<span class="sd">        rng:            If provided, a random number generator to use as the random number</span>
<span class="sd">                        generator of the resulting noise object. (may be any kind of</span>
<span class="sd">                        `BaseDeviate` object) [default: None, in which case, one will be</span>
<span class="sd">                        automatically created, using the time as a seed.]</span>
<span class="sd">        cosmos_scale:   COSMOS ACS F814W coadd image pixel scale in the units you are using to</span>
<span class="sd">                        describe `GSObject` instances and image scales in GalSim. [default: 0.03</span>
<span class="sd">                        (arcsec), see below for more information.]</span>
<span class="sd">        variance:       Scales the correlation function so that its point variance, equivalent</span>
<span class="sd">                        to its value at zero separation distance, matches this value.</span>
<span class="sd">                        [default: 0., which means to use the variance in the original COSMOS</span>
<span class="sd">                        noise fields.]</span>
<span class="sd">        x_interpolant:  Forces use of a non-default interpolant for interpolation of the</span>
<span class="sd">                        internal lookup table in real space.  See below for more details.</span>
<span class="sd">                        [default: galsim.Linear()]</span>
<span class="sd">        gsparams:       An optional `GSParams` argument. [default: None]</span>

<span class="sd">    Returns:</span>
<span class="sd">        a `BaseCorrelatedNoise` instance representing correlated noise in F814W COSMOS images.</span>

<span class="sd">    The default ``x_interpolant`` is a ``galsim.Linear()``, which uses bilinear interpolation.</span>
<span class="sd">    The use of this interpolant is an approximation that gives good empirical results without</span>
<span class="sd">    requiring internal convolution of the correlation function profile by a `Pixel` object when</span>
<span class="sd">    applying correlated noise to images: such an internal convolution has been found to be</span>
<span class="sd">    computationally costly in practice, requiring the Fourier transform of very large arrays.</span>

<span class="sd">    The use of the bilinear interpolants means that the representation of correlated noise will be</span>
<span class="sd">    noticeably inaccurate in at least the following two regimes:</span>

<span class="sd">    1. If the pixel scale of the desired final output (e.g. the target image of</span>
<span class="sd">       `BaseCorrelatedNoise.drawImage`, `BaseCorrelatedNoise.applyTo` or</span>
<span class="sd">       `BaseCorrelatedNoise.whitenImage`) is small relative to the separation between pixels in</span>
<span class="sd">       the ``image`` used to instantiate ``cn`` as shown above.</span>
<span class="sd">    2. If the `BaseCorrelatedNoise` instance ``cn`` was instantiated with an image of scale</span>
<span class="sd">       comparable to that in the final output, and ``cn`` has been rotated or otherwise transformed</span>
<span class="sd">       (e.g.  via the `BaseCorrelatedNoise.rotate`, `BaseCorrelatedNoise.shear` methods; see below).</span>

<span class="sd">    Conversely, the approximation will work best in the case where the correlated noise used to</span>
<span class="sd">    instantiate the ``cn`` is taken from an input image for which ``image.scale`` is smaller than</span>
<span class="sd">    that in the desired output.  This is the most common use case in the practical treatment of</span>
<span class="sd">    correlated noise when simulating galaxies from COSMOS, for which this function is expressly</span>
<span class="sd">    designed.</span>

<span class="sd">    Changing from the default bilinear interpolant is made possible, but not recommended.</span>
<span class="sd">    In our validation tests, we found that the Linear interpolant usually gave the most</span>
<span class="sd">    accurate results.</span>

<span class="sd">    You may also specify a gsparams argument.  See the docstring for `GSParams` for more</span>
<span class="sd">    information about this option.</span>

<span class="sd">    .. note::</span>

<span class="sd">        The ACS coadd images in COSMOS have a pixel scale of 0.03 arcsec, and so the pixel scale</span>
<span class="sd">        ``cosmos_scale`` adopted in the representation of of the correlation function takes a</span>
<span class="sd">        default value ``cosmos_scale = 0.03``</span>

<span class="sd">        If you wish to use other units, ensure that the input keyword ``cosmos_scale`` takes the</span>
<span class="sd">        value corresponding to 0.03 arcsec in your chosen system.</span>

<span class="sd">    **Example**:</span>

<span class="sd">    The following commands use this function to generate a 300 pixel x 300 pixel image of noise with</span>
<span class="sd">    HST COSMOS correlation properties (substitute in your own file and path for the ``filestring``)::</span>

<span class="sd">        &gt;&gt;&gt; rng = galsim.BaseDeviate(123456)</span>
<span class="sd">        &gt;&gt;&gt; noise = galsim.getCOSMOSNoise(rng=rng)</span>
<span class="sd">        &gt;&gt;&gt; image = galsim.ImageD(nx, ny, scale=0.03)</span>
<span class="sd">        &gt;&gt;&gt; image.addNoise(cf)</span>

<span class="sd">    If your image has some other pixel scale or a complicated WCS, then the applied noise will</span>
<span class="sd">    have the correct correlations in world coordinates, which may not be what you wanted if you</span>
<span class="sd">    expected the pixel-to-pixel correlations to match the COSMOS noise profile.  However, in</span>
<span class="sd">    this case, you would want to view your image with the COSMOS pixel scale when you apply</span>
<span class="sd">    the noise::</span>

<span class="sd">        &gt;&gt;&gt; image = galsim.Image(nx, ny, wcs=complicated_wcs)</span>
<span class="sd">        &gt;&gt;&gt; noise = galsim.getCOSMOSNoise(rng=rng)</span>
<span class="sd">        &gt;&gt;&gt; image.view(wcs=noise.wcs).addNoise(noise)</span>

<span class="sd">    The FITS file ``out.fits`` should then contain an image of randomly-generated, COSMOS-like noise.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">file_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">file_name</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">meta_data</span><span class="o">.</span><span class="n">share_dir</span><span class="p">,</span><span class="s1">&#39;acs_I_unrot_sci_20_cf.fits&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">BaseCorrelatedNoise</span><span class="o">.</span><span class="n">from_file</span><span class="p">(</span><span class="n">file_name</span><span class="p">,</span> <span class="n">cosmos_scale</span><span class="p">,</span>
                                         <span class="n">rng</span><span class="o">=</span><span class="n">rng</span><span class="p">,</span> <span class="n">variance</span><span class="o">=</span><span class="n">variance</span><span class="p">,</span>
                                         <span class="n">x_interpolant</span><span class="o">=</span><span class="n">x_interpolant</span><span class="p">,</span>
                                         <span class="n">gsparams</span><span class="o">=</span><span class="n">gsparams</span><span class="p">)</span></div>

<div class="viewcode-block" id="UncorrelatedNoise"><a class="viewcode-back" href="../../corr_noise.html#galsim.UncorrelatedNoise">[docs]</a><span class="k">class</span> <span class="nc">UncorrelatedNoise</span><span class="p">(</span><span class="n">BaseCorrelatedNoise</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A class that represents 2D correlated noise fields that are actually (at least initially)</span>
<span class="sd">    uncorrelated.  Subsequent applications of things like `BaseCorrelatedNoise.shear` or</span>
<span class="sd">    `BaseCorrelatedNoise.convolvedWith` will induce correlations.</span>

<span class="sd">    The noise is characterized by a variance in each image pixel and a pixel size and shape.</span>
<span class="sd">    The ``variance`` value refers to the noise variance in each pixel.  If the pixels are square</span>
<span class="sd">    (the usual case), you can specify the size using the ``scale`` parameter.  If not, they</span>
<span class="sd">    are effectively specified using the local wcs function that defines the pixel shape.  i.e.::</span>

<span class="sd">        &gt;&gt;&gt; world_pix = wcs.toWorld(Pixel(1.))</span>

<span class="sd">    should return the pixel profile in world coordinates.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        variance:       The noise variance value to model as being uniform and uncorrelated</span>
<span class="sd">                        over the whole image.</span>
<span class="sd">        rng:            If provided, a random number generator to use as the random number</span>
<span class="sd">                        generator of the resulting noise object. (may be any kind of</span>
<span class="sd">                        `BaseDeviate` object) [default: None, in which case, one will be</span>
<span class="sd">                        automatically created, using the time as a seed.]</span>
<span class="sd">        scale:          If provided, use this as the pixel scale.  [default: 1.0, unless ``wcs`` is</span>
<span class="sd">                        provided]</span>
<span class="sd">        wcs:            If provided, use this as the wcs for the image.  At most one of ``scale``</span>
<span class="sd">                        or ``wcs`` may be provided. [default: None]</span>
<span class="sd">        gsparams:       An optional `GSParams` argument. [default: None]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">variance</span><span class="p">,</span> <span class="n">rng</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">wcs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">gsparams</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="k">if</span> <span class="n">variance</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">GalSimRangeError</span><span class="p">(</span><span class="s2">&quot;Specified variance must be zero or positive.&quot;</span><span class="p">,</span>
                                   <span class="n">variance</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">wcs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">scale</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">GalSimIncompatibleValuesError</span><span class="p">(</span><span class="s2">&quot;Cannot provide both wcs and scale&quot;</span><span class="p">,</span>
                                                    <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">,</span> <span class="n">wcs</span><span class="o">=</span><span class="n">wcs</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">wcs</span><span class="p">,</span> <span class="n">BaseWCS</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;wcs must be a BaseWCS instance&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">wcs</span><span class="o">.</span><span class="n">_isUniform</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">GalSimValueError</span><span class="p">(</span><span class="s2">&quot;Cannot provide non-uniform wcs&quot;</span><span class="p">,</span> <span class="n">wcs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">scale</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">wcs</span> <span class="o">=</span> <span class="n">PixelScale</span><span class="p">(</span><span class="n">scale</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">wcs</span> <span class="o">=</span> <span class="n">PixelScale</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span>

        <span class="c1"># Save the things that won&#39;t get saved by the base class, for use in repr.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">variance</span> <span class="o">=</span> <span class="n">variance</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_gsparams</span> <span class="o">=</span> <span class="n">GSParams</span><span class="o">.</span><span class="n">check</span><span class="p">(</span><span class="n">gsparams</span><span class="p">)</span>

        <span class="c1"># Need variance == xvalue(0,0) after autoconvolution</span>
        <span class="c1"># So the Pixel needs to have an amplitude of sigma at (0,0)</span>
        <span class="n">sigma</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">variance</span><span class="p">)</span>
        <span class="n">pix</span> <span class="o">=</span> <span class="n">Pixel</span><span class="p">(</span><span class="n">scale</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">flux</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">gsparams</span><span class="o">=</span><span class="n">gsparams</span><span class="p">)</span>
        <span class="n">cf</span> <span class="o">=</span> <span class="n">AutoConvolve</span><span class="p">(</span><span class="n">pix</span><span class="p">,</span> <span class="n">real_space</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">gsparams</span><span class="o">=</span><span class="n">gsparams</span><span class="p">)</span>
        <span class="n">world_cf</span> <span class="o">=</span> <span class="n">wcs</span><span class="o">.</span><span class="n">profileToWorld</span><span class="p">(</span><span class="n">cf</span><span class="p">)</span>
        <span class="c1"># This gets the shape right, but not the amplitude.  Need to rescale by the pixel area</span>
        <span class="n">world_cf</span> <span class="o">*=</span> <span class="n">wcs</span><span class="o">.</span><span class="n">pixelArea</span><span class="p">()</span>
        <span class="n">BaseCorrelatedNoise</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rng</span><span class="p">,</span> <span class="n">world_cf</span><span class="p">,</span> <span class="n">wcs</span><span class="p">)</span>

<div class="viewcode-block" id="UncorrelatedNoise.withGSParams"><a class="viewcode-back" href="../../corr_noise.html#galsim.UncorrelatedNoise.withGSParams">[docs]</a>    <span class="k">def</span> <span class="nf">withGSParams</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gsparams</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">gsparams</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">gsparams</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">kwargs</span><span class="p">:</span> <span class="k">return</span> <span class="bp">self</span>
        <span class="n">gsparams</span> <span class="o">=</span> <span class="n">GSParams</span><span class="o">.</span><span class="n">check</span><span class="p">(</span><span class="n">gsparams</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gsparams</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">UncorrelatedNoise</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">variance</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rng</span><span class="p">,</span> <span class="n">wcs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">wcs</span><span class="p">,</span> <span class="n">gsparams</span><span class="o">=</span><span class="n">gsparams</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;galsim.UncorrelatedNoise(</span><span class="si">%r</span><span class="s2">, </span><span class="si">%r</span><span class="s2">, wcs=</span><span class="si">%r</span><span class="s2">, gsparams=</span><span class="si">%r</span><span class="s2">)&quot;</span><span class="o">%</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">variance</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rng</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">wcs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gsparams</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;galsim.UncorrelatedNoise(variance=</span><span class="si">%r</span><span class="s2">, wcs=</span><span class="si">%s</span><span class="s2">)&quot;</span><span class="o">%</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">variance</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">wcs</span><span class="p">)</span></div>


<div class="viewcode-block" id="CovarianceSpectrum"><a class="viewcode-back" href="../../spectral.html#galsim.CovarianceSpectrum">[docs]</a><span class="k">class</span> <span class="nc">CovarianceSpectrum</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Class to hold a `ChromaticSum` noise covariance spectrum (which is a generalization of a</span>
<span class="sd">    power spectrum or equivalently a correlation function).</span>

<span class="sd">    Analogous to how a `galsim.CorrelatedNoise` object stores the variance and covariance of a</span>
<span class="sd">    `galsim.Image` object, a `galsim.CovarianceSpectrum` stores the variance and covariance of the</span>
<span class="sd">    Fourier mode amplitudes in different components of a `ChromaticSum`.</span>

<span class="sd">    Note that the covariance in question exists between different `SED` components of the</span>
<span class="sd">    `ChromaticSum`, and not between different Fourier modes, which are assumed to be uncorrelated.</span>
<span class="sd">    This structure arises naturally for a `ChromaticRealGalaxy` (see devel/modules/CGNotes.pdf for</span>
<span class="sd">    more details).</span>

<span class="sd">    Parameters:</span>
<span class="sd">        Sigma:     A dictionary whose keys are tuples numerically indicating a pair of</span>
<span class="sd">                    `ChromaticSum` components whose Fourier mode amplitude covariances are</span>
<span class="sd">                    described by the corresponding `GSObject` values.</span>
<span class="sd">        SEDs:      `SED` instances of associated `ChromaticSum` components.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Sigma</span><span class="p">,</span> <span class="n">SEDs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span> <span class="o">=</span> <span class="n">Sigma</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">SEDs</span> <span class="o">=</span> <span class="n">SEDs</span>

    <span class="k">def</span> <span class="fm">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">variance_ratio</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">withScaledVariance</span><span class="p">(</span><span class="n">variance_ratio</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dudx</span><span class="p">,</span> <span class="n">dudy</span><span class="p">,</span> <span class="n">dvdx</span><span class="p">,</span> <span class="n">dvdy</span><span class="p">):</span>
        <span class="n">Sigma</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">Sigma</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">dudx</span><span class="p">,</span> <span class="n">dudy</span><span class="p">,</span> <span class="n">dvdx</span><span class="p">,</span> <span class="n">dvdy</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">CovarianceSpectrum</span><span class="p">(</span><span class="n">Sigma</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">SEDs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">withScaledVariance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">variance_ratio</span><span class="p">):</span>
        <span class="n">Sigma</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">Sigma</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span> <span class="o">*</span> <span class="n">variance_ratio</span>
        <span class="k">return</span> <span class="n">CovarianceSpectrum</span><span class="p">(</span><span class="n">Sigma</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">SEDs</span><span class="p">)</span>

<div class="viewcode-block" id="CovarianceSpectrum.toNoise"><a class="viewcode-back" href="../../spectral.html#galsim.CovarianceSpectrum.toNoise">[docs]</a>    <span class="k">def</span> <span class="nf">toNoise</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bandpass</span><span class="p">,</span> <span class="n">PSF</span><span class="p">,</span> <span class="n">wcs</span><span class="p">,</span> <span class="n">rng</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Derive the `CorrelatedNoise` object for the associated `ChromaticSum` when convolved</span>
<span class="sd">        with ``PSF`` and drawn through ``bandpass`` onto pixels with specified ``wcs``.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            bandpass:     `Bandpass` object representing filter image is drawn through.</span>
<span class="sd">            PSF:          output chromatic PSF to convolve by.</span>
<span class="sd">            wcs:          WCS of output pixel scale.</span>
<span class="sd">            rng:          Random number generator to forward to resulting CorrelatedNoise object.</span>

<span class="sd">        Returns:</span>
<span class="sd">            CorrelatedNoise object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">NSED</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">SEDs</span><span class="p">)</span>
        <span class="n">maxk</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">([</span><span class="n">PSF</span><span class="o">.</span><span class="n">evaluateAtWavelength</span><span class="p">(</span><span class="n">bandpass</span><span class="o">.</span><span class="n">blue_limit</span><span class="p">)</span><span class="o">.</span><span class="n">maxk</span><span class="p">,</span>
                       <span class="n">PSF</span><span class="o">.</span><span class="n">evaluateAtWavelength</span><span class="p">(</span><span class="n">bandpass</span><span class="o">.</span><span class="n">red_limit</span><span class="p">)</span><span class="o">.</span><span class="n">maxk</span><span class="p">])</span>
        <span class="n">stepk</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">([</span><span class="n">PSF</span><span class="o">.</span><span class="n">evaluateAtWavelength</span><span class="p">(</span><span class="n">bandpass</span><span class="o">.</span><span class="n">blue_limit</span><span class="p">)</span><span class="o">.</span><span class="n">stepk</span><span class="p">,</span>
                        <span class="n">PSF</span><span class="o">.</span><span class="n">evaluateAtWavelength</span><span class="p">(</span><span class="n">bandpass</span><span class="o">.</span><span class="n">red_limit</span><span class="p">)</span><span class="o">.</span><span class="n">stepk</span><span class="p">])</span>
        <span class="n">nk</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">maxk</span><span class="o">/</span><span class="n">stepk</span><span class="p">))</span>

        <span class="n">PSF_eff_kimgs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">NSED</span><span class="p">,</span> <span class="n">nk</span><span class="p">,</span> <span class="n">nk</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">sed</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">SEDs</span><span class="p">):</span>
            <span class="c1"># Assume that PSF does not yet include pixel contribution, so add it in.</span>
            <span class="n">conv</span> <span class="o">=</span> <span class="n">Convolve</span><span class="p">(</span><span class="n">PSF</span><span class="p">,</span> <span class="n">Pixel</span><span class="p">(</span><span class="n">wcs</span><span class="o">.</span><span class="n">scale</span><span class="p">,</span> <span class="n">gsparams</span><span class="o">=</span><span class="n">PSF</span><span class="o">.</span><span class="n">gsparams</span><span class="p">))</span> <span class="o">*</span> <span class="n">sed</span>
            <span class="n">PSF_eff_kimgs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">conv</span><span class="o">.</span><span class="n">drawKImage</span><span class="p">(</span><span class="n">bandpass</span><span class="p">,</span> <span class="n">nx</span><span class="o">=</span><span class="n">nk</span><span class="p">,</span> <span class="n">ny</span><span class="o">=</span><span class="n">nk</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">stepk</span><span class="p">)</span><span class="o">.</span><span class="n">array</span>
        <span class="n">pkout</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nk</span><span class="p">,</span> <span class="n">nk</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">NSED</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">NSED</span><span class="p">):</span>
                <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">[(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)]</span><span class="o">.</span><span class="n">drawKImage</span><span class="p">(</span><span class="n">nx</span><span class="o">=</span><span class="n">nk</span><span class="p">,</span> <span class="n">ny</span><span class="o">=</span><span class="n">nk</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">stepk</span><span class="p">)</span><span class="o">.</span><span class="n">array</span>
                <span class="n">pkout</span> <span class="o">+=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">PSF_eff_kimgs</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">*</span> <span class="n">s</span> <span class="o">*</span> <span class="n">PSF_eff_kimgs</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">*</span>
                          <span class="p">(</span><span class="mi">2</span> <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">j</span> <span class="k">else</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">real</span>
        <span class="n">pk</span> <span class="o">=</span> <span class="n">Image</span><span class="p">(</span><span class="n">pkout</span> <span class="o">+</span> <span class="mi">0</span><span class="n">j</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">stepk</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>  <span class="c1"># imag part should be zero</span>
        <span class="n">iki</span> <span class="o">=</span> <span class="n">InterpolatedKImage</span><span class="p">(</span><span class="n">pk</span><span class="p">)</span>
        <span class="n">iki</span> <span class="o">*=</span> <span class="n">wcs</span><span class="o">.</span><span class="n">pixelArea</span><span class="p">()</span><span class="o">**</span><span class="mi">2</span>  <span class="c1"># determined this empirically</span>
        <span class="k">return</span> <span class="n">BaseCorrelatedNoise</span><span class="p">(</span><span class="n">rng</span><span class="p">,</span> <span class="n">iki</span><span class="p">,</span> <span class="n">wcs</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span> <span class="ow">is</span> <span class="n">other</span> <span class="ow">or</span>
                <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">CovarianceSpectrum</span><span class="p">)</span> <span class="ow">and</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">SEDs</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">SEDs</span> <span class="ow">and</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">Sigma</span><span class="p">))</span>
    <span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span> <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__eq__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">((</span><span class="s2">&quot;galsim.CovarianceSpectrum&quot;</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">SEDs</span><span class="p">),</span>
                     <span class="nb">frozenset</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="o">.</span><span class="n">items</span><span class="p">())))</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;galsim.CovarianceSpectrum(</span><span class="si">%r</span><span class="s2">, </span><span class="si">%r</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">SEDs</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">sigma_str</span> <span class="o">=</span> <span class="s1">&#39;{&#39;</span> <span class="o">+</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s1">&#39;:&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">((</span><span class="nb">str</span><span class="p">(</span><span class="n">k</span><span class="p">),</span><span class="nb">str</span><span class="p">(</span><span class="n">v</span><span class="p">)))</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="o">.</span><span class="n">items</span><span class="p">()])</span> <span class="o">+</span> <span class="s1">&#39;}&#39;</span>
        <span class="n">seds_str</span> <span class="o">=</span> <span class="s1">&#39;[&#39;</span> <span class="o">+</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">SEDs</span><span class="p">])</span> <span class="o">+</span> <span class="s1">&#39;]&#39;</span>
        <span class="k">return</span> <span class="s2">&quot;galsim.CovarianceSpectrum(</span><span class="si">%s</span><span class="s2">, </span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">sigma_str</span><span class="p">,</span> <span class="n">seds_str</span><span class="p">)</span></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, GalSim-developers.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>