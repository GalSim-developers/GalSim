<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>galsim.sed &mdash; GalSim 2.3.5 documentation</title><link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../index.html" class="icon icon-home"> GalSim
          </a>
              <div class="version">
                2.3
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../overview.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../install.html">Installation Instructions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tutorials.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../image.html">Images and Related Concepts</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../sb.html">Surface Brightness Profiles</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../chromatic.html">Wavelength-dependent Profiles</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../units.html">Units</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../wcs.html">World Coordinate Systems</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../random.html">Noise and Random Values</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../wl.html">Weak Lensing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../photon.html">Photon Shooting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../utilities.html">Helper Functions and Classes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../errors.html">Errors and Warnings</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../config.html">The Config Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../hsm.html">The HSM Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../des.html">The DES Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../roman.html">The Roman Space Telescope Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../shared.html">Shared Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../history.html">Revision History</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">GalSim</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../index.html">Module code</a> &raquo;</li>
      <li>galsim.sed</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for galsim.sed</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright (c) 2012-2021 by the GalSim developers team on GitHub</span>
<span class="c1"># https://github.com/GalSim-developers</span>
<span class="c1">#</span>
<span class="c1"># This file is part of GalSim: The modular galaxy image simulation toolkit.</span>
<span class="c1"># https://github.com/GalSim-developers/GalSim</span>
<span class="c1">#</span>
<span class="c1"># GalSim is free software: redistribution and use in source and binary forms,</span>
<span class="c1"># with or without modification, are permitted provided that the following</span>
<span class="c1"># conditions are met:</span>
<span class="c1">#</span>
<span class="c1"># 1. Redistributions of source code must retain the above copyright notice, this</span>
<span class="c1">#    list of conditions, and the disclaimer given in the accompanying LICENSE</span>
<span class="c1">#    file.</span>
<span class="c1"># 2. Redistributions in binary form must reproduce the above copyright notice,</span>
<span class="c1">#    this list of conditions, and the disclaimer given in the documentation</span>
<span class="c1">#    and/or other materials provided with the distribution.</span>
<span class="c1">#</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">astropy</span> <span class="kn">import</span> <span class="n">units</span>
<span class="kn">from</span> <span class="nn">astropy</span> <span class="kn">import</span> <span class="n">constants</span>

<span class="kn">from</span> <span class="nn">.gsobject</span> <span class="kn">import</span> <span class="n">GSObject</span>
<span class="kn">from</span> <span class="nn">.table</span> <span class="kn">import</span> <span class="n">LookupTable</span><span class="p">,</span> <span class="n">_LookupTable</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">utilities</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">integ</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">dcr</span>
<span class="kn">from</span> <span class="nn">.utilities</span> <span class="kn">import</span> <span class="n">WeakMethod</span><span class="p">,</span> <span class="n">lazy_property</span><span class="p">,</span> <span class="n">combine_wave_list</span><span class="p">,</span> <span class="n">basestring</span>
<span class="kn">from</span> <span class="nn">.errors</span> <span class="kn">import</span> <span class="n">GalSimError</span><span class="p">,</span> <span class="n">GalSimValueError</span><span class="p">,</span> <span class="n">GalSimRangeError</span><span class="p">,</span> <span class="n">GalSimSEDError</span>
<span class="kn">from</span> <span class="nn">.errors</span> <span class="kn">import</span> <span class="n">GalSimIncompatibleValuesError</span>

<div class="viewcode-block" id="SED"><a class="viewcode-back" href="../../sed.html#galsim.SED">[docs]</a><span class="k">class</span> <span class="nc">SED</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Object to represent the spectral energy distributions of stars and galaxies.</span>

<span class="sd">    SEDs are callable, usually returning the flux density in photons/nm/cm^2/s as a function of</span>
<span class="sd">    wavelength, though SEDs are also used by GalSim to track dimensionless wavelength-dependent</span>
<span class="sd">    normalizations, and may thus also return dimensionless values.  By default, the above wavelength</span>
<span class="sd">    used by __call__ is nanometers, but it&#39;s possible to use other units via the astropy.units</span>
<span class="sd">    module (at least, if the SED keyword argument ``fast=False``, see below).  For instance,::</span>

<span class="sd">        &gt;&gt;&gt; sed = galsim.SED(...)</span>
<span class="sd">        &gt;&gt;&gt; from astropy import units as u</span>
<span class="sd">        &gt;&gt;&gt; assert sed(500) == sed(5000 * u.AA)  # 500 nm == 5000 Angstroms</span>

<span class="sd">    The python type of the return value depends on the type of the input wavelength(s).  A scalar</span>
<span class="sd">    input wavelength yields a scalar flux density, a tuple yields a tuple, a list yields a list, and</span>
<span class="sd">    a numpy.ndarray yields a numpy.ndarray.  A scalar astropy.units.Quantity yields a python scalar,</span>
<span class="sd">    and a vector astropy.units.Quantity yields a numpy.ndarray.</span>

<span class="sd">    SEDs are immutable; all transformative SED methods return *new* SEDs, and leave their</span>
<span class="sd">    originating SEDs unaltered.</span>

<span class="sd">    SEDs have ``blue_limit`` and ``red_limit`` attributes, which indicate the range over which the</span>
<span class="sd">    SED is defined.  An exception will be raised if the flux density or normalization is requested</span>
<span class="sd">    outside of this range.  Note that ``blue_limit`` and ``red_limit`` are always in nanometers and</span>
<span class="sd">    in the observed frame when ``redshift != 0``.</span>

<span class="sd">    SEDs may be multiplied by scalars or scalar functions of wavelength.  In particular, an SED</span>
<span class="sd">    multiplied by a `Bandpass` will yield the appropriately filtered SED.  Two SEDs may be</span>
<span class="sd">    multiplied together if at least one of them represents a dimensionless normalization.</span>

<span class="sd">    SEDs may be added together if they are at the same redshift.  The resulting SED will only be</span>
<span class="sd">    defined on the wavelength region where both of the operand SEDs are defined. ``blue_limit`` and</span>
<span class="sd">    ``red_limit`` will be reset accordingly.</span>

<span class="sd">    The input parameter, ``spec``, may be one of several possible forms:</span>

<span class="sd">    1. a regular python function (or an object that acts like a function)</span>
<span class="sd">    2. a `LookupTable`</span>
<span class="sd">    3. a file from which a `LookupTable` can be read in</span>
<span class="sd">    4. a string which can be evaluated to a function of ``wave`` via ``eval(&#39;lambda wave:&#39;+spec)``,</span>
<span class="sd">       e.g.::</span>

<span class="sd">            spec = &#39;0.8 + 0.2 * (wave-800)&#39;</span>

<span class="sd">    5. a python scalar (only possible for dimensionless SEDs)</span>

<span class="sd">    The argument of ``spec`` should be the wavelength in units specified by ``wave_type``, which</span>
<span class="sd">    should be an instance of ``astropy.units.Unit`` of equivalency class ``astropy.units.spectral``,</span>
<span class="sd">    or one of the case-insensitive aliases &#39;nm&#39;, &#39;nanometer&#39;, &#39;nanometers&#39;, &#39;A&#39;, &#39;Ang&#39;, &#39;Angstrom&#39;,</span>
<span class="sd">    or &#39;Angstroms&#39;.  Note that ``astropy.units.spectral`` includes not only units with dimensions</span>
<span class="sd">    of length, but also frequency, energy, or wavenumber.</span>

<span class="sd">    The return value of ``spec`` should be a spectral density with units specified by ``flux_type``,</span>
<span class="sd">    which should be an instance of ``astropy.units.Unit`` of equivalency class</span>
<span class="sd">    ``astropy.units.spectral_density``, or one of the case-insensitive aliases:</span>

<span class="sd">    1. &#39;flambda&#39;:  erg/wave_type/cm^2/s, where wave_type is as above.</span>
<span class="sd">    2. &#39;fnu&#39;:      erg/Hz/cm^2/s</span>
<span class="sd">    3. &#39;fphotons&#39;: photons/wave_type/cm^2/s, where wave_type is as above.</span>
<span class="sd">    4. &#39;1&#39;:        dimensionless</span>

<span class="sd">    Note that the ``astropy.units.spectral_density`` class includes units with dimensions of</span>
<span class="sd">    [energy/time/area/unit-wavelength], [energy/time/area/unit-frequency],</span>
<span class="sd">    [photons/time/area/unit-wavelength], and so on.</span>

<span class="sd">    Finally, the optional ``fast`` keyword option is used to specify when unit and dimension changes</span>
<span class="sd">    are executed, particularly for SEDs specified by a `LookupTable`.  If ``fast=True``, the</span>
<span class="sd">    default, then the input units/dimensions may be converted to an internal working unit before</span>
<span class="sd">    interpolation in wavelength is performed.  Alternatively, ``fast=False`` implies that</span>
<span class="sd">    interpolation should take place in the native units of the input ``spec``, and subsequently flux</span>
<span class="sd">    density converted to photons/cm^2/s/nm afterwards.  Generally, the former option is faster, but</span>
<span class="sd">    may be less accurate since interpolation and dimensionality conversion do not commute.  One</span>
<span class="sd">    consequence of using ``fast=True`` is that __call__ can not accept an ``astropy.units.Quantity``</span>
<span class="sd">    in this case.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        spec:        Function defining the z=0 spectrum at each wavelength.  See above for</span>
<span class="sd">                     valid options for this parameter.</span>
<span class="sd">        wave_type:   String or astropy.unit specifying units for wavelength input to ``spec``.</span>
<span class="sd">        flux_type:   String or astropy.unit specifying what type of spectral density or</span>
<span class="sd">                     dimensionless normalization ``spec`` represents.  See above for valid options</span>
<span class="sd">                     for this parameter.</span>
<span class="sd">        redshift:    Optionally shift the spectrum to the given redshift. [default: 0]</span>
<span class="sd">        fast:        Convert units on initialization instead of on __call__. [default: True]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># We&#39;ll use these multiple times below, and they are ridiculously slow to construct,</span>
    <span class="c1"># so just make them once at the class level.</span>
    <span class="n">_fphotons_base</span> <span class="o">=</span> <span class="n">units</span><span class="o">.</span><span class="n">astrophys</span><span class="o">.</span><span class="n">photon</span><span class="o">/</span><span class="p">(</span><span class="n">units</span><span class="o">.</span><span class="n">s</span> <span class="o">*</span> <span class="n">units</span><span class="o">.</span><span class="n">cm</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">_flambda_base</span> <span class="o">=</span> <span class="n">units</span><span class="o">.</span><span class="n">erg</span><span class="o">/</span><span class="p">(</span><span class="n">units</span><span class="o">.</span><span class="n">s</span> <span class="o">*</span> <span class="n">units</span><span class="o">.</span><span class="n">cm</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">_fphotons</span> <span class="o">=</span> <span class="n">_fphotons_base</span> <span class="o">/</span> <span class="n">units</span><span class="o">.</span><span class="n">nm</span>
    <span class="n">_flambda</span> <span class="o">=</span> <span class="n">_flambda_base</span> <span class="o">/</span> <span class="n">units</span><span class="o">.</span><span class="n">nm</span>
    <span class="n">_fnu</span> <span class="o">=</span> <span class="n">units</span><span class="o">.</span><span class="n">erg</span> <span class="o">/</span> <span class="p">(</span><span class="n">units</span><span class="o">.</span><span class="n">s</span> <span class="o">*</span> <span class="n">units</span><span class="o">.</span><span class="n">Hz</span> <span class="o">*</span> <span class="n">units</span><span class="o">.</span><span class="n">cm</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">_spec_nm</span> <span class="o">=</span> <span class="n">units</span><span class="o">.</span><span class="n">spectral_density</span><span class="p">(</span><span class="mi">1</span><span class="o">*</span><span class="n">units</span><span class="o">.</span><span class="n">nm</span><span class="p">)</span>
    <span class="n">_c</span> <span class="o">=</span> <span class="n">constants</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="s1">&#39;nm/s&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">value</span>
    <span class="n">_h</span> <span class="o">=</span> <span class="n">constants</span><span class="o">.</span><span class="n">h</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="s1">&#39;erg s&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">value</span>
    <span class="n">_dimensionless</span> <span class="o">=</span> <span class="n">units</span><span class="o">.</span><span class="n">dimensionless_unscaled</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spec</span><span class="p">,</span> <span class="n">wave_type</span><span class="p">,</span> <span class="n">flux_type</span><span class="p">,</span> <span class="n">redshift</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span> <span class="n">fast</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                 <span class="n">_blue_limit</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">_red_limit</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">_wave_list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">_spectral</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_flux_type</span> <span class="o">=</span> <span class="n">flux_type</span>  <span class="c1"># Need to save the original for repr</span>
        <span class="c1"># Parse the various options for wave_type</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">wave_type</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">wave_type</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;nm&#39;</span><span class="p">,</span> <span class="s1">&#39;nanometer&#39;</span><span class="p">,</span> <span class="s1">&#39;nanometers&#39;</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">wave_type</span> <span class="o">=</span> <span class="s1">&#39;nm&#39;</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">wave_factor</span> <span class="o">=</span> <span class="mf">1.</span>
            <span class="k">elif</span> <span class="n">wave_type</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;ang&#39;</span><span class="p">,</span> <span class="s1">&#39;angstrom&#39;</span><span class="p">,</span> <span class="s1">&#39;angstroms&#39;</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">wave_type</span> <span class="o">=</span> <span class="s1">&#39;Angstrom&#39;</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">wave_factor</span> <span class="o">=</span> <span class="mf">10.</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">GalSimValueError</span><span class="p">(</span><span class="s2">&quot;Unknown wave_type&quot;</span><span class="p">,</span> <span class="n">wave_type</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;nm&#39;</span><span class="p">,</span> <span class="s1">&#39;Angstrom&#39;</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">wave_type</span> <span class="o">=</span> <span class="n">wave_type</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">wave_factor</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">*</span><span class="n">units</span><span class="o">.</span><span class="n">nm</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wave_type</span><span class="p">)</span><span class="o">.</span><span class="n">value</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">wave_factor</span> <span class="o">==</span> <span class="mf">1.</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">wave_type</span> <span class="o">=</span> <span class="s1">&#39;nm&#39;</span>
                <span class="k">elif</span> <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wave_factor</span><span class="o">-</span><span class="mf">10.</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">2.e-15</span><span class="p">:</span>  <span class="c1"># This doesn&#39;t come out exactly 10.</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">wave_type</span> <span class="o">=</span> <span class="s1">&#39;Angstrom&#39;</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">wave_factor</span> <span class="o">=</span> <span class="mf">10.</span>
            <span class="k">except</span> <span class="n">units</span><span class="o">.</span><span class="n">UnitConversionError</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">wave_factor</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Parse the various options for flux_type</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flux_factor</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">flux_type</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">flux_type</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;flambda&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">flux_type</span> <span class="o">=</span> <span class="s1">&#39;flambda&#39;</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">spectral</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">flux_factor</span> <span class="o">=</span> <span class="mf">1.</span> <span class="o">/</span> <span class="p">(</span><span class="n">SED</span><span class="o">.</span><span class="n">_h</span> <span class="o">*</span> <span class="n">SED</span><span class="o">.</span><span class="n">_c</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">flux_type</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;fphotons&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">spectral</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">wave_factor</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">flux_type</span> <span class="o">=</span> <span class="s1">&#39;fphotons&#39;</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">flux_factor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wave_factor</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">flux_type</span> <span class="o">=</span> <span class="n">SED</span><span class="o">.</span><span class="n">_fphotons</span>
            <span class="k">elif</span> <span class="n">flux_type</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;fnu&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">spectral</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">wave_factor</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">flux_type</span> <span class="o">=</span> <span class="s1">&#39;fnu&#39;</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">flux_factor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wave_factor</span> <span class="o">/</span> <span class="n">SED</span><span class="o">.</span><span class="n">_h</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">flux_type</span> <span class="o">=</span> <span class="n">SED</span><span class="o">.</span><span class="n">_fnu</span>
            <span class="k">elif</span> <span class="n">flux_type</span> <span class="o">==</span> <span class="s1">&#39;1&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">flux_type</span> <span class="o">=</span> <span class="s1">&#39;1&#39;</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">spectral</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">GalSimValueError</span><span class="p">(</span><span class="s2">&quot;Unknown flux_type&quot;</span><span class="p">,</span> <span class="n">flux_type</span><span class="p">,</span>
                                       <span class="p">(</span><span class="s1">&#39;flambda&#39;</span><span class="p">,</span> <span class="s1">&#39;fnu&#39;</span><span class="p">,</span> <span class="s1">&#39;fphotons&#39;</span><span class="p">,</span> <span class="s1">&#39;1&#39;</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">flux_type</span> <span class="o">=</span> <span class="n">flux_type</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spectral</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_spectral</span><span class="p">()</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectral</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_dimensionless</span><span class="p">():</span>
                <span class="k">raise</span> <span class="n">GalSimValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Flux_type must be equivalent to a spectral density or dimensionless.&quot;</span><span class="p">,</span>
                    <span class="n">flux_type</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">wave_factor</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectral</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">flux_factor</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">flux_type</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">SED</span><span class="o">.</span><span class="n">_fphotons</span><span class="p">)</span><span class="o">.</span><span class="n">value</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">flux_type</span> <span class="o">=</span> <span class="s1">&#39;fphotons&#39;</span>
            <span class="k">except</span> <span class="n">units</span><span class="o">.</span><span class="n">UnitConversionError</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">flux_factor</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">flux_type</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">SED</span><span class="o">.</span><span class="n">_flambda</span><span class="p">)</span><span class="o">.</span><span class="n">value</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">flux_factor</span> <span class="o">/=</span> <span class="n">SED</span><span class="o">.</span><span class="n">_h</span> <span class="o">*</span> <span class="n">SED</span><span class="o">.</span><span class="n">_c</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">wave_factor</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">flux_type</span> <span class="o">=</span> <span class="s1">&#39;flambda&#39;</span>
                <span class="k">except</span> <span class="n">units</span><span class="o">.</span><span class="n">UnitConversionError</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">flux_factor</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">flux_type</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">SED</span><span class="o">.</span><span class="n">_fnu</span><span class="p">)</span><span class="o">.</span><span class="n">value</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">flux_factor</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wave_factor</span> <span class="o">/</span> <span class="n">SED</span><span class="o">.</span><span class="n">_h</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">flux_type</span> <span class="o">=</span> <span class="s1">&#39;fnu&#39;</span>
                    <span class="k">except</span> <span class="n">units</span><span class="o">.</span><span class="n">UnitConversionError</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">wave_type</span> <span class="o">=</span> <span class="n">units</span><span class="o">.</span><span class="n">Unit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wave_type</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">redshift</span> <span class="o">=</span> <span class="n">redshift</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fast</span> <span class="o">=</span> <span class="n">fast</span>

        <span class="c1"># Convert string input into a real function (possibly a LookupTable)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_orig_spec</span> <span class="o">=</span> <span class="n">spec</span>  <span class="c1"># Save this for pickling</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_spec</span><span class="p">()</span>

        <span class="c1"># Setup the wave_list, red_limit, blue_limit</span>
        <span class="k">if</span> <span class="n">_wave_list</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">wave_list</span> <span class="o">=</span> <span class="n">_wave_list</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">blue_limit</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">_blue_limit</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">red_limit</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">_red_limit</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_spec</span><span class="p">,</span> <span class="n">LookupTable</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">wave_list</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_spec</span><span class="o">.</span><span class="n">getArgs</span><span class="p">())</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">wave_factor</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">wave_list</span> <span class="o">*=</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">redshift</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">wave_factor</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">wave_list</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wave_list</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">wave_type</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">units</span><span class="o">.</span><span class="n">nm</span><span class="p">,</span> <span class="n">units</span><span class="o">.</span><span class="n">spectral</span><span class="p">())</span><span class="o">.</span><span class="n">value</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">wave_list</span> <span class="o">*=</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">redshift</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">blue_limit</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wave_list</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">red_limit</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wave_list</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">blue_limit</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">red_limit</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">wave_list</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

        <span class="c1"># Define the appropriate functions to call</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_setup_funcs</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_setup_funcs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Set up the various functions we use to do the right calculation based on which</span>
        <span class="c1"># wave type and/or flux type we have for _spec.</span>
        <span class="c1"># The astropy unit functions are horribly slow, so we want to avoid them as much as</span>
        <span class="c1"># possible.  If the wave_type and flux_type are one of the simpler (and most common)</span>
        <span class="c1"># types, then we have custom functions that do the necessary conversions directly.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">wave_factor</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_get_native_waves</span> <span class="o">=</span> <span class="n">WeakMethod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_native_waves_trivial</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">wave_factor</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_get_native_waves</span> <span class="o">=</span> <span class="n">WeakMethod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_native_waves_fast</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_get_native_waves</span> <span class="o">=</span> <span class="n">WeakMethod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_native_waves_slow</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">redshift</span> <span class="o">==</span> <span class="mf">0.</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_get_rest_native_waves</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_native_waves</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">wave_factor</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_get_rest_native_waves</span> <span class="o">=</span> <span class="n">WeakMethod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_rest_native_waves_fast</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_get_rest_native_waves</span> <span class="o">=</span> <span class="n">WeakMethod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_rest_native_waves_slow</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">flux_type</span> <span class="o">==</span> <span class="s1">&#39;fphotons&#39;</span><span class="p">:</span>
            <span class="c1">#assert self.flux_factor is not None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_flux_to_photons</span> <span class="o">=</span> <span class="n">WeakMethod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_flux_to_photons_fphot</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">flux_type</span> <span class="o">==</span> <span class="s1">&#39;flambda&#39;</span><span class="p">:</span>
            <span class="c1">#assert self.flux_factor is not None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_flux_to_photons</span> <span class="o">=</span> <span class="n">WeakMethod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_flux_to_photons_flam</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">flux_type</span> <span class="o">==</span> <span class="s1">&#39;fnu&#39;</span><span class="p">:</span>
            <span class="c1">#assert self.flux_factor is not None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_flux_to_photons</span> <span class="o">=</span> <span class="n">WeakMethod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_flux_to_photons_fnu</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_flux_to_photons</span> <span class="o">=</span> <span class="n">WeakMethod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_flux_to_photons_slow</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fast</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_call</span> <span class="o">=</span> <span class="n">WeakMethod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_call_fast</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_call</span> <span class="o">=</span> <span class="n">WeakMethod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_call_slow</span><span class="p">)</span>

    <span class="c1"># Here are the definitions for the various functions we can use depending on the wave_type</span>
    <span class="c1"># and flux_type (cf. _setup_funcs).</span>
    <span class="k">def</span> <span class="nf">_get_native_waves_trivial</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">wave</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">wave</span>

    <span class="k">def</span> <span class="nf">_get_native_waves_fast</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">wave</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">wave</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">wave_factor</span>

    <span class="k">def</span> <span class="nf">_get_native_waves_slow</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">wave</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">wave</span> <span class="o">*</span> <span class="n">units</span><span class="o">.</span><span class="n">nm</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wave_type</span><span class="p">,</span> <span class="n">units</span><span class="o">.</span><span class="n">spectral</span><span class="p">())</span><span class="o">.</span><span class="n">value</span>

    <span class="k">def</span> <span class="nf">_get_rest_native_waves_fast</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">wave</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">wave</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wave_factor</span> <span class="o">/</span> <span class="p">(</span><span class="mf">1.0</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">redshift</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_get_rest_native_waves_slow</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">wave</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">wave</span> <span class="o">/</span> <span class="p">(</span><span class="mf">1.0</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">redshift</span><span class="p">)</span> <span class="o">*</span> <span class="n">units</span><span class="o">.</span><span class="n">nm</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wave_type</span><span class="p">,</span> <span class="n">units</span><span class="o">.</span><span class="n">spectral</span><span class="p">())</span><span class="o">.</span><span class="n">value</span>

    <span class="k">def</span> <span class="nf">_flux_to_photons_fphot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">flux_native</span><span class="p">,</span> <span class="n">wave_native</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">flux_native</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">flux_factor</span>

    <span class="k">def</span> <span class="nf">_flux_to_photons_flam</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">flux_native</span><span class="p">,</span> <span class="n">wave_native</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">flux_native</span> <span class="o">*</span> <span class="n">wave_native</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">flux_factor</span>

    <span class="k">def</span> <span class="nf">_flux_to_photons_fnu</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">flux_native</span><span class="p">,</span> <span class="n">wave_native</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">flux_native</span> <span class="o">/</span> <span class="n">wave_native</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">flux_factor</span>

    <span class="k">def</span> <span class="nf">_flux_to_photons_slow</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">flux_native</span><span class="p">,</span> <span class="n">wave_native</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">flux_native</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">flux_type</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span>
                <span class="n">SED</span><span class="o">.</span><span class="n">_fphotons</span><span class="p">,</span> <span class="n">units</span><span class="o">.</span><span class="n">spectral_density</span><span class="p">(</span><span class="n">wave_native</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">wave_type</span><span class="p">))</span><span class="o">.</span><span class="n">value</span>


    <span class="k">def</span> <span class="nf">_initialize_spec</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Turn the input _orig_spec into a real function _spec.</span>
        <span class="c1"># The function cannot be pickled, so will need to do this in getstate as well as init.</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_const</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_orig_spec</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensionless</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">GalSimSEDError</span><span class="p">(</span><span class="s2">&quot;Attempt to set spectral SED using float or integer.&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_const</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_spec</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">w</span><span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_orig_spec</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_orig_spec</span><span class="p">,</span> <span class="n">basestring</span><span class="p">):</span>
            <span class="n">isfile</span><span class="p">,</span> <span class="n">filename</span> <span class="o">=</span> <span class="n">utilities</span><span class="o">.</span><span class="n">check_share_file</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_orig_spec</span><span class="p">,</span> <span class="s1">&#39;SEDs&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">isfile</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_spec</span> <span class="o">=</span> <span class="n">LookupTable</span><span class="o">.</span><span class="n">from_file</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">interpolant</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Don&#39;t catch ArithmeticErrors when testing to see if the the result of `eval()`</span>
                <span class="c1"># is valid since `spec = &#39;1./(wave-700)&#39;` will generate a ZeroDivisionError (which</span>
                <span class="c1"># is a subclass of ArithmeticError) despite being a valid spectrum specification,</span>
                <span class="c1"># while `spec = &#39;blah&#39;` where `blah` is undefined generates a NameError and is not</span>
                <span class="c1"># a valid spectrum specification.</span>
                <span class="c1"># Are there any other types of errors we should trap here?</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_spec</span> <span class="o">=</span> <span class="n">utilities</span><span class="o">.</span><span class="n">math_eval</span><span class="p">(</span><span class="s1">&#39;lambda wave : &#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_orig_spec</span><span class="p">)</span>
                    <span class="n">test_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_spec</span><span class="p">(</span><span class="mf">700.0</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">ArithmeticError</span><span class="p">:</span>
                    <span class="n">test_value</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">GalSimValueError</span><span class="p">(</span>
                        <span class="s2">&quot;String spec must either be a valid filename or something that &quot;</span>
                        <span class="s2">&quot;can eval to a function of wave.</span><span class="se">\n</span><span class="s2">&quot;</span>
                        <span class="s2">&quot;Caught error: </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">e</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_orig_spec</span><span class="p">)</span>
                <span class="kn">from</span> <span class="nn">numbers</span> <span class="kn">import</span> <span class="n">Real</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">test_value</span><span class="p">,</span> <span class="n">Real</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="n">GalSimValueError</span><span class="p">(</span><span class="s2">&quot;The given SED function did not return a valid number &quot;</span>
                                           <span class="s2">&quot;at test wavelength </span><span class="si">%s</span><span class="s2">: got </span><span class="si">%s</span><span class="s2">&quot;</span><span class="o">%</span><span class="p">(</span><span class="mf">700.0</span><span class="p">,</span> <span class="n">test_value</span><span class="p">),</span>
                                           <span class="bp">self</span><span class="o">.</span><span class="n">_orig_spec</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_spec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_orig_spec</span>

<div class="viewcode-block" id="SED.check_spectral"><a class="viewcode-back" href="../../sed.html#galsim.SED.check_spectral">[docs]</a>    <span class="k">def</span> <span class="nf">check_spectral</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return boolean indicating if SED has units compatible with a spectral density.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">flux_type</span><span class="o">.</span><span class="n">is_equivalent</span><span class="p">(</span><span class="n">SED</span><span class="o">.</span><span class="n">_fphotons</span><span class="p">,</span> <span class="n">SED</span><span class="o">.</span><span class="n">_spec_nm</span><span class="p">)</span></div>

<div class="viewcode-block" id="SED.check_dimensionless"><a class="viewcode-back" href="../../sed.html#galsim.SED.check_dimensionless">[docs]</a>    <span class="k">def</span> <span class="nf">check_dimensionless</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return boolean indicating if SED is dimensionless.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">flux_type</span><span class="o">.</span><span class="n">is_equivalent</span><span class="p">(</span><span class="n">SED</span><span class="o">.</span><span class="n">_dimensionless</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_flux_type</span> <span class="o">=</span> <span class="s1">&#39;1&#39;</span>
            <span class="c1"># The astropy.units.dimensionless_unscaled object isn&#39;t properly reprable.</span>
            <span class="c1"># So switch to using &#39;1&#39; in these cases.</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dimensionless</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>  <span class="c1"># for convenience</span>
        <span class="sd">&quot;&quot;&quot;Whether the object is dimensionless (rather than spectral).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectral</span>

    <span class="k">def</span> <span class="nf">_rest_nm_to_photons</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">wave</span><span class="p">):</span>
        <span class="n">wave_native</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_native_waves</span><span class="p">(</span><span class="n">wave</span><span class="p">)</span>
        <span class="n">flux_native</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_spec</span><span class="p">(</span><span class="n">wave_native</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flux_to_photons</span><span class="p">(</span><span class="n">flux_native</span><span class="p">,</span> <span class="n">wave_native</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_rest_nm_to_dimensionless</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">wave</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_spec</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_native_waves</span><span class="p">(</span><span class="n">wave</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_check_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">wave</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">wave</span><span class="p">,</span> <span class="s1">&#39;__iter__&#39;</span><span class="p">):</span>
            <span class="n">wmin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">wave</span><span class="p">)</span>
            <span class="n">wmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">wave</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">wmin</span> <span class="o">=</span> <span class="n">wmax</span> <span class="o">=</span> <span class="n">wave</span>

        <span class="n">extrapolation_slop</span> <span class="o">=</span> <span class="mf">1.e-6</span> <span class="c1"># allow a small amount of extrapolation</span>
        <span class="k">if</span> <span class="n">wmin</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">blue_limit</span> <span class="o">-</span> <span class="n">extrapolation_slop</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">GalSimRangeError</span><span class="p">(</span><span class="s2">&quot;Requested wavelength is bluer than blue_limit.&quot;</span><span class="p">,</span>
                                   <span class="n">wave</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">blue_limit</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">red_limit</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">wmax</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">red_limit</span> <span class="o">+</span> <span class="n">extrapolation_slop</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">GalSimRangeError</span><span class="p">(</span><span class="s2">&quot;Requested wavelength is redder than red_limit.&quot;</span><span class="p">,</span>
                                   <span class="n">wave</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">blue_limit</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">red_limit</span><span class="p">)</span>

    <span class="nd">@lazy_property</span>
    <span class="k">def</span> <span class="nf">_fast_spec</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Create a fast version of self._spec by constructing a LookupTable on self.wave_list</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">wave_factor</span> <span class="o">==</span> <span class="mf">1.</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">flux_factor</span> <span class="o">==</span> <span class="mf">1.</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_spec</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wave_list</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectral</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">WeakMethod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_rest_nm_to_photons</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">WeakMethod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_rest_nm_to_dimensionless</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wave_list</span> <span class="o">/</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">redshift</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectral</span><span class="p">:</span>
                    <span class="n">f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rest_nm_to_photons</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rest_nm_to_dimensionless</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">_LookupTable</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">interpolant</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_call_fast</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">wave</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return either flux in photons / sec / cm^2 / nm, or dimensionless normalization.</span>

<span class="sd">        Assumes that self._spec has already been transformed to accept correct wavelength units and</span>
<span class="sd">        yield correct flux units.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            wave:   Wavelength in nanometers.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Flux or normalization.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_bounds</span><span class="p">(</span><span class="n">wave</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fast_spec</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">wave</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">redshift</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_call_slow</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">wave</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return flux in photons / sec / cm^2 / nm or dimensionless normalization.</span>

<span class="sd">        Uses self._spec that has not been pre-transformed for desired units, instead does all unit</span>
<span class="sd">        conversions inside this method.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            wave:   Wavelength.  If not an astropy.units.Quantity, then assumed units are</span>
<span class="sd">                    nanometers.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Flux.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">wave_in</span> <span class="o">=</span> <span class="n">wave</span>
        <span class="c1"># Convert wave to nanometers if needed.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">wave</span><span class="p">,</span> <span class="n">units</span><span class="o">.</span><span class="n">Quantity</span><span class="p">):</span>
            <span class="n">wave</span> <span class="o">=</span> <span class="n">wave</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">units</span><span class="o">.</span><span class="n">nm</span><span class="p">,</span> <span class="n">units</span><span class="o">.</span><span class="n">spectral</span><span class="p">())</span><span class="o">.</span><span class="n">value</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_check_bounds</span><span class="p">(</span><span class="n">wave</span><span class="p">)</span>

        <span class="c1"># Figure out rest-frame wave_type wavelength array for query to self._spec.</span>
        <span class="n">rest_wave_native</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_rest_native_waves</span><span class="p">(</span><span class="n">wave</span><span class="p">)</span>

        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_spec</span><span class="p">(</span><span class="n">rest_wave_native</span><span class="p">)</span>

        <span class="c1"># Manipulate output units</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectral</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flux_to_photons</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">rest_wave_native</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span>

<div class="viewcode-block" id="SED.__call__"><a class="viewcode-back" href="../../sed.html#galsim.SED.__call__">[docs]</a>    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">wave</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return photon flux density or dimensionless normalization at wavelength ``wave``.</span>

<span class="sd">        Note that outside of the wavelength range defined by the ``blue_limit`` and ``red_limit``</span>
<span class="sd">        attributes, the SED is considered undefined, and this method will raise an exception if a</span>
<span class="sd">        wavelength outside the defined range is passed as an argument.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            wave:   Wavelength in nanometers at which to evaluate the SED. May be a scalar,</span>
<span class="sd">                    a numpy.array, or an astropy.units.Quantity</span>

<span class="sd">        Returns:</span>
<span class="sd">            photon flux density in units of photons/nm/cm^2/s if self.spectral, or</span>
<span class="sd">            dimensionless normalization if self.dimensionless.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_call</span><span class="p">(</span><span class="n">wave</span><span class="p">)</span></div>

<div class="viewcode-block" id="SED._mul_sed"><a class="viewcode-back" href="../../sed.html#galsim.SED._mul_sed">[docs]</a>    <span class="k">def</span> <span class="nf">_mul_sed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Equivalent to self * other when other is an SED, but no sanity checks.&quot;&quot;&quot;</span>
        <span class="c1"># There should only be one SED with a non-trivial redshift, so adding them</span>
        <span class="c1"># should always give us the right net redshift to use.</span>
        <span class="n">redshift</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">redshift</span> <span class="o">+</span> <span class="n">other</span><span class="o">.</span><span class="n">redshift</span>

        <span class="n">fast</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fast</span> <span class="ow">and</span> <span class="n">other</span><span class="o">.</span><span class="n">fast</span>

        <span class="n">wave_list</span><span class="p">,</span> <span class="n">blue_limit</span><span class="p">,</span> <span class="n">red_limit</span> <span class="o">=</span> <span class="n">combine_wave_list</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">fast</span><span class="p">:</span>
            <span class="n">zfactor1</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">redshift</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">redshift</span><span class="p">)</span>
            <span class="n">zfactor2</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">redshift</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">other</span><span class="o">.</span><span class="n">redshift</span><span class="p">)</span>
            <span class="n">spec</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">w</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fast_spec</span><span class="p">(</span><span class="n">w</span> <span class="o">*</span> <span class="n">zfactor1</span><span class="p">)</span> <span class="o">*</span> <span class="n">other</span><span class="o">.</span><span class="n">_fast_spec</span><span class="p">(</span><span class="n">w</span> <span class="o">*</span> <span class="n">zfactor2</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">spec</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">w</span><span class="p">:</span> <span class="bp">self</span><span class="p">(</span><span class="n">w</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">redshift</span><span class="p">))</span> <span class="o">*</span> <span class="n">other</span><span class="p">(</span><span class="n">w</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">redshift</span><span class="p">))</span>
        <span class="n">_spectral</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectral</span> <span class="ow">or</span> <span class="n">other</span><span class="o">.</span><span class="n">spectral</span>
        <span class="k">return</span> <span class="n">SED</span><span class="p">(</span><span class="n">spec</span><span class="p">,</span> <span class="s1">&#39;nm&#39;</span><span class="p">,</span> <span class="s1">&#39;fphotons&#39;</span><span class="p">,</span> <span class="n">redshift</span><span class="o">=</span><span class="n">redshift</span><span class="p">,</span> <span class="n">fast</span><span class="o">=</span><span class="n">fast</span><span class="p">,</span>
                   <span class="n">_blue_limit</span><span class="o">=</span><span class="n">blue_limit</span><span class="p">,</span> <span class="n">_red_limit</span><span class="o">=</span><span class="n">red_limit</span><span class="p">,</span> <span class="n">_wave_list</span><span class="o">=</span><span class="n">wave_list</span><span class="p">,</span>
                   <span class="n">_spectral</span><span class="o">=</span><span class="n">_spectral</span><span class="p">)</span></div>

<div class="viewcode-block" id="SED._mul_bandpass"><a class="viewcode-back" href="../../sed.html#galsim.SED._mul_bandpass">[docs]</a>    <span class="k">def</span> <span class="nf">_mul_bandpass</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Equivalent to self * other when other is a Bandpass&quot;&quot;&quot;</span>
        <span class="n">wave_list</span><span class="p">,</span> <span class="n">blue_limit</span><span class="p">,</span> <span class="n">red_limit</span> <span class="o">=</span> <span class="n">combine_wave_list</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
        <span class="n">zfactor</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.0</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">redshift</span><span class="p">)</span> <span class="o">/</span> <span class="n">other</span><span class="o">.</span><span class="n">wave_factor</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fast</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_fast_spec</span><span class="p">,</span> <span class="n">LookupTable</span><span class="p">)</span>
                <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fast_spec</span><span class="o">.</span><span class="n">x_log</span>
                <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fast_spec</span><span class="o">.</span><span class="n">f_log</span>
                <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fast_spec</span><span class="o">.</span><span class="n">interpolant</span> <span class="o">==</span> <span class="s1">&#39;linear&#39;</span><span class="p">):</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">wave_list</span> <span class="o">/</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">redshift</span><span class="p">)</span>
                <span class="n">f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fast_spec</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="n">other</span><span class="o">.</span><span class="n">_tp</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">zfactor</span><span class="p">)</span>
                <span class="n">spec</span> <span class="o">=</span> <span class="n">_LookupTable</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="s1">&#39;linear&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">spec</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">w</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fast_spec</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="o">*</span> <span class="n">other</span><span class="o">.</span><span class="n">_tp</span><span class="p">(</span><span class="n">w</span><span class="o">*</span><span class="n">zfactor</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">spec</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">w</span><span class="p">:</span> <span class="bp">self</span><span class="p">(</span><span class="n">w</span><span class="o">*</span><span class="p">(</span><span class="mf">1.0</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">redshift</span><span class="p">))</span> <span class="o">*</span> <span class="n">other</span><span class="o">.</span><span class="n">_tp</span><span class="p">(</span><span class="n">w</span><span class="o">*</span><span class="n">zfactor</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">SED</span><span class="p">(</span><span class="n">spec</span><span class="p">,</span> <span class="s1">&#39;nm&#39;</span><span class="p">,</span> <span class="s1">&#39;fphotons&#39;</span><span class="p">,</span> <span class="n">redshift</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">redshift</span><span class="p">,</span> <span class="n">fast</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">fast</span><span class="p">,</span>
                   <span class="n">_blue_limit</span><span class="o">=</span><span class="n">blue_limit</span><span class="p">,</span> <span class="n">_red_limit</span><span class="o">=</span><span class="n">red_limit</span><span class="p">,</span> <span class="n">_wave_list</span><span class="o">=</span><span class="n">wave_list</span><span class="p">,</span>
                   <span class="n">_spectral</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">spectral</span><span class="p">)</span></div>


<div class="viewcode-block" id="SED._mul_scalar"><a class="viewcode-back" href="../../sed.html#galsim.SED._mul_scalar">[docs]</a>    <span class="k">def</span> <span class="nf">_mul_scalar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Equivalent to self * other when other is a scalar&quot;&quot;&quot;</span>
        <span class="c1"># If other is a scalar and self._spec a LookupTable, then remake that LookupTable.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_spec</span><span class="p">,</span> <span class="n">LookupTable</span><span class="p">):</span>
            <span class="n">wave_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wave_type</span>
            <span class="n">flux_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">flux_type</span>
            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_spec</span><span class="o">.</span><span class="n">getArgs</span><span class="p">()</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_spec</span><span class="o">.</span><span class="n">getVals</span><span class="p">())</span> <span class="o">*</span> <span class="n">other</span>
            <span class="n">spec</span> <span class="o">=</span> <span class="n">_LookupTable</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">x_log</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_spec</span><span class="o">.</span><span class="n">x_log</span><span class="p">,</span> <span class="n">f_log</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_spec</span><span class="o">.</span><span class="n">f_log</span><span class="p">,</span>
                                <span class="n">interpolant</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_spec</span><span class="o">.</span><span class="n">interpolant</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_const</span><span class="p">:</span>
            <span class="n">spec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_spec</span><span class="p">(</span><span class="mf">42.0</span><span class="p">)</span> <span class="o">*</span> <span class="n">other</span>
            <span class="n">wave_type</span> <span class="o">=</span> <span class="s1">&#39;nm&#39;</span>
            <span class="n">flux_type</span> <span class="o">=</span> <span class="s1">&#39;1&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">wave_type</span> <span class="o">=</span> <span class="s1">&#39;nm&#39;</span>
            <span class="n">flux_type</span> <span class="o">=</span> <span class="s1">&#39;fphotons&#39;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectral</span> <span class="k">else</span> <span class="s1">&#39;1&#39;</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fast</span><span class="p">:</span>
                <span class="n">spec</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">w</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fast_spec</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="o">*</span> <span class="n">other</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">spec</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">w</span><span class="p">:</span> <span class="bp">self</span><span class="p">(</span><span class="n">w</span><span class="o">*</span><span class="p">(</span><span class="mf">1.0</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">redshift</span><span class="p">))</span> <span class="o">*</span> <span class="n">other</span>
        <span class="k">return</span> <span class="n">SED</span><span class="p">(</span><span class="n">spec</span><span class="p">,</span> <span class="n">wave_type</span><span class="p">,</span> <span class="n">flux_type</span><span class="p">,</span> <span class="n">redshift</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">redshift</span><span class="p">,</span> <span class="n">fast</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">fast</span><span class="p">,</span>
                   <span class="n">_blue_limit</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">blue_limit</span><span class="p">,</span> <span class="n">_red_limit</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">red_limit</span><span class="p">,</span>
                   <span class="n">_wave_list</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">wave_list</span><span class="p">,</span>
                   <span class="n">_spectral</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">spectral</span><span class="p">)</span></div>


<div class="viewcode-block" id="SED.__mul__"><a class="viewcode-back" href="../../sed.html#galsim.SED.__mul__">[docs]</a>    <span class="k">def</span> <span class="fm">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Multiply the SED by something.</span>

<span class="sd">        There are several possibilities:</span>

<span class="sd">        1. SED * SED -&gt; SED (at least one must be dimensionless)</span>
<span class="sd">        2. SED * GSObject -&gt; ChromaticObject</span>
<span class="sd">        3. SED * Bandpass -&gt; SED (treating throughput similarly to dimensionless SED)</span>
<span class="sd">        4. SED * callable function -&gt; SED (treating function as dimensionless SED)</span>
<span class="sd">        5. SED * scalar -&gt; SED</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.transform</span> <span class="kn">import</span> <span class="n">Transform</span>
        <span class="kn">from</span> <span class="nn">.bandpass</span> <span class="kn">import</span> <span class="n">Bandpass</span>
        <span class="c1"># Watch out for 5 types of `other`:</span>
        <span class="c1"># 1.  SED: Check that not both spectral densities.</span>
        <span class="c1"># 2.  GSObject: return a ChromaticObject().</span>
        <span class="c1"># 3.  Bandpass: return an SED, but carefully propagate blue/red limit and wave_list.</span>
        <span class="c1"># 4.  Callable: return an SED</span>
        <span class="c1"># 5.  Scalar: return an SED</span>
        <span class="c1">#</span>
        <span class="c1"># Additionally, check for shortcuts when self._const</span>

        <span class="c1"># Product of two SEDs</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">SED</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectral</span> <span class="ow">and</span> <span class="n">other</span><span class="o">.</span><span class="n">spectral</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">GalSimIncompatibleValuesError</span><span class="p">(</span>
                    <span class="s2">&quot;Cannot multiply two spectral densities together.&quot;</span><span class="p">,</span> <span class="n">self_sed</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="o">=</span><span class="n">other</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">other</span><span class="o">.</span><span class="n">_const</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mul_scalar</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">_spec</span><span class="p">(</span><span class="mf">42.0</span><span class="p">))</span>  <span class="c1"># const, so can eval anywhere.</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_const</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">other</span><span class="o">.</span><span class="n">_mul_scalar</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_spec</span><span class="p">(</span><span class="mf">42.0</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mul_sed</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

        <span class="c1"># Product of SED and achromatic GSObject is a `ChromaticTransformation`.</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">GSObject</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">Transform</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">flux_ratio</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>

        <span class="c1"># Product of SED and Bandpass is (filtered) SED.  The `redshift` attribute is retained.</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Bandpass</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mul_bandpass</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

        <span class="c1"># Product of SED with generic callable is also a (filtered) SED, with retained `redshift`.</span>
        <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="s1">&#39;__call__&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fast</span><span class="p">:</span>
                <span class="n">spec</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">w</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fast_spec</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="o">*</span> <span class="n">other</span><span class="p">(</span><span class="n">w</span><span class="o">*</span><span class="p">(</span><span class="mf">1.0</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">redshift</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">spec</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">w</span><span class="p">:</span> <span class="bp">self</span><span class="p">(</span><span class="n">w</span><span class="o">*</span><span class="p">(</span><span class="mf">1.0</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">redshift</span><span class="p">))</span> <span class="o">*</span> <span class="n">other</span><span class="p">(</span><span class="n">w</span><span class="o">*</span><span class="p">(</span><span class="mf">1.0</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">redshift</span><span class="p">))</span>
            <span class="n">flux_type</span> <span class="o">=</span> <span class="s1">&#39;fphotons&#39;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectral</span> <span class="k">else</span> <span class="s1">&#39;1&#39;</span>
            <span class="k">return</span> <span class="n">SED</span><span class="p">(</span><span class="n">spec</span><span class="p">,</span> <span class="s1">&#39;nm&#39;</span><span class="p">,</span> <span class="n">flux_type</span><span class="p">,</span> <span class="n">redshift</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">redshift</span><span class="p">,</span> <span class="n">fast</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">fast</span><span class="p">,</span>
                       <span class="n">_blue_limit</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">blue_limit</span><span class="p">,</span> <span class="n">_red_limit</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">red_limit</span><span class="p">,</span>
                       <span class="n">_wave_list</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">wave_list</span><span class="p">,</span>
                       <span class="n">_spectral</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">spectral</span><span class="p">)</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mul_scalar</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Cannot multiply an SED by </span><span class="si">%s</span><span class="s2">&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">other</span><span class="p">))</span></div>

    <span class="k">def</span> <span class="fm">__rmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">*</span><span class="n">other</span>

    <span class="k">def</span> <span class="nf">__div__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="c1"># Enable division by scalars or dimensionless callables (including dimensionless SEDs.)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">SED</span><span class="p">)</span> <span class="ow">and</span> <span class="n">other</span><span class="o">.</span><span class="n">spectral</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">GalSimSEDError</span><span class="p">(</span><span class="s2">&quot;Cannot divide by spectral SED.&quot;</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="s1">&#39;__call__&#39;</span><span class="p">):</span>
            <span class="n">spec</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">w</span><span class="p">:</span> <span class="bp">self</span><span class="p">(</span><span class="n">w</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">redshift</span><span class="p">))</span> <span class="o">/</span> <span class="n">other</span><span class="p">(</span><span class="n">w</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">redshift</span><span class="p">))</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_spec</span><span class="p">,</span> <span class="n">LookupTable</span><span class="p">):</span>
            <span class="c1"># If other is not a function, then there is no loss of accuracy by applying the</span>
            <span class="c1"># factor directly to the LookupTable, if that&#39;s what we are using.</span>
            <span class="c1"># Make sure to keep the same properties about the table, flux_type, wave_type.</span>
            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_spec</span><span class="o">.</span><span class="n">getArgs</span><span class="p">()</span>
            <span class="n">f</span> <span class="o">=</span> <span class="p">[</span> <span class="n">val</span> <span class="o">/</span> <span class="n">other</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_spec</span><span class="o">.</span><span class="n">getVals</span><span class="p">()</span> <span class="p">]</span>
            <span class="n">spec</span> <span class="o">=</span> <span class="n">_LookupTable</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">x_log</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_spec</span><span class="o">.</span><span class="n">x_log</span><span class="p">,</span> <span class="n">f_log</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_spec</span><span class="o">.</span><span class="n">f_log</span><span class="p">,</span>
                                <span class="n">interpolant</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_spec</span><span class="o">.</span><span class="n">interpolant</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">spec</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">w</span><span class="p">:</span> <span class="bp">self</span><span class="p">(</span><span class="n">w</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">redshift</span><span class="p">))</span> <span class="o">/</span> <span class="n">other</span>

        <span class="k">return</span> <span class="n">SED</span><span class="p">(</span><span class="n">spec</span><span class="p">,</span> <span class="n">flux_type</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">flux_type</span><span class="p">,</span> <span class="n">wave_type</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">wave_type</span><span class="p">,</span>
                   <span class="n">redshift</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">redshift</span><span class="p">,</span> <span class="n">fast</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">fast</span><span class="p">,</span>
                   <span class="n">_wave_list</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">wave_list</span><span class="p">,</span>
                   <span class="n">_blue_limit</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">blue_limit</span><span class="p">,</span> <span class="n">_red_limit</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">red_limit</span><span class="p">)</span>

    <span class="fm">__truediv__</span> <span class="o">=</span> <span class="n">__div__</span>

    <span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="c1"># Add together two SEDs, with the following caveats:</span>
        <span class="c1"># 1) The SEDs must have the same redshift.</span>
        <span class="c1"># 2) The resulting SED will be defined on the wavelength range set by the overlap of the</span>
        <span class="c1">#    wavelength ranges of the two SED operands.</span>
        <span class="c1"># 3) The new `wave_list` will be the union of the operand `wave_list`s in the intersecting</span>
        <span class="c1">#    region, even if one or both of the `wave_list`s are empty.</span>
        <span class="c1"># These conditions ensure that SED addition is commutative.</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">redshift</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">redshift</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">GalSimIncompatibleValuesError</span><span class="p">(</span>
                <span class="s2">&quot;Can only add SEDs with same redshift.&quot;</span><span class="p">,</span> <span class="n">self_sed</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="o">=</span><span class="n">other</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensionless</span> <span class="ow">and</span> <span class="n">other</span><span class="o">.</span><span class="n">dimensionless</span><span class="p">:</span>
            <span class="n">flux_type</span> <span class="o">=</span> <span class="s1">&#39;1&#39;</span>
            <span class="n">_spectral</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectral</span> <span class="ow">and</span> <span class="n">other</span><span class="o">.</span><span class="n">spectral</span><span class="p">:</span>
            <span class="n">flux_type</span> <span class="o">=</span> <span class="s1">&#39;fphotons&#39;</span>
            <span class="n">_spectral</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">GalSimIncompatibleValuesError</span><span class="p">(</span>
                <span class="s2">&quot;Cannot add SEDs with incompatible dimensions.&quot;</span><span class="p">,</span> <span class="n">self_sed</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="o">=</span><span class="n">other</span><span class="p">)</span>

        <span class="n">wave_list</span><span class="p">,</span> <span class="n">blue_limit</span><span class="p">,</span> <span class="n">red_limit</span> <span class="o">=</span> <span class="n">combine_wave_list</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

        <span class="c1"># If both SEDs are `fast`, and both `_fast_spec`s are LookupTables, then make a new</span>
        <span class="c1"># LookupTable instead and preserve picklability.</span>
        <span class="c1"># First need to make sure self._fast_spec and other._fast_spec are initialized.  Can do this</span>
        <span class="c1"># by evaluating them at a good wavelength.  blue_limit should work.</span>
        <span class="bp">self</span><span class="p">(</span><span class="n">blue_limit</span><span class="p">)</span>
        <span class="n">other</span><span class="p">(</span><span class="n">blue_limit</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fast</span>
                <span class="ow">and</span> <span class="n">other</span><span class="o">.</span><span class="n">fast</span>
                <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_fast_spec</span><span class="p">,</span> <span class="n">LookupTable</span><span class="p">)</span>
                <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">_fast_spec</span><span class="p">,</span> <span class="n">LookupTable</span><span class="p">)</span>
                <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fast_spec</span><span class="o">.</span><span class="n">x_log</span>
                <span class="ow">and</span> <span class="ow">not</span> <span class="n">other</span><span class="o">.</span><span class="n">_fast_spec</span><span class="o">.</span><span class="n">x_log</span>
                <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fast_spec</span><span class="o">.</span><span class="n">f_log</span>
                <span class="ow">and</span> <span class="ow">not</span> <span class="n">other</span><span class="o">.</span><span class="n">_fast_spec</span><span class="o">.</span><span class="n">f_log</span>
                <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fast_spec</span><span class="o">.</span><span class="n">interpolant</span> <span class="o">==</span> <span class="s1">&#39;linear&#39;</span>
                <span class="ow">and</span> <span class="n">other</span><span class="o">.</span><span class="n">_fast_spec</span><span class="o">.</span><span class="n">interpolant</span> <span class="o">==</span> <span class="s1">&#39;linear&#39;</span><span class="p">):</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">wave_list</span> <span class="o">/</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">redshift</span><span class="p">)</span>
            <span class="n">f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fast_spec</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">other</span><span class="o">.</span><span class="n">_fast_spec</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="n">spec</span> <span class="o">=</span> <span class="n">_LookupTable</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">interpolant</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">spec</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">w</span><span class="p">:</span> <span class="bp">self</span><span class="p">(</span><span class="n">w</span><span class="o">*</span><span class="p">(</span><span class="mf">1.0</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">redshift</span><span class="p">))</span> <span class="o">+</span> <span class="n">other</span><span class="p">(</span><span class="n">w</span><span class="o">*</span><span class="p">(</span><span class="mf">1.0</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">redshift</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">SED</span><span class="p">(</span><span class="n">spec</span><span class="p">,</span> <span class="n">wave_type</span><span class="o">=</span><span class="s1">&#39;nm&#39;</span><span class="p">,</span> <span class="n">flux_type</span><span class="o">=</span><span class="n">flux_type</span><span class="p">,</span>
                   <span class="n">redshift</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">redshift</span><span class="p">,</span> <span class="n">fast</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">fast</span><span class="p">,</span> <span class="n">_wave_list</span><span class="o">=</span><span class="n">wave_list</span><span class="p">,</span>
                   <span class="n">_blue_limit</span><span class="o">=</span><span class="n">blue_limit</span><span class="p">,</span> <span class="n">_red_limit</span><span class="o">=</span><span class="n">red_limit</span><span class="p">,</span>
                   <span class="n">_spectral</span><span class="o">=</span><span class="n">_spectral</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__sub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="c1"># Subtract two SEDs, with the same caveats as adding two SEDs.</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__add__</span><span class="p">(</span><span class="o">-</span><span class="mf">1.0</span> <span class="o">*</span> <span class="n">other</span><span class="p">)</span>

<div class="viewcode-block" id="SED.withFluxDensity"><a class="viewcode-back" href="../../sed.html#galsim.SED.withFluxDensity">[docs]</a>    <span class="k">def</span> <span class="nf">withFluxDensity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target_flux_density</span><span class="p">,</span> <span class="n">wavelength</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a new `SED` with flux density set to ``target_flux_density`` at wavelength</span>
<span class="sd">        ``wavelength``.</span>

<span class="sd">        See `ChromaticObject` docstring for information about how `SED` normalization affects</span>
<span class="sd">        `ChromaticObject` normalization.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            target_flux_density:    The target normalization in photons/nm/cm^2/s.</span>
<span class="sd">            wavelength:             The wavelength, in nm, at which the flux density will be set.</span>

<span class="sd">        Returns:</span>
<span class="sd">            the new normalized SED.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensionless</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">GalSimSEDError</span><span class="p">(</span><span class="s2">&quot;Cannot set flux density of dimensionless SED.&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">wavelength</span><span class="p">,</span> <span class="n">units</span><span class="o">.</span><span class="n">Quantity</span><span class="p">):</span>
            <span class="n">wavelength_nm</span> <span class="o">=</span> <span class="n">wavelength</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">units</span><span class="o">.</span><span class="n">nm</span><span class="p">,</span> <span class="n">units</span><span class="o">.</span><span class="n">spectral</span><span class="p">())</span>
            <span class="n">current_flux_density</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_call</span><span class="p">(</span><span class="n">wavelength_nm</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">wavelength_nm</span> <span class="o">=</span> <span class="n">wavelength</span> <span class="o">*</span> <span class="n">units</span><span class="o">.</span><span class="n">nm</span>
            <span class="n">current_flux_density</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_call</span><span class="p">(</span><span class="n">wavelength</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">target_flux_density</span><span class="p">,</span> <span class="n">units</span><span class="o">.</span><span class="n">Quantity</span><span class="p">):</span>
            <span class="n">target_flux_density</span> <span class="o">=</span> <span class="n">target_flux_density</span><span class="o">.</span><span class="n">to</span><span class="p">(</span>
                    <span class="n">SED</span><span class="o">.</span><span class="n">_fphotons</span><span class="p">,</span> <span class="n">units</span><span class="o">.</span><span class="n">spectral_density</span><span class="p">(</span><span class="n">wavelength_nm</span><span class="p">))</span><span class="o">.</span><span class="n">value</span>
        <span class="n">factor</span> <span class="o">=</span> <span class="n">target_flux_density</span> <span class="o">/</span> <span class="n">current_flux_density</span>
        <span class="k">return</span> <span class="bp">self</span> <span class="o">*</span> <span class="n">factor</span></div>

<div class="viewcode-block" id="SED.withFlux"><a class="viewcode-back" href="../../sed.html#galsim.SED.withFlux">[docs]</a>    <span class="k">def</span> <span class="nf">withFlux</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target_flux</span><span class="p">,</span> <span class="n">bandpass</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a new `SED` with flux through the `Bandpass` ``bandpass`` set to ``target_flux``.</span>

<span class="sd">        See `ChromaticObject` docstring for information about how `SED` normalization affects</span>
<span class="sd">        `ChromaticObject` normalization.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            target_flux:    The desired flux normalization of the SED.</span>
<span class="sd">            bandpass:       A `Bandpass` object defining a filter bandpass.</span>

<span class="sd">        Returns:</span>
<span class="sd">            the new normalized `SED`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">current_flux</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculateFlux</span><span class="p">(</span><span class="n">bandpass</span><span class="p">)</span>
        <span class="n">norm</span> <span class="o">=</span> <span class="n">target_flux</span><span class="o">/</span><span class="n">current_flux</span>
        <span class="k">return</span> <span class="bp">self</span> <span class="o">*</span> <span class="n">norm</span></div>

<div class="viewcode-block" id="SED.withMagnitude"><a class="viewcode-back" href="../../sed.html#galsim.SED.withMagnitude">[docs]</a>    <span class="k">def</span> <span class="nf">withMagnitude</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target_magnitude</span><span class="p">,</span> <span class="n">bandpass</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a new `SED` with magnitude through the `Bandpass` ``bandpass`` set to</span>
<span class="sd">        ``target_magnitude``.</span>

<span class="sd">        Note that this requires ``bandpass`` to have been assigned a zeropoint using</span>
<span class="sd">        `Bandpass.withZeropoint`.  See `ChromaticObject` docstring for information about how `SED`</span>
<span class="sd">        normalization affects `ChromaticObject` normalization.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            target_magnitude:   The desired magnitude of the `SED`.</span>
<span class="sd">            bandpass:           A `Bandpass` object defining a filter bandpass.</span>

<span class="sd">        Returns:</span>
<span class="sd">            the new normalized `SED`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">bandpass</span><span class="o">.</span><span class="n">zeropoint</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">GalSimError</span><span class="p">(</span><span class="s2">&quot;Cannot call SED.withMagnitude on this bandpass, because it does &quot;</span>
                              <span class="s2">&quot;not have a zeropoint.  See Bandpass.withZeropoint()&quot;</span><span class="p">)</span>
        <span class="n">current_magnitude</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculateMagnitude</span><span class="p">(</span><span class="n">bandpass</span><span class="p">)</span>
        <span class="n">norm</span> <span class="o">=</span> <span class="mi">10</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="mf">0.4</span><span class="o">*</span><span class="p">(</span><span class="n">target_magnitude</span> <span class="o">-</span> <span class="n">current_magnitude</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span> <span class="o">*</span> <span class="n">norm</span></div>

<div class="viewcode-block" id="SED.atRedshift"><a class="viewcode-back" href="../../sed.html#galsim.SED.atRedshift">[docs]</a>    <span class="k">def</span> <span class="nf">atRedshift</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">redshift</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a new `SED` with redshifted wavelengths.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            redshift:   The redshift for the returned `SED`</span>

<span class="sd">        Returns:</span>
<span class="sd">            the redshifted `SED`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">redshift</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">redshift</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">if</span> <span class="n">redshift</span> <span class="o">&lt;=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">GalSimRangeError</span><span class="p">(</span><span class="s2">&quot;Invalid redshift&quot;</span><span class="p">,</span> <span class="n">redshift</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span><span class="p">)</span>
        <span class="n">zfactor</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="n">redshift</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">redshift</span><span class="p">)</span>
        <span class="n">wave_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wave_list</span> <span class="o">*</span> <span class="n">zfactor</span>
        <span class="n">blue_limit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">blue_limit</span> <span class="o">*</span> <span class="n">zfactor</span>
        <span class="n">red_limit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">red_limit</span> <span class="o">*</span> <span class="n">zfactor</span>

        <span class="k">return</span> <span class="n">SED</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_spec</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">wave_type</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">flux_type</span><span class="p">,</span> <span class="n">redshift</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fast</span><span class="p">,</span>
                   <span class="n">_wave_list</span><span class="o">=</span><span class="n">wave_list</span><span class="p">,</span> <span class="n">_blue_limit</span><span class="o">=</span><span class="n">blue_limit</span><span class="p">,</span> <span class="n">_red_limit</span><span class="o">=</span><span class="n">red_limit</span><span class="p">)</span></div>

<div class="viewcode-block" id="SED.calculateFlux"><a class="viewcode-back" href="../../sed.html#galsim.SED.calculateFlux">[docs]</a>    <span class="k">def</span> <span class="nf">calculateFlux</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bandpass</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the flux (photons/cm^2/s) of the `SED` through the `Bandpass` bandpass.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            bandpass:   A `Bandpass` object representing a filter, or None to compute the</span>
<span class="sd">                        bolometric flux.  For the bolometric flux the integration limits will be</span>
<span class="sd">                        set to (0, infinity), which implies that the `SED` needs to be evaluable</span>
<span class="sd">                        over this entire range.</span>

<span class="sd">        Returns:</span>
<span class="sd">            the flux through the bandpass.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">integ</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensionless</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">GalSimSEDError</span><span class="p">(</span><span class="s2">&quot;Cannot calculate flux of dimensionless SED.&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">bandpass</span><span class="o">.</span><span class="n">wave_list</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wave_list</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">slop</span> <span class="o">=</span> <span class="mf">1e-6</span> <span class="c1"># nm</span>
            <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">blue_limit</span> <span class="o">&gt;</span> <span class="n">bandpass</span><span class="o">.</span><span class="n">blue_limit</span> <span class="o">+</span> <span class="n">slop</span>
                    <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">red_limit</span> <span class="o">&lt;</span> <span class="n">bandpass</span><span class="o">.</span><span class="n">red_limit</span> <span class="o">-</span> <span class="n">slop</span><span class="p">):</span>
                <span class="k">raise</span> <span class="n">GalSimRangeError</span><span class="p">(</span><span class="s2">&quot;Bandpass is not completely within defined wavelength &quot;</span>
                                       <span class="s2">&quot;range for this SED.&quot;</span><span class="p">,</span>
                                       <span class="p">(</span><span class="n">bandpass</span><span class="o">.</span><span class="n">blue_limit</span><span class="p">,</span> <span class="n">bandpass</span><span class="o">.</span><span class="n">red_limit</span><span class="p">),</span>
                                       <span class="bp">self</span><span class="o">.</span><span class="n">blue_limit</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">red_limit</span><span class="p">)</span>
            <span class="n">wmin</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">blue_limit</span><span class="p">,</span> <span class="n">bandpass</span><span class="o">.</span><span class="n">blue_limit</span><span class="p">)</span>
            <span class="n">wmax</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">red_limit</span><span class="p">,</span> <span class="n">bandpass</span><span class="o">.</span><span class="n">red_limit</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fast</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_fast_spec</span><span class="p">,</span> <span class="n">LookupTable</span><span class="p">):</span>
                <span class="n">wf</span> <span class="o">=</span> <span class="mf">1.</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">redshift</span><span class="p">)</span> <span class="o">/</span> <span class="n">bandpass</span><span class="o">.</span><span class="n">wave_factor</span>
                <span class="n">ff</span> <span class="o">=</span> <span class="mf">1.</span><span class="o">/</span><span class="n">bandpass</span><span class="o">.</span><span class="n">wave_factor</span>
                <span class="n">wmin</span> <span class="o">*=</span> <span class="n">bandpass</span><span class="o">.</span><span class="n">wave_factor</span>
                <span class="n">wmax</span> <span class="o">*=</span> <span class="n">bandpass</span><span class="o">.</span><span class="n">wave_factor</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fast_spec</span><span class="o">.</span><span class="n">integrate_product</span><span class="p">(</span><span class="n">bandpass</span><span class="o">.</span><span class="n">_tp</span><span class="p">,</span> <span class="n">wmin</span><span class="p">,</span> <span class="n">wmax</span><span class="p">,</span> <span class="n">wf</span><span class="p">)</span> <span class="o">*</span> <span class="n">ff</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">w</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">combine_wave_list</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bandpass</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">fast</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">flux_type</span> <span class="o">!=</span> <span class="s1">&#39;fphotons&#39;</span><span class="p">:</span>
                    <span class="c1"># When not fast, the SED definition is not linear between the wave_list</span>
                    <span class="c1"># points, so this can be slightly inaccurate if the waves are too far apart.</span>
                    <span class="c1"># Add in 100 uniformly spaced points to achieve relative accurace ~few e-6.</span>
                    <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">union1d</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">w</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">w</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="mi">100</span><span class="p">))</span>
                <span class="k">return</span> <span class="n">_LookupTable</span><span class="p">(</span><span class="n">w</span><span class="p">,</span><span class="n">bandpass</span><span class="p">(</span><span class="n">w</span><span class="p">),</span><span class="s1">&#39;linear&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">integrate_product</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">integ</span><span class="o">.</span><span class="n">int1d</span><span class="p">(</span><span class="k">lambda</span> <span class="n">w</span><span class="p">:</span> <span class="n">bandpass</span><span class="p">(</span><span class="n">w</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="p">(</span><span class="n">w</span><span class="p">),</span>
                               <span class="n">bandpass</span><span class="o">.</span><span class="n">blue_limit</span><span class="p">,</span> <span class="n">bandpass</span><span class="o">.</span><span class="n">red_limit</span><span class="p">)</span></div>

<div class="viewcode-block" id="SED.calculateMagnitude"><a class="viewcode-back" href="../../sed.html#galsim.SED.calculateMagnitude">[docs]</a>    <span class="k">def</span> <span class="nf">calculateMagnitude</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bandpass</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the `SED` magnitude through a `Bandpass` ``bandpass``.</span>

<span class="sd">        Note that this requires ``bandpass`` to have been assigned a zeropoint using</span>
<span class="sd">        `Bandpass.withZeropoint`.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            bandpass:     A `Bandpass` object representing a filter, or None to compute the</span>
<span class="sd">                          bolometric magnitude.  For the bolometric magnitude the integration</span>
<span class="sd">                          limits will be set to (0, infinity), which implies that the `SED` needs</span>
<span class="sd">                          to be evaluable over this entire range.</span>

<span class="sd">        Returns:</span>
<span class="sd">            the bandpass magnitude.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensionless</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">GalSimSEDError</span><span class="p">(</span><span class="s2">&quot;Cannot calculate magnitude of dimensionless SED.&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">bandpass</span><span class="o">.</span><span class="n">zeropoint</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">GalSimError</span><span class="p">(</span><span class="s2">&quot;Cannot do this calculation for a bandpass without an assigned &quot;</span>
                              <span class="s2">&quot;zeropoint&quot;</span><span class="p">)</span>
        <span class="n">flux</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculateFlux</span><span class="p">(</span><span class="n">bandpass</span><span class="p">)</span>
        <span class="k">return</span> <span class="o">-</span><span class="mf">2.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">flux</span><span class="p">)</span> <span class="o">+</span> <span class="n">bandpass</span><span class="o">.</span><span class="n">zeropoint</span></div>

<div class="viewcode-block" id="SED.thin"><a class="viewcode-back" href="../../sed.html#galsim.SED.thin">[docs]</a>    <span class="k">def</span> <span class="nf">thin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rel_err</span><span class="o">=</span><span class="mf">1.e-4</span><span class="p">,</span> <span class="n">trim_zeros</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">preserve_range</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">fast_search</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Remove some tabulated values while keeping the integral over the set of tabulated values</span>
<span class="sd">        still accurate to ``rel_err``.</span>

<span class="sd">        This is only relevant if the `SED` was initialized with a `LookupTable` or from a file</span>
<span class="sd">        (which internally creates a `LookupTable`).</span>

<span class="sd">        Parameters:</span>
<span class="sd">            rel_err:          The relative error allowed in the integral over the `SED`</span>
<span class="sd">                              [default: 1.e-4]</span>
<span class="sd">            trim_zeros:       Remove redundant leading and trailing points where f=0?  (The last</span>
<span class="sd">                              leading point with f=0 and the first trailing point with f=0 will</span>
<span class="sd">                              be retained).  Note that if both trim_leading_zeros and</span>
<span class="sd">                              preserve_range are True, then the only the range of ``x`` *after*</span>
<span class="sd">                              zero trimming is preserved.  [default: True]</span>
<span class="sd">            preserve_range:   Should the original range (``blue_limit`` and ``red_limit``) of the</span>
<span class="sd">                              `SED` be preserved? (True) Or should the ends be trimmed to</span>
<span class="sd">                              include only the region where the integral is significant? (False)</span>
<span class="sd">                              [default: True]</span>
<span class="sd">            fast_search:      If set to True, then the underlying algorithm will use a</span>
<span class="sd">                              relatively fast O(N) algorithm to select points to include in the</span>
<span class="sd">                              thinned approximation.  If set to False, then a slower O(N^2)</span>
<span class="sd">                              algorithm will be used.  We have found that the slower algorithm</span>
<span class="sd">                              tends to yield a thinned representation that retains fewer samples</span>
<span class="sd">                              while still meeting the relative error requirement.</span>
<span class="sd">                              [default: True]</span>

<span class="sd">        Returns:</span>
<span class="sd">            the thinned `SED`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wave_list</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">rest_wave_native</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_rest_native_waves</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wave_list</span><span class="p">)</span>
            <span class="n">spec_native</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_spec</span><span class="p">(</span><span class="n">rest_wave_native</span><span class="p">)</span>

            <span class="c1"># Note that this is thinning in native units, not nm and photons/nm.</span>
            <span class="n">newx</span><span class="p">,</span> <span class="n">newf</span> <span class="o">=</span> <span class="n">utilities</span><span class="o">.</span><span class="n">thin_tabulated_values</span><span class="p">(</span>
                    <span class="n">rest_wave_native</span><span class="p">,</span> <span class="n">spec_native</span><span class="p">,</span> <span class="n">rel_err</span><span class="o">=</span><span class="n">rel_err</span><span class="p">,</span>
                    <span class="n">trim_zeros</span><span class="o">=</span><span class="n">trim_zeros</span><span class="p">,</span> <span class="n">preserve_range</span><span class="o">=</span><span class="n">preserve_range</span><span class="p">,</span> <span class="n">fast_search</span><span class="o">=</span><span class="n">fast_search</span><span class="p">)</span>

            <span class="n">newspec</span> <span class="o">=</span> <span class="n">_LookupTable</span><span class="p">(</span><span class="n">newx</span><span class="p">,</span> <span class="n">newf</span><span class="p">,</span> <span class="n">interpolant</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">SED</span><span class="p">(</span><span class="n">newspec</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">wave_type</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">flux_type</span><span class="p">,</span> <span class="n">redshift</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">redshift</span><span class="p">,</span>
                       <span class="n">fast</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">fast</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="SED.calculateDCRMomentShifts"><a class="viewcode-back" href="../../sed.html#galsim.SED.calculateDCRMomentShifts">[docs]</a>    <span class="k">def</span> <span class="nf">calculateDCRMomentShifts</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bandpass</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculates shifts in first and second moments of PSF due to differential chromatic</span>
<span class="sd">        refraction (DCR).</span>

<span class="sd">        I.e., equations (1) and (2) from Plazas and Bernstein (2012):</span>

<span class="sd">        http://arxiv.org/abs/1204.1346).</span>

<span class="sd">        Parameters:</span>
<span class="sd">            bandpass:           `Bandpass` through which object is being imaged.</span>
<span class="sd">            zenith_angle:       `Angle` from object to zenith</span>
<span class="sd">            parallactic_angle:  Parallactic angle, i.e. the position angle of the zenith,</span>
<span class="sd">                                measured from North through East.  [default: 0]</span>
<span class="sd">            obj_coord:          Celestial coordinates of the object being drawn as a</span>
<span class="sd">                                `CelestialCoord`. [default: None]</span>
<span class="sd">            zenith_coord:       Celestial coordinates of the zenith as a `CelestialCoord`.</span>
<span class="sd">                                [default: None]</span>
<span class="sd">            HA:                 Hour angle of the object as an `Angle`. [default: None]</span>
<span class="sd">            latitude:           Latitude of the observer as an `Angle`. [default: None]</span>
<span class="sd">            pressure:           Air pressure in kiloPascals.  [default: 69.328 kPa]</span>
<span class="sd">            temperature:        Temperature in Kelvins.  [default: 293.15 K]</span>
<span class="sd">            H2O_pressure:       Water vapor pressure in kiloPascals.  [default: 1.067 kPa]</span>

<span class="sd">        Returns:</span>
<span class="sd">            a tuple:</span>

<span class="sd">            - The first element is the vector of DCR first moment shifts</span>
<span class="sd">            - The second element is the 2x2 matrix of DCR second (central) moment shifts.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.dcr</span> <span class="kn">import</span> <span class="n">parse_dcr_angles</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensionless</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">GalSimSEDError</span><span class="p">(</span><span class="s2">&quot;Cannot calculate DCR shifts of dimensionless SED.&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

        <span class="n">zenith_angle</span><span class="p">,</span> <span class="n">parallactic_angle</span><span class="p">,</span> <span class="n">kwargs</span> <span class="o">=</span> <span class="n">parse_dcr_angles</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Any remaining kwargs will get forwarded to galsim.dcr.get_refraction</span>
        <span class="c1"># Check that they&#39;re valid</span>
        <span class="k">for</span> <span class="n">kw</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">kw</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;temperature&#39;</span><span class="p">,</span> <span class="s1">&#39;pressure&#39;</span><span class="p">,</span> <span class="s1">&#39;H2O_pressure&#39;</span><span class="p">):</span>
                <span class="k">raise</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Got unexpected keyword in calculateDCRMomentShifts: </span><span class="si">{0}</span><span class="s2">&quot;</span>
                                 <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">kw</span><span class="p">)))</span>

        <span class="c1"># Now actually start calculating things.</span>
        <span class="n">flux</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculateFlux</span><span class="p">(</span><span class="n">bandpass</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wave_list</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">bandpass</span><span class="o">.</span><span class="n">wave_list</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">w</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">combine_wave_list</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bandpass</span><span class="p">)</span>
            <span class="n">bp</span> <span class="o">=</span> <span class="n">_LookupTable</span><span class="p">(</span><span class="n">w</span><span class="p">,</span><span class="n">bandpass</span><span class="p">(</span><span class="n">w</span><span class="p">),</span><span class="s1">&#39;linear&#39;</span><span class="p">)</span>
            <span class="n">R</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">w</span><span class="p">:</span> <span class="n">dcr</span><span class="o">.</span><span class="n">get_refraction</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">zenith_angle</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="n">Rbar</span> <span class="o">=</span> <span class="n">bp</span><span class="o">.</span><span class="n">integrate_product</span><span class="p">(</span><span class="k">lambda</span> <span class="n">w</span><span class="p">:</span> <span class="bp">self</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="o">*</span> <span class="n">R</span><span class="p">(</span><span class="n">w</span><span class="p">))</span> <span class="o">/</span> <span class="n">flux</span>
            <span class="n">V</span> <span class="o">=</span> <span class="n">bp</span><span class="o">.</span><span class="n">integrate_product</span><span class="p">(</span><span class="k">lambda</span> <span class="n">w</span><span class="p">:</span> <span class="bp">self</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">R</span><span class="p">(</span><span class="n">w</span><span class="p">)</span><span class="o">-</span><span class="n">Rbar</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">flux</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">weight</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">w</span><span class="p">:</span> <span class="n">bandpass</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
            <span class="n">Rbar_kernel</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">w</span><span class="p">:</span> <span class="n">dcr</span><span class="o">.</span><span class="n">get_refraction</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">zenith_angle</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="n">Rbar</span> <span class="o">=</span> <span class="n">integ</span><span class="o">.</span><span class="n">int1d</span><span class="p">(</span><span class="k">lambda</span> <span class="n">w</span><span class="p">:</span> <span class="n">weight</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="o">*</span> <span class="n">Rbar_kernel</span><span class="p">(</span><span class="n">w</span><span class="p">),</span>
                               <span class="n">bandpass</span><span class="o">.</span><span class="n">blue_limit</span><span class="p">,</span> <span class="n">bandpass</span><span class="o">.</span><span class="n">red_limit</span><span class="p">)</span>
            <span class="n">Rbar</span> <span class="o">/=</span> <span class="n">flux</span>
            <span class="n">V_kernel</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">w</span><span class="p">:</span> <span class="p">(</span><span class="n">dcr</span><span class="o">.</span><span class="n">get_refraction</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">zenith_angle</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-</span> <span class="n">Rbar</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
            <span class="n">V</span> <span class="o">=</span> <span class="n">integ</span><span class="o">.</span><span class="n">int1d</span><span class="p">(</span><span class="k">lambda</span> <span class="n">w</span><span class="p">:</span> <span class="n">weight</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="o">*</span> <span class="n">V_kernel</span><span class="p">(</span><span class="n">w</span><span class="p">),</span>
                            <span class="n">bandpass</span><span class="o">.</span><span class="n">blue_limit</span><span class="p">,</span> <span class="n">bandpass</span><span class="o">.</span><span class="n">red_limit</span><span class="p">)</span>
            <span class="n">V</span> <span class="o">/=</span> <span class="n">flux</span>
        <span class="c1"># Rbar and V are computed above assuming that the parallactic angle is 0.  Hence we</span>
        <span class="c1"># need to rotate our frame by the parallactic angle to get the desired output.</span>
        <span class="n">sinp</span><span class="p">,</span> <span class="n">cosp</span> <span class="o">=</span> <span class="n">parallactic_angle</span><span class="o">.</span><span class="n">sincos</span><span class="p">()</span>
        <span class="n">rot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">cosp</span><span class="p">,</span> <span class="o">-</span><span class="n">sinp</span><span class="p">],</span> <span class="p">[</span><span class="n">sinp</span><span class="p">,</span> <span class="n">cosp</span><span class="p">]])</span>
        <span class="n">Rbar</span> <span class="o">=</span> <span class="n">Rbar</span> <span class="o">*</span> <span class="n">rot</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]))</span>
        <span class="n">V</span> <span class="o">=</span> <span class="n">rot</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">V</span><span class="p">]]))</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">rot</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Rbar</span><span class="p">,</span> <span class="n">V</span></div>

<div class="viewcode-block" id="SED.calculateSeeingMomentRatio"><a class="viewcode-back" href="../../sed.html#galsim.SED.calculateSeeingMomentRatio">[docs]</a>    <span class="k">def</span> <span class="nf">calculateSeeingMomentRatio</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bandpass</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=-</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">base_wavelength</span><span class="o">=</span><span class="mi">500</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculates the relative size of a PSF compared to the monochromatic PSF size at</span>
<span class="sd">        wavelength ``base_wavelength``.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            bandpass:           `Bandpass` through which object is being imaged.</span>
<span class="sd">            alpha:              Power law index for wavelength-dependent seeing.  [default:</span>
<span class="sd">                                -0.2, the prediction for Kolmogorov turbulence]</span>
<span class="sd">            base_wavelength:    Reference wavelength in nm from which to compute the relative</span>
<span class="sd">                                PSF size.  [default: 500]</span>

<span class="sd">        Returns:</span>
<span class="sd">            the ratio of the PSF second moments to the second moments of the reference PSF.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensionless</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">GalSimSEDError</span><span class="p">(</span><span class="s2">&quot;Cannot calculate seeing moment ratio of dimensionless SED.&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
        <span class="n">flux</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculateFlux</span><span class="p">(</span><span class="n">bandpass</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wave_list</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">bandpass</span><span class="o">.</span><span class="n">wave_list</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># With three things multiplied together, we can&#39;t rely on integrate_product</span>
            <span class="c1"># being completely accurate if the waves are spaced too far apart, especially with</span>
            <span class="c1"># a power law being one of the factors.</span>
            <span class="c1"># So make sure to include a uniform density of points along with the native sed and</span>
            <span class="c1"># bandpass points. The error goes like dx**3, so 100 points should give relative</span>
            <span class="c1"># errors of order ~few e-6.</span>
            <span class="n">w</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">combine_wave_list</span><span class="p">([</span><span class="bp">self</span><span class="p">,</span> <span class="n">bandpass</span><span class="p">])</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">union1d</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">w</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">w</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="mi">100</span><span class="p">))</span>
            <span class="n">bp</span> <span class="o">=</span> <span class="n">_LookupTable</span><span class="p">(</span><span class="n">w</span><span class="p">,</span><span class="n">bandpass</span><span class="p">(</span><span class="n">w</span><span class="p">),</span><span class="s1">&#39;linear&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">bp</span><span class="o">.</span><span class="n">integrate_product</span><span class="p">(</span><span class="k">lambda</span> <span class="n">w</span><span class="p">:</span> <span class="bp">self</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">w</span><span class="o">/</span><span class="n">base_wavelength</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">alpha</span><span class="p">))</span> <span class="o">/</span> <span class="n">flux</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">weight</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">w</span><span class="p">:</span> <span class="n">bandpass</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
            <span class="n">kernel</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">w</span><span class="p">:</span> <span class="p">(</span><span class="n">w</span><span class="o">/</span><span class="n">base_wavelength</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">alpha</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">integ</span><span class="o">.</span><span class="n">int1d</span><span class="p">(</span><span class="k">lambda</span> <span class="n">w</span><span class="p">:</span> <span class="n">weight</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="o">*</span> <span class="n">kernel</span><span class="p">(</span><span class="n">w</span><span class="p">),</span>
                               <span class="n">bandpass</span><span class="o">.</span><span class="n">blue_limit</span><span class="p">,</span> <span class="n">bandpass</span><span class="o">.</span><span class="n">red_limit</span><span class="p">)</span> <span class="o">/</span> <span class="n">flux</span></div>

    <span class="nd">@lazy_property</span>
    <span class="k">def</span> <span class="nf">_cache_deviate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">dict</span><span class="p">()</span>

<div class="viewcode-block" id="SED.sampleWavelength"><a class="viewcode-back" href="../../sed.html#galsim.SED.sampleWavelength">[docs]</a>    <span class="k">def</span> <span class="nf">sampleWavelength</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nphotons</span><span class="p">,</span> <span class="n">bandpass</span><span class="p">,</span> <span class="n">rng</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">npoints</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Sample a number of random wavelength values from the `SED`, possibly as observed through</span>
<span class="sd">        a `Bandpass` bandpass.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            nphotons:    Number of samples (photons) to randomly draw.</span>
<span class="sd">            bandpass:    A `Bandpass` object representing a filter, or None to sample over the full</span>
<span class="sd">                         `SED` wavelength range.</span>
<span class="sd">            rng:         If provided, a random number generator that is any kind of `BaseDeviate`</span>
<span class="sd">                         object. If ``rng`` is None, one will be automatically created from the</span>
<span class="sd">                         system. [default: None]</span>
<span class="sd">            npoints:     Number of points `DistDeviate` should use for its internal interpolation</span>
<span class="sd">                         tables. [default: None, which uses the `DistDeviate` default]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.random</span> <span class="kn">import</span> <span class="n">DistDeviate</span>
        <span class="n">nphotons</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">nphotons</span><span class="p">)</span>

        <span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="n">bandpass</span><span class="p">,</span><span class="n">npoints</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cache_deviate</span><span class="p">:</span>
            <span class="n">dev</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cache_deviate</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">bandpass</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">sed</span> <span class="o">=</span> <span class="bp">self</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">sed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mul_bandpass</span><span class="p">(</span><span class="n">bandpass</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sed</span><span class="o">.</span><span class="n">_fast_spec</span><span class="p">,</span> <span class="n">LookupTable</span><span class="p">):</span>
                <span class="n">dev</span> <span class="o">=</span> <span class="n">DistDeviate</span><span class="p">(</span><span class="n">function</span><span class="o">=</span><span class="n">sed</span><span class="o">.</span><span class="n">_fast_spec</span><span class="p">,</span> <span class="n">npoints</span><span class="o">=</span><span class="n">npoints</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">xmin</span> <span class="o">=</span> <span class="n">sed</span><span class="o">.</span><span class="n">blue_limit</span> <span class="o">/</span> <span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">redshift</span><span class="p">)</span>
                <span class="n">xmax</span> <span class="o">=</span> <span class="n">sed</span><span class="o">.</span><span class="n">red_limit</span> <span class="o">/</span> <span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">redshift</span><span class="p">)</span>
                <span class="n">dev</span> <span class="o">=</span> <span class="n">DistDeviate</span><span class="p">(</span><span class="n">function</span><span class="o">=</span><span class="n">sed</span><span class="o">.</span><span class="n">_fast_spec</span><span class="p">,</span> <span class="n">x_min</span><span class="o">=</span><span class="n">xmin</span><span class="p">,</span> <span class="n">x_max</span><span class="o">=</span><span class="n">xmax</span><span class="p">,</span>
                                  <span class="n">npoints</span><span class="o">=</span><span class="n">npoints</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cache_deviate</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">dev</span>

        <span class="c1"># Reset the deviate explicitly</span>
        <span class="k">if</span> <span class="n">rng</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="n">dev</span><span class="o">.</span><span class="n">reset</span><span class="p">(</span><span class="n">rng</span><span class="p">)</span>

        <span class="n">ret</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">nphotons</span><span class="p">)</span>
        <span class="n">dev</span><span class="o">.</span><span class="n">generate</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">redshift</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">ret</span> <span class="o">*=</span> <span class="p">(</span><span class="mf">1.</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">redshift</span><span class="p">)</span>
            <span class="c1"># Rarely, with the redshift round trip, this can produce wavelengths &lt; blue_limit.</span>
            <span class="c1"># If this happens, set those values equal to blue_limit.</span>
            <span class="c1"># I&#39;m not sure if the red limit overrun can happen (we didn&#39;t see any in the use case</span>
            <span class="c1"># that noticed the blue overruns), but it seems prudent to also correct any of these</span>
            <span class="c1"># that may occur too.  Plus it&#39;s not noticeably slower using clip to do both at once.</span>
            <span class="k">if</span> <span class="n">bandpass</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span> <span class="n">bandpass</span><span class="o">.</span><span class="n">blue_limit</span><span class="p">,</span> <span class="n">bandpass</span><span class="o">.</span><span class="n">red_limit</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">ret</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">ret</span></div>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span> <span class="ow">is</span> <span class="n">other</span> <span class="ow">or</span>
                <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">SED</span><span class="p">)</span> <span class="ow">and</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">_orig_spec</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_orig_spec</span> <span class="ow">and</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">fast</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">fast</span> <span class="ow">and</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">wave_type</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">wave_type</span> <span class="ow">and</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">flux_type</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">flux_type</span> <span class="ow">and</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">redshift</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">redshift</span> <span class="ow">and</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">red_limit</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">red_limit</span> <span class="ow">and</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">blue_limit</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">blue_limit</span> <span class="ow">and</span>
                 <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wave_list</span><span class="p">,</span><span class="n">other</span><span class="o">.</span><span class="n">wave_list</span><span class="p">)))</span>

    <span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span> <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__eq__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Cache this in case self._orig_spec or self.wave_list is long.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_hash&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_hash</span> <span class="o">=</span> <span class="nb">hash</span><span class="p">((</span><span class="s2">&quot;galsim.SED&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_orig_spec</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">wave_type</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">flux_type</span><span class="p">,</span>
                               <span class="bp">self</span><span class="o">.</span><span class="n">redshift</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fast</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">blue_limit</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">red_limit</span><span class="p">,</span>
                               <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wave_list</span><span class="p">)))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hash</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">outstr</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;galsim.SED(</span><span class="si">%r</span><span class="s1">, wave_type=</span><span class="si">%r</span><span class="s1">, flux_type=</span><span class="si">%r</span><span class="s1">, redshift=</span><span class="si">%r</span><span class="s1">, fast=</span><span class="si">%r</span><span class="s1">,&#39;</span>
                  <span class="s1">&#39; _wave_list=</span><span class="si">%r</span><span class="s1">, _blue_limit=</span><span class="si">%r</span><span class="s1">, _red_limit=</span><span class="si">%s</span><span class="s1">)&#39;</span><span class="p">)</span><span class="o">%</span><span class="p">(</span>
                      <span class="bp">self</span><span class="o">.</span><span class="n">_orig_spec</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">wave_type</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flux_type</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">redshift</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fast</span><span class="p">,</span>
                      <span class="bp">self</span><span class="o">.</span><span class="n">wave_list</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">blue_limit</span><span class="p">,</span>
                      <span class="s2">&quot;float(&#39;inf&#39;)&quot;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">red_limit</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span> <span class="k">else</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">red_limit</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">outstr</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">orig_spec</span> <span class="o">=</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_orig_spec</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">orig_spec</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">80</span><span class="p">:</span>
            <span class="n">orig_spec</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_orig_spec</span><span class="p">)</span>
        <span class="k">return</span> <span class="s1">&#39;galsim.SED(</span><span class="si">%s</span><span class="s1">, redshift=</span><span class="si">%s</span><span class="s1">)&#39;</span><span class="o">%</span><span class="p">(</span><span class="n">orig_spec</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">redshift</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="s1">&#39;_spec&#39;</span><span class="p">],</span> <span class="n">LookupTable</span><span class="p">):</span>
            <span class="k">del</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;_spec&#39;</span><span class="p">]</span>
        <span class="n">d</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;_fast_spec&#39;</span><span class="p">,</span><span class="kc">None</span><span class="p">)</span>
        <span class="k">del</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;_call&#39;</span><span class="p">]</span>
        <span class="k">del</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;_get_native_waves&#39;</span><span class="p">]</span>
        <span class="k">del</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;_get_rest_native_waves&#39;</span><span class="p">]</span>
        <span class="k">del</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;_flux_to_photons&#39;</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">d</span>

    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span> <span class="o">=</span> <span class="n">d</span>
        <span class="k">if</span> <span class="s1">&#39;_spec&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">d</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_spec</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_setup_funcs</span><span class="p">()</span></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2019, GalSim-developers.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>