<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>galsim.lensing_ps &mdash; GalSim 2.7.2 documentation</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/sphinx_highlight.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            GalSim
          </a>
              <div class="version">
                2.7
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../overview.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../install.html">Installation Instructions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tutorials.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../image.html">Images and Related Concepts</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../sb.html">Surface Brightness Profiles</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../chromatic.html">Wavelength-dependent Profiles</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../units.html">Units</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../wcs.html">World Coordinate Systems</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../random.html">Noise and Random Values</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../wl.html">Weak Lensing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../photon.html">Photon Shooting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../utilities.html">Helper Functions and Classes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../errors.html">Errors and Warnings</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../config.html">The Config Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../hsm.html">The HSM Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../des.html">The DES Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../roman.html">The Roman Space Telescope Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../cpp.html">C++ Layer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../shared.html">Shared Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../history.html">Revision History</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">GalSim</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">galsim.lensing_ps</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for galsim.lensing_ps</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright (c) 2012-2023 by the GalSim developers team on GitHub</span>
<span class="c1"># https://github.com/GalSim-developers</span>
<span class="c1">#</span>
<span class="c1"># This file is part of GalSim: The modular galaxy image simulation toolkit.</span>
<span class="c1"># https://github.com/GalSim-developers/GalSim</span>
<span class="c1">#</span>
<span class="c1"># GalSim is free software: redistribution and use in source and binary forms,</span>
<span class="c1"># with or without modification, are permitted provided that the following</span>
<span class="c1"># conditions are met:</span>
<span class="c1">#</span>
<span class="c1"># 1. Redistributions of source code must retain the above copyright notice, this</span>
<span class="c1">#    list of conditions, and the disclaimer given in the accompanying LICENSE</span>
<span class="c1">#    file.</span>
<span class="c1"># 2. Redistributions in binary form must reproduce the above copyright notice,</span>
<span class="c1">#    this list of conditions, and the disclaimer given in the documentation</span>
<span class="c1">#    and/or other materials provided with the distribution.</span>
<span class="c1">#</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span> <span class="s1">&#39;PowerSpectrum&#39;</span> <span class="p">]</span>

<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">.angle</span> <span class="kn">import</span> <span class="n">arcsec</span><span class="p">,</span> <span class="n">AngleUnit</span>
<span class="kn">from</span> <span class="nn">.position</span> <span class="kn">import</span> <span class="n">PositionD</span><span class="p">,</span> <span class="n">PositionI</span>
<span class="kn">from</span> <span class="nn">.bounds</span> <span class="kn">import</span> <span class="n">BoundsD</span><span class="p">,</span> <span class="n">BoundsI</span>
<span class="kn">from</span> <span class="nn">.interpolant</span> <span class="kn">import</span> <span class="n">Quintic</span><span class="p">,</span> <span class="n">Lanczos</span>
<span class="kn">from</span> <span class="nn">.image</span> <span class="kn">import</span> <span class="n">Image</span><span class="p">,</span> <span class="n">ImageD</span>
<span class="kn">from</span> <span class="nn">.random</span> <span class="kn">import</span> <span class="n">GaussianDeviate</span>
<span class="kn">from</span> <span class="nn">.table</span> <span class="kn">import</span> <span class="n">LookupTable</span><span class="p">,</span> <span class="n">LookupTable2D</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">utilities</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">integ</span>
<span class="kn">from</span> <span class="nn">.errors</span> <span class="kn">import</span> <span class="n">GalSimError</span><span class="p">,</span> <span class="n">GalSimValueError</span><span class="p">,</span> <span class="n">GalSimIncompatibleValuesError</span>
<span class="kn">from</span> <span class="nn">.errors</span> <span class="kn">import</span> <span class="n">GalSimNotImplementedError</span><span class="p">,</span> <span class="n">galsim_warn</span>
<span class="kn">from</span> <span class="nn">.bessel</span> <span class="kn">import</span> <span class="n">j0</span><span class="p">,</span> <span class="n">jn</span>

<div class="viewcode-block" id="theoryToObserved"><a class="viewcode-back" href="../../powerspectrum.html#galsim.theoryToObserved">[docs]</a><span class="k">def</span> <span class="nf">theoryToObserved</span><span class="p">(</span><span class="n">gamma1</span><span class="p">,</span> <span class="n">gamma2</span><span class="p">,</span> <span class="n">kappa</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Helper function to convert theoretical lensing quantities to observed ones.</span>

<span class="sd">    This helper function is used internally by the methods `PowerSpectrum.getShear`,</span>
<span class="sd">    `PowerSpectrum.getMagnification`, and `PowerSpectrum.getLensing` to convert from theoretical</span>
<span class="sd">    quantities (shear and convergence) to observable ones (reduced shear and magnification).</span>
<span class="sd">    Users of `PowerSpectrum.buildGrid` outputs can also apply this method directly to the outputs</span>
<span class="sd">    in order to get the values of reduced shear and magnification on the output grid.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        gamma1:     The first shear component, which must be the NON-reduced shear.  This and</span>
<span class="sd">                    all other inputs may be supplied either as individual floating point</span>
<span class="sd">                    numbers or lists/arrays of floats.</span>
<span class="sd">        gamma2:     The second (x) shear component, which must be the NON-reduced shear.</span>
<span class="sd">        kappa:      The convergence.</span>

<span class="sd">    Returns:</span>
<span class="sd">        the reduced shear and magnification as a tuple (g1, g2, mu)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">gamma1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">gamma1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">gamma2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">gamma2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">kappa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">kappa</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

    <span class="n">g1</span> <span class="o">=</span> <span class="n">gamma1</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">-</span><span class="n">kappa</span><span class="p">)</span>
    <span class="n">g2</span> <span class="o">=</span> <span class="n">gamma2</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">-</span><span class="n">kappa</span><span class="p">)</span>
    <span class="n">mu</span> <span class="o">=</span> <span class="mf">1.</span><span class="o">/</span><span class="p">((</span><span class="mf">1.</span><span class="o">-</span><span class="n">kappa</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="p">(</span><span class="n">gamma1</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">gamma2</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">g1</span><span class="p">,</span> <span class="n">g2</span><span class="p">,</span> <span class="n">mu</span></div>

<div class="viewcode-block" id="PowerSpectrum"><a class="viewcode-back" href="../../powerspectrum.html#galsim.PowerSpectrum">[docs]</a><span class="k">class</span> <span class="nc">PowerSpectrum</span><span class="p">:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Class to represent a lensing shear field according to some power spectrum :math:`P(k)`.</span>

<span class="sd">    **General considerations**:</span>

<span class="sd">    A PowerSpectrum represents some (flat-sky) shear power spectrum, either for gridded points or at</span>
<span class="sd">    arbitary positions.  This class is originally initialized with a power spectrum from which we</span>
<span class="sd">    would like to generate g1 and g2 (and, optionally, convergence kappa) values.  It generates</span>
<span class="sd">    shears on a grid, and if necessary, when `getShear` (or another &quot;get&quot; method) is called, it</span>
<span class="sd">    will interpolate to the requested positions.  For detail on how these processes are carried</span>
<span class="sd">    out, please see the document in the GalSim repository, ``devel/modules/lensing_engine.pdf``.</span>

<span class="sd">    This class generates the shears according to the input power spectrum using a DFT approach,</span>
<span class="sd">    which means that we implicitly assume our discrete representation of :math:`P(k)` on a grid is</span>
<span class="sd">    one complete cell in an infinite periodic series.  We are making assumptions about what</span>
<span class="sd">    :math:`P(k)` is doing outside of our minimum and maximum k range, and those must be kept in</span>
<span class="sd">    mind when comparing with theoretical expectations.  Specifically, since the power spectrum is</span>
<span class="sd">    realized on only a finite grid it has been been effectively bandpass filtered between a</span>
<span class="sd">    minimum and maximum k value in each of the k1, k2 directions.  See the `buildGrid` method for</span>
<span class="sd">    more information.</span>

<span class="sd">    As a result, the shear generation currently does not include sample variance due to coverage of</span>
<span class="sd">    a finite patch.  We explicitly enforce :math:`P(0)=0`, which is true for the full sky in a</span>
<span class="sd">    reasonable cosmological model, but it ignores the fact that our little patch of sky might</span>
<span class="sd">    reasonably live in some special region with respect to shear correlations.  Our :math:`P(0)=0`</span>
<span class="sd">    is essentially setting the integrated power below our minimum k value to zero.  The</span>
<span class="sd">    implications of the discrete representation, and the :math:`P(0)=0` choice, are discussed in</span>
<span class="sd">    more detail in ``devel/modules/lensing_engine.pdf``.</span>

<span class="sd">    The effective shear correlation function for the gridded points will be modified both because of</span>
<span class="sd">    the DFT approach to representing shears according to a power spectrum, and because of the power</span>
<span class="sd">    cutoff below and above the minimum k values.  The latter effect can be particularly important on</span>
<span class="sd">    large scales, so the `buildGrid` method has some keywords that can be used to reduce the</span>
<span class="sd">    impact of the minimum k set by the grid extent.  The calculateXi() method can be used to</span>
<span class="sd">    calculate the expected shear correlation functions given the minimum and maximum k for some grid</span>
<span class="sd">    (but ignoring the discrete vs. continuous Fourier transform effects), for comparison with some</span>
<span class="sd">    ideal theoretical correlation function given an infinite k range.</span>

<span class="sd">    When interpolating the shears to non-gridded points, the shear correlation function and power</span>
<span class="sd">    spectrum are modified; see the `getShear` and other &quot;get&quot; method docstrings for more details.</span>

<span class="sd">    **The power spectra to be used**:</span>

<span class="sd">    When creating a PowerSpectrum instance, you must specify at least one of the E or B mode power</span>
<span class="sd">    spectra, which is normally given as a function :math:`P(k)`.  The typical thing is to just use a lambda</span>
<span class="sd">    function in Python (i.e., a function that is not associated with a name); for example, to define</span>
<span class="sd">    :math:`P(k)=k^2`, one would use ``lambda k : k**2``.  But the power spectra can also be more complicated</span>
<span class="sd">    user-defined functions that take a single argument ``k`` and return the power at that ``k``</span>
<span class="sd">    value, or they can be instances of the `LookupTable` class for power spectra that are known at</span>
<span class="sd">    particular ``k`` values but for which there is not a simple analytic form.</span>

<span class="sd">    Cosmologists often express the power spectra in terms of an expansion in spherical harmonics</span>
<span class="sd">    (ell), i.e., the :math:`C_\ell` values.  In the flat-sky limit, we can replace :math:`\ell`</span>
<span class="sd">    with :math:`k` and :math:`C_\ell` with :math:`P(k)`.  Thus, :math:`k` and :math:`P(k)` have</span>
<span class="sd">    dimensions of inverse angle and angle^2, respectively.  It is quite common for people to plot</span>
<span class="sd">    :math:`\ell(\ell+1) C_\ell/2\pi`, a dimensionless quantity; the analogous flat-sky</span>
<span class="sd">    quantity is :math:`\Delta^2 = k^2 P(k)/2\pi`.</span>

<span class="sd">    By default, the PowerSpectrum object assumes it is getting :math:`P(k)`, but it is possible to</span>
<span class="sd">    instead give it :math:`\Delta^2` by setting the optional keyword ``delta2 = True`` in the</span>
<span class="sd">    constructor.</span>

<span class="sd">    The power functions must return a list/array that is the same size as what they are given, e.g.,</span>
<span class="sd">    in the case of no power or constant power, a function that just returns a float would not be</span>
<span class="sd">    permitted; it would have to return an array of floats all with the same value.</span>

<span class="sd">    It is important to note that the power spectra used to initialize the PowerSpectrum object</span>
<span class="sd">    should use the same units for k and :math:`P(k)`, i.e., if k is in inverse radians then</span>
<span class="sd">    :math:`P(k)` should be in radians^2 (as is natural for outputs from a cosmological shear power</span>
<span class="sd">    spectrum calculator).  However, when we actually draw images, there is a natural scale that</span>
<span class="sd">    defines the pitch of the image, which is typically taken to be arcsec.  This definition of a</span>
<span class="sd">    specific length scale means that by default we assume all quantities to the PowerSpectrum are</span>
<span class="sd">    in arcsec, and those are the units used for internal calculations, but the ``units`` keyword</span>
<span class="sd">    can be used to specify different input units for :math:`P(k)` (again, within the constraint</span>
<span class="sd">    that k and :math:`P(k)` must be consistent).  If the ``delta2`` keyword is set to specify that</span>
<span class="sd">    the input is actually the dimensionless power :math:`\Delta^2`, then the input ``units`` are</span>
<span class="sd">    taken to apply only to the k values.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        e_power_function:   A function or other callable that accepts a NumPy array of abs(k)</span>
<span class="sd">                            values, and returns the E-mode power spectrum P_E(abs(k)) in an array of</span>
<span class="sd">                            the same shape.  The function should return the power spectrum desired</span>
<span class="sd">                            in the E (gradient) mode of the image.</span>
<span class="sd">                            It may also be a string that can be converted to a function using</span>
<span class="sd">                            ``eval(&#39;lambda k : &#39;+e_power_function)``, a `LookupTable`, or</span>
<span class="sd">                            ``file_name`` from which to read in a `LookupTable`.  If a ``file_name``</span>
<span class="sd">                            is given, the resulting `LookupTable` uses the defaults for the</span>
<span class="sd">                            `LookupTable` class, namely spline interpolation in :math:`P(k)`.</span>
<span class="sd">                            Users who wish to deviate from those defaults (for example, to</span>
<span class="sd">                            interpolate in log(P) and log(k), as might be more natural for</span>
<span class="sd">                            power-law functions) should instead read in the file to create a</span>
<span class="sd">                            `LookupTable` using the necessary non-default settings. [default: None,</span>
<span class="sd">                            which means no E-mode power.]</span>
<span class="sd">        b_power_function:   A function or other callable that accepts a NumPy array of abs(k)</span>
<span class="sd">                            values, and returns the B-mode power spectrum P_B(abs(k)) in an array of</span>
<span class="sd">                            the same shape.  The function should return the power spectrum desired</span>
<span class="sd">                            in the B (curl) mode of the image.  See description of</span>
<span class="sd">                            ``e_power_function`` for input format options.  [default: None, which</span>
<span class="sd">                            means no B-mode power.]</span>
<span class="sd">        delta2:             Is the power actually given as dimensionless :math:`\Delta^2`, which</span>
<span class="sd">                            requires us to multiply by :math:`2\pi / k^2` to get the shear power</span>
<span class="sd">                            :math:`P(k)` in units of angle^2?  [default: False]</span>
<span class="sd">        units:              The angular units used for the power spectrum (i.e. the units of</span>
<span class="sd">                            k^-1 and sqrt(P)). This should be either an `AngleUnit` instance</span>
<span class="sd">                            (e.g. galsim.radians) or a string (e.g. &#39;radians&#39;). [default: arcsec]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_opt_params</span> <span class="o">=</span> <span class="p">{</span> <span class="s1">&#39;e_power_function&#39;</span> <span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="s1">&#39;b_power_function&#39;</span> <span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
                    <span class="s1">&#39;delta2&#39;</span> <span class="p">:</span> <span class="nb">bool</span><span class="p">,</span> <span class="s1">&#39;units&#39;</span> <span class="p">:</span> <span class="nb">str</span> <span class="p">}</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">e_power_function</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">b_power_function</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">delta2</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">units</span><span class="o">=</span><span class="n">arcsec</span><span class="p">):</span>
        <span class="c1"># Check that at least one power function is not None</span>
        <span class="k">if</span> <span class="n">e_power_function</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">b_power_function</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">GalSimIncompatibleValuesError</span><span class="p">(</span>
                <span class="s2">&quot;At least one of e_power_function or b_power_function must be provided.&quot;</span><span class="p">,</span>
                <span class="n">e_power_function</span><span class="o">=</span><span class="n">e_power_function</span><span class="p">,</span> <span class="n">b_power_function</span><span class="o">=</span><span class="n">b_power_function</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">e_power_function</span> <span class="o">=</span> <span class="n">e_power_function</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">b_power_function</span> <span class="o">=</span> <span class="n">b_power_function</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">delta2</span> <span class="o">=</span> <span class="n">delta2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">units</span> <span class="o">=</span> <span class="n">units</span>

        <span class="c1"># Try these conversions, but we don&#39;t actually keep the output.  This just</span>
        <span class="c1"># provides a way to test if the arguments are sane.</span>
        <span class="c1"># Note: we redo this in buildGrid for real rather than keeping the outputs</span>
        <span class="c1"># (e.g. in self.e_power_function, self.b_power_function) so that PowerSpectrum is</span>
        <span class="c1"># picklable.  It turns out lambda functions are not picklable.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_convert_power_function</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">e_power_function</span><span class="p">,</span><span class="s1">&#39;e_power_function&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_convert_power_function</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">b_power_function</span><span class="p">,</span><span class="s1">&#39;b_power_function&#39;</span><span class="p">)</span>

        <span class="c1"># Check validity of units</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">units</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="c1"># if the string is invalid, this raises a reasonable error message.</span>
            <span class="n">units</span> <span class="o">=</span> <span class="n">AngleUnit</span><span class="o">.</span><span class="n">from_name</span><span class="p">(</span><span class="n">units</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">units</span><span class="p">,</span> <span class="n">AngleUnit</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">GalSimValueError</span><span class="p">(</span><span class="s2">&quot;units must be either an AngleUnit or a string&quot;</span><span class="p">,</span> <span class="n">units</span><span class="p">,</span>
                                   <span class="p">(</span><span class="s1">&#39;arcsec&#39;</span><span class="p">,</span> <span class="s1">&#39;arcmin&#39;</span><span class="p">,</span> <span class="s1">&#39;degree&#39;</span><span class="p">,</span> <span class="s1">&#39;hour&#39;</span><span class="p">,</span> <span class="s1">&#39;radian&#39;</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">units</span> <span class="o">==</span> <span class="n">arcsec</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">scale</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">scale</span> <span class="o">=</span> <span class="n">units</span> <span class="o">/</span> <span class="n">arcsec</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">s</span> <span class="o">=</span> <span class="s1">&#39;galsim.PowerSpectrum(e_power_function=</span><span class="si">%r</span><span class="s1">&#39;</span><span class="o">%</span><span class="bp">self</span><span class="o">.</span><span class="n">e_power_function</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">b_power_function</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="s1">&#39;, b_power_function=</span><span class="si">%r</span><span class="s1">&#39;</span><span class="o">%</span><span class="bp">self</span><span class="o">.</span><span class="n">b_power_function</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta2</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="s1">&#39;, delta2=</span><span class="si">%r</span><span class="s1">&#39;</span><span class="o">%</span><span class="bp">self</span><span class="o">.</span><span class="n">delta2</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">units</span> <span class="o">!=</span> <span class="n">arcsec</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="s1">&#39;, units=</span><span class="si">%r</span><span class="s1">&#39;</span><span class="o">%</span><span class="bp">self</span><span class="o">.</span><span class="n">units</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="s1">&#39;)&#39;</span>
        <span class="k">return</span> <span class="n">s</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">s</span> <span class="o">=</span> <span class="s1">&#39;galsim.PowerSpectrum(e_power_function=</span><span class="si">%s</span><span class="s1">&#39;</span><span class="o">%</span><span class="bp">self</span><span class="o">.</span><span class="n">e_power_function</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">b_power_function</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="s1">&#39;, b_power_function=</span><span class="si">%s</span><span class="s1">&#39;</span><span class="o">%</span><span class="bp">self</span><span class="o">.</span><span class="n">b_power_function</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="s1">&#39;)&#39;</span>
        <span class="k">return</span> <span class="n">s</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span> <span class="ow">is</span> <span class="n">other</span> <span class="ow">or</span>
                <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">PowerSpectrum</span><span class="p">)</span> <span class="ow">and</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">e_power_function</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">e_power_function</span> <span class="ow">and</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">b_power_function</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">b_power_function</span> <span class="ow">and</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">delta2</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">delta2</span> <span class="ow">and</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">scale</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">scale</span><span class="p">))</span>
    <span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span> <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__eq__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="nb">hash</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_get_scale_fac</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">units</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">units</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="c1"># if the string is invalid, this raises a reasonable error message.</span>
            <span class="n">units</span> <span class="o">=</span> <span class="n">AngleUnit</span><span class="o">.</span><span class="n">from_name</span><span class="p">(</span><span class="n">units</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">units</span><span class="p">,</span> <span class="n">AngleUnit</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">GalSimValueError</span><span class="p">(</span><span class="s2">&quot;units must be either an AngleUnit or a string&quot;</span><span class="p">,</span> <span class="n">units</span><span class="p">,</span>
                                   <span class="p">(</span><span class="s1">&#39;arcsec&#39;</span><span class="p">,</span> <span class="s1">&#39;arcmin&#39;</span><span class="p">,</span> <span class="s1">&#39;degree&#39;</span><span class="p">,</span> <span class="s1">&#39;hour&#39;</span><span class="p">,</span> <span class="s1">&#39;radian&#39;</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">units</span> <span class="o">/</span> <span class="n">arcsec</span>

    <span class="k">def</span> <span class="nf">_get_bandlimit_func</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bandlimit</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">bandlimit</span> <span class="o">==</span> <span class="s1">&#39;hard&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hard_cutoff</span>
        <span class="k">elif</span> <span class="n">bandlimit</span> <span class="o">==</span> <span class="s1">&#39;soft&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_softening_function</span>
        <span class="k">elif</span> <span class="n">bandlimit</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="k">lambda</span> <span class="n">k</span><span class="p">,</span> <span class="n">kmax</span><span class="p">:</span> <span class="mf">1.0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">GalSimValueError</span><span class="p">(</span><span class="s2">&quot;Unrecognized option for band limit!&quot;</span><span class="p">,</span> <span class="n">bandlimit</span><span class="p">,</span>
                                   <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;soft&#39;</span><span class="p">,</span> <span class="s1">&#39;hard&#39;</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_get_pk</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">power_function</span><span class="p">,</span> <span class="n">k_max</span><span class="p">,</span> <span class="n">bandlimit_func</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">power_function</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta2</span><span class="p">:</span>
            <span class="c1"># Here we have to go from Delta^2 (dimensionless) to P = 2pi Delta^2 / k^2.  We want to</span>
            <span class="c1"># have P and therefore 1/k^2 in units of arcsec, so we won&#39;t rescale the k that goes in</span>
            <span class="c1"># the denominator.  This naturally gives P(k) in arcsec^2.</span>
            <span class="k">return</span> <span class="k">lambda</span> <span class="n">k</span> <span class="p">:</span> <span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">*</span> <span class="n">power_function</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="o">*</span><span class="n">k</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">k</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> \
                <span class="n">bandlimit_func</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="o">*</span><span class="n">k</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="o">*</span><span class="n">k_max</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># Here, the scale comes in two places:</span>
            <span class="c1"># The units of k have to be converted from 1/arcsec, which GalSim wants to use, into</span>
            <span class="c1"># whatever the power spectrum function was defined to use.</span>
            <span class="c1"># The units of power have to be converted from (input units)^2 as returned by the power</span>
            <span class="c1"># function, to Galsim&#39;s units of arcsec^2.</span>
            <span class="c1"># Recall that scale is (input units)/arcsec.</span>
            <span class="k">return</span> <span class="k">lambda</span> <span class="n">k</span> <span class="p">:</span> <span class="n">power_function</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="o">*</span><span class="n">k</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> \
                <span class="n">bandlimit_func</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="o">*</span><span class="n">k</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="o">*</span><span class="n">k_max</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="k">lambda</span> <span class="n">k</span> <span class="p">:</span> <span class="n">power_function</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="o">*</span> <span class="n">bandlimit_func</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">k_max</span><span class="p">)</span>

<div class="viewcode-block" id="PowerSpectrum.buildGrid"><a class="viewcode-back" href="../../powerspectrum.html#galsim.PowerSpectrum.buildGrid">[docs]</a>    <span class="k">def</span> <span class="nf">buildGrid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grid_spacing</span><span class="p">,</span> <span class="n">ngrid</span><span class="p">,</span> <span class="n">rng</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">interpolant</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                  <span class="n">center</span><span class="o">=</span><span class="n">PositionD</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="n">units</span><span class="o">=</span><span class="n">arcsec</span><span class="p">,</span> <span class="n">get_convergence</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                  <span class="n">kmax_factor</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">kmin_factor</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">bandlimit</span><span class="o">=</span><span class="s2">&quot;hard&quot;</span><span class="p">,</span> <span class="n">variance</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate a realization of the current power spectrum on the specified grid.</span>

<span class="sd">        **Basic functionality**:</span>

<span class="sd">        This function will generate a Gaussian random realization of the specified E and B mode</span>
<span class="sd">        shear power spectra at a grid of positions, specified by the input parameters</span>
<span class="sd">        ``grid_spacing`` (distance between grid points) and ``ngrid`` (number of grid points in</span>
<span class="sd">        each direction.)  Units for ``grid_spacing`` and ``center`` can be specified using the</span>
<span class="sd">        ``units`` keyword; the default is arcsec, which is how all values are stored internally.</span>
<span class="sd">        It automatically computes and stores grids for the shears and convergence.  However, since</span>
<span class="sd">        many users are primarily concerned with shape distortion due to shear, the default is to</span>
<span class="sd">        return only the shear components; the ``get_convergence`` keyword can be used to also</span>
<span class="sd">        return the convergence.</span>

<span class="sd">        The quantities that are returned are the theoretical shears and convergences, usually</span>
<span class="sd">        denoted gamma and kappa, respectively.  Users who wish to obtain the more</span>
<span class="sd">        observationally-relevant reduced shear and magnification (that describe real lensing</span>
<span class="sd">        distortions) can either use the `getShear`, `getMagnification`, or `getLensing` methods</span>
<span class="sd">        after `buildGrid`, or can use the convenience function `galsim.lensing_ps.theoryToObserved`</span>
<span class="sd">        to convert from theoretical to observed quantities.</span>

<span class="sd">        **Caveats of the DFT approach**:</span>

<span class="sd">        Note that the shears generated using this method correspond to the PowerSpectrum multiplied</span>
<span class="sd">        by a sharp bandpass filter, set by the dimensions of the grid.</span>

<span class="sd">        The filter sets :math:`P(k) = 0` for::</span>

<span class="sd">            abs(k1), abs(k2) &lt; kmin / 2</span>

<span class="sd">        and::</span>

<span class="sd">            abs(k1), abs(k2) &gt; kmax + kmin / 2</span>

<span class="sd">        where::</span>

<span class="sd">            kmin = 2. * pi / (ngrid * grid_spacing)</span>
<span class="sd">            kmax = pi / grid_spacing</span>

<span class="sd">        and where we have adopted the convention that grid points at a given ``k`` represent the</span>
<span class="sd">        interval between (k - dk/2) and (k + dk/2) (noting that the grid spacing dk in k space</span>
<span class="sd">        is equivalent to ``kmin``).</span>

<span class="sd">        It is worth remembering that this bandpass filter will *not* look like a circular annulus</span>
<span class="sd">        in 2D ``k`` space, but is rather more like a thick-sided picture frame, having a small</span>
<span class="sd">        square central cutout of dimensions ``kmin`` by ``kmin``.  These properties are visible in</span>
<span class="sd">        the shears generated by this method.</span>

<span class="sd">        If you care about these effects and want to ameliorate their effect, there are two</span>
<span class="sd">        optional kwargs you can provide: ``kmin_factor`` and ``kmax_factor``, both of which are 1</span>
<span class="sd">        by default.  These should be integers &gt;= 1 that specify some factor smaller or larger</span>
<span class="sd">        (for kmin and kmax respectively) you want the code to use for the underlying grid in</span>
<span class="sd">        fourier space.  The final shear grid is returned using the specified ``ngrid`` and</span>
<span class="sd">        ``grid_spacing`` parameters.  But the intermediate grid in Fourier space will be larger</span>
<span class="sd">        by the specified factors.</span>

<span class="sd">        Note: These are really just for convenience, since you could easily get the same effect</span>
<span class="sd">        by providing different values of ngrid and grid_spacing and then take a subset of them.</span>
<span class="sd">        The ``kmin_factor`` and ``kmax_factor`` just handle the scalings appropriately for you.</span>

<span class="sd">        Use of ``kmin_factor`` and ``kmax_factor`` should depend on the desired application.  For</span>
<span class="sd">        accurate representation of power spectra, one should not change these values from their</span>
<span class="sd">        defaults of 1.  Changing them from one means the E- and B-mode power spectra that are input</span>
<span class="sd">        will be valid for the larger intermediate grids that get generated in Fourier space, but not</span>
<span class="sd">        necessarily for the smaller ones that get returned to the user.  However, for accurate</span>
<span class="sd">        representation of cosmological shear correlation functions, use of ``kmin_factor`` larger</span>
<span class="sd">        than one can be helpful in getting the shear correlations closer to the ideal theoretical</span>
<span class="sd">        ones (see ``devel/module/lensing_engine.pdf`` for details).</span>

<span class="sd">        **Aliasing**:</span>

<span class="sd">        If the user provides a power spectrum that does not include a cutoff at kmax, then our</span>
<span class="sd">        method of generating shears will result in aliasing that will show up in both E- and</span>
<span class="sd">        B-modes.  Thus the `buildGrid` method accepts an optional keyword argument called</span>
<span class="sd">        ``bandlimit`` that can tell the PowerSpectrum object to cut off power above kmax</span>
<span class="sd">        automatically, where the relevant kmax is larger than the grid Nyquist frequency by a factor</span>
<span class="sd">        of ``kmax_factor``.  The allowed values for ``bandlimit`` are None (i.e., do nothing),</span>
<span class="sd">        ``hard`` (set power to zero above the band limit), or ``soft`` (use an arctan-based</span>
<span class="sd">        softening function to make the power go gradually to zero above the band limit).  By</span>
<span class="sd">        default, ``bandlimit=hard``.  Use of this keyword does nothing to the internal</span>
<span class="sd">        representation of the power spectrum, so if the user calls the `buildGrid` method again,</span>
<span class="sd">        they will need to set ``bandlimit`` again (and if their grid setup is different in a way</span>
<span class="sd">        that changes ``kmax``, then that&#39;s fine).</span>

<span class="sd">        **Interpolation**:</span>

<span class="sd">        If the grid is being created for the purpose of later interpolating to random positions, the</span>
<span class="sd">        following findings should be kept in mind: since the interpolant modifies the effective</span>
<span class="sd">        shear correlation function on scales comparable to &lt;~3x the grid spacing, the grid spacing</span>
<span class="sd">        should be chosen to be at least 3 times smaller than the minimum scales on which the user</span>
<span class="sd">        wishes to reproduce the shear correlation function accurately.  Ideally, the grid should be</span>
<span class="sd">        somewhat larger than the region in which shears at random points are needed, so that edge</span>
<span class="sd">        effects in the interpolation will not be important.  For this purpose, there should be &gt;~5</span>
<span class="sd">        grid points outside of the region in which interpolation will take place.  Ignoring this</span>
<span class="sd">        edge effect and using the grid for interpolation out to its edges can suppress shear</span>
<span class="sd">        correlations on all scales by an amount that depends on the grid size; for a 100x100 grid,</span>
<span class="sd">        the suppression is ~2-3%.  Note that the above numbers came from tests that use a</span>
<span class="sd">        cosmological shear power spectrum; precise figures for this suppression can also depend on</span>
<span class="sd">        the shear correlation function itself.</span>

<span class="sd">        **Sign conventions and other info**:</span>

<span class="sd">        Note also that the convention for axis orientation differs from that for the GREAT10</span>
<span class="sd">        challenge, so when using codes that deal with GREAT10 challenge outputs, the sign of our g2</span>
<span class="sd">        shear component must be flipped.</span>

<span class="sd">        For more information on the effects of finite grid representation of the power spectrum</span>
<span class="sd">        see ``devel/modules/lensing_engine.pdf``.</span>

<span class="sd">        **Examples**:</span>

<span class="sd">        1. Get shears on a grid of points separated by 1 arcsec::</span>

<span class="sd">                &gt;&gt;&gt; my_ps = galsim.PowerSpectrum(lambda k : k**2)</span>
<span class="sd">                &gt;&gt;&gt; g1, g2 = my_ps.buildGrid(grid_spacing = 1., ngrid = 100)</span>

<span class="sd">           The returned g1, g2 are 2-d NumPy arrays of values, corresponding to the values of</span>
<span class="sd">           g1 and g2 at the locations of the grid points.</span>

<span class="sd">           For a given value of ``grid_spacing`` and ``ngrid``, we could get the x and y values on</span>
<span class="sd">           the grid using::</span>

<span class="sd">                &gt;&gt;&gt; import numpy as np</span>
<span class="sd">                &gt;&gt;&gt; min = (-ngrid/2 + 0.5) * grid_spacing</span>
<span class="sd">                &gt;&gt;&gt; max = (ngrid/2 - 0.5) * grid_spacing</span>
<span class="sd">                &gt;&gt;&gt; x, y = np.meshgrid(np.arange(min,max+grid_spacing,grid_spacing),</span>
<span class="sd">                ...                    np.arange(min,max+grid_spacing,grid_spacing))</span>

<span class="sd">           where the center of the grid is taken to be (0,0).</span>

<span class="sd">        2. Rebuild the grid using a particular rng and set the location of the center of the grid</span>
<span class="sd">           to be something other than the default (0,0)::</span>

<span class="sd">                &gt;&gt;&gt; g1, g2 = my_ps.buildGrid(grid_spacing = 8., ngrid = 65,</span>
<span class="sd">                ...                          rng = galsim.BaseDeviate(1413231),</span>
<span class="sd">                ...                          center = galsim.PositionD(256.5, 256.5) )</span>

<span class="sd">        3. Make a `PowerSpectrum` from a tabulated :math:`P(k)` that gets interpolated to find the</span>
<span class="sd">           power at all necessary values of k, then generate shears and convergences on a grid, and</span>
<span class="sd">           convert to reduced shear and magnification so they can be used to transform galaxy</span>
<span class="sd">           images.  E.g., assuming that k and P_k are NumPy arrays containing k and :math:`P(k)`::</span>

<span class="sd">                &gt;&gt;&gt; tab_pk = galsim.LookupTable(k, P_k)</span>
<span class="sd">                &gt;&gt;&gt; my_ps = galsim.PowerSpectrum(tab_pk)</span>
<span class="sd">                &gt;&gt;&gt; g1, g2, kappa = my_ps.buildGrid(grid_spacing = 1., ngrid = 100,</span>
<span class="sd">                ...                                 get_convergence = True)</span>
<span class="sd">                &gt;&gt;&gt; g1_r, g2_r, mu = galsim.lensing_ps.theoryToObserved(g1, g2, kappa)</span>

<span class="sd">        Parameters:</span>
<span class="sd">            grid_spacing:       Spacing for an evenly spaced grid of points, by default in arcsec</span>
<span class="sd">                                for consistency with the natural length scale of images created</span>
<span class="sd">                                using the `GSObject.drawImage` method.  Other units can be</span>
<span class="sd">                                specified using the ``units`` keyword.</span>
<span class="sd">            ngrid:              Number of grid points in each dimension.  [Must be an integer]</span>
<span class="sd">            rng:                A `BaseDeviate` object for drawing the random numbers.</span>
<span class="sd">                                [default: None]</span>
<span class="sd">            interpolant:        `Interpolant` that will be used for interpolating the gridded shears</span>
<span class="sd">                                by methods like `getShear`, `getConvergence`, etc. if they are</span>
<span class="sd">                                later called. [default: galsim.Lanczos(5)]</span>
<span class="sd">            center:             If setting up a new grid, define what position you want to consider</span>
<span class="sd">                                the center of that grid.  Units must be consistent with those for</span>
<span class="sd">                                ``grid_spacing``.  [default: galsim.PositionD(0,0)]</span>
<span class="sd">            units:              The angular units used for the positions.  [default: arcsec]</span>
<span class="sd">            get_convergence:    Return the convergence in addition to the shear?  Regardless of the</span>
<span class="sd">                                value of ``get_convergence``, the convergence will still be computed</span>
<span class="sd">                                and stored for future use. [default: False]</span>
<span class="sd">            kmin_factor:        Factor by which the grid spacing in fourier space is smaller than</span>
<span class="sd">                                the default.  i.e.::</span>

<span class="sd">                                    kmin = 2. * pi / (ngrid * grid_spacing) / kmin_factor</span>

<span class="sd">                                [default: 1; must be an integer]</span>
<span class="sd">            kmax_factor:        Factor by which the overall grid in fourier space is larger than</span>
<span class="sd">                                the default.  i.e.::</span>

<span class="sd">                                    kmax = pi / grid_spacing * kmax_factor</span>

<span class="sd">                                [default: 1; must be an integer]</span>
<span class="sd">            bandlimit:          Keyword determining how to handle power :math:`P(k)` above the</span>
<span class="sd">                                limiting k value, kmax.  The options None, &#39;hard&#39;, and &#39;soft&#39;</span>
<span class="sd">                                correspond to doing nothing (i.e., allow P(&gt;kmax) to be aliased to</span>
<span class="sd">                                lower k values), cutting off all power above kmax, and applying a</span>
<span class="sd">                                softening filter to gradually cut off power above kmax.  Use of</span>
<span class="sd">                                this keyword does not modify the internally-stored power spectrum,</span>
<span class="sd">                                just the shears generated for this particular call to `buildGrid`.</span>
<span class="sd">                                [default: &quot;hard&quot;]</span>
<span class="sd">            variance:           Optionally renormalize the variance of the output shears to a</span>
<span class="sd">                                given value.  This is useful if you know the functional form of</span>
<span class="sd">                                the power spectrum you want, but not the normalization.  This lets</span>
<span class="sd">                                you set the normalization separately.  The resulting shears should</span>
<span class="sd">                                have var(g1) + var(g2) ~= variance.  If only ``e_power_function`` is</span>
<span class="sd">                                given, then this is also the variance of kappa.  Otherwise, the</span>
<span class="sd">                                variance of kappa may be smaller than the specified variance.</span>
<span class="sd">                                [default: None]</span>

<span class="sd">        Returns:</span>
<span class="sd">            the tuple (g1,g2[,kappa]), where each is a 2-d NumPy array and kappa is included</span>
<span class="sd">            iff ``get_convergence`` is set to True.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Check for validity of integer values</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ngrid</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">ngrid</span> <span class="o">!=</span> <span class="nb">int</span><span class="p">(</span><span class="n">ngrid</span><span class="p">):</span>
                <span class="k">raise</span> <span class="n">GalSimValueError</span><span class="p">(</span><span class="s2">&quot;ngrid must be an integer&quot;</span><span class="p">,</span> <span class="n">ngrid</span><span class="p">)</span>
            <span class="n">ngrid</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">ngrid</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">kmin_factor</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">kmin_factor</span> <span class="o">!=</span> <span class="nb">int</span><span class="p">(</span><span class="n">kmin_factor</span><span class="p">):</span>
                <span class="k">raise</span> <span class="n">GalSimValueError</span><span class="p">(</span><span class="s2">&quot;kmin_factor must be an integer&quot;</span><span class="p">,</span> <span class="n">kmin_factor</span><span class="p">)</span>
            <span class="n">kmin_factor</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">kmin_factor</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">kmax_factor</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">kmax_factor</span> <span class="o">!=</span> <span class="nb">int</span><span class="p">(</span><span class="n">kmax_factor</span><span class="p">):</span>
                <span class="k">raise</span> <span class="n">GalSimValueError</span><span class="p">(</span><span class="s2">&quot;kmax_factor must be an integer&quot;</span><span class="p">,</span> <span class="n">kmax_factor</span><span class="p">)</span>
            <span class="n">kmax_factor</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">kmax_factor</span><span class="p">)</span>

        <span class="c1"># Check if center is a PositionD</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">center</span><span class="p">,</span> <span class="n">PositionD</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">GalSimValueError</span><span class="p">(</span><span class="s2">&quot;center argument for buildGrid must be a PositionD instance&quot;</span><span class="p">,</span>
                                   <span class="n">center</span><span class="p">)</span>

        <span class="c1"># Automatically convert units to arcsec at the outset, then forget about it.  This is</span>
        <span class="c1"># because PowerSpectrum by default wants to work in arsec, and all power functions are</span>
        <span class="c1"># automatically converted to do so, so we&#39;ll also do that here.</span>
        <span class="n">scale_fac</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_scale_fac</span><span class="p">(</span><span class="n">units</span><span class="p">)</span>
        <span class="n">center</span> <span class="o">*=</span> <span class="n">scale_fac</span>
        <span class="n">grid_spacing</span> <span class="o">*=</span> <span class="n">scale_fac</span>

        <span class="c1"># The final grid spacing that will be in the computed images is grid_spacing/kmax_factor.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grid_spacing</span> <span class="o">=</span> <span class="n">grid_spacing</span> <span class="o">/</span> <span class="n">kmax_factor</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">center</span> <span class="o">=</span> <span class="n">center</span>

        <span class="c1"># It is also convenient to store the bounds within which an input position is allowed.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span> <span class="o">=</span> <span class="n">BoundsD</span><span class="p">(</span> <span class="n">center</span><span class="o">.</span><span class="n">x</span> <span class="o">-</span> <span class="p">(</span><span class="n">ngrid</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">grid_spacing</span> <span class="o">/</span> <span class="mf">2.</span> <span class="p">,</span>
                               <span class="n">center</span><span class="o">.</span><span class="n">x</span> <span class="o">+</span> <span class="p">(</span><span class="n">ngrid</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">grid_spacing</span> <span class="o">/</span> <span class="mf">2.</span> <span class="p">,</span>
                               <span class="n">center</span><span class="o">.</span><span class="n">y</span> <span class="o">-</span> <span class="p">(</span><span class="n">ngrid</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">grid_spacing</span> <span class="o">/</span> <span class="mf">2.</span> <span class="p">,</span>
                               <span class="n">center</span><span class="o">.</span><span class="n">y</span> <span class="o">+</span> <span class="p">(</span><span class="n">ngrid</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">grid_spacing</span> <span class="o">/</span> <span class="mf">2.</span> <span class="p">)</span>
        <span class="c1"># Expand the bounds slightly to make sure rounding errors don&#39;t lead to points on the</span>
        <span class="c1"># edge being considered off the edge.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span> <span class="mf">1.</span> <span class="o">+</span> <span class="mf">1.e-15</span> <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">x_grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="o">.</span><span class="n">xmin</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="o">.</span><span class="n">xmax</span><span class="p">,</span> <span class="n">ngrid</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y_grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="o">.</span><span class="n">ymin</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="o">.</span><span class="n">ymax</span><span class="p">,</span> <span class="n">ngrid</span><span class="p">)</span>

        <span class="n">gd</span> <span class="o">=</span> <span class="n">GaussianDeviate</span><span class="p">(</span><span class="n">rng</span><span class="p">)</span>

        <span class="c1"># Check that the interpolant is valid.</span>
        <span class="k">if</span> <span class="n">interpolant</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">interpolant</span> <span class="o">=</span> <span class="n">Lanczos</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">interpolant</span> <span class="o">=</span> <span class="n">utilities</span><span class="o">.</span><span class="n">convert_interpolant</span><span class="p">(</span><span class="n">interpolant</span><span class="p">)</span>

        <span class="c1"># Convert power_functions into callables:</span>
        <span class="n">e_power_function</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_convert_power_function</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">e_power_function</span><span class="p">,</span><span class="s1">&#39;e_power_function&#39;</span><span class="p">)</span>
        <span class="n">b_power_function</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_convert_power_function</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">b_power_function</span><span class="p">,</span><span class="s1">&#39;b_power_function&#39;</span><span class="p">)</span>

        <span class="c1"># Figure out how to apply band limit if requested.</span>
        <span class="c1"># Start by calculating kmax in the appropriate units:</span>
        <span class="c1"># Generally, it should be kmax_factor*pi/(input grid spacing).  We have already converted</span>
        <span class="c1"># the user-input grid spacing to arcsec, the units that the PowerSpectrum class uses</span>
        <span class="c1"># internally, and divided it by kmax_factor to get self.grid_spacing, so here we just use</span>
        <span class="c1"># pi/self.grid_spacing.</span>
        <span class="n">k_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_spacing</span>
        <span class="n">bandlimit_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_bandlimit_func</span><span class="p">(</span><span class="n">bandlimit</span><span class="p">)</span>

        <span class="c1"># If we actually have dimensionless Delta^2, then we must convert to power</span>
        <span class="c1"># P(k) = 2pi Delta^2 / k^2,</span>
        <span class="c1"># which has dimensions of angle^2.</span>
        <span class="c1"># Also apply the bandlimit and/or scale as appropriate.</span>
        <span class="n">p_E</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_pk</span><span class="p">(</span><span class="n">e_power_function</span><span class="p">,</span> <span class="n">k_max</span><span class="p">,</span> <span class="n">bandlimit_func</span><span class="p">)</span>
        <span class="n">p_B</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_pk</span><span class="p">(</span><span class="n">b_power_function</span><span class="p">,</span> <span class="n">k_max</span><span class="p">,</span> <span class="n">bandlimit_func</span><span class="p">)</span>

        <span class="c1"># Build the grid</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ngrid_tot</span> <span class="o">=</span> <span class="n">ngrid</span> <span class="o">*</span> <span class="n">kmin_factor</span> <span class="o">*</span> <span class="n">kmax_factor</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pixel_size</span> <span class="o">=</span> <span class="n">grid_spacing</span><span class="o">/</span><span class="n">kmax_factor</span>
        <span class="n">psr</span> <span class="o">=</span> <span class="n">PowerSpectrumRealizer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ngrid_tot</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pixel_size</span><span class="p">,</span> <span class="n">p_E</span><span class="p">,</span> <span class="n">p_B</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grid_g1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_g2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_kappa</span> <span class="o">=</span> <span class="n">psr</span><span class="p">(</span><span class="n">gd</span><span class="p">,</span> <span class="n">variance</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">kmin_factor</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">kmax_factor</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># Need to make sure the rows are contiguous so we can use it in the constructor</span>
            <span class="c1"># of the ImageD objects below.  This requires a copy.</span>
            <span class="n">s</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">ngrid</span><span class="o">*</span><span class="n">kmax_factor</span><span class="p">,</span><span class="n">kmax_factor</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">grid_g1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid_g1</span><span class="p">[</span><span class="n">s</span><span class="p">,</span><span class="n">s</span><span class="p">],</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">grid_g2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid_g2</span><span class="p">[</span><span class="n">s</span><span class="p">,</span><span class="n">s</span><span class="p">],</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">grid_kappa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid_kappa</span><span class="p">[</span><span class="n">s</span><span class="p">,</span><span class="n">s</span><span class="p">],</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>

        <span class="c1"># Set up the images to be interpolated.</span>
        <span class="c1"># Note: We don&#39;t make the LookupTable2D&#39;s yet, since we don&#39;t know if</span>
        <span class="c1">#       the user wants periodic wrapping or not.</span>
        <span class="c1">#       So we wait to create them when we are actually going to use them.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">im_g1</span> <span class="o">=</span> <span class="n">ImageD</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid_g1</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">grid_spacing</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">im_g2</span> <span class="o">=</span> <span class="n">ImageD</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid_g2</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">grid_spacing</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">im_kappa</span> <span class="o">=</span> <span class="n">ImageD</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid_kappa</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">grid_spacing</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">get_convergence</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_g1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_g2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_kappa</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_g1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_g2</span></div>

<div class="viewcode-block" id="PowerSpectrum.nRandCallsForBuildGrid"><a class="viewcode-back" href="../../powerspectrum.html#galsim.PowerSpectrum.nRandCallsForBuildGrid">[docs]</a>    <span class="k">def</span> <span class="nf">nRandCallsForBuildGrid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the number of times the rng() was called the last time `buildGrid` was called.</span>

<span class="sd">        This can be useful for keeping rngs in sync if the connection between them is broken</span>
<span class="sd">        (e.g. when calling the function through a Proxy object).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s1">&#39;ngrid_tot&#39;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">GalSimError</span><span class="p">(</span><span class="s2">&quot;BuildGrid has not been called yet.&quot;</span><span class="p">)</span>
        <span class="n">ntot</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># cf. PowerSpectrumRealizer._generate_power_array</span>
        <span class="n">temp</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ngrid_tot</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ngrid_tot</span><span class="o">//</span><span class="mi">2</span> <span class="o">+</span><span class="mi">1</span> <span class="p">)</span> <span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">e_power_function</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ntot</span> <span class="o">+=</span> <span class="n">temp</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">b_power_function</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ntot</span> <span class="o">+=</span> <span class="n">temp</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">ntot</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_convert_power_function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pf</span><span class="p">,</span> <span class="n">pf_str</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">pf</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="k">return</span> <span class="kc">None</span>

        <span class="c1"># Convert string inputs to either a lambda function or LookupTable</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pf</span><span class="p">,</span><span class="nb">str</span><span class="p">):</span>
            <span class="n">origpf</span> <span class="o">=</span> <span class="n">pf</span>
            <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">pf</span><span class="p">):</span>
                <span class="n">pf</span> <span class="o">=</span> <span class="n">LookupTable</span><span class="o">.</span><span class="n">from_file</span><span class="p">(</span><span class="n">pf</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Detect at least _some_ forms of malformed string input.  Note that this</span>
                <span class="c1"># test assumes that the eval string completion is defined for k=1.0.</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">pf</span> <span class="o">=</span> <span class="n">utilities</span><span class="o">.</span><span class="n">math_eval</span><span class="p">(</span><span class="s1">&#39;lambda k : &#39;</span> <span class="o">+</span> <span class="n">pf</span><span class="p">)</span>
                    <span class="n">pf</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">GalSimValueError</span><span class="p">(</span>
                        <span class="s2">&quot;String </span><span class="si">{0}</span><span class="s2"> must either be a valid filename or something that &quot;</span>
                        <span class="s2">&quot;can eval to a function of k.</span><span class="se">\n</span><span class="s2">&quot;</span>
                        <span class="s2">&quot;Caught error: </span><span class="si">{1}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">pf_str</span><span class="p">,</span> <span class="n">e</span><span class="p">),</span> <span class="n">origpf</span><span class="p">)</span>

        <span class="c1"># Check that the function is sane.</span>
        <span class="c1"># Note: Only try tests below if it&#39;s not a LookupTable.</span>
        <span class="c1">#       (If it&#39;s a LookupTable, then it could be a valid function that isn&#39;t</span>
        <span class="c1">#        defined at k=1.)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pf</span><span class="p">,</span> <span class="n">LookupTable</span><span class="p">):</span>
            <span class="n">pf</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="mf">0.1</span><span class="p">,</span><span class="mf">1.</span><span class="p">)))</span>
        <span class="k">return</span> <span class="n">pf</span>

<div class="viewcode-block" id="PowerSpectrum.calculateXi"><a class="viewcode-back" href="../../powerspectrum.html#galsim.PowerSpectrum.calculateXi">[docs]</a>    <span class="k">def</span> <span class="nf">calculateXi</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grid_spacing</span><span class="p">,</span> <span class="n">ngrid</span><span class="p">,</span> <span class="n">kmax_factor</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">kmin_factor</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_theta</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
                    <span class="n">units</span><span class="o">=</span><span class="n">arcsec</span><span class="p">,</span> <span class="n">bandlimit</span><span class="o">=</span><span class="s2">&quot;hard&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Calculate shear correlation functions for the current power spectrum on the specified</span>
<span class="sd">        grid.</span>

<span class="sd">        This function will calculate the theoretical shear correlation functions, :math:`\xi_+`</span>
<span class="sd">        and :math:`\xi_-`, for this power spectrum and the grid configuration specified using</span>
<span class="sd">        keyword arguments, taking into account the minimum and maximum k range implied by the grid</span>
<span class="sd">        parameters, ``kmin_factor`` and ``kmax_factor``.  Most theoretical correlation function</span>
<span class="sd">        calculators assume an infinite k range, so this utility can be used to check how close the</span>
<span class="sd">        chosen grid parameters (and the implied minimum and maximum k) come to the &quot;ideal&quot; result.</span>
<span class="sd">        This is particularly useful on large scales, since in practice the finite grid extent</span>
<span class="sd">        limits the minimum k value and therefore can suppress shear correlations on large scales.</span>
<span class="sd">        Note that the actual shear correlation function in the generated shears will still differ</span>
<span class="sd">        from the one calculated here due to differences between the discrete and continuous Fourier</span>
<span class="sd">        transform.</span>

<span class="sd">        The quantities that are returned are three NumPy arrays: separation theta (in the adopted</span>
<span class="sd">        units), :math:`\xi_+`, and :math:`\xi_-`.  These are defined in terms of the E- and B-mode</span>
<span class="sd">        shear power spectrum as in the document ``devel/modules/lensing_engine.pdf``, equations 2</span>
<span class="sd">        and 3.  The values that are returned are for a particular theta value, not an average over</span>
<span class="sd">        a range of theta values in some bin of finite width.</span>

<span class="sd">        This method has been tested with cosmological shear power spectra; users should check for</span>
<span class="sd">        sanity of outputs if attempting to use power spectra that have very different scalings with</span>
<span class="sd">        k.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            grid_spacing:   Spacing for an evenly spaced grid of points, by default in arcsec</span>
<span class="sd">                            for consistency with the natural length scale of images created</span>
<span class="sd">                            using the `GSObject.drawImage` method.  Other units can be specified</span>
<span class="sd">                            using the ``units`` keyword.</span>
<span class="sd">            ngrid:          Number of grid points in each dimension.  [Must be an integer]</span>
<span class="sd">            units:          The angular units used for the positions.  [default = arcsec]</span>
<span class="sd">            kmin_factor:    (Optional) Factor by which the grid spacing in fourier space is</span>
<span class="sd">                            smaller than the default.  i.e.::</span>

<span class="sd">                                kmin = 2. * pi / (ngrid * grid_spacing) / kmin_factor</span>

<span class="sd">                            [default ``kmin_factor = 1``; must be an integer]</span>
<span class="sd">            kmax_factor:    (Optional) Factor by which the overall grid in fourier space is</span>
<span class="sd">                            larger than the default.  i.e.::</span>

<span class="sd">                                kmax = pi / grid_spacing * kmax_factor</span>

<span class="sd">                            [default ``kmax_factor = 1``; must be an integer]</span>
<span class="sd">            n_theta:        (Optional) Number of logarithmically spaced bins in angular</span>
<span class="sd">                            separation. [default ``n_theta=100``]</span>
<span class="sd">            bandlimit:      (Optional) Keyword determining how to handle power :math:`P(k)` above</span>
<span class="sd">                            the limiting k value, kmax.  The options None, &#39;hard&#39;, and &#39;soft&#39;</span>
<span class="sd">                            correspond to doing nothing (i.e., allow P(&gt;kmax) to be aliased to</span>
<span class="sd">                            lower k values), cutting off all power above kmax, and applying a</span>
<span class="sd">                            softening filter to gradually cut off power above kmax.  Use of this</span>
<span class="sd">                            keyword does not modify the internally-stored power spectrum, just</span>
<span class="sd">                            the result generated by this particular call to `calculateXi`.</span>
<span class="sd">                            [default ``bandlimit=&quot;hard&quot;``]</span>

<span class="sd">        Returns:</span>
<span class="sd">            the tuple (theta, xi_p, xi_m), 1-d NumPy arrays for the angular separation theta</span>
<span class="sd">            and the two shear correlation functions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Normalize inputs</span>
        <span class="n">grid_spacing</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">grid_spacing</span><span class="p">)</span>
        <span class="n">ngrid</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">ngrid</span><span class="p">)</span>
        <span class="n">kmin_factor</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">kmin_factor</span><span class="p">)</span>
        <span class="n">kmax_factor</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">kmax_factor</span><span class="p">)</span>
        <span class="n">n_theta</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">n_theta</span><span class="p">)</span>

        <span class="c1"># Automatically convert units to arcsec at the outset, then forget about it.  This is</span>
        <span class="c1"># because PowerSpectrum by default wants to work in arsec, and all power functions are</span>
        <span class="c1"># automatically converted to do so, so we&#39;ll also do that here.</span>
        <span class="n">scale_fac</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_scale_fac</span><span class="p">(</span><span class="n">units</span><span class="p">)</span>
        <span class="n">grid_spacing</span> <span class="o">*=</span> <span class="n">scale_fac</span>

        <span class="c1"># Decide on a grid of separation values.  Do this in arcsec, for consistency with the</span>
        <span class="c1"># internals of the PowerSpectrum class.</span>
        <span class="n">min_sep</span> <span class="o">=</span> <span class="n">grid_spacing</span>
        <span class="n">max_sep</span> <span class="o">=</span> <span class="n">ngrid</span><span class="o">*</span><span class="n">grid_spacing</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logspace</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">min_sep</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">max_sep</span><span class="p">),</span> <span class="n">n_theta</span><span class="p">)</span>

        <span class="c1"># Set up the power spectrum to use for the calculations, just as in buildGrid.</span>
        <span class="c1"># Convert power_functions into callables:</span>
        <span class="n">e_power_function</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_convert_power_function</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">e_power_function</span><span class="p">,</span><span class="s1">&#39;e_power_function&#39;</span><span class="p">)</span>
        <span class="n">b_power_function</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_convert_power_function</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">b_power_function</span><span class="p">,</span><span class="s1">&#39;b_power_function&#39;</span><span class="p">)</span>

        <span class="c1"># Apply band limit if requested; see comments in &#39;buildGrid()&#39; for more details.</span>
        <span class="n">k_max</span> <span class="o">=</span> <span class="n">kmax_factor</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="n">grid_spacing</span>
        <span class="n">bandlimit_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_bandlimit_func</span><span class="p">(</span><span class="n">bandlimit</span><span class="p">)</span>

        <span class="c1"># If we actually have dimensionless Delta^2, then we must convert to power</span>
        <span class="c1"># P(k) = 2pi Delta^2 / k^2,</span>
        <span class="c1"># which has dimensions of angle^2.</span>
        <span class="c1"># Also apply the bandlimit and/or scale as appropriate.</span>
        <span class="n">p_E</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_pk</span><span class="p">(</span><span class="n">e_power_function</span><span class="p">,</span> <span class="n">k_max</span><span class="p">,</span> <span class="n">bandlimit_func</span><span class="p">)</span>
        <span class="n">p_B</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_pk</span><span class="p">(</span><span class="n">b_power_function</span><span class="p">,</span> <span class="n">k_max</span><span class="p">,</span> <span class="n">bandlimit_func</span><span class="p">)</span>

        <span class="c1"># Get k_min value in arcsec:</span>
        <span class="n">k_min</span> <span class="o">=</span> <span class="mf">2.</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="p">(</span><span class="n">ngrid</span> <span class="o">*</span> <span class="n">grid_spacing</span> <span class="o">*</span> <span class="n">kmin_factor</span><span class="p">)</span>

        <span class="c1"># Do the actual integration for each of the separation values, now that we have power</span>
        <span class="c1"># spectrum functions p_E and p_B.</span>
        <span class="n">xi_p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_theta</span><span class="p">)</span>
        <span class="n">xi_m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_theta</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i_theta</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_theta</span><span class="p">):</span>
            <span class="c1"># Usually theory calculations use radians.  However, our k and P are already set up to</span>
            <span class="c1"># use arcsec, so we need theta to be in arcsec (which it already is) in order for the</span>
            <span class="c1"># units to work out right.</span>
            <span class="c1"># xi_p = (1/2pi) \int (P_E + P_B) J_0(k theta) k dk</span>
            <span class="c1"># xi_m = (1/2pi) \int (P_E - P_B) J_4(k theta) k dk</span>
            <span class="k">if</span> <span class="n">p_E</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">p_B</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">integrand_p</span> <span class="o">=</span> <span class="n">xip_integrand</span><span class="p">(</span><span class="k">lambda</span> <span class="n">k</span><span class="p">:</span> <span class="n">p_E</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="o">+</span> <span class="n">p_B</span><span class="p">(</span><span class="n">k</span><span class="p">),</span> <span class="n">theta</span><span class="p">[</span><span class="n">i_theta</span><span class="p">])</span>
                <span class="n">integrand_m</span> <span class="o">=</span> <span class="n">xim_integrand</span><span class="p">(</span><span class="k">lambda</span> <span class="n">k</span><span class="p">:</span> <span class="n">p_E</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="o">-</span> <span class="n">p_B</span><span class="p">(</span><span class="n">k</span><span class="p">),</span> <span class="n">theta</span><span class="p">[</span><span class="n">i_theta</span><span class="p">])</span>
            <span class="k">elif</span> <span class="n">p_E</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">integrand_p</span> <span class="o">=</span> <span class="n">xip_integrand</span><span class="p">(</span><span class="n">p_E</span><span class="p">,</span> <span class="n">theta</span><span class="p">[</span><span class="n">i_theta</span><span class="p">])</span>
                <span class="n">integrand_m</span> <span class="o">=</span> <span class="n">xim_integrand</span><span class="p">(</span><span class="n">p_E</span><span class="p">,</span> <span class="n">theta</span><span class="p">[</span><span class="n">i_theta</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">integrand_p</span> <span class="o">=</span> <span class="n">xip_integrand</span><span class="p">(</span><span class="n">p_B</span><span class="p">,</span> <span class="n">theta</span><span class="p">[</span><span class="n">i_theta</span><span class="p">])</span>
                <span class="n">integrand_m</span> <span class="o">=</span> <span class="n">xim_integrand</span><span class="p">(</span><span class="k">lambda</span> <span class="n">k</span><span class="p">:</span> <span class="o">-</span><span class="n">p_B</span><span class="p">(</span><span class="n">k</span><span class="p">),</span> <span class="n">theta</span><span class="p">[</span><span class="n">i_theta</span><span class="p">])</span>
            <span class="n">xi_p</span><span class="p">[</span><span class="n">i_theta</span><span class="p">]</span> <span class="o">=</span> <span class="n">integ</span><span class="o">.</span><span class="n">int1d</span><span class="p">(</span><span class="n">integrand_p</span><span class="p">,</span> <span class="n">k_min</span><span class="p">,</span> <span class="n">k_max</span><span class="p">,</span> <span class="n">rel_err</span><span class="o">=</span><span class="mf">1.e-6</span><span class="p">,</span>
                                        <span class="n">abs_err</span><span class="o">=</span><span class="mf">1.e-12</span><span class="p">)</span>
            <span class="n">xi_m</span><span class="p">[</span><span class="n">i_theta</span><span class="p">]</span> <span class="o">=</span> <span class="n">integ</span><span class="o">.</span><span class="n">int1d</span><span class="p">(</span><span class="n">integrand_m</span><span class="p">,</span> <span class="n">k_min</span><span class="p">,</span> <span class="n">k_max</span><span class="p">,</span> <span class="n">rel_err</span><span class="o">=</span><span class="mf">1.e-6</span><span class="p">,</span>
                                        <span class="n">abs_err</span><span class="o">=</span><span class="mf">1.e-12</span><span class="p">)</span>
        <span class="n">xi_p</span> <span class="o">/=</span> <span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
        <span class="n">xi_m</span> <span class="o">/=</span> <span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>

        <span class="c1"># Now convert the array of separation values back to whatever units were used as inputs to</span>
        <span class="c1"># this function.</span>
        <span class="n">theta</span> <span class="o">/=</span> <span class="n">scale_fac</span>

        <span class="c1"># Return arrays with results.</span>
        <span class="k">return</span> <span class="n">theta</span><span class="p">,</span> <span class="n">xi_p</span><span class="p">,</span> <span class="n">xi_m</span></div>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_softening_function</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">k_max</span><span class="p">):</span>
        <span class="c1"># Softening function for the power spectrum band-limiting step, instead of a hard cut in k.</span>
        <span class="c1"># We use an arctan function to go smoothly from 1 to 0 above k_max.  The input k values</span>
        <span class="c1"># can be in any units, as long as the choice of units for k and k_max is the same.</span>

        <span class="c1"># The magic numbers in the code below come from the following:</span>
        <span class="c1"># We define the function as</span>
        <span class="c1">#     (arctan[A log(k/k_max) + B] + pi/2)/pi</span>
        <span class="c1"># For our current purposes, we will define A and B by requiring that this function go to</span>
        <span class="c1"># 0.95 (0.05) for k/k_max = 0.95 (1).  This gives two equations:</span>
        <span class="c1">#     0.95 = (arctan[log(0.95) A + B] + pi/2)/pi</span>
        <span class="c1">#     0.05 = (arctan[B] + pi/2)/pi.</span>
        <span class="c1"># We will solve the second equation:</span>
        <span class="c1">#     -0.45 pi = arctan(B), or</span>
        <span class="c1">#     B = tan(-0.45 pi).</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tan</span><span class="p">(</span><span class="o">-</span><span class="mf">0.45</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>

        <span class="c1"># Then, we get A from the first equation:</span>
        <span class="c1">#     0.45 pi = arctan[log(0.95) A + B]</span>
        <span class="c1">#     tan(0.45 pi) = log(0.95) A  + B</span>
        <span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">tan</span><span class="p">(</span><span class="mf">0.45</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span><span class="o">-</span><span class="n">b</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mf">0.95</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arctan</span><span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">k</span><span class="o">/</span><span class="n">k_max</span><span class="p">)</span><span class="o">+</span><span class="n">b</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mf">2.</span><span class="p">)</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_hard_cutoff</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">k_max</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">k</span> <span class="o">&lt;</span> <span class="n">k_max</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">k</span> <span class="o">&lt;</span> <span class="n">k_max</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>

<div class="viewcode-block" id="PowerSpectrum.getShear"><a class="viewcode-back" href="../../powerspectrum.html#galsim.PowerSpectrum.getShear">[docs]</a>    <span class="k">def</span> <span class="nf">getShear</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">units</span><span class="o">=</span><span class="n">arcsec</span><span class="p">,</span> <span class="n">reduced</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">periodic</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function can interpolate between grid positions to find the shear values for a given</span>
<span class="sd">        list of input positions (or just a single position).  Before calling this function, you must</span>
<span class="sd">        call `buildGrid` first to define the grid of shears and convergences on which to</span>
<span class="sd">        interpolate.  The docstring for `buildGrid` provides some guidance on appropriate grid</span>
<span class="sd">        configurations to use when building a grid that is to be later interpolated to random</span>
<span class="sd">        positions.</span>

<span class="sd">        By default, this method returns the reduced shear, which is defined in terms of shear and</span>
<span class="sd">        convergence as reduced shear ``g=gamma/(1-kappa)``; the ``reduced`` keyword can be set to</span>
<span class="sd">        False in order to return the non-reduced shear.</span>

<span class="sd">        Note that the interpolation (specified when calling `buildGrid`) modifies the effective</span>
<span class="sd">        shear power spectrum and correlation function somewhat, though the effects can be limited</span>
<span class="sd">        by careful choice of grid parameters (see buildGrid() docstring for details).  Assuming</span>
<span class="sd">        those guidelines are followed, then the shear correlation function modifications due to use</span>
<span class="sd">        of the quintic, Lanczos-3, and Lanczos-5 interpolants are below 5% on all scales from the</span>
<span class="sd">        grid spacing to the total grid extent, typically below 2%.  The linear, cubic, and nearest</span>
<span class="sd">        interpolants perform significantly more poorly, with modifications of the correlation</span>
<span class="sd">        functions that can reach tens of percent on the scales where the recommended interpolants</span>
<span class="sd">        perform well.  Thus, the default interpolant is Lanczos-5, and users should think carefully</span>
<span class="sd">        about the acceptability of significant modification of the shear correlation function before</span>
<span class="sd">        changing to use linear, cubic, or nearest.</span>

<span class="sd">        Users who wish to ensure that the shear power spectrum is preserved post-interpolation</span>
<span class="sd">        should consider using the ``periodic`` interpolation option, which assumes the shear field</span>
<span class="sd">        is periodic (i.e., the sky is tiled with many copies of the given shear field).  Those who</span>
<span class="sd">        care about the correlation function should not use this option, and for this reason it&#39;s</span>
<span class="sd">        not the default.</span>

<span class="sd">        **Examples**:</span>

<span class="sd">        1. Get the shear for a particular point::</span>

<span class="sd">                &gt;&gt;&gt; g1, g2 = my_ps.getShear(pos = galsim.PositionD(12, 412))</span>

<span class="sd">           This time the returned values are just floats and correspond to the shear for the</span>
<span class="sd">           provided position.</span>

<span class="sd">        2. You can also provide a position as a tuple to save the explicit PositionD construction::</span>

<span class="sd">                &gt;&gt;&gt; g1, g2 = my_ps.getShear(pos = (12, 412))</span>

<span class="sd">        3. Get the shears for a bunch of points at once::</span>

<span class="sd">                &gt;&gt;&gt; xlist = [ 141, 313,  12, 241, 342 ]</span>
<span class="sd">                &gt;&gt;&gt; ylist = [  75, 199, 306, 225, 489 ]</span>
<span class="sd">                &gt;&gt;&gt; poslist = [ galsim.PositionD(xlist[i],ylist[i]) for i in range(len(xlist)) ]</span>
<span class="sd">                &gt;&gt;&gt; g1, g2 = my_ps.getShear( poslist )</span>
<span class="sd">                &gt;&gt;&gt; g1, g2 = my_ps.getShear( (xlist, ylist) )</span>

<span class="sd">           Both calls do the same thing.  The returned g1, g2 this time are numpy arrays of g1, g2</span>
<span class="sd">           values.  The arrays are the same length as the number of input positions.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            pos:            Position(s) of the source(s), assumed to be post-lensing!</span>
<span class="sd">                            Valid ways to input this:</span>

<span class="sd">                            - single `Position` instance</span>
<span class="sd">                            - tuple of floats: (x,y)</span>
<span class="sd">                            - list/array of `Position` instances</span>
<span class="sd">                            - tuple of lists/arrays: ( xlist, ylist )</span>

<span class="sd">            units:          The angular units used for the positions.  [default: arcsec]</span>
<span class="sd">            reduced:        Whether returned shear(s) should be reduced shears. [default: True]</span>
<span class="sd">            periodi:        Whether the interpolation should treat the positions as being defined</span>
<span class="sd">                            with respect to a periodic grid, which will wrap them around if they</span>
<span class="sd">                            are outside the bounds of the original grid on which shears were</span>
<span class="sd">                            defined.  If not, then shears are set to zero for positions outside the</span>
<span class="sd">                            original grid. [default: False]</span>

<span class="sd">        Returns:</span>
<span class="sd">            the shear as a tuple, (g1,g2)</span>

<span class="sd">        If the input ``pos`` is given a single position, (g1,g2) are the two shear components.</span>
<span class="sd">        If the input ``pos`` is given a list/array of positions, they are NumPy arrays.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;im_g1&#39;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">GalSimError</span><span class="p">(</span><span class="s2">&quot;PowerSpectrum.buildGrid must be called before getShear&quot;</span><span class="p">)</span>

        <span class="c1"># Convert to numpy arrays for internal usage:</span>
        <span class="n">pos_x</span><span class="p">,</span> <span class="n">pos_y</span> <span class="o">=</span> <span class="n">utilities</span><span class="o">.</span><span class="n">_convertPositions</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">units</span><span class="p">,</span> <span class="s1">&#39;getShear&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getShear</span><span class="p">(</span><span class="n">pos_x</span><span class="p">,</span> <span class="n">pos_y</span><span class="p">,</span> <span class="n">reduced</span><span class="p">,</span> <span class="n">periodic</span><span class="p">)</span></div>

<div class="viewcode-block" id="PowerSpectrum._getShear"><a class="viewcode-back" href="../../powerspectrum.html#galsim.PowerSpectrum._getShear">[docs]</a>    <span class="k">def</span> <span class="nf">_getShear</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pos_x</span><span class="p">,</span> <span class="n">pos_y</span><span class="p">,</span> <span class="n">reduced</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">periodic</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Equivalent to `getShear`, but without some sanity checks and the positions must be</span>
<span class="sd">        given as ``pos_x``, ``pos_y`` in arcsec.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            pos_x:      x position in arcsec (either a scalar or a numpy array)</span>
<span class="sd">            pos_y:      y position in arcsec (either a scalar or a numpy array)</span>
<span class="sd">            reduced:    Whether returned shear(s) should be reduced shears. [default: True]</span>
<span class="sd">            periodic:   Whether the interpolation should treat the positions as being defined</span>
<span class="sd">                        with respect to a periodic grid. [default: False]</span>

<span class="sd">        Returns:</span>
<span class="sd">            the (possibly reduced) shears as a tuple (g1,g2) (either scalars or numpy arrays)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">g1_grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">im_g1</span><span class="o">.</span><span class="n">array</span>
        <span class="n">g2_grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">im_g2</span><span class="o">.</span><span class="n">array</span>

        <span class="k">if</span> <span class="n">reduced</span><span class="p">:</span>
            <span class="c1"># get reduced shear (just discard magnification)</span>
            <span class="n">g1_grid</span><span class="p">,</span> <span class="n">g2_grid</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">theoryToObserved</span><span class="p">(</span><span class="n">g1_grid</span><span class="p">,</span> <span class="n">g2_grid</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">im_kappa</span><span class="o">.</span><span class="n">array</span><span class="p">)</span>

        <span class="n">lut_g1</span> <span class="o">=</span> <span class="n">LookupTable2D</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x_grid</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_grid</span><span class="p">,</span> <span class="n">g1_grid</span><span class="p">,</span>
                               <span class="n">edge_mode</span><span class="o">=</span><span class="s1">&#39;wrap&#39;</span> <span class="k">if</span> <span class="n">periodic</span> <span class="k">else</span> <span class="s1">&#39;warn&#39;</span><span class="p">,</span>
                               <span class="n">interpolant</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">interpolant</span><span class="p">)</span>
        <span class="n">lut_g2</span> <span class="o">=</span> <span class="n">LookupTable2D</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x_grid</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_grid</span><span class="p">,</span> <span class="n">g2_grid</span><span class="p">,</span>
                               <span class="n">edge_mode</span><span class="o">=</span><span class="s1">&#39;wrap&#39;</span> <span class="k">if</span> <span class="n">periodic</span> <span class="k">else</span> <span class="s1">&#39;warn&#39;</span><span class="p">,</span>
                               <span class="n">interpolant</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">interpolant</span><span class="p">)</span>

        <span class="n">ret</span> <span class="o">=</span> <span class="n">lut_g1</span><span class="p">(</span><span class="n">pos_x</span><span class="p">,</span> <span class="n">pos_y</span><span class="p">),</span> <span class="n">lut_g2</span><span class="p">(</span><span class="n">pos_x</span><span class="p">,</span> <span class="n">pos_y</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ret</span></div>

<div class="viewcode-block" id="PowerSpectrum.getConvergence"><a class="viewcode-back" href="../../powerspectrum.html#galsim.PowerSpectrum.getConvergence">[docs]</a>    <span class="k">def</span> <span class="nf">getConvergence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">units</span><span class="o">=</span><span class="n">arcsec</span><span class="p">,</span> <span class="n">periodic</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function can interpolate between grid positions to find the convergence values for a</span>
<span class="sd">        given list of input positions (or just a single position).  Before calling this function,</span>
<span class="sd">        you must call `buildGrid` first to define the grid of convergences on which to interpolate.</span>
<span class="sd">        The docstring for `buildGrid` provides some guidance on appropriate grid configurations to</span>
<span class="sd">        use when building a grid that is to be later interpolated to random positions.</span>

<span class="sd">        Note that the interpolation (specified when calling `buildGrid`) modifies the effective</span>
<span class="sd">        2-point functions of these quantities.  See docstring for `getShear` docstring for caveats</span>
<span class="sd">        about interpolation.  The user is advised to be very careful about deviating from the</span>
<span class="sd">        default Lanczos-5 interpolant.</span>

<span class="sd">        The usage of getConvergence() is the same as for `getShear`, except that it returns only a</span>
<span class="sd">        single quantity (convergence value or array of convergence values) rather than two</span>
<span class="sd">        quantities.  See documentation for `getShear` for some examples.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            pos:        Position(s) of the source(s), assumed to be post-lensing!</span>
<span class="sd">                        Valid ways to input this:</span>

<span class="sd">                        - single `Position` instance</span>
<span class="sd">                        - tuple of floats: (x,y)</span>
<span class="sd">                        - list or array of `Position` instances</span>
<span class="sd">                        - tuple of lists/arrays: ( xlist, ylist )</span>

<span class="sd">            units:      The angular units used for the positions.  [default: arcsec]</span>
<span class="sd">            periodic:   Whether the interpolation should treat the positions as being defined</span>
<span class="sd">                        with respect to a periodic grid, which will wrap them around if they</span>
<span class="sd">                        are outside the bounds of the original grid on which shears and</span>
<span class="sd">                        convergences were defined.  If not, then convergences are set to zero</span>
<span class="sd">                        for positions outside the original grid.  [default: False]</span>

<span class="sd">        Returns:</span>
<span class="sd">            the convergence, kappa (either a scalar or a numpy array)</span>

<span class="sd">        If the input ``pos`` is given a single position, kappa is the convergence value.</span>
<span class="sd">        If the input ``pos`` is given a list/array of positions, kappa is a NumPy array.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;im_kappa&#39;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">GalSimError</span><span class="p">(</span><span class="s2">&quot;PowerSpectrum.buildGrid must be called before getConvergence&quot;</span><span class="p">)</span>

        <span class="c1"># Convert to numpy arrays for internal usage:</span>
        <span class="n">pos_x</span><span class="p">,</span> <span class="n">pos_y</span> <span class="o">=</span> <span class="n">utilities</span><span class="o">.</span><span class="n">_convertPositions</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">units</span><span class="p">,</span> <span class="s1">&#39;getConvergence&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getConvergence</span><span class="p">(</span><span class="n">pos_x</span><span class="p">,</span> <span class="n">pos_y</span><span class="p">,</span> <span class="n">periodic</span><span class="p">)</span></div>

<div class="viewcode-block" id="PowerSpectrum._getConvergence"><a class="viewcode-back" href="../../powerspectrum.html#galsim.PowerSpectrum._getConvergence">[docs]</a>    <span class="k">def</span> <span class="nf">_getConvergence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pos_x</span><span class="p">,</span> <span class="n">pos_y</span><span class="p">,</span> <span class="n">periodic</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Equivalent to `getConvergence`, but without some sanity checks and the positions must be</span>
<span class="sd">        given as ``pos_x``, ``pos_y`` in arcsec.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            pos_x:      x position in arcsec (either a scalar or a numpy array)</span>
<span class="sd">            pos_y:      y position in arcsec (either a scalar or a numpy array)</span>
<span class="sd">            periodic:   Whether the interpolation should treat the positions as being defined</span>
<span class="sd">                        with respect to a periodic grid. [default: False]</span>

<span class="sd">        Returns:</span>
<span class="sd">            the convergence, kappa (either a scalar or a numpy array)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">kappa_grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">im_kappa</span><span class="o">.</span><span class="n">array</span>

        <span class="n">lut_kappa</span> <span class="o">=</span> <span class="n">LookupTable2D</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x_grid</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_grid</span><span class="p">,</span> <span class="n">kappa_grid</span><span class="p">,</span>
                                  <span class="n">edge_mode</span><span class="o">=</span><span class="s1">&#39;wrap&#39;</span> <span class="k">if</span> <span class="n">periodic</span> <span class="k">else</span> <span class="s1">&#39;warn&#39;</span><span class="p">,</span>
                                  <span class="n">interpolant</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">interpolant</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">lut_kappa</span><span class="p">(</span><span class="n">pos_x</span><span class="p">,</span> <span class="n">pos_y</span><span class="p">)</span></div>

<div class="viewcode-block" id="PowerSpectrum.getMagnification"><a class="viewcode-back" href="../../powerspectrum.html#galsim.PowerSpectrum.getMagnification">[docs]</a>    <span class="k">def</span> <span class="nf">getMagnification</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">units</span><span class="o">=</span><span class="n">arcsec</span><span class="p">,</span> <span class="n">periodic</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function can interpolate between grid positions to find the lensing magnification (mu)</span>
<span class="sd">        values for a given list of input positions (or just a single position).  Before calling this</span>
<span class="sd">        function, you must call `buildGrid` first to define the grid of shears and convergences on</span>
<span class="sd">        which to interpolate.  The docstring for `buildGrid` provides some guidance on appropriate</span>
<span class="sd">        grid configurations to use when building a grid that is to be later interpolated to random</span>
<span class="sd">        positions.</span>

<span class="sd">        Note that the interpolation (specified when calling `buildGrid`) modifies the effective</span>
<span class="sd">        2-point functions of these quantities.  See docstring for `getShear` docstring for caveats</span>
<span class="sd">        about interpolation.  The user is advised to be very careful about deviating from the</span>
<span class="sd">        default Lanczos-5 interpolant.</span>

<span class="sd">        The usage of `getMagnification` is the same as for `getShear`, except that it returns only</span>
<span class="sd">        a single quantity (a magnification value or array of magnification values) rather than a</span>
<span class="sd">        pair of quantities.  See documentation for `getShear` for some examples.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            pos:        Position(s) of the source(s), assumed to be post-lensing!</span>
<span class="sd">                        Valid ways to input this:</span>

<span class="sd">                        - single `Position` instance</span>
<span class="sd">                        - tuple of floats: (x,y)</span>
<span class="sd">                        - list/array of `Position` instances</span>
<span class="sd">                        - tuple of lists/arrays: ( xlist, ylist )</span>

<span class="sd">            units:      The angular units used for the positions.  [default: arcsec]</span>
<span class="sd">            periodic:   Whether the interpolation should treat the positions as being</span>
<span class="sd">                        defined with respect to a periodic grid, which will wrap them around</span>
<span class="sd">                        if they are outside the bounds of the original grid on which shears</span>
<span class="sd">                        and convergences were defined.  If not, then magnification is set to</span>
<span class="sd">                        1 for positions outside the original grid.  [default: False]</span>

<span class="sd">        Returns:</span>
<span class="sd">            the magnification, mu (either a scalar or a numpy array)</span>

<span class="sd">        If the input ``pos`` is given a single position, mu is the magnification value.</span>
<span class="sd">        If the input ``pos`` is given a list/array of positions, mu is a NumPy array.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;im_kappa&#39;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">GalSimError</span><span class="p">(</span><span class="s2">&quot;PowerSpectrum.buildGrid must be called before getMagnification&quot;</span><span class="p">)</span>

        <span class="c1"># Convert to numpy arrays for internal usage:</span>
        <span class="n">pos_x</span><span class="p">,</span> <span class="n">pos_y</span> <span class="o">=</span> <span class="n">utilities</span><span class="o">.</span><span class="n">_convertPositions</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">units</span><span class="p">,</span> <span class="s1">&#39;getMagnification&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getMagnification</span><span class="p">(</span><span class="n">pos_x</span><span class="p">,</span> <span class="n">pos_y</span><span class="p">,</span> <span class="n">periodic</span><span class="p">)</span></div>

<div class="viewcode-block" id="PowerSpectrum._getMagnification"><a class="viewcode-back" href="../../powerspectrum.html#galsim.PowerSpectrum._getMagnification">[docs]</a>    <span class="k">def</span> <span class="nf">_getMagnification</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pos_x</span><span class="p">,</span> <span class="n">pos_y</span><span class="p">,</span> <span class="n">periodic</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Equivalent to `getMagnification`, but without some sanity checks and the positions must</span>
<span class="sd">        be given as ``pos_x``, ``pos_y`` in arcsec.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            pos_x:      x position in arcsec (either a scalar or a numpy array)</span>
<span class="sd">            pos_y:      y position in arcsec (either a scalar or a numpy array)</span>
<span class="sd">            periodic:   Whether the interpolation should treat the positions as being defined</span>
<span class="sd">                        with respect to a periodic grid. [default: False]</span>

<span class="sd">        Returns:</span>
<span class="sd">            the magnification, mu (either a scalar or a numpy array)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">mu_grid</span> <span class="o">=</span> <span class="n">theoryToObserved</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">im_g1</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">im_g2</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">im_kappa</span><span class="o">.</span><span class="n">array</span><span class="p">)</span>
        <span class="n">lut_mu</span> <span class="o">=</span> <span class="n">LookupTable2D</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x_grid</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_grid</span><span class="p">,</span> <span class="n">mu_grid</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
                               <span class="n">edge_mode</span><span class="o">=</span><span class="s1">&#39;wrap&#39;</span> <span class="k">if</span> <span class="n">periodic</span> <span class="k">else</span> <span class="s1">&#39;warn&#39;</span><span class="p">,</span>
                               <span class="n">interpolant</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">interpolant</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">lut_mu</span><span class="p">(</span><span class="n">pos_x</span><span class="p">,</span> <span class="n">pos_y</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span></div>

<div class="viewcode-block" id="PowerSpectrum.getLensing"><a class="viewcode-back" href="../../powerspectrum.html#galsim.PowerSpectrum.getLensing">[docs]</a>    <span class="k">def</span> <span class="nf">getLensing</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">units</span><span class="o">=</span><span class="n">arcsec</span><span class="p">,</span> <span class="n">periodic</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function can interpolate between grid positions to find the lensing observable</span>
<span class="sd">        quantities (reduced shears g1 and g2, and magnification mu) for a given list of input</span>
<span class="sd">        positions (or just a single position).  Before calling this function, you must call</span>
<span class="sd">        `buildGrid` first to define the grid of shears and convergences on which to interpolate.</span>
<span class="sd">        The docstring for `buildGrid` provides some guidance on appropriate grid configurations to</span>
<span class="sd">        use when building a grid that is to be later interpolated to random positions.</span>

<span class="sd">        Note that the interpolation (specified when calling `buildGrid`) modifies the effective</span>
<span class="sd">        2-point functions of these quantities.  See docstring for `getShear` docstring for caveats</span>
<span class="sd">        about interpolation.  The user is advised to be very careful about deviating from the</span>
<span class="sd">        default Lanczos-5 interpolant.</span>

<span class="sd">        The usage of `getLensing` is the same as for `getShear`, except that it returns three</span>
<span class="sd">        quantities (two reduced shear components and magnification) rather than two.  See</span>
<span class="sd">        documentation for `getShear` for some examples.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            pos:        Position(s) of the source(s), assumed to be post-lensing!</span>
<span class="sd">                        Valid ways to input this:</span>

<span class="sd">                        - single `Position` instance</span>
<span class="sd">                        - tuple of floats: (x,y)</span>
<span class="sd">                        - list/array of `Position` instances</span>
<span class="sd">                        - tuple of lists/arrays: ( xlist, ylist )</span>

<span class="sd">            units:      The angular units used for the positions.  [default: arcsec]</span>
<span class="sd">            periodic:   Whether the interpolation should treat the positions as being</span>
<span class="sd">                        defined with respect to a periodic grid, which will wrap them around</span>
<span class="sd">                        if they are outside the bounds of the original grid on which shears</span>
<span class="sd">                        and convergences were defined.  If not, then shear is set to zero</span>
<span class="sd">                        and magnification is set to 1 for positions outside the original</span>
<span class="sd">                        grid.  [default: False]</span>

<span class="sd">        Returns:</span>
<span class="sd">            shear and magnification as a tuple (g1,g2,mu).</span>

<span class="sd">        If the input ``pos`` is given a single position, the return values are the shear and</span>
<span class="sd">        magnification values at that position.</span>
<span class="sd">        If the input ``pos`` is given a list/array of positions, they are NumPy arrays.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;im_kappa&#39;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">GalSimError</span><span class="p">(</span><span class="s2">&quot;PowerSpectrum.buildGrid must be called before getLensing&quot;</span><span class="p">)</span>

        <span class="c1"># Convert to numpy arrays for internal usage:</span>
        <span class="n">pos_x</span><span class="p">,</span> <span class="n">pos_y</span> <span class="o">=</span> <span class="n">utilities</span><span class="o">.</span><span class="n">_convertPositions</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">units</span><span class="p">,</span> <span class="s1">&#39;getLensing&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getLensing</span><span class="p">(</span><span class="n">pos_x</span><span class="p">,</span> <span class="n">pos_y</span><span class="p">,</span> <span class="n">periodic</span><span class="p">)</span></div>

<div class="viewcode-block" id="PowerSpectrum._getLensing"><a class="viewcode-back" href="../../powerspectrum.html#galsim.PowerSpectrum._getLensing">[docs]</a>    <span class="k">def</span> <span class="nf">_getLensing</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pos_x</span><span class="p">,</span> <span class="n">pos_y</span><span class="p">,</span> <span class="n">periodic</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Equivalent to `getLensing`, but without some sanity checks and the positions must</span>
<span class="sd">        be given as ``pos_x``, ``pos_y`` in arcsec.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            pos_x:      x position in arcsec (either a scalar or a numpy array)</span>
<span class="sd">            pos_y:      y position in arcsec (either a scalar or a numpy array)</span>
<span class="sd">            periodic:   Whether the interpolation should treat the positions as being defined</span>
<span class="sd">                        with respect to a periodic grid. [default: False]</span>

<span class="sd">        Returns:</span>
<span class="sd">            the reduced shear and magnification as a tuple (g1,g2,mu) (either scalars or</span>
<span class="sd">            numpy arrays)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">g1_grid</span><span class="p">,</span> <span class="n">g2_grid</span><span class="p">,</span> <span class="n">mu_grid</span> <span class="o">=</span> <span class="n">theoryToObserved</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">im_g1</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">im_g2</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">im_kappa</span><span class="o">.</span><span class="n">array</span><span class="p">)</span>

        <span class="n">lut_g1</span> <span class="o">=</span> <span class="n">LookupTable2D</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x_grid</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_grid</span><span class="p">,</span> <span class="n">g1_grid</span><span class="p">,</span>
                               <span class="n">edge_mode</span><span class="o">=</span><span class="s1">&#39;wrap&#39;</span> <span class="k">if</span> <span class="n">periodic</span> <span class="k">else</span> <span class="s1">&#39;warn&#39;</span><span class="p">,</span>
                               <span class="n">interpolant</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">interpolant</span><span class="p">)</span>
        <span class="n">lut_g2</span> <span class="o">=</span> <span class="n">LookupTable2D</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x_grid</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_grid</span><span class="p">,</span> <span class="n">g2_grid</span><span class="p">,</span>
                               <span class="n">edge_mode</span><span class="o">=</span><span class="s1">&#39;wrap&#39;</span> <span class="k">if</span> <span class="n">periodic</span> <span class="k">else</span> <span class="s1">&#39;warn&#39;</span><span class="p">,</span>
                               <span class="n">interpolant</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">interpolant</span><span class="p">)</span>
        <span class="n">lut_mu</span> <span class="o">=</span> <span class="n">LookupTable2D</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x_grid</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_grid</span><span class="p">,</span> <span class="n">mu_grid</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span>
                               <span class="n">edge_mode</span><span class="o">=</span><span class="s1">&#39;wrap&#39;</span> <span class="k">if</span> <span class="n">periodic</span> <span class="k">else</span> <span class="s1">&#39;warn&#39;</span><span class="p">,</span>
                               <span class="n">interpolant</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">interpolant</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">lut_g1</span><span class="p">(</span><span class="n">pos_x</span><span class="p">,</span> <span class="n">pos_y</span><span class="p">),</span> <span class="n">lut_g2</span><span class="p">(</span><span class="n">pos_x</span><span class="p">,</span> <span class="n">pos_y</span><span class="p">),</span> <span class="n">lut_mu</span><span class="p">(</span><span class="n">pos_x</span><span class="p">,</span> <span class="n">pos_y</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span></div></div>

<div class="viewcode-block" id="PowerSpectrumRealizer"><a class="viewcode-back" href="../../powerspectrum.html#galsim.PowerSpectrumRealizer">[docs]</a><span class="k">class</span> <span class="nc">PowerSpectrumRealizer</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Class for generating realizations of power spectra with any area and pixel size.</span>

<span class="sd">    This class is not one that end-users should expect to interact with.  It is designed to quickly</span>
<span class="sd">    generate many realizations of the same shear power spectra on a square grid.  The initializer</span>
<span class="sd">    sets up the grids in k-space and computes the power on them.  It also computes spin weighting</span>
<span class="sd">    terms.  You can alter any of the setup properties later.  It currently only works for square</span>
<span class="sd">    grids (at least, much of the internals would be incorrect for non-square grids), so while it</span>
<span class="sd">    nominally contains arrays that could be allowed to be non-square, the constructor itself</span>
<span class="sd">    enforces squareness.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        ngrid:          The size of the grid in one dimension.</span>
<span class="sd">        pixel_size:     The size of the pixel sides, in units consistent with the units expected</span>
<span class="sd">                        by the power spectrum functions.</span>
<span class="sd">        p_E:            Equivalent to ``e_power_function`` in the documentation for the</span>
<span class="sd">                        `PowerSpectrum` class.</span>
<span class="sd">        p_B:            Equivalent to ``b_power_function`` in the documentation for the</span>
<span class="sd">                        `PowerSpectrum` class.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ngrid</span><span class="p">,</span> <span class="n">pixel_size</span><span class="p">,</span> <span class="n">p_E</span><span class="p">,</span> <span class="n">p_B</span><span class="p">):</span>
        <span class="c1"># Set up the k grids in x and y, and the instance variables</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_size</span><span class="p">(</span><span class="n">ngrid</span><span class="p">,</span> <span class="n">pixel_size</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_power</span><span class="p">(</span><span class="n">p_E</span><span class="p">,</span> <span class="n">p_B</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;galsim.lensing_ps.PowerSpectrumRealizer(ngrid=</span><span class="si">%r</span><span class="s2">, pixel_size=</span><span class="si">%r</span><span class="s2">, p_E=</span><span class="si">%r</span><span class="s2">, p_B=</span><span class="si">%r</span><span class="s2">)&quot;</span><span class="o">%</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">nx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pixel_size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">p_E</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">p_B</span><span class="p">)</span>
    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;galsim.lensing_ps.PowerSpectrumRealizer(ngrid=</span><span class="si">%r</span><span class="s2">, pixel_size=</span><span class="si">%r</span><span class="s2">, p_E=</span><span class="si">%s</span><span class="s2">, p_B=</span><span class="si">%s</span><span class="s2">)&quot;</span><span class="o">%</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">nx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pixel_size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">p_E</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">p_B</span><span class="p">)</span>
    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span> <span class="ow">is</span> <span class="n">other</span> <span class="ow">or</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="nb">repr</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
    <span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span> <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__eq__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="nb">hash</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">set_size</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ngrid</span><span class="p">,</span> <span class="n">pixel_size</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nx</span> <span class="o">=</span> <span class="n">ngrid</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ny</span> <span class="o">=</span> <span class="n">ngrid</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pixel_size</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">pixel_size</span><span class="p">)</span>

        <span class="c1"># Setup some handy slices for indexing different parts of k space</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ikx</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nx</span><span class="o">//</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>       <span class="c1"># positive kx values, including 0, nx/2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ikxp</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">,(</span><span class="bp">self</span><span class="o">.</span><span class="n">nx</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span><span class="p">)</span>    <span class="c1"># limit to only values with a negative value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ikxn</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nx</span><span class="o">//</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>    <span class="c1"># negative kx values</span>

        <span class="c1"># We always call this with nx=ny, so behavior with nx != ny is not tested.</span>
        <span class="c1"># However, we make a basic attempt to enable such behavior in the future if needed.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">iky</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">ny</span><span class="o">//</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ikyp</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">,(</span><span class="bp">self</span><span class="o">.</span><span class="n">ny</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ikyn</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">ny</span><span class="o">//</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Set up the scalar k grid. Generally, for a box size of L (in one dimension), the grid</span>
        <span class="c1"># spacing in k_x or k_y is Delta k=2pi/L</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ky</span> <span class="o">=</span> <span class="n">utilities</span><span class="o">.</span><span class="n">kxky</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">ny</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nx</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kx</span> <span class="o">/=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pixel_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ky</span> <span class="o">/=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pixel_size</span>

        <span class="c1"># Compute the spin weightings</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_generate_exp2ipsi</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">set_power</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p_E</span><span class="p">,</span> <span class="n">p_B</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">p_E</span> <span class="o">=</span> <span class="n">p_E</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">p_B</span> <span class="o">=</span> <span class="n">p_B</span>
        <span class="k">if</span> <span class="n">p_E</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  <span class="bp">self</span><span class="o">.</span><span class="n">amplitude_E</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>            <span class="bp">self</span><span class="o">.</span><span class="n">amplitude_E</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_generate_power_array</span><span class="p">(</span><span class="n">p_E</span><span class="p">))</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">pixel_size</span>
        <span class="k">if</span> <span class="n">p_B</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  <span class="bp">self</span><span class="o">.</span><span class="n">amplitude_B</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>            <span class="bp">self</span><span class="o">.</span><span class="n">amplitude_B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_generate_power_array</span><span class="p">(</span><span class="n">p_B</span><span class="p">))</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">pixel_size</span>

<div class="viewcode-block" id="PowerSpectrumRealizer.__call__"><a class="viewcode-back" href="../../powerspectrum.html#galsim.PowerSpectrumRealizer.__call__">[docs]</a>    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gd</span><span class="p">,</span> <span class="n">variance</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate a realization of the current power spectrum.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            gd:         A Gaussian deviate to use when generating the shear fields.</span>
<span class="sd">            variance:   Optionally renormalize the variance of the output shears to a</span>
<span class="sd">                        given value.  This is useful if you know the functional form of</span>
<span class="sd">                        the power spectrum you want, but not the normalization.  This lets</span>
<span class="sd">                        you set the normalization separately.  The resulting shears should</span>
<span class="sd">                        have var(g1) + var(g2) ~= variance.  If only ``e_power_function`` is</span>
<span class="sd">                        given, then this is also the variance of kappa.  Otherwise, the</span>
<span class="sd">                        variance of kappa may be smaller than the specified variance.</span>
<span class="sd">                        [default: None]</span>

<span class="sd">        @return a tuple of NumPy arrays (g1,g2,kappa) for the shear and convergence.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ISQRT2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">1.0</span><span class="o">/</span><span class="mf">2.0</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">gd</span><span class="p">,</span> <span class="n">GaussianDeviate</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;The gd provided to the PowerSpectrumRealizer is not a GaussianDeviate!&quot;</span><span class="p">)</span>

        <span class="c1"># Generate a random complex realization for the E-mode, if there is one</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">amplitude_E</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">r1</span> <span class="o">=</span> <span class="n">utilities</span><span class="o">.</span><span class="n">rand_arr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">amplitude_E</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">gd</span><span class="p">)</span>
            <span class="n">r2</span> <span class="o">=</span> <span class="n">utilities</span><span class="o">.</span><span class="n">rand_arr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">amplitude_E</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">gd</span><span class="p">)</span>
            <span class="n">E_k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">ny</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nx</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
            <span class="n">E_k</span><span class="p">[:,</span><span class="bp">self</span><span class="o">.</span><span class="n">ikx</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">amplitude_E</span> <span class="o">*</span> <span class="p">(</span><span class="n">r1</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">r2</span><span class="p">)</span> <span class="o">*</span> <span class="n">ISQRT2</span>
            <span class="c1"># E_k corresponds to real kappa, so E_k[-k] = conj(E_k[k])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_make_hermitian</span><span class="p">(</span><span class="n">E_k</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span> <span class="n">E_k</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># Generate a random complex realization for the B-mode, if there is one</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">amplitude_B</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">r1</span> <span class="o">=</span> <span class="n">utilities</span><span class="o">.</span><span class="n">rand_arr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">amplitude_B</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">gd</span><span class="p">)</span>
            <span class="n">r2</span> <span class="o">=</span> <span class="n">utilities</span><span class="o">.</span><span class="n">rand_arr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">amplitude_B</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">gd</span><span class="p">)</span>
            <span class="n">B_k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">ny</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nx</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
            <span class="n">B_k</span><span class="p">[:,</span><span class="bp">self</span><span class="o">.</span><span class="n">ikx</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">amplitude_B</span> <span class="o">*</span> <span class="p">(</span><span class="n">r1</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">r2</span><span class="p">)</span> <span class="o">*</span> <span class="n">ISQRT2</span>
            <span class="c1"># B_k corresponds to imag kappa, so B_k[-k] = -conj(B_k[k])</span>
            <span class="c1"># However, we later multiply this by i, so that means here B_k[-k] = conj(B_k[k])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_make_hermitian</span><span class="p">(</span><span class="n">B_k</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">B_k</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># In terms of kappa, the E mode is the real kappa, and the B mode is imaginary kappa:</span>
        <span class="c1"># In fourier space, both E_k and B_k are complex, but the same E + i B relation holds.</span>
        <span class="n">kappa_k</span> <span class="o">=</span> <span class="n">E_k</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">B_k</span>

        <span class="c1"># Renormalize the variance if desired</span>
        <span class="k">if</span> <span class="n">variance</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">current_var</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">kappa_k</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nx</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">ny</span><span class="p">)</span>
            <span class="n">factor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">variance</span> <span class="o">/</span> <span class="n">current_var</span><span class="p">)</span>
            <span class="n">kappa_k</span> <span class="o">*=</span> <span class="n">factor</span>
            <span class="n">E_k</span> <span class="o">*=</span> <span class="n">factor</span>  <span class="c1"># Need this for the k return value below.</span>

        <span class="c1"># Compute gamma_k as exp(2i psi) kappa_k</span>
        <span class="c1"># Equation 2.1.12 of Kaiser &amp; Squires (1993, ApJ, 404, 441) is equivalent to:</span>
        <span class="c1">#   gamma_k = -self.exp2ipsi * kappa_k</span>
        <span class="c1"># But of course, they only considered real (E-mode) kappa.</span>
        <span class="c1"># However, this equation has a sign error.  There should not be a minus in front.</span>
        <span class="c1"># If you follow their subsequent deviation, you will see that they drop the minus sign</span>
        <span class="c1"># when they get to 2.1.15 (another - appears from the derivative).  2.1.15 is correct.</span>
        <span class="c1"># e.g. it correctly produces a positive point mass for tangential shear ~ 1/r^2.</span>
        <span class="c1"># So this implies that the minus sign in 2.1.12 should not be there.</span>
        <span class="n">gamma_k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exp2ipsi</span> <span class="o">*</span> <span class="n">kappa_k</span>

        <span class="c1"># And go to real space to get the real-space shear and convergence fields.</span>
        <span class="c1"># Note the multiplication by N is needed because the np.fft.ifft2 implicitly includes a</span>
        <span class="c1"># 1/N^2, and for proper normalization we need a factor of 1/N.</span>
        <span class="n">gamma</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nx</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifft2</span><span class="p">(</span><span class="n">gamma_k</span><span class="p">)</span>
        <span class="c1"># Make them contiguous, since we need to use them in an Image, which requires it.</span>
        <span class="n">g1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">gamma</span><span class="p">))</span>
        <span class="n">g2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">gamma</span><span class="p">))</span>

        <span class="c1"># Could do the same thing with kappa..</span>
        <span class="c1">#kappa = self.nx * np.fft.ifft2(kappa_k)</span>
        <span class="c1">#k = np.ascontiguousarray(np.real(kappa))</span>

        <span class="c1"># But, since we don&#39;t care about imag(kappa), this is a bit faster:</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">E_k</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
            <span class="n">k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">ny</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nx</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nx</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">irfft2</span><span class="p">(</span><span class="n">E_k</span><span class="p">[:,</span><span class="bp">self</span><span class="o">.</span><span class="n">ikx</span><span class="p">],</span> <span class="n">s</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ny</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nx</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">g1</span><span class="p">,</span> <span class="n">g2</span><span class="p">,</span> <span class="n">k</span></div>

    <span class="k">def</span> <span class="nf">_make_hermitian</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">P_k</span><span class="p">):</span>
        <span class="c1"># Make P_k[-k] = conj(P_k[k])</span>
        <span class="c1"># First update the kx=0 values to be consistent with this.</span>
        <span class="n">P_k</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ikyn</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">P_k</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ikyp</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">P_k</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">P_k</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>  <span class="c1"># Not reall necessary, since P_k[0,0] = 0, but</span>
                                      <span class="c1"># I do it anyway for the sake of pedantry...</span>
        <span class="c1"># Then fill the kx&lt;0 values appropriately</span>
        <span class="n">P_k</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ikyp</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">ikxn</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">P_k</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ikyn</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">ikxp</span><span class="p">])</span>
        <span class="n">P_k</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ikyn</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">ikxn</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">P_k</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ikyp</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">ikxp</span><span class="p">])</span>
        <span class="n">P_k</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">ikxn</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">P_k</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">ikxp</span><span class="p">])</span>
        <span class="c1"># For even nx,ny, there are a few more changes needed.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ny</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Note: this is a bit more complicated if you have to separately check whether</span>
            <span class="c1"># nx and/or ny are even.  I ignore this subtlety until we decide it is needed.</span>
            <span class="n">P_k</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ikyn</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nx</span><span class="o">//</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">P_k</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ikyp</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nx</span><span class="o">//</span><span class="mi">2</span><span class="p">])</span>
            <span class="n">P_k</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ny</span><span class="o">//</span><span class="mi">2</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">ikxn</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">P_k</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ny</span><span class="o">//</span><span class="mi">2</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">ikxp</span><span class="p">])</span>
            <span class="n">P_k</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ny</span><span class="o">//</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">P_k</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ny</span><span class="o">//</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">P_k</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nx</span><span class="o">//</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">P_k</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nx</span><span class="o">//</span><span class="mi">2</span><span class="p">])</span>
            <span class="n">P_k</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ny</span><span class="o">//</span><span class="mi">2</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nx</span><span class="o">//</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">P_k</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ny</span><span class="o">//</span><span class="mi">2</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nx</span><span class="o">//</span><span class="mi">2</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">_generate_power_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">power_function</span><span class="p">):</span>
        <span class="c1"># Internal function to generate the result of a power function evaluated on a grid,</span>
        <span class="c1"># taking into account the symmetries.</span>
        <span class="n">power_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">ny</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nx</span><span class="o">//</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>

        <span class="c1"># Set up the scalar |k| grid using just the positive kx,ky</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kx</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">iky</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">ikx</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">ky</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">iky</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">ikx</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

        <span class="c1"># Fudge the value at k=0, so we don&#39;t have to evaluate power there</span>
        <span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">k</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">P_k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
        <span class="n">P_k</span><span class="p">[:,:]</span> <span class="o">=</span> <span class="n">power_function</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>

        <span class="c1"># Now fix the k=0 value of power to zero</span>
        <span class="n">P_k</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">P_k</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])(</span><span class="mf">0.</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">P_k</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">GalSimError</span><span class="p">(</span><span class="s2">&quot;Negative power found for some values of k!&quot;</span><span class="p">)</span>

        <span class="n">power_array</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">iky</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ikx</span><span class="p">]</span> <span class="o">=</span> <span class="n">P_k</span>
        <span class="n">power_array</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ikyn</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ikx</span><span class="p">]</span> <span class="o">=</span> <span class="n">P_k</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ikyp</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ikx</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">power_array</span>

    <span class="k">def</span> <span class="nf">_generate_exp2ipsi</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># exp2ipsi = (kx + iky)^2 / |kx + iky|^2 is the phase of the k vector.</span>
        <span class="n">kz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kx</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">ky</span><span class="o">*</span><span class="mi">1</span><span class="n">j</span>
        <span class="c1"># exp(2i psi) = kz^2 / |kz|^2</span>
        <span class="n">ksq</span> <span class="o">=</span> <span class="n">kz</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">kz</span><span class="p">)</span>
        <span class="c1"># Need to adjust denominator for kz=0 to avoid division by 0.</span>
        <span class="n">ksq</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">exp2ipsi</span> <span class="o">=</span> <span class="n">kz</span><span class="o">*</span><span class="n">kz</span><span class="o">/</span><span class="n">ksq</span></div>
        <span class="c1"># Note: this leaves exp2ipsi[0,0] = 0, but it turns out that&#39;s ok, since we only</span>
        <span class="c1"># ever multiply it by something that is 0 anyway (amplitude[0,0] = 0).</span>

<span class="k">def</span> <span class="nf">kappaKaiserSquires</span><span class="p">(</span><span class="n">g1</span><span class="p">,</span> <span class="n">g2</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Perform a Kaiser &amp; Squires (1993) inversion to get a convergence map from gridded shears.</span>

<span class="sd">    This function takes gridded shears and constructs a convergence map from them.  While this is</span>
<span class="sd">    complicated in reality by the non-gridded galaxy positions, it is a straightforward</span>
<span class="sd">    implementation using Fourier transforms for the case of gridded galaxy positions.  Note that</span>
<span class="sd">    there are additional complications when dealing with real observational issues like shape noise</span>
<span class="sd">    that are not handled by this function, and likewise there are known edge effects.</span>

<span class="sd">    Note that, like any process that attempts to recover information from discretely sampled data,</span>
<span class="sd">    the ``kappa_E`` and ``kappa_B`` maps returned by this function are subject to aliasing.</span>
<span class="sd">    There will be distortions if there are non-zero frequency modes in the lensing field represented</span>
<span class="sd">    by ``g1`` and ``g2`` at more than half the frequency represented by the ``g1``, ``g2`` grid</span>
<span class="sd">    spacing.  To avoid this issue in practice you can smooth the input ``g1``, ``g2`` to effectively</span>
<span class="sd">    bandlimit them (the same smoothing kernel will be present in the output ``kappa_E``,</span>
<span class="sd">    ``kappa_B``).  If applying this function to shears drawn randomly according to some power</span>
<span class="sd">    spectrum, the power spectrum that is used should be modified to go to zero above the relevant</span>
<span class="sd">    maximum k value for the grid being used.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        g1:     Square NumPy array containing the first component of shear.</span>
<span class="sd">        g2:     Square NumPy array containing the second component of shear.</span>

<span class="sd">    Returns:</span>
<span class="sd">        the tuple (kappa_E, kappa_B), as NumPy arrays.</span>

<span class="sd">    The returned kappa_E represents the convergence field underlying the input shears.</span>
<span class="sd">    The returned kappa_B is the convergence field generated were all shears rotated by 45 degrees</span>
<span class="sd">    prior to input.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Checks on inputs</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">g1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">g2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Input g1 and g2 must be NumPy arrays.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">g1</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">g2</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">GalSimIncompatibleValuesError</span><span class="p">(</span><span class="s2">&quot;Input g1 and g2 must be the same shape.&quot;</span><span class="p">,</span> <span class="n">g1</span><span class="o">=</span><span class="n">g1</span><span class="p">,</span> <span class="n">g2</span><span class="o">=</span><span class="n">g2</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">g1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">g1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="n">GalSimNotImplementedError</span><span class="p">(</span><span class="s2">&quot;Non-square input shear grids not supported.&quot;</span><span class="p">)</span>

    <span class="c1"># Then setup the kx, ky grids</span>
    <span class="n">kx</span><span class="p">,</span> <span class="n">ky</span> <span class="o">=</span> <span class="n">utilities</span><span class="o">.</span><span class="n">kxky</span><span class="p">(</span><span class="n">g1</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">kz</span> <span class="o">=</span> <span class="n">kx</span> <span class="o">+</span> <span class="n">ky</span><span class="o">*</span><span class="mi">1</span><span class="n">j</span>

    <span class="c1"># exp(2i psi) = kz^2 / |kz|^2</span>
    <span class="n">ksq</span> <span class="o">=</span> <span class="n">kz</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">kz</span><span class="p">)</span>
    <span class="c1"># Need to adjust denominator for kz=0 to avoid division by 0.</span>
    <span class="n">ksq</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.</span>
    <span class="n">exp2ipsi</span> <span class="o">=</span> <span class="n">kz</span><span class="o">*</span><span class="n">kz</span><span class="o">/</span><span class="n">ksq</span>

    <span class="c1"># Build complex g = g1 + i g2</span>
    <span class="n">gz</span> <span class="o">=</span> <span class="n">g1</span> <span class="o">+</span> <span class="n">g2</span><span class="o">*</span><span class="mi">1</span><span class="n">j</span>

    <span class="c1"># Go to fourier space</span>
    <span class="n">gz_k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft2</span><span class="p">(</span><span class="n">gz</span><span class="p">)</span>

    <span class="c1"># Equation 2.1.12 of Kaiser &amp; Squires (1993) is equivalent to:</span>
    <span class="c1">#   kz_k = -np.conj(exp2ipsi)*gz_k</span>
    <span class="c1"># However, this equation has a sign error.  There should not be a minus in front.</span>
    <span class="c1"># If you follow their subsequent deviation, you will see that they drop the minus sign</span>
    <span class="c1"># when they get to 2.1.15 (another - appears from the derivative).  2.1.15 is correct.</span>
    <span class="c1"># e.g. it correctly produces a positive point mass for tangential shear ~ 1/r^2.</span>
    <span class="c1"># So this implies that the minus sign in 2.1.12 should not be there.</span>
    <span class="n">kz_k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">exp2ipsi</span><span class="p">)</span><span class="o">*</span><span class="n">gz_k</span>

    <span class="c1"># Come back to real space</span>
    <span class="n">kz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifft2</span><span class="p">(</span><span class="n">kz_k</span><span class="p">)</span>

    <span class="c1"># kz = kappa_E + i kappa_B</span>
    <span class="n">kappaE</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">kz</span><span class="p">)</span>
    <span class="n">kappaB</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">kz</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">kappaE</span><span class="p">,</span> <span class="n">kappaB</span>

<span class="k">class</span> <span class="nc">xip_integrand</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Utility class to assist in calculating the xi_+ shear correlation function from power</span>
<span class="sd">    spectra.&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pk</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pk</span> <span class="o">=</span> <span class="n">pk</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">r</span> <span class="o">=</span> <span class="n">r</span>
    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">k</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">pk</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="o">*</span> <span class="n">j0</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">r</span><span class="o">*</span><span class="n">k</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">xim_integrand</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Utility class to assist in calculating the xi_- shear correlation function from power</span>
<span class="sd">    spectra.&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pk</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pk</span> <span class="o">=</span> <span class="n">pk</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">r</span> <span class="o">=</span> <span class="n">r</span>
    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">k</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">pk</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="o">*</span> <span class="n">jn</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">r</span><span class="o">*</span><span class="n">k</span><span class="p">)</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, GalSim-developers.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>