

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>galsim.wcs &mdash; GalSim 2.3.2 documentation</title>
  

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home"> GalSim
          

          
          </a>

          
            
            
              <div class="version">
                2.3
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../overview.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../install.html">Installation Instructions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tutorials.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../image.html">Images and Related Concepts</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../sb.html">Surface Brightness Profiles</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../chromatic.html">Wavelength-dependent Profiles</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../units.html">Units</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../wcs.html">World Coordinate Systems</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../random.html">Noise and Random Values</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../wl.html">Weak Lensing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../photon.html">Photon Shooting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../utilities.html">Helper Functions and Classes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../errors.html">Errors and Warnings</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../config.html">The Config Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../hsm.html">The HSM Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../des.html">The DES Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../roman.html">The Roman Space Telescope Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../shared.html">Shared Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../history.html">Revision History</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">GalSim</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
      <li>galsim.wcs</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for galsim.wcs</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright (c) 2012-2021 by the GalSim developers team on GitHub</span>
<span class="c1"># https://github.com/GalSim-developers</span>
<span class="c1">#</span>
<span class="c1"># This file is part of GalSim: The modular galaxy image simulation toolkit.</span>
<span class="c1"># https://github.com/GalSim-developers/GalSim</span>
<span class="c1">#</span>
<span class="c1"># GalSim is free software: redistribution and use in source and binary forms,</span>
<span class="c1"># with or without modification, are permitted provided that the following</span>
<span class="c1"># conditions are met:</span>
<span class="c1">#</span>
<span class="c1"># 1. Redistributions of source code must retain the above copyright notice, this</span>
<span class="c1">#    list of conditions, and the disclaimer given in the accompanying LICENSE</span>
<span class="c1">#    file.</span>
<span class="c1"># 2. Redistributions in binary form must reproduce the above copyright notice,</span>
<span class="c1">#    this list of conditions, and the disclaimer given in the documentation</span>
<span class="c1">#    and/or other materials provided with the distribution.</span>
<span class="c1">#</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">.gsobject</span> <span class="kn">import</span> <span class="n">GSObject</span>
<span class="kn">from</span> <span class="nn">.position</span> <span class="kn">import</span> <span class="n">Position</span><span class="p">,</span> <span class="n">PositionD</span><span class="p">,</span> <span class="n">_PositionI</span><span class="p">,</span> <span class="n">_PositionD</span>
<span class="kn">from</span> <span class="nn">.celestial</span> <span class="kn">import</span> <span class="n">CelestialCoord</span>
<span class="kn">from</span> <span class="nn">.shear</span> <span class="kn">import</span> <span class="n">Shear</span>
<span class="kn">from</span> <span class="nn">.errors</span> <span class="kn">import</span> <span class="n">GalSimError</span><span class="p">,</span> <span class="n">GalSimIncompatibleValuesError</span><span class="p">,</span> <span class="n">GalSimNotImplementedError</span>
<span class="kn">from</span> <span class="nn">.errors</span> <span class="kn">import</span> <span class="n">GalSimValueError</span>
<span class="kn">from</span> <span class="nn">.utilities</span> <span class="kn">import</span> <span class="n">doc_inherit</span><span class="p">,</span> <span class="n">lazy_property</span>

<div class="viewcode-block" id="BaseWCS"><a class="viewcode-back" href="../../wcs.html#galsim.BaseWCS">[docs]</a><span class="k">class</span> <span class="nc">BaseWCS</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;The base class for all other kinds of WCS transformations.</span>

<span class="sd">    All the functions the user will typically need are defined here.  Most subclasses just</span>
<span class="sd">    define helper functions to implement each particular WCS definition.  So this base</span>
<span class="sd">    class defines the common interface for all WCS classes.</span>

<span class="sd">    There are several types of WCS classes that we implement. The basic class hierarchy is::</span>

<span class="sd">        `BaseWCS`</span>
<span class="sd">            --- `EuclideanWCS`</span>
<span class="sd">                    --- `UniformWCS`</span>
<span class="sd">                            --- `LocalWCS`</span>
<span class="sd">            --- `CelestialWCS`</span>

<span class="sd">    These base classes are not constructible.  They do not have __init__ defined.</span>

<span class="sd">    1. `LocalWCS` classes are those which really just define a pixel size and shape.</span>
<span class="sd">       They implicitly have the origin in image coordinates correspond to the origin</span>
<span class="sd">       in world coordinates.  They are primarily designed to handle local transformations</span>
<span class="sd">       at the location of a single galaxy, where it should usually be a good approximation</span>
<span class="sd">       to consider the pixel shape to be constant over the size of the galaxy.</span>

<span class="sd">       Currently we define the following `LocalWCS` classes::</span>

<span class="sd">       - `PixelScale`</span>
<span class="sd">       - `ShearWCS`</span>
<span class="sd">       - `JacobianWCS`</span>

<span class="sd">    2. `UniformWCS` classes have a constant pixel size and shape, but they have an arbitrary origin</span>
<span class="sd">       in both image coordinates and world coordinates.  A `LocalWCS` class can be turned into a</span>
<span class="sd">       non-local `UniformWCS` class when an image has its bounds changed, e.g. by the commands</span>
<span class="sd">       `Image.setCenter`, `Image.setOrigin` or `Image.shift`.</span>

<span class="sd">       Currently we define the following non-local, `UniformWCS` classes::</span>

<span class="sd">       - `OffsetWCS`</span>
<span class="sd">       - `OffsetShearWCS`</span>
<span class="sd">       - `AffineTransform`</span>

<span class="sd">    3. `EuclideanWCS` classes use a regular Euclidean coordinate system for the world coordinates,</span>
<span class="sd">       using `PositionD` for the world positions.  We use the notation (u,v) for the world</span>
<span class="sd">       coordinates and (x,y) for the image coordinates.</span>

<span class="sd">       Currently we define the following non-uniform, `EuclideanWCS` class::</span>

<span class="sd">       - `UVFunction`</span>

<span class="sd">    4. `CelestialWCS` classes are defined with their world coordinates on the celestial sphere</span>
<span class="sd">       in terms of right ascension (RA) and declination (Dec).  The pixel size and shape are</span>
<span class="sd">       always variable.  We use `CelestialCoord` for the world coordinates, which helps</span>
<span class="sd">       facilitate the spherical trigonometry that is sometimes required.</span>

<span class="sd">       Currently we define the following `CelestialWCS` classes: (All but the first are defined</span>
<span class="sd">       in the file fitswcs.py.)</span>

<span class="sd">       - `RaDecFunction`</span>
<span class="sd">       - `AstropyWCS`          -- requires astropy.wcs python module to be installed</span>
<span class="sd">       - `PyAstWCS`            -- requires starlink.Ast python module to be installed</span>
<span class="sd">       - `WcsToolsWCS`         -- requires wcstools command line functions to be installed</span>
<span class="sd">       - `GSFitsWCS`           -- native code, but has less functionality than the above</span>

<span class="sd">    There are also a few factory functions in fitswcs.py intended to act like class initializers:</span>

<span class="sd">    - `FitsWCS` tries to read a fits file using one of the above classes and returns an instance of</span>
<span class="sd">      whichever one it found was successful.  It should always be successful, since its final</span>
<span class="sd">      attempt uses `AffineTransform`, which has reasonable defaults when the WCS key words are not</span>
<span class="sd">      in the file, but of course this will only be a very rough approximation of the true WCS.</span>

<span class="sd">    - `TanWCS` constructs a simple tangent plane projection WCS directly from the projection</span>
<span class="sd">      parameters instead of from a fits header.</span>

<span class="sd">    - `FittedSIPWCS` constructs a TAN-SIP WCS by fitting to a list of reference celestial and image</span>
<span class="sd">      coordinates.</span>

<span class="sd">    Some things you can do with a WCS instance:</span>

<span class="sd">    - Convert positions between image coordinates and world coordinates (sometimes referred</span>
<span class="sd">      to as sky coordinates)::</span>

<span class="sd">            &gt;&gt;&gt; world_pos = wcs.toWorld(image_pos)</span>
<span class="sd">            &gt;&gt;&gt; image_pos = wcs.toImage(world_pos)</span>

<span class="sd">      Note: the transformation from world to image coordinates is not guaranteed to be</span>
<span class="sd">      implemented.  If it is not implemented for a particular WCS class, a NotImplementedError</span>
<span class="sd">      will be raised.</span>

<span class="sd">      The ``image_pos`` parameter should be a `PositionD`.  However, ``world_pos`` will</span>
<span class="sd">      be a `CelestialCoord` if the transformation is in terms of celestial coordinates</span>
<span class="sd">      (if ``wcs.isCelestial() == True``).  Otherwise, it will be a `PositionD` as well.</span>

<span class="sd">    - Convert a `GSObject` that is defined in world coordinates to the equivalent profile defined</span>
<span class="sd">      in terms of image coordinates (or vice versa)::</span>

<span class="sd">            &gt;&gt;&gt; image_profile = wcs.toImage(world_profile)</span>
<span class="sd">            &gt;&gt;&gt; world_profile = wcs.toWorld(image_profile)</span>

<span class="sd">      For non-uniform WCS types (for which ``wcs.isUniform() == False``), these need either an</span>
<span class="sd">      ``image_pos`` or ``world_pos`` parameter to say where this conversion should happen::</span>

<span class="sd">            &gt;&gt;&gt; image_profile = wcs.toImage(world_profile, image_pos=image_pos)</span>

<span class="sd">    - Construct a local linear approximation of a WCS at a given location::</span>

<span class="sd">            &gt;&gt;&gt; local_wcs = wcs.local(image_pos = image_pos)</span>
<span class="sd">            &gt;&gt;&gt; local_wcs = wcs.local(world_pos = world_pos)</span>

<span class="sd">      If ``wcs.toWorld(image_pos)`` is not implemented for a particular WCS class, then a</span>
<span class="sd">      NotImplementedError will be raised if you pass in a ``world_pos`` argument.</span>

<span class="sd">      The returned ``local_wcs`` is usually a `JacobianWCS` instance, but see the doc string for</span>
<span class="sd">      `local` for more details.</span>

<span class="sd">    - Construct a full affine approximation of a WCS at a given location::</span>

<span class="sd">            &gt;&gt;&gt; affine_wcs = wcs.affine(image_pos = image_pos)</span>
<span class="sd">            &gt;&gt;&gt; affine_wcs = wcs.affine(world_pos = world_pos)</span>

<span class="sd">      This preserves the transformation near the location of ``image_pos``, but it is linear, so</span>
<span class="sd">      the transformed values may not agree as you get farther from the given point.</span>

<span class="sd">      The returned ``affine_wcs`` is always an `AffineTransform` instance.</span>

<span class="sd">    - Get some properties of the pixel size and shape::</span>

<span class="sd">            &gt;&gt;&gt; area = local_wcs.pixelArea()</span>
<span class="sd">            &gt;&gt;&gt; min_linear_scale = local_wcs.minLinearScale()</span>
<span class="sd">            &gt;&gt;&gt; max_linear_scale = local_wcs.maxLinearScale()</span>
<span class="sd">            &gt;&gt;&gt; jac = local_wcs.jacobian()</span>
<span class="sd">            &gt;&gt;&gt; # Use jac.dudx, jac.dudy, jac.dvdx, jac.dvdy</span>

<span class="sd">      Non-uniform WCS types also have these functions, but for them, you must supply either</span>
<span class="sd">      ``image_pos`` or ``world_pos``.  So the following are equivalent::</span>

<span class="sd">            &gt;&gt;&gt; area = wcs.pixelArea(image_pos)</span>
<span class="sd">            &gt;&gt;&gt; area = wcs.local(image_pos).pixelArea()</span>

<span class="sd">    - Query some overall attributes of the WCS transformation::</span>

<span class="sd">            &gt;&gt;&gt; wcs.isLocal()       # is this a local WCS?</span>
<span class="sd">            &gt;&gt;&gt; wcs.isUniform()     # does this WCS have a uniform pixel size/shape?</span>
<span class="sd">            &gt;&gt;&gt; wcs.isCelestial()   # are the world coordinates on the celestial sphere?</span>
<span class="sd">            &gt;&gt;&gt; wcs.isPixelScale()  # is this either a PixelScale or an OffsetWCS?</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="BaseWCS.toWorld"><a class="viewcode-back" href="../../wcs.html#galsim.BaseWCS.toWorld">[docs]</a>    <span class="k">def</span> <span class="nf">toWorld</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert from image coordinates to world coordinates.</span>

<span class="sd">        There are essentially three overloaded versions of this function here.</span>

<span class="sd">        1. The first converts a `Position` from image coordinates to world coordinates.</span>
<span class="sd">           It returns the corresponding position in world coordinates as a `PositionD` if the WCS</span>
<span class="sd">           is a `EuclideanWCS`, or a `CelestialCoord` if it is a `CelestialWCS`::</span>

<span class="sd">               &gt;&gt;&gt; world_pos = wcs.toWorld(image_pos)</span>

<span class="sd">           Equivalent to ``wcs.posToWorld(image_pos)``.</span>

<span class="sd">        2. The second is nearly the same, but takes x and y values directly and returns</span>
<span class="sd">           either u, v or ra, dec, depending on the kind of wcs being used.  For this version,</span>
<span class="sd">           x and y may be numpy arrays, in which case the returned values are also numpy</span>
<span class="sd">           arrays::</span>

<span class="sd">               &gt;&gt;&gt; u, v = wcs.toWorld(x, y)                 # For EuclideanWCS types</span>
<span class="sd">               &gt;&gt;&gt; ra, dec = wcs.toWorld(x, y, units=units) # For CelestialWCS types</span>

<span class="sd">           Equivalent to ``wcs.xyTouv(x, y)`` or ``wcs.xyToradec(x, y, units=units)``.</span>

<span class="sd">        3. The third converts a surface brightness profile (a `GSObject`) from image</span>
<span class="sd">           coordinates to world coordinates, returning the profile in world coordinates</span>
<span class="sd">           as a new `GSObject`.  For non-uniform WCS transforms, you must provide either</span>
<span class="sd">           ``image_pos`` or ``world_pos`` to say where the profile is located, so the right</span>
<span class="sd">           transformation can be performed.  And optionally, you may provide a flux scaling</span>
<span class="sd">           to be performed at the same time::</span>

<span class="sd">               &gt;&gt;&gt; world_profile = wcs.toWorld(image_profile, image_pos=None, world_pos=None,</span>
<span class="sd">                                               flux_ratio=1, offset=(0,0))</span>

<span class="sd">           Equivalent to ``wcs.profileToWorld(image_profile, ...)``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.chromatic</span> <span class="kn">import</span> <span class="n">ChromaticObject</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">(</span><span class="n">GSObject</span><span class="p">,</span> <span class="n">ChromaticObject</span><span class="p">)):</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">profileToWorld</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">posToWorld</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_isCelestial</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">xyToradec</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">xyTouv</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;toWorld() takes either 1 or 2 positional arguments&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="BaseWCS.posToWorld"><a class="viewcode-back" href="../../wcs.html#galsim.BaseWCS.posToWorld">[docs]</a>    <span class="k">def</span> <span class="nf">posToWorld</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">image_pos</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert a position from image coordinates to world coordinates.</span>

<span class="sd">        This is equivalent to ``wcs.toWorld(image_pos)``.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            image_pos:      The position in image coordinates</span>
<span class="sd">            color:          For color-dependent WCS&#39;s, the color term to use. [default: None]</span>
<span class="sd">            project_center: (Only valid for `CelestialWCS`) A `CelestialCoord` to use for</span>
<span class="sd">                            projecting the result onto a tangent plane world system rather</span>
<span class="sd">                            than returning a `CelestialCoord`. [default: None]</span>
<span class="sd">            projection:     If project_center != None, the kind of projection to use.  See</span>
<span class="sd">                            `CelestialCoord.project` for the valid options. [default: &#39;gnomonic&#39;]</span>

<span class="sd">        Returns:</span>
<span class="sd">            world_pos</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">color</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">color</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_color</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">image_pos</span><span class="p">,</span> <span class="n">Position</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;image_pos must be a PositionD or PositionI argument&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_posToWorld</span><span class="p">(</span><span class="n">image_pos</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="BaseWCS.profileToWorld"><a class="viewcode-back" href="../../wcs.html#galsim.BaseWCS.profileToWorld">[docs]</a>    <span class="k">def</span> <span class="nf">profileToWorld</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">image_profile</span><span class="p">,</span> <span class="n">image_pos</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">world_pos</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                       <span class="n">flux_ratio</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)):</span>
        <span class="sd">&quot;&quot;&quot;Convert a profile from image coordinates to world coordinates.</span>

<span class="sd">        This is equivalent to ``wcs.toWorld(image_profile, ...)``.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            image_profile:  The profile in image coordinates to transform.</span>
<span class="sd">            image_pos:      The image coordinate position (for non-uniform WCS types)</span>
<span class="sd">            world_pos:      The world coordinate position (for non-uniform WCS types)</span>
<span class="sd">            color:          For color-dependent WCS&#39;s, the color term to use. [default: None]</span>
<span class="sd">            flux_ratio:     An optional flux scaling to be applied at the same time.</span>
<span class="sd">                            [default: 1]</span>
<span class="sd">            offset:         An optional offset to be applied at the same time. [default: 0,0]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">color</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">color</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_color</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">local</span><span class="p">(</span><span class="n">image_pos</span><span class="p">,</span> <span class="n">world_pos</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">)</span><span class="o">.</span><span class="n">_profileToWorld</span><span class="p">(</span>
                    <span class="n">image_profile</span><span class="p">,</span> <span class="n">flux_ratio</span><span class="p">,</span> <span class="n">PositionD</span><span class="p">(</span><span class="n">offset</span><span class="p">))</span></div>

<div class="viewcode-block" id="BaseWCS.toImage"><a class="viewcode-back" href="../../wcs.html#galsim.BaseWCS.toImage">[docs]</a>    <span class="k">def</span> <span class="nf">toImage</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert from world coordinates to image coordinates</span>

<span class="sd">        There are essentially three overloaded versions of this function here.</span>

<span class="sd">        1. The first converts a position from world coordinates to image coordinates.</span>
<span class="sd">           If the WCS is a `EuclideanWCS`, the argument may be either a `PositionD` or `PositionI`</span>
<span class="sd">           argument.  If it is a `CelestialWCS`, then the argument must be a `CelestialCoord`.</span>
<span class="sd">           It returns the corresponding position in image coordinates as a `PositionD`::</span>

<span class="sd">               &gt;&gt;&gt; image_pos = wcs.toImage(world_pos)</span>

<span class="sd">           Equivalent to `posToImage`.</span>

<span class="sd">        2. The second is nearly the same, but takes either u and v values or ra and dec values</span>
<span class="sd">           (depending on the kind of wcs being used) directly and returns x and y values.</span>
<span class="sd">           For this version, the inputs may be numpy arrays, in which case the returned values</span>
<span class="sd">           are also numpy arrays::</span>

<span class="sd">               &gt;&gt;&gt; x, y = wcs.toImage(u, v)                 # For EuclideanWCS types</span>
<span class="sd">               &gt;&gt;&gt; x, y = wcs.toImage(ra, dec, units=units) # For CelestialWCS types</span>

<span class="sd">           Equivalent to `uvToxy` or `radecToxy`.</span>

<span class="sd">        3. The third converts a surface brightness profile (a `GSObject`) from world</span>
<span class="sd">           coordinates to image coordinates, returning the profile in image coordinates</span>
<span class="sd">           as a new `GSObject`.  For non-uniform WCS transforms, you must provide either</span>
<span class="sd">           ``image_pos`` or ``world_pos`` to say where the profile is located so the right</span>
<span class="sd">           transformation can be performed.  And optionally, you may provide a flux scaling</span>
<span class="sd">           to be performed at the same time::</span>

<span class="sd">               &gt;&gt;&gt; image_profile = wcs.toImage(world_profile, image_pos=None, world_pos=None,</span>
<span class="sd">                                               flux_ratio=1, offset=(0,0))</span>

<span class="sd">           Equivalent to `profileToImage`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.chromatic</span> <span class="kn">import</span> <span class="n">ChromaticObject</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">(</span><span class="n">GSObject</span><span class="p">,</span> <span class="n">ChromaticObject</span><span class="p">)):</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">profileToImage</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">posToImage</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_isCelestial</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">radecToxy</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">uvToxy</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;toImage() takes either 1 or 2 positional arguments&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="BaseWCS.posToImage"><a class="viewcode-back" href="../../wcs.html#galsim.BaseWCS.posToImage">[docs]</a>    <span class="k">def</span> <span class="nf">posToImage</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">world_pos</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert a position from world coordinates to image coordinates.</span>

<span class="sd">        This is equivalent to ``wcs.toImage(world_pos)``.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            world_pos:  The world coordinate position</span>
<span class="sd">            color:      For color-dependent WCS&#39;s, the color term to use. [default: None]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">color</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">color</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_color</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_isCelestial</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">world_pos</span><span class="p">,</span> <span class="n">CelestialCoord</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;world_pos must be a CelestialCoord argument&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_isCelestial</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">world_pos</span><span class="p">,</span> <span class="n">Position</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;world_pos must be a PositionD or PositionI argument&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_posToImage</span><span class="p">(</span><span class="n">world_pos</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">)</span></div>

<div class="viewcode-block" id="BaseWCS.profileToImage"><a class="viewcode-back" href="../../wcs.html#galsim.BaseWCS.profileToImage">[docs]</a>    <span class="k">def</span> <span class="nf">profileToImage</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">world_profile</span><span class="p">,</span> <span class="n">image_pos</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">world_pos</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                       <span class="n">flux_ratio</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)):</span>
        <span class="sd">&quot;&quot;&quot;Convert a profile from world coordinates to image coordinates.</span>

<span class="sd">        This is equivalent to ``wcs.toImage(world_profile, ...)``.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            world_profile:  The profile in world coordinates to transform.</span>
<span class="sd">            image_pos:      The image coordinate position (for non-uniform WCS types)</span>
<span class="sd">            world_pos:      The world coordinate position (for non-uniform WCS types)</span>
<span class="sd">            color:          For color-dependent WCS&#39;s, the color term to use. [default: None]</span>
<span class="sd">            flux_ratio:     An optional flux scaling to be applied at the same time.</span>
<span class="sd">                                [default: 1]</span>
<span class="sd">            offset:         An optional offset to be applied at the same time. [default: 0,0]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">color</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">color</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_color</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">local</span><span class="p">(</span><span class="n">image_pos</span><span class="p">,</span> <span class="n">world_pos</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">)</span><span class="o">.</span><span class="n">_profileToImage</span><span class="p">(</span>
                    <span class="n">world_profile</span><span class="p">,</span> <span class="n">flux_ratio</span><span class="p">,</span> <span class="n">PositionD</span><span class="p">(</span><span class="n">offset</span><span class="p">))</span></div>

<div class="viewcode-block" id="BaseWCS.pixelArea"><a class="viewcode-back" href="../../wcs.html#galsim.BaseWCS.pixelArea">[docs]</a>    <span class="k">def</span> <span class="nf">pixelArea</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">image_pos</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">world_pos</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the area of a pixel in arcsec**2 (or in whatever units you are using for</span>
<span class="sd">        world coordinates if it is a `EuclideanWCS`).</span>

<span class="sd">        For non-uniform WCS transforms, you must provide either ``image_pos`` or ``world_pos``</span>
<span class="sd">        to say where the pixel is located.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            image_pos:  The image coordinate position (for non-uniform WCS types)</span>
<span class="sd">            world_pos:  The world coordinate position (for non-uniform WCS types)</span>
<span class="sd">            color:      For color-dependent WCS&#39;s, the color term for which to evaluate the</span>
<span class="sd">                        pixel area. [default: None]</span>

<span class="sd">        Returns:</span>
<span class="sd">            the pixel area in arcsec**2.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">color</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">color</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_color</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">local</span><span class="p">(</span><span class="n">image_pos</span><span class="p">,</span> <span class="n">world_pos</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">)</span><span class="o">.</span><span class="n">_pixelArea</span><span class="p">()</span></div>

<div class="viewcode-block" id="BaseWCS.minLinearScale"><a class="viewcode-back" href="../../wcs.html#galsim.BaseWCS.minLinearScale">[docs]</a>    <span class="k">def</span> <span class="nf">minLinearScale</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">image_pos</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">world_pos</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the minimum linear scale of the transformation in any direction.</span>

<span class="sd">        This is basically the semi-minor axis of the Jacobian.  Sometimes you need a</span>
<span class="sd">        linear scale size for some calculation.  This function returns the smallest</span>
<span class="sd">        scale in any direction.  The function maxLinearScale() returns the largest.</span>

<span class="sd">        For non-uniform WCS transforms, you must provide either ``image_pos`` or ``world_pos``</span>
<span class="sd">        to say where the pixel is located.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            image_pos:  The image coordinate position (for non-uniform WCS types)</span>
<span class="sd">            world_pos:  The world coordinate position (for non-uniform WCS types)</span>
<span class="sd">            color:      For color-dependent WCS&#39;s, the color term for which to evaluate the</span>
<span class="sd">                        scale. [default: None]</span>

<span class="sd">        Returns:</span>
<span class="sd">            the minimum pixel area in any direction in arcsec.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">color</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">color</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_color</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">local</span><span class="p">(</span><span class="n">image_pos</span><span class="p">,</span> <span class="n">world_pos</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">)</span><span class="o">.</span><span class="n">_minScale</span><span class="p">()</span></div>

<div class="viewcode-block" id="BaseWCS.maxLinearScale"><a class="viewcode-back" href="../../wcs.html#galsim.BaseWCS.maxLinearScale">[docs]</a>    <span class="k">def</span> <span class="nf">maxLinearScale</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">image_pos</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">world_pos</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the maximum linear scale of the transformation in any direction.</span>

<span class="sd">        This is basically the semi-major axis of the Jacobian.  Sometimes you need a</span>
<span class="sd">        linear scale size for some calculation.  This function returns the largest</span>
<span class="sd">        scale in any direction.  The function minLinearScale() returns the smallest.</span>

<span class="sd">        For non-uniform WCS transforms, you must provide either ``image_pos`` or ``world_pos``</span>
<span class="sd">        to say where the pixel is located.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            image_pos:  The image coordinate position (for non-uniform WCS types)</span>
<span class="sd">            world_pos:  The world coordinate position (for non-uniform WCS types)</span>
<span class="sd">            color:      For color-dependent WCS&#39;s, the color term for which to evaluate the</span>
<span class="sd">                        scale. [default: None]</span>

<span class="sd">        Returns:</span>
<span class="sd">            the maximum pixel area in any direction in arcsec.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">color</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">color</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_color</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">local</span><span class="p">(</span><span class="n">image_pos</span><span class="p">,</span> <span class="n">world_pos</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">)</span><span class="o">.</span><span class="n">_maxScale</span><span class="p">()</span></div>

<div class="viewcode-block" id="BaseWCS.isPixelScale"><a class="viewcode-back" href="../../wcs.html#galsim.BaseWCS.isPixelScale">[docs]</a>    <span class="k">def</span> <span class="nf">isPixelScale</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return whether the WCS transformation is a simple `PixelScale` or `OffsetWCS`.</span>

<span class="sd">        These are the simplest two WCS transformations.  `PixelScale` is local and `OffsetWCS`</span>
<span class="sd">        is non-local.  If an `Image` has one of these WCS transformations as its WCS, then</span>
<span class="sd">        ``im.scale`` works to read and write the pixel scale.  If not, ``im.scale`` will raise a</span>
<span class="sd">        TypeError exception.</span>

<span class="sd">        ``wcs.isPixelScale()`` is shorthand for ``isinstance(wcs, (galsim.PixelScale,</span>
<span class="sd">        galsim.OffsetWCS))``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_isPixelScale</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_isPixelScale</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">False</span>   <span class="c1"># Overridden by PixelScale and OffsetWCS</span>

<div class="viewcode-block" id="BaseWCS.isLocal"><a class="viewcode-back" href="../../wcs.html#galsim.BaseWCS.isLocal">[docs]</a>    <span class="k">def</span> <span class="nf">isLocal</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return whether the WCS transformation is a local, linear approximation.</span>

<span class="sd">        ``wcs.isLocal()`` is shorthand for ``isinstance(wcs, galsim.LocalWCS)``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_isLocal</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_isLocal</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">False</span>   <span class="c1"># Overridden by LocalWCS</span>

<div class="viewcode-block" id="BaseWCS.isUniform"><a class="viewcode-back" href="../../wcs.html#galsim.BaseWCS.isUniform">[docs]</a>    <span class="k">def</span> <span class="nf">isUniform</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return whether the pixels in this WCS have uniform size and shape.</span>

<span class="sd">        ``wcs.isUniform()`` is shorthand for ``isinstance(wcs, galsim.UniformWCS)``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_isUniform</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_isUniform</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">False</span>   <span class="c1"># Overridden by UniformWCS</span>

<div class="viewcode-block" id="BaseWCS.isCelestial"><a class="viewcode-back" href="../../wcs.html#galsim.BaseWCS.isCelestial">[docs]</a>    <span class="k">def</span> <span class="nf">isCelestial</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return whether the world coordinates are `CelestialCoord` (i.e. ra,dec).</span>

<span class="sd">        ``wcs.isCelestial()`` is shorthand for ``isinstance(wcs, galsim.CelestialWCS)``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_isCelestial</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_isCelestial</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">False</span>   <span class="c1"># Overridden by CelestialWCS</span>

<div class="viewcode-block" id="BaseWCS.local"><a class="viewcode-back" href="../../wcs.html#galsim.BaseWCS.local">[docs]</a>    <span class="k">def</span> <span class="nf">local</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">image_pos</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">world_pos</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the local linear approximation of the WCS at a given point.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            image_pos:  The image coordinate position (for non-uniform WCS types)</span>
<span class="sd">            world_pos:  The world coordinate position (for non-uniform WCS types)</span>
<span class="sd">            color:      For color-dependent WCS&#39;s, the color term for which to evaluate the</span>
<span class="sd">                        local WCS. [default: None]</span>

<span class="sd">        Returns:</span>
<span class="sd">            a `LocalWCS` instance.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">color</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">color</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_color</span>
        <span class="k">if</span> <span class="n">world_pos</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">image_pos</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">GalSimIncompatibleValuesError</span><span class="p">(</span>
                    <span class="s2">&quot;Only one of image_pos or world_pos may be provided&quot;</span><span class="p">,</span>
                    <span class="n">image_pos</span><span class="o">=</span><span class="n">image_pos</span><span class="p">,</span> <span class="n">world_pos</span><span class="o">=</span><span class="n">world_pos</span><span class="p">)</span>
            <span class="n">image_pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">posToImage</span><span class="p">(</span><span class="n">world_pos</span><span class="p">,</span> <span class="n">color</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">image_pos</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">image_pos</span><span class="p">,</span> <span class="n">Position</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;image_pos must be a PositionD or PositionI argument&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_local</span><span class="p">(</span><span class="n">image_pos</span><span class="p">,</span> <span class="n">color</span><span class="p">)</span></div>

<div class="viewcode-block" id="BaseWCS.jacobian"><a class="viewcode-back" href="../../wcs.html#galsim.BaseWCS.jacobian">[docs]</a>    <span class="k">def</span> <span class="nf">jacobian</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">image_pos</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">world_pos</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the local `JacobianWCS` of the WCS at a given point.</span>

<span class="sd">        This is basically the same as local(), but the return value is guaranteed to be a</span>
<span class="sd">        `JacobianWCS`, which can be useful in some situations, since you can access the values</span>
<span class="sd">        of the 2x2 Jacobian matrix directly::</span>

<span class="sd">            &gt;&gt;&gt; jac = wcs.jacobian(image_pos)</span>
<span class="sd">            &gt;&gt;&gt; x,y = np.meshgrid(np.arange(0,32,1), np.arange(0,32,1))</span>
<span class="sd">            &gt;&gt;&gt; u = jac.dudx * x + jac.dudy * y</span>
<span class="sd">            &gt;&gt;&gt; v = jac.dvdx * x + jac.dvdy * y</span>
<span class="sd">            &gt;&gt;&gt; # ... use u,v values to work directly in world coordinates.</span>

<span class="sd">        If you do not need the extra functionality, then you should use local()</span>
<span class="sd">        instead, since it may be more efficient.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            image_pos:  The image coordinate position (for non-uniform WCS types)</span>
<span class="sd">            world_pos:  The world coordinate position (for non-uniform WCS types)</span>
<span class="sd">            color:      For color-dependent WCS&#39;s, the color term for which to evaluate the</span>
<span class="sd">                        local jacobian. [default: None]</span>

<span class="sd">        Returns:</span>
<span class="sd">            a `JacobianWCS` instance.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">color</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">color</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_color</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">local</span><span class="p">(</span><span class="n">image_pos</span><span class="p">,</span> <span class="n">world_pos</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">)</span><span class="o">.</span><span class="n">_toJacobian</span><span class="p">()</span></div>

<div class="viewcode-block" id="BaseWCS.affine"><a class="viewcode-back" href="../../wcs.html#galsim.BaseWCS.affine">[docs]</a>    <span class="k">def</span> <span class="nf">affine</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">image_pos</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">world_pos</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the local `AffineTransform` of the WCS at a given point.</span>

<span class="sd">        This returns a linearized version of the current WCS at a given point.  It</span>
<span class="sd">        returns an `AffineTransform` that is locally approximately the same as the WCS in</span>
<span class="sd">        the vicinity of the given point.</span>

<span class="sd">        It is similar to jacobian(), except that this preserves the offset information</span>
<span class="sd">        between the image coordinates and world coordinates rather than setting both</span>
<span class="sd">        origins to (0,0).  Instead, the image origin is taken to be ``image_pos``.</span>

<span class="sd">        For non-celestial coordinate systems, the world origin is taken to be</span>
<span class="sd">        ``wcs.toWorld(image_pos)``.  In fact, ``wcs.affine(image_pos)`` is really just</span>
<span class="sd">        shorthand for::</span>

<span class="sd">            &gt;&gt;&gt; wcs.jacobian(image_pos).withOrigin(image_pos, wcs.toWorld(image_pos))</span>

<span class="sd">        For celestial coordinate systems, there is no well-defined choice for the</span>
<span class="sd">        origin of the Euclidean world coordinate system.  So we just take (u,v) = (0,0)</span>
<span class="sd">        at the given position.  So, ``wcs.affine(image_pos)`` is equivalent to::</span>

<span class="sd">            &gt;&gt;&gt; wcs.jacobian(image_pos).withOrigin(image_pos)</span>

<span class="sd">        You can use the returned `AffineTransform` to access the relevant values of the 2x2</span>
<span class="sd">        Jacobian matrix and the origins directly::</span>

<span class="sd">            &gt;&gt;&gt; affine = wcs.affine(image_pos)</span>
<span class="sd">            &gt;&gt;&gt; x,y = np.meshgrid(np.arange(0,32,1), np.arange(0,32,1))</span>
<span class="sd">            &gt;&gt;&gt; u = affine.dudx * (x-affine.x0) + jac.dudy * (y-affine.y0) + affine.u0</span>
<span class="sd">            &gt;&gt;&gt; v = affine.dvdx * (x-affine.x0) + jac.dvdy * (y-affine.y0) + affine.v0</span>
<span class="sd">            &gt;&gt;&gt; # ... use u,v values to work directly in sky coordinates.</span>

<span class="sd">        As usual, you may provide either ``image_pos`` or ``world_pos`` as you prefer to</span>
<span class="sd">        specify the location at which to approximate the WCS.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            image_pos:  The image coordinate position (for non-uniform WCS types)</span>
<span class="sd">            world_pos:  The world coordinate position (for non-uniform WCS types)</span>
<span class="sd">            color:      For color-dependent WCS&#39;s, the color term for which to evaluate the</span>
<span class="sd">                        local affine transform. [default: None]</span>

<span class="sd">        Returns:</span>
<span class="sd">            an `AffineTransform` instance</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">color</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">color</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_color</span>
        <span class="n">jac</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">jacobian</span><span class="p">(</span><span class="n">image_pos</span><span class="p">,</span> <span class="n">world_pos</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">)</span>
        <span class="c1"># That call checked that only one of image_pos or world_pos is provided.</span>
        <span class="k">if</span> <span class="n">world_pos</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">image_pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">toImage</span><span class="p">(</span><span class="n">world_pos</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">image_pos</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Both are None.  Must be a local WCS</span>
            <span class="n">image_pos</span> <span class="o">=</span> <span class="n">_PositionD</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_isCelestial</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">jac</span><span class="o">.</span><span class="n">withOrigin</span><span class="p">(</span><span class="n">image_pos</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">world_pos</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">world_pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">toWorld</span><span class="p">(</span><span class="n">image_pos</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">jac</span><span class="o">.</span><span class="n">withOrigin</span><span class="p">(</span><span class="n">image_pos</span><span class="p">,</span> <span class="n">world_pos</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">)</span></div>

<div class="viewcode-block" id="BaseWCS.shiftOrigin"><a class="viewcode-back" href="../../wcs.html#galsim.BaseWCS.shiftOrigin">[docs]</a>    <span class="k">def</span> <span class="nf">shiftOrigin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">origin</span><span class="p">,</span> <span class="n">world_origin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Shift the origin of the current WCS function, returning the new WCS.</span>

<span class="sd">        This function creates a new WCS instance (always a non-local WCS) that shifts the</span>
<span class="sd">        origin by the given amount.  In other words, it treats the image position ``origin``</span>
<span class="sd">        the same way the current WCS treats (x,y) = (0,0).</span>

<span class="sd">        If the current WCS is a local WCS, this essentially declares where on the image</span>
<span class="sd">        you want the origin of the world coordinate system to be.  i.e. where is (u,v) = (0,0).</span>
<span class="sd">        So, for example, to set a WCS that has a constant pixel size with the world coordinates</span>
<span class="sd">        centered at the center of an image, you could write::</span>

<span class="sd">            &gt;&gt;&gt; wcs = galsim.PixelScale(scale).shiftOrigin(im.center)</span>

<span class="sd">        This is equivalent to the following::</span>

<span class="sd">            &gt;&gt;&gt; wcs = galsim.OffsetWCS(scale, origin=im.center)</span>

<span class="sd">        For non-local WCS types, the origin defines the location in the image coordinate system</span>
<span class="sd">        should mean the same thing as (x,y) = (0,0) does for the current WCS.  The following</span>
<span class="sd">        example should work regardless of what kind of WCS this is::</span>

<span class="sd">            &gt;&gt;&gt; world_pos1 = wcs.toWorld(PositionD(0,0))</span>
<span class="sd">            &gt;&gt;&gt; wcs2 = wcs.shiftOrigin(new_origin)</span>
<span class="sd">            &gt;&gt;&gt; world_pos2 = wcs2.toWorld(new_origin)</span>
<span class="sd">            &gt;&gt;&gt; # world_pos1 should be equal to world_pos2</span>

<span class="sd">        Furthermore, if the current WCS is a `EuclideanWCS` (wcs.isCelestial() == False) you may</span>
<span class="sd">        also provide a ``world_origin`` argument which defines what (u,v) position you want to</span>
<span class="sd">        correspond to the new origin.  Continuing the previous example::</span>

<span class="sd">            &gt;&gt;&gt; wcs3 = wcs.shiftOrigin(new_origin, new_world_origin)</span>
<span class="sd">            &gt;&gt;&gt; world_pos3 = wcs3.toWorld(new_origin)</span>
<span class="sd">            &gt;&gt;&gt; # world_pos3 should be equal to new_world_origin</span>

<span class="sd">        Parameters:</span>
<span class="sd">            origin:         The image coordinate position to use for what is currently treated</span>
<span class="sd">                            as (0,0).</span>
<span class="sd">            world_origin:   The world coordinate position to use at the origin.  Only valid if</span>
<span class="sd">                            wcs.isCelestial() == False. [default: None]</span>
<span class="sd">            color:          For color-dependent WCS&#39;s, the color term to use in the connection</span>
<span class="sd">                            between the current origin and world_origin. [default: None]</span>

<span class="sd">        Returns:</span>
<span class="sd">            the new shifted WCS</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">color</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">color</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_color</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">origin</span><span class="p">,</span> <span class="n">Position</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;origin must be a PositionD or PositionI argument&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shiftOrigin</span><span class="p">(</span><span class="n">origin</span><span class="p">,</span> <span class="n">world_origin</span><span class="p">,</span> <span class="n">color</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">withOrigin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">origin</span><span class="p">,</span> <span class="n">world_origin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">.deprecated</span> <span class="kn">import</span> <span class="n">depr</span>
        <span class="n">depr</span><span class="p">(</span><span class="s1">&#39;withOrigin&#39;</span><span class="p">,</span> <span class="mf">2.3</span><span class="p">,</span> <span class="s1">&#39;shiftOrigin&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">shiftOrigin</span><span class="p">(</span><span class="n">origin</span><span class="p">,</span> <span class="n">world_origin</span><span class="p">,</span> <span class="n">color</span><span class="p">)</span>

<div class="viewcode-block" id="BaseWCS.fixColor"><a class="viewcode-back" href="../../wcs.html#galsim.BaseWCS.fixColor">[docs]</a>    <span class="k">def</span> <span class="nf">fixColor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">color</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Fix the color to a particular value.</span>

<span class="sd">        This changes a color-dependent WCS into the corresponding color-independent WCS</span>
<span class="sd">        for the given color.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            color:      The value of the color term to use.</span>

<span class="sd">        Returns:</span>
<span class="sd">            the new color-independent WCS</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">_color</span> <span class="o">=</span> <span class="n">color</span>
        <span class="k">return</span> <span class="n">ret</span></div>

<div class="viewcode-block" id="BaseWCS.writeToFitsHeader"><a class="viewcode-back" href="../../wcs.html#galsim.BaseWCS.writeToFitsHeader">[docs]</a>    <span class="k">def</span> <span class="nf">writeToFitsHeader</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">header</span><span class="p">,</span> <span class="n">bounds</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Write this WCS function to a FITS header.</span>

<span class="sd">        This is normally called automatically from within the galsim.fits.write() function.</span>

<span class="sd">        The code will attempt to write standard FITS WCS keys so that the WCS will be readable</span>
<span class="sd">        by other software (e.g. ds9).  It may not be able to do so accurately, in which case a</span>
<span class="sd">        linearized version will be used instead.  (Specifically, it will use the local affine</span>
<span class="sd">        transform with respect to the image center.)</span>

<span class="sd">        However, this is not necessary for the WCS to survive a round trip through the FITS</span>
<span class="sd">        header, as it will also write GalSim-specific key words that should allow it to</span>
<span class="sd">        reconstruct the WCS correctly.</span>

<span class="sd">        .. note:</span>
<span class="sd">            For `UVFunction` and `RaDecFunction`, if the functions are real python functions</span>
<span class="sd">            (rather than a string that is converted to a function), then the mechanism we use to</span>
<span class="sd">            convert the function to a string that can be written to the header has a few</span>
<span class="sd">            limitations.</span>

<span class="sd">            1. It apparently only works for cpython implementations.</span>
<span class="sd">            2. It probably won&#39;t work to write from one version of python and read from another.</span>
<span class="sd">               (At least for major version differences.)</span>
<span class="sd">            3. If the function uses globals, you&#39;ll need to make sure the globals are present</span>
<span class="sd">               when you read it back in as well, or it probably won&#39;t work.</span>
<span class="sd">            4. It looks really ugly in the header.</span>
<span class="sd">            5. We haven&#39;t thought much about the security implications of this, so beware using</span>
<span class="sd">               GalSim to open FITS files from untrusted sources.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            header:     A FitsHeader (or dict-like) object to write the data to.</span>
<span class="sd">            bounds:     The bounds of the image.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">fits</span>
        <span class="c1"># First write the XMIN, YMIN values</span>
        <span class="n">header</span><span class="p">[</span><span class="s2">&quot;GS_XMIN&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">bounds</span><span class="o">.</span><span class="n">xmin</span><span class="p">,</span> <span class="s2">&quot;GalSim image minimum x coordinate&quot;</span><span class="p">)</span>
        <span class="n">header</span><span class="p">[</span><span class="s2">&quot;GS_YMIN&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">bounds</span><span class="o">.</span><span class="n">ymin</span><span class="p">,</span> <span class="s2">&quot;GalSim image minimum y coordinate&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">bounds</span><span class="o">.</span><span class="n">xmin</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">bounds</span><span class="o">.</span><span class="n">ymin</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># ds9 always assumes the image has an origin at (1,1), so we always write the</span>
            <span class="c1"># WCS to the file with this convention.  We&#39;ll convert back when we read it</span>
            <span class="c1"># in if necessary.</span>
            <span class="n">delta</span> <span class="o">=</span> <span class="n">_PositionI</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">bounds</span><span class="o">.</span><span class="n">xmin</span><span class="p">,</span> <span class="mi">1</span><span class="o">-</span><span class="n">bounds</span><span class="o">.</span><span class="n">ymin</span><span class="p">)</span>
            <span class="n">bounds</span> <span class="o">=</span> <span class="n">bounds</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span><span class="n">delta</span><span class="p">)</span>
            <span class="n">wcs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shiftOrigin</span><span class="p">(</span><span class="n">delta</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">wcs</span> <span class="o">=</span> <span class="bp">self</span>

        <span class="n">wcs</span><span class="o">.</span><span class="n">_writeHeader</span><span class="p">(</span><span class="n">header</span><span class="p">,</span> <span class="n">bounds</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;header&#39;</span><span class="p">):</span>
            <span class="c1"># Store the items that are in self.header in the header if they weren&#39;t already put</span>
            <span class="c1"># there by the call to wcs._writeHeader() call.  (We don&#39;t want to overwrite the WCS.)</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">header</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">header</span> <span class="ow">and</span> <span class="n">key</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="o">!=</span> <span class="s1">&#39;&#39;</span> <span class="ow">and</span>
                    <span class="n">key</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="o">!=</span> <span class="s1">&#39;COMMENT&#39;</span> <span class="ow">and</span> <span class="n">key</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="o">!=</span> <span class="s1">&#39;HISTORY&#39;</span><span class="p">):</span>
                    <span class="n">header</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="n">key</span><span class="p">]</span></div>

<div class="viewcode-block" id="BaseWCS.makeSkyImage"><a class="viewcode-back" href="../../wcs.html#galsim.BaseWCS.makeSkyImage">[docs]</a>    <span class="k">def</span> <span class="nf">makeSkyImage</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span> <span class="n">sky_level</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Make an image of the sky, correctly accounting for the pixel area, which might be</span>
<span class="sd">        variable over the image.</span>

<span class="sd">        Note: This uses finite differences of the wcs mapping to calculate the area of each</span>
<span class="sd">              pixel in world coordinates.  It is usually pretty accurate everywhere except</span>
<span class="sd">              within a few arcsec of the north or south poles.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            image:      The image onto which the sky values will be put.</span>
<span class="sd">            sky_level:  The sky level in ADU/arcsec^2 (or whatever your world coordinate</span>
<span class="sd">                        system units are, if not arcsec).</span>
<span class="sd">            color:      For color-dependent WCS&#39;s, the color term to use for making the</span>
<span class="sd">                        sky image. [default: None]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">color</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">color</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_color</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_makeSkyImage</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">sky_level</span><span class="p">,</span> <span class="n">color</span><span class="p">)</span></div>


    <span class="c1"># A lot of classes will need these checks, so consolidate them here</span>
    <span class="k">def</span> <span class="nf">_set_origin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">origin</span><span class="p">,</span> <span class="n">world_origin</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">origin</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_origin</span> <span class="o">=</span> <span class="n">_PositionD</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">origin</span><span class="p">,</span> <span class="n">Position</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;origin must be a PositionD or PositionI argument&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_origin</span> <span class="o">=</span> <span class="n">origin</span>
        <span class="k">if</span> <span class="n">world_origin</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_world_origin</span> <span class="o">=</span> <span class="n">_PositionD</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">world_origin</span><span class="p">,</span> <span class="n">Position</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;world_origin must be a PositionD argument&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_world_origin</span> <span class="o">=</span> <span class="n">world_origin</span></div>


<div class="viewcode-block" id="readFromFitsHeader"><a class="viewcode-back" href="../../wcs.html#galsim.readFromFitsHeader">[docs]</a><span class="k">def</span> <span class="nf">readFromFitsHeader</span><span class="p">(</span><span class="n">header</span><span class="p">,</span> <span class="n">suppress_warning</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Read a WCS function from a FITS header.</span>

<span class="sd">    This is normally called automatically from within the `galsim.fits.read` function, but</span>
<span class="sd">    you can also call it directly as::</span>

<span class="sd">        wcs, origin = galsim.wcs.readFromFitsHeader(header)</span>

<span class="sd">    If the file was originally written by GalSim using one of the galsim.fits.write() functions,</span>
<span class="sd">    then this should always succeed in reading back in the original WCS.  It may not end up</span>
<span class="sd">    as exactly the same class as the original, but the underlying world coordinate system</span>
<span class="sd">    transformation should be preserved.</span>

<span class="sd">    .. note::</span>
<span class="sd">        For `UVFunction` and `RaDecFunction`, if the functions that were written to the FITS</span>
<span class="sd">        header were real python functions (rather than a string that is converted to a function),</span>
<span class="sd">        then the mechanism we use to write to the header and read it back in has some limitations:</span>

<span class="sd">        1. It apparently only works for cpython implementations.</span>
<span class="sd">        2. It probably won&#39;t work to write from one version of python and read from another.</span>
<span class="sd">           (At least for major version differences.)</span>
<span class="sd">        3. If the function uses globals, you&#39;ll need to make sure the globals are present</span>
<span class="sd">           when you read it back in as well, or it probably won&#39;t work.</span>
<span class="sd">        4. It looks really ugly in the header.</span>
<span class="sd">        5. We haven&#39;t thought much about the security implications of this, so beware using</span>
<span class="sd">           GalSim to open FITS files from untrusted sources.</span>

<span class="sd">    If the file was not written by GalSim, then this code will do its best to read the</span>
<span class="sd">    WCS information in the FITS header.  Depending on what kind of WCS is encoded in the</span>
<span class="sd">    header, this may or may not be successful.</span>

<span class="sd">    If there is no WCS information in the header, then this will default to a pixel scale</span>
<span class="sd">    of 1.</span>

<span class="sd">    In addition to the wcs, this function will also return the image origin that the WCS</span>
<span class="sd">    is assuming for the image.  If the file was originally written by GalSim, this should</span>
<span class="sd">    correspond to the original image origin.  If not, it will default to (1,1).</span>

<span class="sd">    Parameters:</span>
<span class="sd">        header:             The fits header with the WCS information.</span>
<span class="sd">        suppress_warning:   Whether to suppress a warning that the WCS could not be read from the</span>
<span class="sd">                            FITS header, so the WCS defaulted to either a `PixelScale` or</span>
<span class="sd">                            `AffineTransform`. [default: True]</span>

<span class="sd">    Returns:</span>
<span class="sd">        a tuple (wcs, origin) of the wcs from the header and the image origin.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">fits</span>
    <span class="kn">from</span> <span class="nn">.fitswcs</span> <span class="kn">import</span> <span class="n">FitsWCS</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">header</span><span class="p">,</span> <span class="n">fits</span><span class="o">.</span><span class="n">FitsHeader</span><span class="p">):</span>
        <span class="n">header</span> <span class="o">=</span> <span class="n">fits</span><span class="o">.</span><span class="n">FitsHeader</span><span class="p">(</span><span class="n">header</span><span class="p">)</span>
    <span class="n">xmin</span> <span class="o">=</span> <span class="n">header</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;GS_XMIN&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">ymin</span> <span class="o">=</span> <span class="n">header</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;GS_YMIN&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">origin</span> <span class="o">=</span> <span class="n">_PositionI</span><span class="p">(</span><span class="n">xmin</span><span class="p">,</span> <span class="n">ymin</span><span class="p">)</span>
    <span class="n">wcs_name</span> <span class="o">=</span> <span class="n">header</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;GS_WCS&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">wcs_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">gdict</span> <span class="o">=</span> <span class="nb">globals</span><span class="p">()</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">exec</span><span class="p">(</span><span class="s1">&#39;import galsim&#39;</span><span class="p">,</span> <span class="n">gdict</span><span class="p">)</span>
        <span class="n">wcs_type</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="s1">&#39;galsim.&#39;</span> <span class="o">+</span> <span class="n">wcs_name</span><span class="p">,</span> <span class="n">gdict</span><span class="p">)</span>
        <span class="n">wcs</span> <span class="o">=</span> <span class="n">wcs_type</span><span class="o">.</span><span class="n">_readHeader</span><span class="p">(</span><span class="n">header</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># If we aren&#39;t told which type to use, this should find something appropriate</span>
        <span class="n">wcs</span> <span class="o">=</span> <span class="n">FitsWCS</span><span class="p">(</span><span class="n">header</span><span class="o">=</span><span class="n">header</span><span class="p">,</span> <span class="n">suppress_warning</span><span class="o">=</span><span class="n">suppress_warning</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">xmin</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">ymin</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c1"># ds9 always assumes the image has an origin at (1,1), so convert back to actual</span>
        <span class="c1"># xmin, ymin if necessary.</span>
        <span class="n">delta</span> <span class="o">=</span> <span class="n">_PositionI</span><span class="p">(</span><span class="n">xmin</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">ymin</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">wcs</span> <span class="o">=</span> <span class="n">wcs</span><span class="o">.</span><span class="n">shiftOrigin</span><span class="p">(</span><span class="n">delta</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">wcs</span><span class="p">,</span> <span class="n">origin</span></div>


<span class="c1">#########################################################################################</span>
<span class="c1">#</span>
<span class="c1"># Our class hierarchy is:</span>
<span class="c1">#</span>
<span class="c1">#    BaseWCS</span>
<span class="c1">#        --- EuclideanWCS</span>
<span class="c1">#                --- UniformWCS</span>
<span class="c1">#                        --- LocalWCS</span>
<span class="c1">#        --- CelestialWCS</span>
<span class="c1">#</span>
<span class="c1"># Here we define the rest of these classes (besides BaseWCS that is), and implement some</span>
<span class="c1"># functionality that is common among the subclasses of these when possible.</span>
<span class="c1">#</span>
<span class="c1">#########################################################################################</span>


<div class="viewcode-block" id="EuclideanWCS"><a class="viewcode-back" href="../../wcs.html#galsim.EuclideanWCS">[docs]</a><span class="k">class</span> <span class="nc">EuclideanWCS</span><span class="p">(</span><span class="n">BaseWCS</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A EuclideanWCS is a `BaseWCS` whose world coordinates are on a Euclidean plane.</span>
<span class="sd">    We usually use the notation (u,v) to refer to positions in world coordinates, and</span>
<span class="sd">    they use the class `PositionD`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># All EuclideanWCS classes must define origin and world_origin.</span>
    <span class="c1"># Sometimes it is convenient to access x0,y0,u0,v0 directly.</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">x0</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The x component of self.origin.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">origin</span><span class="o">.</span><span class="n">x</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">y0</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The y component of self.origin.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">origin</span><span class="o">.</span><span class="n">y</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">u0</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The x component of self.world_origin (aka u).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">world_origin</span><span class="o">.</span><span class="n">x</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">v0</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The y component of self.world_origin (aka v).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">world_origin</span><span class="o">.</span><span class="n">y</span>

<div class="viewcode-block" id="EuclideanWCS.xyTouv"><a class="viewcode-back" href="../../wcs.html#galsim.EuclideanWCS.xyTouv">[docs]</a>    <span class="k">def</span> <span class="nf">xyTouv</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert x,y from image coordinates to world coordinates.</span>

<span class="sd">        This is equivalent to ``wcs.toWorld(x,y)``.</span>

<span class="sd">        It is also equivalent to ``wcs.posToWorld(galsim.PositionD(x,y))`` when x and y are scalars;</span>
<span class="sd">        however, this routine allows x and y to be numpy arrays, in which case, the calculation</span>
<span class="sd">        will be vectorized, which is often much faster than using the pos interface.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            x:          The x value(s) in image coordinates</span>
<span class="sd">            y:          The y value(s) in image coordinates</span>
<span class="sd">            color:      For color-dependent WCS&#39;s, the color term to use. [default: None]</span>

<span class="sd">        Returns:</span>
<span class="sd">            ra, dec</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.angle</span> <span class="kn">import</span> <span class="n">AngleUnit</span>
        <span class="k">if</span> <span class="n">color</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">color</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_color</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xyTouv</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">)</span></div>

<div class="viewcode-block" id="EuclideanWCS.uvToxy"><a class="viewcode-back" href="../../wcs.html#galsim.EuclideanWCS.uvToxy">[docs]</a>    <span class="k">def</span> <span class="nf">uvToxy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert u,v from world coordinates to image coordinates.</span>

<span class="sd">        This is equivalent to ``wcs.toWorld(u,v)``.</span>

<span class="sd">        It is also equivalent to ``wcs.posToImage(galsim.PositionD(u,v))`` when u and v are scalars;</span>
<span class="sd">        however, this routine allows u and v to be numpy arrays, in which case, the calculation</span>
<span class="sd">        will be vectorized, which is often much faster than using the pos interface.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            u:          The u value(s) in world coordinates</span>
<span class="sd">            v:          The v value(s) in world coordinates</span>
<span class="sd">            color:      For color-dependent WCS&#39;s, the color term to use. [default: None]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">color</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">color</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_color</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_uvToxy</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">color</span><span class="p">)</span></div>

    <span class="c1"># Simple.  Just call _u, _v.</span>
    <span class="k">def</span> <span class="nf">_posToWorld</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">image_pos</span><span class="p">,</span> <span class="n">color</span><span class="p">):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">image_pos</span><span class="o">.</span><span class="n">x</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">x0</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">image_pos</span><span class="o">.</span><span class="n">y</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">y0</span>
        <span class="k">return</span> <span class="n">_PositionD</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_u</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">color</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">color</span><span class="p">))</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">world_origin</span>

    <span class="k">def</span> <span class="nf">_xyTouv</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">color</span><span class="p">):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">x0</span>  <span class="c1"># Not -=, since don&#39;t want to modify the input arrays in place.</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">y</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">y0</span>
        <span class="n">u</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_u</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">color</span><span class="p">)</span>
        <span class="n">v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">color</span><span class="p">)</span>
        <span class="n">u</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">u0</span>
        <span class="n">v</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">v0</span>
        <span class="k">return</span> <span class="n">u</span><span class="p">,</span><span class="n">v</span>

    <span class="c1"># Also simple if _x,_y are implemented.  However, they are allowed to raise a</span>
    <span class="c1"># NotImplementedError.</span>
    <span class="k">def</span> <span class="nf">_posToImage</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">world_pos</span><span class="p">,</span> <span class="n">color</span><span class="p">):</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">world_pos</span><span class="o">.</span><span class="n">x</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">u0</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">world_pos</span><span class="o">.</span><span class="n">y</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">v0</span>
        <span class="k">return</span> <span class="n">_PositionD</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_x</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">,</span><span class="n">color</span><span class="p">),</span><span class="bp">self</span><span class="o">.</span><span class="n">_y</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">,</span><span class="n">color</span><span class="p">))</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">origin</span>

    <span class="k">def</span> <span class="nf">_uvToxy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">color</span><span class="p">):</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">u</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">u0</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">v</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">v0</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">,</span><span class="n">color</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_y</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">,</span><span class="n">color</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x0</span>
        <span class="n">y</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">y0</span>
        <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>

    <span class="c1"># Each subclass has a function _newOrigin, which just calls the constructor with new</span>
    <span class="c1"># values for origin and world_origin.  This function figures out what those values</span>
    <span class="c1"># should be to match the desired behavior of shiftOrigin.</span>
    <span class="k">def</span> <span class="nf">_shiftOrigin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">origin</span><span class="p">,</span> <span class="n">world_origin</span><span class="p">,</span> <span class="n">color</span><span class="p">):</span>
        <span class="c1"># Current u,v are:</span>
        <span class="c1">#     u = ufunc(x-x0, y-y0) + u0</span>
        <span class="c1">#     v = vfunc(x-x0, y-y0) + v0</span>
        <span class="c1"># where ufunc, vfunc represent the underlying wcs transformations.</span>
        <span class="c1">#</span>
        <span class="c1"># The _newOrigin call is expecting new values for the (x0,y0) and (u0,v0), so</span>
        <span class="c1"># we need to figure out how to modify the parameters given the current values.</span>
        <span class="c1">#</span>
        <span class="c1">#     Use (x1,y1) and (u1,v1) for the new values that we will pass to _newOrigin.</span>
        <span class="c1">#     Use (x2,y2) and (u2,v2) for the values passed as arguments.</span>
        <span class="c1">#</span>
        <span class="c1"># If world_origin is None, then we want to do basically the same thing as in the</span>
        <span class="c1"># non-uniform case, except that we also need to pass the function the current value of</span>
        <span class="c1"># wcs.world_pos to keep it from resetting the world_pos back to None.</span>

        <span class="k">if</span> <span class="n">world_origin</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_isLocal</span><span class="p">:</span>
                <span class="n">origin</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">origin</span>
                <span class="n">world_origin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">world_origin</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_newOrigin</span><span class="p">(</span><span class="n">origin</span><span class="p">,</span> <span class="n">world_origin</span><span class="p">)</span>

        <span class="c1"># But if world_origin is given, it isn&#39;t quite as simple.</span>
        <span class="c1">#</span>
        <span class="c1">#     u&#39; = ufunc(x-x1, y-y1) + u1</span>
        <span class="c1">#     v&#39; = vfunc(x-x1, y-y1) + v1</span>
        <span class="c1">#</span>
        <span class="c1"># We want to have:</span>
        <span class="c1">#     u&#39;(x2,y2) = u2</span>
        <span class="c1">#     ufunc(x2-x1, y2-y1) + u1 = u2</span>
        <span class="c1">#</span>
        <span class="c1"># We don&#39;t have access to ufunc directly, just u, so</span>
        <span class="c1">#     (u(x2-x1+x0, y2-y1+y0) - u0) + u1 = u2</span>
        <span class="c1">#</span>
        <span class="c1"># If we take</span>
        <span class="c1">#     x1 = x2</span>
        <span class="c1">#     y1 = y2</span>
        <span class="c1">#</span>
        <span class="c1"># Then</span>
        <span class="c1">#     u(x0,y0) - u0 + u1 = u2</span>
        <span class="c1"># =&gt;  u1 = u0 + u2 - u(x0,y0)</span>
        <span class="c1">#</span>
        <span class="c1"># And similarly,</span>
        <span class="c1">#     v1 = v0 + v2 - v(x0,y0)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">world_origin</span><span class="p">,</span> <span class="n">Position</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;world_origin must be a PositionD or PositionI argument&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_isLocal</span><span class="p">:</span>
                <span class="n">world_origin</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">world_origin</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_posToWorld</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">origin</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_newOrigin</span><span class="p">(</span><span class="n">origin</span><span class="p">,</span> <span class="n">world_origin</span><span class="p">)</span>

    <span class="c1"># If the class doesn&#39;t define something else, then we can approximate the local Jacobian</span>
    <span class="c1"># from finite differences for the derivatives.  This will be overridden by UniformWCS.</span>
    <span class="k">def</span> <span class="nf">_local</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">image_pos</span><span class="p">,</span> <span class="n">color</span><span class="p">):</span>

        <span class="k">if</span> <span class="n">image_pos</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;origin must be a PositionD or PositionI argument&quot;</span><span class="p">)</span>

        <span class="c1"># Calculate the Jacobian using finite differences for the derivatives.</span>
        <span class="n">x0</span> <span class="o">=</span> <span class="n">image_pos</span><span class="o">.</span><span class="n">x</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">x0</span>
        <span class="n">y0</span> <span class="o">=</span> <span class="n">image_pos</span><span class="o">.</span><span class="n">y</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">y0</span>

        <span class="c1"># Use dx,dy = 1 pixel for numerical derivatives</span>
        <span class="n">dx</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">dy</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="n">xlist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span> <span class="n">x0</span><span class="o">+</span><span class="n">dx</span><span class="p">,</span> <span class="n">x0</span><span class="o">-</span><span class="n">dx</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span>    <span class="n">x0</span>    <span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">ylist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span> <span class="n">y0</span><span class="p">,</span>    <span class="n">y0</span><span class="p">,</span>    <span class="n">y0</span><span class="o">+</span><span class="n">dy</span><span class="p">,</span> <span class="n">y0</span><span class="o">-</span><span class="n">dy</span> <span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">u</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_u</span><span class="p">(</span><span class="n">xlist</span><span class="p">,</span><span class="n">ylist</span><span class="p">,</span><span class="n">color</span><span class="p">)</span>
        <span class="n">v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v</span><span class="p">(</span><span class="n">xlist</span><span class="p">,</span><span class="n">ylist</span><span class="p">,</span><span class="n">color</span><span class="p">)</span>

        <span class="n">dudx</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="n">dx</span>
        <span class="n">dudy</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">u</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span> <span class="o">/</span> <span class="n">dy</span>
        <span class="n">dvdx</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="n">dx</span>
        <span class="n">dvdy</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">v</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span> <span class="o">/</span> <span class="n">dy</span>

        <span class="k">return</span> <span class="n">JacobianWCS</span><span class="p">(</span><span class="n">dudx</span><span class="p">,</span> <span class="n">dudy</span><span class="p">,</span> <span class="n">dvdx</span><span class="p">,</span> <span class="n">dvdy</span><span class="p">)</span>

    <span class="c1"># The naive way to make the sky image is to loop over pixels and call pixelArea(pos)</span>
    <span class="c1"># for that position.  This is extremely slow.  Here, we use the fact that the _u and _v</span>
    <span class="c1"># functions might work with numpy arrays.  If they do, this function is quite fast.</span>
    <span class="c1"># If not, we still get some gain from calculating u,v for each pixel and sharing some</span>
    <span class="c1"># of those calculations for multiple finite difference derivatives.  But the latter</span>
    <span class="c1"># option is still pretty slow, so it&#39;s much better to have the _u and _v work with</span>
    <span class="c1"># numpy arrays!</span>
    <span class="k">def</span> <span class="nf">_makeSkyImage</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span> <span class="n">sky_level</span><span class="p">,</span> <span class="n">color</span><span class="p">):</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">bounds</span>
        <span class="n">nx</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">xmax</span><span class="o">-</span><span class="n">b</span><span class="o">.</span><span class="n">xmin</span><span class="o">+</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span>  <span class="c1"># +2 more than in image to get row/col off each edge.</span>
        <span class="n">ny</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">ymax</span><span class="o">-</span><span class="n">b</span><span class="o">.</span><span class="n">ymin</span><span class="o">+</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span>
        <span class="n">x</span><span class="p">,</span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">xmin</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">b</span><span class="o">.</span><span class="n">xmax</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">nx</span><span class="p">),</span>
                           <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">ymin</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">b</span><span class="o">.</span><span class="n">ymax</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">ny</span><span class="p">)</span> <span class="p">)</span>
        <span class="n">x</span> <span class="o">-=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x0</span>
        <span class="n">y</span> <span class="o">-=</span> <span class="bp">self</span><span class="o">.</span><span class="n">y0</span>
        <span class="n">u</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_u</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span><span class="n">y</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span><span class="n">color</span><span class="p">)</span>
        <span class="n">v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span><span class="n">y</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span><span class="n">color</span><span class="p">)</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="c1"># Use the finite differences to estimate the derivatives.</span>
        <span class="n">dudx</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">ny</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">:</span><span class="n">nx</span><span class="p">]</span> <span class="o">-</span> <span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">ny</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">:</span><span class="n">nx</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span>
        <span class="n">dudy</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="n">ny</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="n">nx</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">ny</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="n">nx</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">dvdx</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">ny</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">:</span><span class="n">nx</span><span class="p">]</span> <span class="o">-</span> <span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">ny</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">:</span><span class="n">nx</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span>
        <span class="n">dvdy</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="n">ny</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="n">nx</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">ny</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="n">nx</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="n">area</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">dudx</span> <span class="o">*</span> <span class="n">dvdy</span> <span class="o">-</span> <span class="n">dvdx</span> <span class="o">*</span> <span class="n">dudy</span><span class="p">)</span>
        <span class="n">image</span><span class="o">.</span><span class="n">array</span><span class="p">[:,:]</span> <span class="o">=</span> <span class="n">area</span> <span class="o">*</span> <span class="n">sky_level</span>

    <span class="c1"># Each class should define the __eq__ function.  Then __ne__ is obvious.</span>
    <span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span> <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__eq__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span></div>


<div class="viewcode-block" id="UniformWCS"><a class="viewcode-back" href="../../wcs.html#galsim.UniformWCS">[docs]</a><span class="k">class</span> <span class="nc">UniformWCS</span><span class="p">(</span><span class="n">EuclideanWCS</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A UniformWCS is a `EuclideanWCS` which has a uniform pixel size and shape.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_isUniform</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="c1"># These can also just pass through to the _localwcs attribute.</span>
    <span class="k">def</span> <span class="nf">_u</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_local_wcs</span><span class="o">.</span><span class="n">_u</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">_v</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_local_wcs</span><span class="o">.</span><span class="n">_v</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">_x</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_local_wcs</span><span class="o">.</span><span class="n">_x</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">_y</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_local_wcs</span><span class="o">.</span><span class="n">_y</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">)</span>

    <span class="c1"># For UniformWCS, the local WCS is an attribute.  Just return it.</span>
    <span class="k">def</span> <span class="nf">_local</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">image_pos</span><span class="p">,</span> <span class="n">color</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_local_wcs</span>

    <span class="c1"># UniformWCS transformations can be inverted easily, so might as well provide that function.</span>
<div class="viewcode-block" id="UniformWCS.inverse"><a class="viewcode-back" href="../../wcs.html#galsim.UniformWCS.inverse">[docs]</a>    <span class="k">def</span> <span class="nf">inverse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the inverse transformation, i.e. the transformation that swaps the roles of</span>
<span class="sd">        the &quot;image&quot; and &quot;world&quot; coordinates.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inverse</span><span class="p">()</span></div>

    <span class="c1"># We&#39;ll override this for LocalWCS classes. Non-local UniformWCS classes can use that function</span>
    <span class="c1"># do the inversion.</span>
    <span class="k">def</span> <span class="nf">_inverse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_local_wcs</span><span class="o">.</span><span class="n">_inverse</span><span class="p">()</span><span class="o">.</span><span class="n">_newOrigin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">world_origin</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">origin</span><span class="p">)</span>

    <span class="c1"># This is very simple if the pixels are uniform.</span>
    <span class="k">def</span> <span class="nf">_makeSkyImage</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span> <span class="n">sky_level</span><span class="p">,</span> <span class="n">color</span><span class="p">):</span>
        <span class="n">image</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">sky_level</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">pixelArea</span><span class="p">())</span>

    <span class="c1"># Just check if the locals match and if the origins match.</span>
    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span> <span class="ow">is</span> <span class="n">other</span> <span class="ow">or</span>
                <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">)</span> <span class="ow">and</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">_local_wcs</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_local_wcs</span> <span class="ow">and</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">origin</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">origin</span> <span class="ow">and</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">world_origin</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">world_origin</span><span class="p">))</span></div>


<div class="viewcode-block" id="LocalWCS"><a class="viewcode-back" href="../../wcs.html#galsim.LocalWCS">[docs]</a><span class="k">class</span> <span class="nc">LocalWCS</span><span class="p">(</span><span class="n">UniformWCS</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A LocalWCS is a `UniformWCS` in which (0,0) in image coordinates is at the same place</span>
<span class="sd">    as (0,0) in world coordinates</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="LocalWCS.withOrigin"><a class="viewcode-back" href="../../wcs.html#galsim.LocalWCS.withOrigin">[docs]</a>    <span class="k">def</span> <span class="nf">withOrigin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">origin</span><span class="p">,</span> <span class="n">world_origin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Recenter the current WCS function at a new origin location, returning the new WCS.</span>

<span class="sd">        This function creates a new WCS instance (a non-local WCS) with the same local</span>
<span class="sd">        behavior as the current WCS, but with the given origin.  In other words, you are</span>
<span class="sd">        declaring where on the image you want the new origin of the world coordinate</span>
<span class="sd">        system to be.  i.e. where is (u,v) = (0,0).</span>

<span class="sd">        So, for example, to set a WCS that has a constant pixel size with the world coordinates</span>
<span class="sd">        centered at the center of an image, you could write::</span>

<span class="sd">            &gt;&gt;&gt; wcs = galsim.PixelScale(scale).withOrigin(im.center)</span>

<span class="sd">        This is equivalent to the following::</span>

<span class="sd">            &gt;&gt;&gt; wcs = galsim.OffsetWCS(scale, origin=im.center)</span>

<span class="sd">        You may also provide a ``world_origin`` argument which defines what (u,v) position you</span>
<span class="sd">        want to correspond to the new origin.</span>

<span class="sd">            &gt;&gt;&gt; wcs2 = galsim.PixelScale(scale).withOrigin(new_origin, new_world_origin)</span>
<span class="sd">            &gt;&gt;&gt; world_pos2 = wcs2.toWorld(new_origin)</span>
<span class="sd">            &gt;&gt;&gt; assert world_pos2 == new_world_origin</span>

<span class="sd">        .. note::</span>

<span class="sd">            This is equivalent to `shiftOrigin`, but for for local WCS&#39;s, the shift is also</span>
<span class="sd">            the new location of the origin, so `withOrigin` is a convenient alternate name</span>
<span class="sd">            for this action.  Indeed the `shiftOrigin` function used to be named `withOrigin`,</span>
<span class="sd">            but that name was confusing for non-local WCS&#39;s, as the action in that case is really</span>
<span class="sd">            shifting the origin, not setting the new value.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            origin:         The image coordinate position to use as the origin.</span>
<span class="sd">            world_origin:   The world coordinate position to use as the origin. [default: None]</span>
<span class="sd">            color:          For color-dependent WCS&#39;s, the color term to use in the connection</span>
<span class="sd">                            between the current origin and world_origin. [default: None]</span>

<span class="sd">        Returns:</span>
<span class="sd">            the new recentered WCS</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">origin</span><span class="p">,</span> <span class="n">Position</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;origin must be a PositionD or PositionI argument&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">world_origin</span><span class="p">,</span> <span class="p">(</span><span class="n">Position</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">))):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;world_origin must be a PositionD or PositionI argument&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_newOrigin</span><span class="p">(</span><span class="n">origin</span><span class="p">,</span> <span class="n">world_origin</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_isLocal</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="c1"># The origins are definitionally (0,0) for these.  So just define them here.</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">origin</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The image coordinate position to use as the origin.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_PositionD</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">world_origin</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The world coordinate position to use as the origin.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_PositionD</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>

    <span class="c1"># For LocalWCS, there is no origin to worry about.</span>
    <span class="k">def</span> <span class="nf">_posToWorld</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">image_pos</span><span class="p">,</span> <span class="n">color</span><span class="p">):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">image_pos</span><span class="o">.</span><span class="n">x</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">image_pos</span><span class="o">.</span><span class="n">y</span>
        <span class="k">return</span> <span class="n">_PositionD</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_u</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">),</span><span class="bp">self</span><span class="o">.</span><span class="n">_v</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_xyTouv</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">color</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_u</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>

    <span class="c1"># For LocalWCS, there is no origin to worry about.</span>
    <span class="k">def</span> <span class="nf">_posToImage</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">world_pos</span><span class="p">,</span> <span class="n">color</span><span class="p">):</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">world_pos</span><span class="o">.</span><span class="n">x</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">world_pos</span><span class="o">.</span><span class="n">y</span>
        <span class="k">return</span> <span class="n">_PositionD</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_x</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">),</span><span class="bp">self</span><span class="o">.</span><span class="n">_y</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_uvToxy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">color</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_y</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">)</span>

    <span class="c1"># For LocalWCS, this is of course trivial.</span>
    <span class="k">def</span> <span class="nf">_local</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">image_pos</span><span class="p">,</span> <span class="n">color</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span></div>


<div class="viewcode-block" id="CelestialWCS"><a class="viewcode-back" href="../../wcs.html#galsim.CelestialWCS">[docs]</a><span class="k">class</span> <span class="nc">CelestialWCS</span><span class="p">(</span><span class="n">BaseWCS</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A CelestialWCS is a `BaseWCS` whose world coordinates are on the celestial sphere.</span>
<span class="sd">    We use the `CelestialCoord` class for the world coordinates.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_isCelestial</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="c1"># CelestialWCS classes still have origin, but not world_origin.</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">x0</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The x coordinate of self.origin.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">origin</span><span class="o">.</span><span class="n">x</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">y0</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The y coordinate of self.origin.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">origin</span><span class="o">.</span><span class="n">y</span>

<div class="viewcode-block" id="CelestialWCS.xyToradec"><a class="viewcode-back" href="../../wcs.html#galsim.CelestialWCS.xyToradec">[docs]</a>    <span class="k">def</span> <span class="nf">xyToradec</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">units</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert x,y from image coordinates to world coordinates.</span>

<span class="sd">        This is equivalent to ``wcs.toWorld(x,y, units=units)``.</span>

<span class="sd">        It is also equivalent to ``wcs.posToWorld(galsim.PositionD(x,y)).rad`` when x and y are</span>
<span class="sd">        scalars if units is &#39;radians&#39;; however, this routine allows x and y to be numpy arrays,</span>
<span class="sd">        in which case, the calculation will be vectorized, which is often much faster than using</span>
<span class="sd">        the pos interface.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            x:          The x value(s) in image coordinates</span>
<span class="sd">            y:          The y value(s) in image coordinates</span>
<span class="sd">            units:      (Only valid for `CelestialWCS`, in which case it is required)</span>
<span class="sd">                        The units to use for the returned ra, dec values.</span>
<span class="sd">            color:      For color-dependent WCS&#39;s, the color term to use. [default: None]</span>

<span class="sd">        Returns:</span>
<span class="sd">            ra, dec</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.angle</span> <span class="kn">import</span> <span class="n">AngleUnit</span>
        <span class="k">if</span> <span class="n">color</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">color</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_color</span>
        <span class="k">if</span> <span class="n">units</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;units is required for CelestialWCS types&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">units</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">units</span> <span class="o">=</span> <span class="n">AngleUnit</span><span class="o">.</span><span class="n">from_name</span><span class="p">(</span><span class="n">units</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">units</span><span class="p">,</span> <span class="n">AngleUnit</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">GalSimValueError</span><span class="p">(</span><span class="s2">&quot;units must be either an AngleUnit or a string&quot;</span><span class="p">,</span> <span class="n">units</span><span class="p">,</span>
                                    <span class="n">AngleUnit</span><span class="o">.</span><span class="n">valid_names</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xyToradec</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">units</span><span class="p">,</span> <span class="n">color</span><span class="p">)</span></div>

<div class="viewcode-block" id="CelestialWCS.radecToxy"><a class="viewcode-back" href="../../wcs.html#galsim.CelestialWCS.radecToxy">[docs]</a>    <span class="k">def</span> <span class="nf">radecToxy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ra</span><span class="p">,</span> <span class="n">dec</span><span class="p">,</span> <span class="n">units</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert ra,dec from world coordinates to image coordinates.</span>

<span class="sd">        This is equivalent to ``wcs.toWorld(ra,dec, units=units)``.</span>

<span class="sd">        It is also equivalent to ``wcs.posToImage(galsim.CelestialCoord(ra * units, dec * units))``</span>
<span class="sd">        when ra and dec are scalars; however, this routine allows ra and dec to be numpy arrays,</span>
<span class="sd">        in which case, the calculation will be vectorized, which is often much faster than using</span>
<span class="sd">        the pos interface.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            ra:         The ra value(s) in world coordinates</span>
<span class="sd">            dec:        The dec value(s) in world coordinates</span>
<span class="sd">            units:      The units to use for the input ra, dec values.</span>
<span class="sd">            color:      For color-dependent WCS&#39;s, the color term to use. [default: None]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.angle</span> <span class="kn">import</span> <span class="n">AngleUnit</span>
        <span class="k">if</span> <span class="n">color</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">color</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_color</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">units</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">units</span> <span class="o">=</span> <span class="n">AngleUnit</span><span class="o">.</span><span class="n">from_name</span><span class="p">(</span><span class="n">units</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">units</span><span class="p">,</span> <span class="n">AngleUnit</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">GalSimValueError</span><span class="p">(</span><span class="s2">&quot;units must be either an AngleUnit or a string&quot;</span><span class="p">,</span> <span class="n">units</span><span class="p">,</span>
                                    <span class="n">AngleUnit</span><span class="o">.</span><span class="n">valid_names</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_radecToxy</span><span class="p">(</span><span class="n">ra</span><span class="p">,</span> <span class="n">dec</span><span class="p">,</span> <span class="n">units</span><span class="p">,</span> <span class="n">color</span><span class="p">)</span></div>

    <span class="c1"># This is a bit simpler than the EuclideanWCS version, since there is no world_origin.</span>
    <span class="k">def</span> <span class="nf">_shiftOrigin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">origin</span><span class="p">,</span> <span class="n">world_origin</span><span class="p">,</span> <span class="n">color</span><span class="p">):</span>
        <span class="c1"># We want the new wcs to have wcs.toWorld(x2,y2) match the current wcs.toWorld(0,0).</span>
        <span class="c1"># So,</span>
        <span class="c1">#</span>
        <span class="c1">#     u&#39; = ufunc(x-x1, y-y1)        # In this case, there are no u0,v0</span>
        <span class="c1">#     v&#39; = vfunc(x-x1, y-y1)</span>
        <span class="c1">#</span>
        <span class="c1">#     u&#39;(x2,y2) = u(0,0)    v&#39;(x2,y2) = v(0,0)</span>
        <span class="c1">#</span>
        <span class="c1">#     x2 - x1 = 0 - x0      y2 - y1 = 0 - y0</span>
        <span class="c1"># =&gt;  x1 = x0 + x2          y1 = y0 + y2</span>
        <span class="k">if</span> <span class="n">world_origin</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;world_origin is invalid for CelestialWCS classes&quot;</span><span class="p">)</span>
        <span class="n">origin</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">origin</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_newOrigin</span><span class="p">(</span><span class="n">origin</span><span class="p">)</span>

    <span class="c1"># If the class doesn&#39;t define something else, then we can approximate the local Jacobian</span>
    <span class="c1"># from finite differences for the derivatives of ra and dec.  Very similar to the</span>
    <span class="c1"># version for EuclideanWCS, but convert from dra, ddec to du, dv locallat at the given</span>
    <span class="c1"># position.</span>
    <span class="k">def</span> <span class="nf">_local</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">image_pos</span><span class="p">,</span> <span class="n">color</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">.angle</span> <span class="kn">import</span> <span class="n">radians</span><span class="p">,</span> <span class="n">arcsec</span>

        <span class="k">if</span> <span class="n">image_pos</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;origin must be a PositionD or PositionI argument&quot;</span><span class="p">)</span>

        <span class="n">x0</span> <span class="o">=</span> <span class="n">image_pos</span><span class="o">.</span><span class="n">x</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">x0</span>
        <span class="n">y0</span> <span class="o">=</span> <span class="n">image_pos</span><span class="o">.</span><span class="n">y</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">y0</span>
        <span class="c1"># Use dx,dy = 1 pixel for numerical derivatives</span>
        <span class="n">dx</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">dy</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="n">xlist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span> <span class="n">x0</span><span class="p">,</span> <span class="n">x0</span><span class="o">+</span><span class="n">dx</span><span class="p">,</span> <span class="n">x0</span><span class="o">-</span><span class="n">dx</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span>    <span class="n">x0</span>    <span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">ylist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span> <span class="n">y0</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span>    <span class="n">y0</span><span class="p">,</span>    <span class="n">y0</span><span class="o">+</span><span class="n">dy</span><span class="p">,</span> <span class="n">y0</span><span class="o">-</span><span class="n">dy</span> <span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">ra</span><span class="p">,</span> <span class="n">dec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_radec</span><span class="p">(</span><span class="n">xlist</span><span class="p">,</span><span class="n">ylist</span><span class="p">,</span><span class="n">color</span><span class="p">)</span>

        <span class="c1"># Note: our convention is that ra increases to the left!</span>
        <span class="c1"># i.e. The u,v plane is the tangent plane as seen from Earth with +v pointing</span>
        <span class="c1"># north, and +u pointing west.</span>
        <span class="c1"># That means the du values are the negative of dra.</span>
        <span class="n">cosdec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">dec</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">dudx</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">ra</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">ra</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">/</span> <span class="n">dx</span> <span class="o">*</span> <span class="n">cosdec</span>
        <span class="n">dudy</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">ra</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">-</span> <span class="n">ra</span><span class="p">[</span><span class="mi">4</span><span class="p">])</span> <span class="o">/</span> <span class="n">dy</span> <span class="o">*</span> <span class="n">cosdec</span>
        <span class="n">dvdx</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">dec</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">dec</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">/</span> <span class="n">dx</span>
        <span class="n">dvdy</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">dec</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">-</span> <span class="n">dec</span><span class="p">[</span><span class="mi">4</span><span class="p">])</span> <span class="o">/</span> <span class="n">dy</span>

        <span class="c1"># These values are all in radians.  Convert to arcsec as per our usual standard.</span>
        <span class="n">factor</span> <span class="o">=</span> <span class="n">radians</span> <span class="o">/</span> <span class="n">arcsec</span>
        <span class="k">return</span> <span class="n">JacobianWCS</span><span class="p">(</span><span class="n">dudx</span><span class="o">*</span><span class="n">factor</span><span class="p">,</span> <span class="n">dudy</span><span class="o">*</span><span class="n">factor</span><span class="p">,</span> <span class="n">dvdx</span><span class="o">*</span><span class="n">factor</span><span class="p">,</span> <span class="n">dvdy</span><span class="o">*</span><span class="n">factor</span><span class="p">)</span>

    <span class="c1"># This is similar to the version for EuclideanWCS, but uses dra, ddec.</span>
    <span class="c1"># Again, it is much faster if the _radec function works with numpy arrays.</span>
    <span class="k">def</span> <span class="nf">_makeSkyImage</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span> <span class="n">sky_level</span><span class="p">,</span> <span class="n">color</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">.angle</span> <span class="kn">import</span> <span class="n">radians</span><span class="p">,</span> <span class="n">arcsec</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">bounds</span>
        <span class="n">nx</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">xmax</span><span class="o">-</span><span class="n">b</span><span class="o">.</span><span class="n">xmin</span><span class="o">+</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span>  <span class="c1"># +2 more than in image to get row/col off each edge.</span>
        <span class="n">ny</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">ymax</span><span class="o">-</span><span class="n">b</span><span class="o">.</span><span class="n">ymin</span><span class="o">+</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span>
        <span class="n">x</span><span class="p">,</span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">xmin</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">b</span><span class="o">.</span><span class="n">xmax</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">nx</span><span class="p">),</span>
                           <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">ymin</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">b</span><span class="o">.</span><span class="n">ymax</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">ny</span><span class="p">)</span> <span class="p">)</span>
        <span class="n">x</span> <span class="o">-=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x0</span>
        <span class="n">y</span> <span class="o">-=</span> <span class="bp">self</span><span class="o">.</span><span class="n">y0</span>
        <span class="n">ra</span><span class="p">,</span> <span class="n">dec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_radec</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span><span class="n">y</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span><span class="n">color</span><span class="p">)</span>
        <span class="n">ra</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">ra</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">dec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">dec</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

        <span class="c1"># Use the finite differences to estimate the derivatives.</span>
        <span class="n">cosdec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">dec</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">ny</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="n">nx</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">dudx</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">ra</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">ny</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">:</span><span class="n">nx</span><span class="p">]</span> <span class="o">-</span> <span class="n">ra</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">ny</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">:</span><span class="n">nx</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span>
        <span class="n">dudy</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">ra</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="n">ny</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="n">nx</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">ra</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">ny</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="n">nx</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="c1"># Check for discontinuities in ra.  ra can jump by 2pi, so when it does</span>
        <span class="c1"># add (or subtract) pi to dudx, which is dra/2</span>
        <span class="n">dudx</span><span class="p">[</span><span class="n">dudx</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
        <span class="n">dudx</span><span class="p">[</span><span class="n">dudx</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
        <span class="n">dudy</span><span class="p">[</span><span class="n">dudy</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
        <span class="n">dudy</span><span class="p">[</span><span class="n">dudy</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
        <span class="c1"># Now account for the cosdec factor</span>
        <span class="n">dudx</span> <span class="o">*=</span> <span class="n">cosdec</span>
        <span class="n">dudy</span> <span class="o">*=</span> <span class="n">cosdec</span>
        <span class="n">dvdx</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">dec</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">ny</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">:</span><span class="n">nx</span><span class="p">]</span> <span class="o">-</span> <span class="n">dec</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">ny</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">:</span><span class="n">nx</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span>
        <span class="n">dvdy</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">dec</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="n">ny</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="n">nx</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">dec</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">ny</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="n">nx</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="n">area</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">dudx</span> <span class="o">*</span> <span class="n">dvdy</span> <span class="o">-</span> <span class="n">dvdx</span> <span class="o">*</span> <span class="n">dudy</span><span class="p">)</span>
        <span class="n">factor</span> <span class="o">=</span> <span class="n">radians</span> <span class="o">/</span> <span class="n">arcsec</span>
        <span class="n">image</span><span class="o">.</span><span class="n">array</span><span class="p">[:,:]</span> <span class="o">=</span> <span class="n">area</span> <span class="o">*</span> <span class="n">sky_level</span> <span class="o">*</span> <span class="n">factor</span><span class="o">**</span><span class="mi">2</span>


    <span class="c1"># Simple.  Just call _radec.</span>
    <span class="k">def</span> <span class="nf">_posToWorld</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">image_pos</span><span class="p">,</span> <span class="n">color</span><span class="p">,</span> <span class="n">project_center</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">projection</span><span class="o">=</span><span class="s1">&#39;gnomonic&#39;</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">.angle</span> <span class="kn">import</span> <span class="n">radians</span><span class="p">,</span> <span class="n">arcsec</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">image_pos</span><span class="o">.</span><span class="n">x</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">x0</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">image_pos</span><span class="o">.</span><span class="n">y</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">y0</span>
        <span class="n">ra</span><span class="p">,</span> <span class="n">dec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_radec</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">color</span><span class="p">)</span>
        <span class="n">coord</span> <span class="o">=</span> <span class="n">CelestialCoord</span><span class="p">(</span><span class="n">ra</span><span class="o">*</span><span class="n">radians</span><span class="p">,</span> <span class="n">dec</span><span class="o">*</span><span class="n">radians</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">project_center</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">coord</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">u</span><span class="p">,</span><span class="n">v</span> <span class="o">=</span> <span class="n">project_center</span><span class="o">.</span><span class="n">project</span><span class="p">(</span><span class="n">coord</span><span class="p">,</span> <span class="n">projection</span><span class="o">=</span><span class="n">projection</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">_PositionD</span><span class="p">(</span><span class="n">u</span><span class="o">/</span><span class="n">arcsec</span><span class="p">,</span> <span class="n">v</span><span class="o">/</span><span class="n">arcsec</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_xyToradec</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">units</span><span class="p">,</span> <span class="n">color</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">.angle</span> <span class="kn">import</span> <span class="n">radians</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">x0</span>  <span class="c1"># Not -=, since don&#39;t want to modify the input arrays in place.</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">y</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">y0</span>
        <span class="n">ra</span><span class="p">,</span> <span class="n">dec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_radec</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">color</span><span class="p">)</span>
        <span class="n">ra</span> <span class="o">*=</span> <span class="n">radians</span> <span class="o">/</span> <span class="n">units</span>
        <span class="n">dec</span> <span class="o">*=</span> <span class="n">radians</span> <span class="o">/</span> <span class="n">units</span>
        <span class="k">return</span> <span class="n">ra</span><span class="p">,</span> <span class="n">dec</span>

    <span class="c1"># Also simple if _xy is implemented.  However, it is allowed to raise a NotImplementedError.</span>
    <span class="k">def</span> <span class="nf">_posToImage</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">world_pos</span><span class="p">,</span> <span class="n">color</span><span class="p">):</span>
        <span class="n">ra</span> <span class="o">=</span> <span class="n">world_pos</span><span class="o">.</span><span class="n">ra</span><span class="o">.</span><span class="n">rad</span>
        <span class="n">dec</span> <span class="o">=</span> <span class="n">world_pos</span><span class="o">.</span><span class="n">dec</span><span class="o">.</span><span class="n">rad</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xy</span><span class="p">(</span><span class="n">ra</span><span class="p">,</span><span class="n">dec</span><span class="p">,</span><span class="n">color</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_PositionD</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">origin</span>

    <span class="k">def</span> <span class="nf">_radecToxy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ra</span><span class="p">,</span> <span class="n">dec</span><span class="p">,</span> <span class="n">units</span><span class="p">,</span> <span class="n">color</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">.angle</span> <span class="kn">import</span> <span class="n">radians</span>
        <span class="n">ra</span> <span class="o">=</span> <span class="n">ra</span> <span class="o">*</span> <span class="p">(</span><span class="n">units</span> <span class="o">/</span> <span class="n">radians</span><span class="p">)</span>
        <span class="n">dec</span> <span class="o">=</span> <span class="n">dec</span> <span class="o">*</span> <span class="p">(</span><span class="n">units</span> <span class="o">/</span> <span class="n">radians</span><span class="p">)</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xy</span><span class="p">(</span><span class="n">ra</span><span class="p">,</span><span class="n">dec</span><span class="p">,</span><span class="n">color</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">origin</span><span class="o">.</span><span class="n">x</span>
        <span class="n">y</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">origin</span><span class="o">.</span><span class="n">y</span>
        <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>

    <span class="c1"># Each class should define the __eq__ function.  Then __ne__ is obvious.</span>
    <span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span> <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__eq__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span></div>



<span class="c1">#########################################################################################</span>
<span class="c1">#</span>
<span class="c1"># Local WCS classes are those where (x,y) = (0,0) corresponds to (u,v) = (0,0).</span>
<span class="c1">#</span>
<span class="c1"># We have the following local WCS classes:</span>
<span class="c1">#</span>
<span class="c1">#     PixelScale</span>
<span class="c1">#     ShearWCS</span>
<span class="c1">#     JacobianWCS</span>
<span class="c1">#</span>
<span class="c1"># They must define the following:</span>
<span class="c1">#</span>
<span class="c1">#     origin            attribute or property returning the origin</span>
<span class="c1">#     world_origin      attribute or property returning the world origin</span>
<span class="c1">#     _u                function returning u(x,y)</span>
<span class="c1">#     _v                function returning v(x,y)</span>
<span class="c1">#     _x                function returning x(u,v)</span>
<span class="c1">#     _y                function returning y(u,v)</span>
<span class="c1">#     _profileToWorld   function converting image_profile to world_profile</span>
<span class="c1">#     _profileToImage   function converting world_profile to image_profile</span>
<span class="c1">#     _pixelArea        function returning the pixel area</span>
<span class="c1">#     _minScale         function returning the minimum linear pixel scale</span>
<span class="c1">#     _maxScale         function returning the maximum linear pixel scale</span>
<span class="c1">#     _toJacobian       function returning an equivalent JacobianWCS</span>
<span class="c1">#     _writeHeader      function that writes the WCS to a fits header.</span>
<span class="c1">#     _readHeader       static function that reads the WCS from a fits header.</span>
<span class="c1">#     _newOrigin        function returning a non-local WCS corresponding to this WCS</span>
<span class="c1">#     copy              return a copy</span>
<span class="c1">#     __eq__            check if this equals another WCS</span>
<span class="c1">#     __repr__          convert to string</span>
<span class="c1">#</span>
<span class="c1">#########################################################################################</span>

<div class="viewcode-block" id="PixelScale"><a class="viewcode-back" href="../../wcs.html#galsim.PixelScale">[docs]</a><span class="k">class</span> <span class="nc">PixelScale</span><span class="p">(</span><span class="n">LocalWCS</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;This is the simplest possible WCS transformation.  It only involves a unit conversion</span>
<span class="sd">    from pixels to arcsec (or whatever units you want to take for your world coordinate system).</span>

<span class="sd">    The conversion functions are:</span>

<span class="sd">        u = x * scale</span>
<span class="sd">        v = y * scale</span>

<span class="sd">    A PixelScale is initialized with the command::</span>

<span class="sd">        &gt;&gt;&gt; wcs = galsim.PixelScale(scale)</span>

<span class="sd">    Parameters:</span>
<span class="sd">        scale:  The pixel scale, typically in units of arcsec/pixel.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_req_params</span> <span class="o">=</span> <span class="p">{</span> <span class="s2">&quot;scale&quot;</span> <span class="p">:</span> <span class="nb">float</span> <span class="p">}</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scale</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_color</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_scale</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">scale</span><span class="p">)</span>

    <span class="c1"># Help make sure PixelScale is read-only.</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">scale</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The pixel scale</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scale</span>

    <span class="nd">@lazy_property</span>
    <span class="k">def</span> <span class="nf">_invscale</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="mf">1.</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">_scale</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_isPixelScale</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">_u</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scale</span>

    <span class="k">def</span> <span class="nf">_v</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">y</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scale</span>

    <span class="k">def</span> <span class="nf">_x</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">u</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_invscale</span>

    <span class="k">def</span> <span class="nf">_y</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">v</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_invscale</span>

    <span class="k">def</span> <span class="nf">_profileToWorld</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">image_profile</span><span class="p">,</span> <span class="n">flux_ratio</span><span class="p">,</span> <span class="n">offset</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">.transform</span> <span class="kn">import</span> <span class="n">_Transform</span><span class="p">,</span> <span class="n">Transform</span>
        <span class="c1"># In the usual case of GSObject, it&#39;s more efficient to use the _Transform version.</span>
        <span class="c1"># else, it&#39;s a ChromaticObject, and we need to use the regular Transform function.</span>
        <span class="n">Transform</span> <span class="o">=</span> <span class="n">_Transform</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">image_profile</span><span class="p">,</span> <span class="n">GSObject</span><span class="p">)</span> <span class="k">else</span> <span class="n">Transform</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scale</span> <span class="o">==</span> <span class="mf">1.</span><span class="p">:</span>
            <span class="n">j</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">j</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(((</span><span class="bp">self</span><span class="o">.</span><span class="n">_scale</span><span class="p">,</span> <span class="mf">0.</span><span class="p">),</span> <span class="p">(</span><span class="mf">0.</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scale</span><span class="p">)))</span>
        <span class="k">return</span> <span class="n">Transform</span><span class="p">(</span><span class="n">image_profile</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">flux_ratio</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_invscale</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">flux_ratio</span><span class="p">,</span>
                         <span class="n">offset</span><span class="o">=</span><span class="p">(</span><span class="n">offset</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">offset</span><span class="o">.</span><span class="n">y</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_profileToImage</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">world_profile</span><span class="p">,</span> <span class="n">flux_ratio</span><span class="p">,</span> <span class="n">offset</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">.transform</span> <span class="kn">import</span> <span class="n">_Transform</span><span class="p">,</span> <span class="n">Transform</span>
        <span class="n">Transform</span> <span class="o">=</span> <span class="n">_Transform</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">world_profile</span><span class="p">,</span> <span class="n">GSObject</span><span class="p">)</span> <span class="k">else</span> <span class="n">Transform</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scale</span> <span class="o">==</span> <span class="mf">1.</span><span class="p">:</span>
            <span class="n">j</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">j</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(((</span><span class="bp">self</span><span class="o">.</span><span class="n">_invscale</span><span class="p">,</span> <span class="mf">0.</span><span class="p">),</span> <span class="p">(</span><span class="mf">0.</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_invscale</span><span class="p">)))</span>
        <span class="k">return</span> <span class="n">Transform</span><span class="p">(</span><span class="n">world_profile</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">flux_ratio</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_scale</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">flux_ratio</span><span class="p">,</span>
                         <span class="n">offset</span><span class="o">=</span><span class="p">(</span><span class="n">offset</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">offset</span><span class="o">.</span><span class="n">y</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_pixelArea</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scale</span><span class="o">**</span><span class="mi">2</span>

    <span class="k">def</span> <span class="nf">_minScale</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scale</span>

    <span class="k">def</span> <span class="nf">_maxScale</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scale</span>

    <span class="k">def</span> <span class="nf">_inverse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">PixelScale</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_invscale</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_toJacobian</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">JacobianWCS</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_scale</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scale</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_writeHeader</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">header</span><span class="p">,</span> <span class="n">bounds</span><span class="p">):</span>
        <span class="n">header</span><span class="p">[</span><span class="s2">&quot;GS_WCS&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;PixelScale&quot;</span><span class="p">,</span> <span class="s2">&quot;GalSim WCS name&quot;</span><span class="p">)</span>
        <span class="n">header</span><span class="p">[</span><span class="s2">&quot;GS_SCALE&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">,</span> <span class="s2">&quot;GalSim image scale&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">affine</span><span class="p">()</span><span class="o">.</span><span class="n">_writeLinearWCS</span><span class="p">(</span><span class="n">header</span><span class="p">,</span> <span class="n">bounds</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_readHeader</span><span class="p">(</span><span class="n">header</span><span class="p">):</span>
        <span class="n">scale</span> <span class="o">=</span> <span class="n">header</span><span class="p">[</span><span class="s2">&quot;GS_SCALE&quot;</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">PixelScale</span><span class="p">(</span><span class="n">scale</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_newOrigin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">origin</span><span class="p">,</span> <span class="n">world_origin</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">OffsetWCS</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_scale</span><span class="p">,</span> <span class="n">origin</span><span class="p">,</span> <span class="n">world_origin</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">PixelScale</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_scale</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span> <span class="ow">is</span> <span class="n">other</span> <span class="ow">or</span>
                <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">PixelScale</span><span class="p">)</span> <span class="ow">and</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">scale</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">scale</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="s2">&quot;galsim.PixelScale(</span><span class="si">%r</span><span class="s2">)&quot;</span><span class="o">%</span><span class="bp">self</span><span class="o">.</span><span class="n">scale</span>
    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="nb">hash</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span></div>


<div class="viewcode-block" id="ShearWCS"><a class="viewcode-back" href="../../wcs.html#galsim.ShearWCS">[docs]</a><span class="k">class</span> <span class="nc">ShearWCS</span><span class="p">(</span><span class="n">LocalWCS</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;This WCS is a uniformly sheared coordinate system.</span>

<span class="sd">    The shear is given as the shape that a round object has when observed in image coordinates.</span>

<span class="sd">    The conversion functions in terms of (g1,g2) are therefore:</span>

<span class="sd">        x = (u + g1 u + g2 v) / scale / sqrt(1-g1**2-g2**2)</span>
<span class="sd">        y = (v - g1 v + g2 u) / scale / sqrt(1-g1**2-g2**2)</span>

<span class="sd">    or, writing this in the usual way of (u,v) as a function of (x,y):</span>

<span class="sd">        u = (x - g1 x - g2 y) * scale / sqrt(1-g1**2-g2**2)</span>
<span class="sd">        v = (y + g1 y - g2 x) * scale / sqrt(1-g1**2-g2**2)</span>

<span class="sd">    A ShearWCS is initialized with the command::</span>

<span class="sd">        &gt;&gt;&gt; wcs = galsim.ShearWCS(scale, shear)</span>

<span class="sd">    Parameters:</span>
<span class="sd">        scale:      The pixel scale, typically in units of arcsec/pixel.</span>
<span class="sd">        shear:      The shear, which should be a `Shear` instance.</span>

<span class="sd">    The Shear transformation conserves object area, so if the input ``scale == 1`` then the</span>
<span class="sd">    transformation represented by the ShearWCS will conserve object area also.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_req_params</span> <span class="o">=</span> <span class="p">{</span> <span class="s2">&quot;scale&quot;</span> <span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="s2">&quot;shear&quot;</span> <span class="p">:</span> <span class="n">Shear</span> <span class="p">}</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scale</span><span class="p">,</span> <span class="n">shear</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_color</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_scale</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">scale</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_shear</span> <span class="o">=</span> <span class="n">shear</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_g1</span> <span class="o">=</span> <span class="n">shear</span><span class="o">.</span><span class="n">g1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_g2</span> <span class="o">=</span> <span class="n">shear</span><span class="o">.</span><span class="n">g2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_gsq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_g1</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_g2</span><span class="o">**</span><span class="mi">2</span>
        <span class="kn">import</span> <span class="nn">math</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_gfactor</span> <span class="o">=</span> <span class="mf">1.</span> <span class="o">/</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">1.</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gsq</span><span class="p">)</span>

    <span class="c1"># Help make sure ShearWCS is read-only.</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">scale</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The pixel scale.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scale</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">shear</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The applied `Shear`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shear</span>

    <span class="k">def</span> <span class="nf">_u</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">_g1</span><span class="p">)</span> <span class="o">-</span> <span class="n">y</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_g2</span>
        <span class="n">u</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gfactor</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scale</span>
        <span class="k">return</span> <span class="n">u</span>

    <span class="k">def</span> <span class="nf">_v</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">y</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">_g1</span><span class="p">)</span> <span class="o">-</span> <span class="n">x</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_g2</span>
        <span class="n">v</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gfactor</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scale</span>
        <span class="k">return</span> <span class="n">v</span>

    <span class="k">def</span> <span class="nf">_x</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">u</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">_g1</span><span class="p">)</span> <span class="o">+</span> <span class="n">v</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_g2</span>
        <span class="n">x</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gfactor</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scale</span>
        <span class="k">return</span> <span class="n">x</span>

    <span class="k">def</span> <span class="nf">_y</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">v</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">_g1</span><span class="p">)</span> <span class="o">+</span> <span class="n">u</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_g2</span>
        <span class="n">y</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gfactor</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scale</span>
        <span class="k">return</span> <span class="n">y</span>

    <span class="k">def</span> <span class="nf">_profileToWorld</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">image_profile</span><span class="p">,</span> <span class="n">flux_ratio</span><span class="p">,</span> <span class="n">offset</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">image_profile</span><span class="o">.</span><span class="n">dilate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_scale</span><span class="p">)</span><span class="o">.</span><span class="n">shear</span><span class="p">(</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">shear</span><span class="p">)</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span><span class="n">offset</span><span class="p">)</span> <span class="o">*</span> <span class="n">flux_ratio</span>

    <span class="k">def</span> <span class="nf">_profileToImage</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">world_profile</span><span class="p">,</span> <span class="n">flux_ratio</span><span class="p">,</span> <span class="n">offset</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">world_profile</span><span class="o">.</span><span class="n">dilate</span><span class="p">(</span><span class="mf">1.</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">_scale</span><span class="p">)</span><span class="o">.</span><span class="n">shear</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shear</span><span class="p">)</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span><span class="n">offset</span><span class="p">)</span> <span class="o">*</span> <span class="n">flux_ratio</span>

    <span class="k">def</span> <span class="nf">_pixelArea</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scale</span><span class="o">**</span><span class="mi">2</span>

    <span class="k">def</span> <span class="nf">_minScale</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># min stretch is (1-|g|) / sqrt(1-|g|^2)</span>
        <span class="kn">import</span> <span class="nn">math</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scale</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.</span> <span class="o">-</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_gsq</span><span class="p">))</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gfactor</span>

    <span class="k">def</span> <span class="nf">_maxScale</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># max stretch is (1+|g|) / sqrt(1-|g|^2)</span>
        <span class="kn">import</span> <span class="nn">math</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scale</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.</span> <span class="o">+</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_gsq</span><span class="p">))</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gfactor</span>

    <span class="k">def</span> <span class="nf">_inverse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">ShearWCS</span><span class="p">(</span><span class="mf">1.</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">_scale</span><span class="p">,</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">_shear</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_toJacobian</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">JacobianWCS</span><span class="p">(</span>
            <span class="p">(</span><span class="mf">1.</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">_g1</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scale</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gfactor</span><span class="p">,</span>
            <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">_g2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scale</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gfactor</span><span class="p">,</span>
            <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">_g2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scale</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gfactor</span><span class="p">,</span>
            <span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">_g1</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scale</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gfactor</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_writeHeader</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">header</span><span class="p">,</span> <span class="n">bounds</span><span class="p">):</span>
        <span class="n">header</span><span class="p">[</span><span class="s2">&quot;GS_WCS&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;ShearWCS&quot;</span><span class="p">,</span> <span class="s2">&quot;GalSim WCS name&quot;</span><span class="p">)</span>
        <span class="n">header</span><span class="p">[</span><span class="s2">&quot;GS_SCALE&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">,</span> <span class="s2">&quot;GalSim image scale&quot;</span><span class="p">)</span>
        <span class="n">header</span><span class="p">[</span><span class="s2">&quot;GS_G1&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shear</span><span class="o">.</span><span class="n">g1</span><span class="p">,</span> <span class="s2">&quot;GalSim image shear g1&quot;</span><span class="p">)</span>
        <span class="n">header</span><span class="p">[</span><span class="s2">&quot;GS_G2&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shear</span><span class="o">.</span><span class="n">g2</span><span class="p">,</span> <span class="s2">&quot;GalSim image shear g2&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">affine</span><span class="p">()</span><span class="o">.</span><span class="n">_writeLinearWCS</span><span class="p">(</span><span class="n">header</span><span class="p">,</span> <span class="n">bounds</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_readHeader</span><span class="p">(</span><span class="n">header</span><span class="p">):</span>
        <span class="n">scale</span> <span class="o">=</span> <span class="n">header</span><span class="p">[</span><span class="s2">&quot;GS_SCALE&quot;</span><span class="p">]</span>
        <span class="n">g1</span> <span class="o">=</span> <span class="n">header</span><span class="p">[</span><span class="s2">&quot;GS_G1&quot;</span><span class="p">]</span>
        <span class="n">g2</span> <span class="o">=</span> <span class="n">header</span><span class="p">[</span><span class="s2">&quot;GS_G2&quot;</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">ShearWCS</span><span class="p">(</span><span class="n">scale</span><span class="p">,</span> <span class="n">Shear</span><span class="p">(</span><span class="n">g1</span><span class="o">=</span><span class="n">g1</span><span class="p">,</span> <span class="n">g2</span><span class="o">=</span><span class="n">g2</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_newOrigin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">origin</span><span class="p">,</span> <span class="n">world_origin</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">OffsetShearWCS</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_scale</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shear</span><span class="p">,</span> <span class="n">origin</span><span class="p">,</span> <span class="n">world_origin</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">ShearWCS</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_scale</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shear</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span> <span class="ow">is</span> <span class="n">other</span> <span class="ow">or</span>
                <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">ShearWCS</span><span class="p">)</span> <span class="ow">and</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">scale</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">scale</span> <span class="ow">and</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">shear</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">shear</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="s2">&quot;galsim.ShearWCS(</span><span class="si">%r</span><span class="s2">, </span><span class="si">%r</span><span class="s2">)&quot;</span><span class="o">%</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">shear</span><span class="p">)</span>
    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="nb">hash</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span></div>


<div class="viewcode-block" id="JacobianWCS"><a class="viewcode-back" href="../../wcs.html#galsim.JacobianWCS">[docs]</a><span class="k">class</span> <span class="nc">JacobianWCS</span><span class="p">(</span><span class="n">LocalWCS</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;This WCS is the most general local linear WCS implementing a 2x2 Jacobian matrix.</span>

<span class="sd">    The conversion functions are:</span>

<span class="sd">        u = dudx x + dudy y</span>
<span class="sd">        v = dvdx x + dvdy y</span>

<span class="sd">    A JacobianWCS has attributes dudx, dudy, dvdx, dvdy that you can access directly if that</span>
<span class="sd">    is convenient.  You can also access these as a NumPy array directly with::</span>

<span class="sd">        &gt;&gt;&gt; J = jac_wcs.getMatrix()</span>

<span class="sd">    Also, JacobianWCS has another method that other WCS classes do not have. The call::</span>

<span class="sd">        &gt;&gt;&gt; scale, shear, theta, flip = jac_wcs.getDecomposition()</span>

<span class="sd">    will return the equivalent expansion, shear, rotation and possible flip corresponding to</span>
<span class="sd">    this transformation.  See the docstring for that method for more information.</span>

<span class="sd">    A JacobianWCS is initialized with the command::</span>

<span class="sd">        &gt;&gt;&gt; wcs = galsim.JacobianWCS(dudx, dudy, dvdx, dvdy)</span>

<span class="sd">    Parameters:</span>
<span class="sd">        dudx:       du/dx</span>
<span class="sd">        dudy:       du/dy</span>
<span class="sd">        dvdx:       dv/dx</span>
<span class="sd">        dvdy:       dv/dy</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_req_params</span> <span class="o">=</span> <span class="p">{</span> <span class="s2">&quot;dudx&quot;</span> <span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="s2">&quot;dudy&quot;</span> <span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="s2">&quot;dvdx&quot;</span> <span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="s2">&quot;dvdy&quot;</span> <span class="p">:</span> <span class="nb">float</span> <span class="p">}</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dudx</span><span class="p">,</span> <span class="n">dudy</span><span class="p">,</span> <span class="n">dvdx</span><span class="p">,</span> <span class="n">dvdy</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_color</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dudx</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">dudx</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dudy</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">dudy</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dvdx</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">dvdx</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dvdy</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">dvdy</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_det</span> <span class="o">=</span> <span class="n">dudx</span> <span class="o">*</span> <span class="n">dvdy</span> <span class="o">-</span> <span class="n">dudy</span> <span class="o">*</span> <span class="n">dvdx</span>

    <span class="c1"># Help make sure JacobianWCS is read-only.</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dudx</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;du/dx</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dudx</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dudy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;du/dy</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dudy</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dvdx</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;dv/dx</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dvdx</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dvdy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;dv/dy</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dvdy</span>

    <span class="k">def</span> <span class="nf">_u</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dudx</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dudy</span> <span class="o">*</span> <span class="n">y</span>

    <span class="k">def</span> <span class="nf">_v</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dvdx</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dvdy</span> <span class="o">*</span> <span class="n">y</span>

    <span class="k">def</span> <span class="nf">_x</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1">#  J = ( dudx  dudy )</span>
        <span class="c1">#      ( dvdx  dvdy )</span>
        <span class="c1">#  J^-1 = (1/det) (  dvdy  -dudy )</span>
        <span class="c1">#                 ( -dvdx   dudx )</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dvdy</span> <span class="o">*</span> <span class="n">u</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dudy</span> <span class="o">*</span> <span class="n">v</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_invdet</span>

    <span class="k">def</span> <span class="nf">_y</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">_dvdx</span> <span class="o">*</span> <span class="n">u</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dudx</span> <span class="o">*</span> <span class="n">v</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_invdet</span>

    <span class="k">def</span> <span class="nf">_profileToWorld</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">image_profile</span><span class="p">,</span> <span class="n">flux_ratio</span><span class="p">,</span> <span class="n">offset</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">.transform</span> <span class="kn">import</span> <span class="n">_Transform</span><span class="p">,</span> <span class="n">Transform</span>
        <span class="c1"># In the usual case of GSObject, it&#39;s more efficient to use the _Transform version.</span>
        <span class="c1"># else, it&#39;s a ChromaticObject, and we need to use the regular Transform function.</span>
        <span class="n">Transform</span> <span class="o">=</span> <span class="n">_Transform</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">image_profile</span><span class="p">,</span> <span class="n">GSObject</span><span class="p">)</span> <span class="k">else</span> <span class="n">Transform</span>
        <span class="n">j</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(((</span><span class="bp">self</span><span class="o">.</span><span class="n">_dudx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dudy</span><span class="p">),</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dvdx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dvdy</span><span class="p">)))</span>
        <span class="k">return</span> <span class="n">Transform</span><span class="p">(</span><span class="n">image_profile</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">flux_ratio</span><span class="o">=</span><span class="n">flux_ratio</span><span class="o">*</span><span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_invdet</span><span class="p">),</span>
                         <span class="n">offset</span><span class="o">=</span><span class="p">(</span><span class="n">offset</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">offset</span><span class="o">.</span><span class="n">y</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_profileToImage</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">world_profile</span><span class="p">,</span> <span class="n">flux_ratio</span><span class="p">,</span> <span class="n">offset</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">.transform</span> <span class="kn">import</span> <span class="n">_Transform</span><span class="p">,</span> <span class="n">Transform</span>
        <span class="n">Transform</span> <span class="o">=</span> <span class="n">_Transform</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">world_profile</span><span class="p">,</span> <span class="n">GSObject</span><span class="p">)</span> <span class="k">else</span> <span class="n">Transform</span>
        <span class="n">j</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(((</span><span class="bp">self</span><span class="o">.</span><span class="n">_dvdy</span><span class="p">,</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">_dudy</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">_dvdx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dudx</span><span class="p">)))</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_invdet</span>
        <span class="k">return</span> <span class="n">Transform</span><span class="p">(</span><span class="n">world_profile</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">flux_ratio</span><span class="o">=</span><span class="n">flux_ratio</span><span class="o">*</span><span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_det</span><span class="p">),</span>
                         <span class="n">offset</span><span class="o">=</span><span class="p">(</span><span class="n">offset</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">offset</span><span class="o">.</span><span class="n">y</span><span class="p">))</span>

    <span class="nd">@lazy_property</span>
    <span class="k">def</span> <span class="nf">_invdet</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="mf">1.</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">_det</span>
        <span class="k">except</span> <span class="ne">ZeroDivisionError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">GalSimError</span><span class="p">(</span><span class="s2">&quot;Transformation is singular&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_pixelArea</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_det</span><span class="p">)</span>

<div class="viewcode-block" id="JacobianWCS.getMatrix"><a class="viewcode-back" href="../../wcs.html#galsim.JacobianWCS.getMatrix">[docs]</a>    <span class="k">def</span> <span class="nf">getMatrix</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the Jacobian as a NumPy matrix:</span>

<span class="sd">                numpy.array( [[ dudx, dudy ],</span>
<span class="sd">                              [ dvdx, dvdy ]] )</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dudx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dudy</span> <span class="p">],</span>
                         <span class="p">[</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dvdx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dvdy</span> <span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span></div>

<div class="viewcode-block" id="JacobianWCS.getDecomposition"><a class="viewcode-back" href="../../wcs.html#galsim.JacobianWCS.getDecomposition">[docs]</a>    <span class="k">def</span> <span class="nf">getDecomposition</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the equivalent expansion, shear, rotation and possible flip corresponding to</span>
<span class="sd">        this Jacobian transformation.</span>

<span class="sd">        A non-singular real matrix can always be decomposed into a symmetric positive definite</span>
<span class="sd">        matrix times an orthogonal matrix:</span>

<span class="sd">            M = P Q</span>

<span class="sd">        In our case, P includes an overall scale and a shear, and Q is a rotation and possibly</span>
<span class="sd">        a flip of (x,y) -&gt; (y,x).</span>

<span class="sd">            ( dudx  dudy ) = scale/sqrt(1-g1^2-g2^2) ( 1+g1  g2  ) ( cos(theta)  -sin(theta) ) F</span>
<span class="sd">            ( dvdx  dvdy )                           (  g2  1-g1 ) ( sin(theta)   cos(theta) )</span>

<span class="sd">        where F is either the identity matrix, ( 1 0 ), or a flip matrix, ( 0 1 ).</span>
<span class="sd">                                               ( 0 1 )                    ( 1 0 )</span>

<span class="sd">        If there is no flip, then this means that the effect of::</span>

<span class="sd">            &gt;&gt;&gt; prof.transform(dudx, dudy, dvdx, dvdy)</span>

<span class="sd">        is equivalent to::</span>

<span class="sd">            &gt;&gt;&gt; prof.rotate(theta).shear(shear).expand(scale)</span>

<span class="sd">        in that order.  (Rotation and shear do not commute.)</span>

<span class="sd">        The decomposition is returned as a tuple: (scale, shear, theta, flip), where scale is a</span>
<span class="sd">        float, shear is a `Shear`, theta is an `Angle`, and flip is a bool.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">math</span>
        <span class="kn">from</span> <span class="nn">.angle</span> <span class="kn">import</span> <span class="n">radians</span>
        <span class="c1"># First we need to see whether or not the transformation includes a flip.  The evidence</span>
        <span class="c1"># for a flip is that the determinant is negative.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_det</span> <span class="o">==</span> <span class="mf">0.</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">GalSimError</span><span class="p">(</span><span class="s2">&quot;Transformation is singular&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_det</span> <span class="o">&lt;</span> <span class="mf">0.</span><span class="p">:</span>
            <span class="n">flip</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">scale</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">_det</span><span class="p">)</span>
            <span class="n">dudx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dudy</span>
            <span class="n">dudy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dudx</span>
            <span class="n">dvdx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dvdy</span>
            <span class="n">dvdy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dvdx</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">flip</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">scale</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_det</span><span class="p">)</span>
            <span class="n">dudx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dudx</span>
            <span class="n">dudy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dudy</span>
            <span class="n">dvdx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dvdx</span>
            <span class="n">dvdy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dvdy</span>

        <span class="c1"># A small bit of algebraic manipulations yield the following two equations that let us</span>
        <span class="c1"># determine theta:</span>
        <span class="c1">#</span>
        <span class="c1"># (dudx + dvdy) = 2 scale/sqrt(1-g^2) cos(t)</span>
        <span class="c1"># (dvdx - dudy) = 2 scale/sqrt(1-g^2) sin(t)</span>

        <span class="n">C</span> <span class="o">=</span> <span class="n">dudx</span> <span class="o">+</span> <span class="n">dvdy</span>
        <span class="n">S</span> <span class="o">=</span> <span class="n">dvdx</span> <span class="o">-</span> <span class="n">dudy</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">atan2</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="n">C</span><span class="p">)</span> <span class="o">*</span> <span class="n">radians</span>

        <span class="c1"># The next step uses the following equations that you can get from a bit more algebra:</span>
        <span class="c1">#</span>
        <span class="c1"># cost (dudx - dvdy) - sint (dudy + dvdx) = 2 scale/sqrt(1-g^2) g1</span>
        <span class="c1"># sint (dudx - dvdy) + cost (dudy + dvdx) = 2 scale/sqrt(1-g^2) g2</span>

        <span class="n">factor</span> <span class="o">=</span> <span class="n">C</span><span class="o">*</span><span class="n">C</span><span class="o">+</span><span class="n">S</span><span class="o">*</span><span class="n">S</span>    <span class="c1"># factor = (2 scale/sqrt(1-g^2))^2</span>
        <span class="n">C</span> <span class="o">/=</span> <span class="n">factor</span>         <span class="c1"># C is now cost / (2 scale/sqrt(1-g^2))</span>
        <span class="n">S</span> <span class="o">/=</span> <span class="n">factor</span>         <span class="c1"># S is now sint / (2 scale/sqrt(1-g^2))</span>

        <span class="n">g1</span> <span class="o">=</span> <span class="n">C</span><span class="o">*</span><span class="p">(</span><span class="n">dudx</span><span class="o">-</span><span class="n">dvdy</span><span class="p">)</span> <span class="o">-</span> <span class="n">S</span><span class="o">*</span><span class="p">(</span><span class="n">dudy</span><span class="o">+</span><span class="n">dvdx</span><span class="p">)</span>
        <span class="n">g2</span> <span class="o">=</span> <span class="n">S</span><span class="o">*</span><span class="p">(</span><span class="n">dudx</span><span class="o">-</span><span class="n">dvdy</span><span class="p">)</span> <span class="o">+</span> <span class="n">C</span><span class="o">*</span><span class="p">(</span><span class="n">dudy</span><span class="o">+</span><span class="n">dvdx</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">scale</span><span class="p">,</span> <span class="n">Shear</span><span class="p">(</span><span class="n">g1</span><span class="o">=</span><span class="n">g1</span><span class="p">,</span> <span class="n">g2</span><span class="o">=</span><span class="n">g2</span><span class="p">),</span> <span class="n">theta</span><span class="p">,</span> <span class="n">flip</span></div>

    <span class="k">def</span> <span class="nf">_minScale</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="kn">import</span> <span class="nn">math</span>
        <span class="c1"># min scale is scale * (1-|g|) / sqrt(1-|g|^2)</span>
        <span class="c1"># We could get this from the decomposition, but some algebra finds that this</span>
        <span class="c1"># reduces to the following calculation:</span>
        <span class="c1"># NB: The unit tests test for the equivalence with the above formula.</span>
        <span class="n">h1</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dudx</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dvdy</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dudy</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dvdx</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="p">)</span>
        <span class="n">h2</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dudx</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dvdy</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dudy</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dvdx</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="p">)</span>
        <span class="k">return</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="nb">abs</span><span class="p">(</span><span class="n">h1</span> <span class="o">-</span> <span class="n">h2</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_maxScale</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="kn">import</span> <span class="nn">math</span>
        <span class="c1"># min scale is scale * (1+|g|) / sqrt(1-|g|^2)</span>
        <span class="c1"># which is equivalent to the following:</span>
        <span class="c1"># NB: The unit tests test for the equivalence with the above formula.</span>
        <span class="n">h1</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dudx</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dvdy</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dudy</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dvdx</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="p">)</span>
        <span class="n">h2</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dudx</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dvdy</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dudy</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dvdx</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="p">)</span>
        <span class="k">return</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">h1</span> <span class="o">+</span> <span class="n">h2</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_inverse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">JacobianWCS</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dvdy</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_invdet</span><span class="p">,</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">_dudy</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_invdet</span><span class="p">,</span>
                           <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">_dvdx</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_invdet</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dudx</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_invdet</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_toJacobian</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">_writeHeader</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">header</span><span class="p">,</span> <span class="n">bounds</span><span class="p">):</span>
        <span class="n">header</span><span class="p">[</span><span class="s2">&quot;GS_WCS&quot;</span><span class="p">]</span>  <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;JacobianWCS&quot;</span><span class="p">,</span> <span class="s2">&quot;GalSim WCS name&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">affine</span><span class="p">()</span><span class="o">.</span><span class="n">_writeLinearWCS</span><span class="p">(</span><span class="n">header</span><span class="p">,</span> <span class="n">bounds</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_readHeader</span><span class="p">(</span><span class="n">header</span><span class="p">):</span>
        <span class="n">dudx</span> <span class="o">=</span> <span class="n">header</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;CD1_1&quot;</span><span class="p">,</span><span class="mf">1.</span><span class="p">)</span>
        <span class="n">dudy</span> <span class="o">=</span> <span class="n">header</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;CD1_2&quot;</span><span class="p">,</span><span class="mf">0.</span><span class="p">)</span>
        <span class="n">dvdx</span> <span class="o">=</span> <span class="n">header</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;CD2_1&quot;</span><span class="p">,</span><span class="mf">0.</span><span class="p">)</span>
        <span class="n">dvdy</span> <span class="o">=</span> <span class="n">header</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;CD2_2&quot;</span><span class="p">,</span><span class="mf">1.</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">JacobianWCS</span><span class="p">(</span><span class="n">dudx</span><span class="p">,</span> <span class="n">dudy</span><span class="p">,</span> <span class="n">dvdx</span><span class="p">,</span> <span class="n">dvdy</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_newOrigin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">origin</span><span class="p">,</span> <span class="n">world_origin</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">AffineTransform</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dudx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dudy</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dvdx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dvdy</span><span class="p">,</span> <span class="n">origin</span><span class="p">,</span>
                               <span class="n">world_origin</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">JacobianWCS</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dudx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dudy</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dvdx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dvdy</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span> <span class="ow">is</span> <span class="n">other</span> <span class="ow">or</span>
                <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">JacobianWCS</span><span class="p">)</span> <span class="ow">and</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">dudx</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">dudx</span> <span class="ow">and</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">dudy</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">dudy</span> <span class="ow">and</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">dvdx</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">dvdx</span> <span class="ow">and</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">dvdy</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">dvdy</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="s2">&quot;galsim.JacobianWCS(</span><span class="si">%r</span><span class="s2">, </span><span class="si">%r</span><span class="s2">, </span><span class="si">%r</span><span class="s2">, </span><span class="si">%r</span><span class="s2">)&quot;</span><span class="o">%</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dudx</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">dudy</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">dvdx</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">dvdy</span><span class="p">)</span>
    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="nb">hash</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span></div>


<span class="c1">#########################################################################################</span>
<span class="c1">#</span>
<span class="c1"># Non-local UniformWCS classes are those where (x,y) = (0,0) does not (necessarily)</span>
<span class="c1"># correspond to (u,v) = (0,0).</span>
<span class="c1">#</span>
<span class="c1"># We have the following non-local UniformWCS classes:</span>
<span class="c1">#</span>
<span class="c1">#     OffsetWCS</span>
<span class="c1">#     OffsetShearWCS</span>
<span class="c1">#     AffineTransform</span>
<span class="c1">#</span>
<span class="c1"># They must define the following:</span>
<span class="c1">#</span>
<span class="c1">#     origin            attribute or property returning the origin</span>
<span class="c1">#     world_origin      attribute or property returning the world origin</span>
<span class="c1">#     _local_wcs        property returning a local WCS with the same pixel shape</span>
<span class="c1">#     _writeHeader      function that writes the WCS to a fits header.</span>
<span class="c1">#     _readHeader       static function that reads the WCS from a fits header.</span>
<span class="c1">#     _newOrigin        function returning the saem WCS, but with new origin, world_origin</span>
<span class="c1">#     copy              return a copy</span>
<span class="c1">#     __repr__          convert to string</span>
<span class="c1">#</span>
<span class="c1">#########################################################################################</span>


<div class="viewcode-block" id="OffsetWCS"><a class="viewcode-back" href="../../wcs.html#galsim.OffsetWCS">[docs]</a><span class="k">class</span> <span class="nc">OffsetWCS</span><span class="p">(</span><span class="n">UniformWCS</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;This WCS is similar to `PixelScale`, except the origin is not necessarily (0,0) in both</span>
<span class="sd">    the image and world coordinates.</span>

<span class="sd">    The conversion functions are:</span>

<span class="sd">        u = (x-x0) * scale + u0</span>
<span class="sd">        v = (y-y0) * scale + v0</span>

<span class="sd">    An OffsetWCS is initialized with the command::</span>

<span class="sd">        &gt;&gt;&gt; wcs = galsim.OffsetWCS(scale, origin=None, world_origin=None)</span>

<span class="sd">    Parameters:</span>
<span class="sd">        scale:          The pixel scale, typically in units of arcsec/pixel.</span>
<span class="sd">        origin:         Optional origin position for the image coordinate system.</span>
<span class="sd">                        If provided, it should be a `PositionD` or `PositionI`.</span>
<span class="sd">                        [default: PositionD(0., 0.)]</span>
<span class="sd">        world_origin:   Optional origin position for the world coordinate system.</span>
<span class="sd">                        If provided, it should be a `PositionD`.</span>
<span class="sd">                        [default: galsim.PositionD(0., 0.)]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_req_params</span> <span class="o">=</span> <span class="p">{</span> <span class="s2">&quot;scale&quot;</span> <span class="p">:</span> <span class="nb">float</span> <span class="p">}</span>
    <span class="n">_opt_params</span> <span class="o">=</span> <span class="p">{</span> <span class="s2">&quot;origin&quot;</span> <span class="p">:</span> <span class="n">PositionD</span><span class="p">,</span> <span class="s2">&quot;world_origin&quot;</span><span class="p">:</span> <span class="n">PositionD</span> <span class="p">}</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scale</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">world_origin</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_color</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_origin</span><span class="p">(</span><span class="n">origin</span><span class="p">,</span> <span class="n">world_origin</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_scale</span> <span class="o">=</span> <span class="n">scale</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_local_wcs</span> <span class="o">=</span> <span class="n">PixelScale</span><span class="p">(</span><span class="n">scale</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">scale</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The pixel scale.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scale</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">origin</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The image coordinate position to use as the origin.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_origin</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">world_origin</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The world coordinate position to use as the origin.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_world_origin</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_isPixelScale</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">_writeHeader</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">header</span><span class="p">,</span> <span class="n">bounds</span><span class="p">):</span>
        <span class="n">header</span><span class="p">[</span><span class="s2">&quot;GS_WCS&quot;</span><span class="p">]</span>  <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;OffsetWCS&quot;</span><span class="p">,</span> <span class="s2">&quot;GalSim WCS name&quot;</span><span class="p">)</span>
        <span class="n">header</span><span class="p">[</span><span class="s2">&quot;GS_SCALE&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">,</span> <span class="s2">&quot;GalSim image scale&quot;</span><span class="p">)</span>
        <span class="n">header</span><span class="p">[</span><span class="s2">&quot;GS_X0&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">origin</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="s2">&quot;GalSim image origin x&quot;</span><span class="p">)</span>
        <span class="n">header</span><span class="p">[</span><span class="s2">&quot;GS_Y0&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">origin</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="s2">&quot;GalSim image origin y&quot;</span><span class="p">)</span>
        <span class="n">header</span><span class="p">[</span><span class="s2">&quot;GS_U0&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">world_origin</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="s2">&quot;GalSim world origin u&quot;</span><span class="p">)</span>
        <span class="n">header</span><span class="p">[</span><span class="s2">&quot;GS_V0&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">world_origin</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="s2">&quot;GalSim world origin v&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">affine</span><span class="p">()</span><span class="o">.</span><span class="n">_writeLinearWCS</span><span class="p">(</span><span class="n">header</span><span class="p">,</span> <span class="n">bounds</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_readHeader</span><span class="p">(</span><span class="n">header</span><span class="p">):</span>
        <span class="n">scale</span> <span class="o">=</span> <span class="n">header</span><span class="p">[</span><span class="s2">&quot;GS_SCALE&quot;</span><span class="p">]</span>
        <span class="n">x0</span> <span class="o">=</span> <span class="n">header</span><span class="p">[</span><span class="s2">&quot;GS_X0&quot;</span><span class="p">]</span>
        <span class="n">y0</span> <span class="o">=</span> <span class="n">header</span><span class="p">[</span><span class="s2">&quot;GS_Y0&quot;</span><span class="p">]</span>
        <span class="n">u0</span> <span class="o">=</span> <span class="n">header</span><span class="p">[</span><span class="s2">&quot;GS_U0&quot;</span><span class="p">]</span>
        <span class="n">v0</span> <span class="o">=</span> <span class="n">header</span><span class="p">[</span><span class="s2">&quot;GS_V0&quot;</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">OffsetWCS</span><span class="p">(</span><span class="n">scale</span><span class="p">,</span> <span class="n">_PositionD</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span><span class="n">y0</span><span class="p">),</span> <span class="n">_PositionD</span><span class="p">(</span><span class="n">u0</span><span class="p">,</span><span class="n">v0</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_newOrigin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">origin</span><span class="p">,</span> <span class="n">world_origin</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">OffsetWCS</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_scale</span><span class="p">,</span> <span class="n">origin</span><span class="p">,</span> <span class="n">world_origin</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">OffsetWCS</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_scale</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">origin</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">world_origin</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="s2">&quot;galsim.OffsetWCS(</span><span class="si">%r</span><span class="s2">, </span><span class="si">%r</span><span class="s2">, </span><span class="si">%r</span><span class="s2">)&quot;</span><span class="o">%</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">origin</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">world_origin</span><span class="p">)</span>
    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="nb">hash</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span></div>


<div class="viewcode-block" id="OffsetShearWCS"><a class="viewcode-back" href="../../wcs.html#galsim.OffsetShearWCS">[docs]</a><span class="k">class</span> <span class="nc">OffsetShearWCS</span><span class="p">(</span><span class="n">UniformWCS</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;This WCS is a uniformly sheared coordinate system with image and world origins</span>
<span class="sd">    that are not necessarily coincident.</span>

<span class="sd">    The conversion functions are:</span>

<span class="sd">        x = ( (1+g1) (u-u0) + g2 (v-v0) ) / scale / sqrt(1-g1**2-g2**2) + x0</span>
<span class="sd">        y = ( (1-g1) (v-v0) + g2 (u-u0) ) / scale / sqrt(1-g1**2-g2**2) + y0</span>

<span class="sd">        u = ( (1-g1) (x-x0) - g2 (y-y0) ) * scale / sqrt(1-g1**2-g2**2) + u0</span>
<span class="sd">        v = ( (1+g1) (y-y0) - g2 (x-x0) ) * scale / sqrt(1-g1**2-g2**2) + v0</span>

<span class="sd">    An OffsetShearWCS is initialized with the command::</span>

<span class="sd">        &gt;&gt;&gt; wcs = galsim.OffsetShearWCS(scale, shear, origin=None, world_origin=None)</span>

<span class="sd">    Parameters:</span>
<span class="sd">        scale:          The pixel scale, typically in units of arcsec/pixel.</span>
<span class="sd">        shear:          The shear, which should be a `Shear` instance.</span>
<span class="sd">        origin:         Optional origin position for the image coordinate system.</span>
<span class="sd">                        If provided, it should be a `PositionD` or `PositionI`.</span>
<span class="sd">                        [default: PositionD(0., 0.)]</span>
<span class="sd">        world_origin:   Optional origin position for the world coordinate system.</span>
<span class="sd">                        If provided, it should be a `PositionD`.</span>
<span class="sd">                        [default: PositionD(0., 0.)]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_req_params</span> <span class="o">=</span> <span class="p">{</span> <span class="s2">&quot;scale&quot;</span> <span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="s2">&quot;shear&quot;</span> <span class="p">:</span> <span class="n">Shear</span> <span class="p">}</span>
    <span class="n">_opt_params</span> <span class="o">=</span> <span class="p">{</span> <span class="s2">&quot;origin&quot;</span> <span class="p">:</span> <span class="n">PositionD</span><span class="p">,</span> <span class="s2">&quot;world_origin&quot;</span><span class="p">:</span> <span class="n">PositionD</span> <span class="p">}</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scale</span><span class="p">,</span> <span class="n">shear</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">world_origin</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_color</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_origin</span><span class="p">(</span><span class="n">origin</span><span class="p">,</span> <span class="n">world_origin</span><span class="p">)</span>
        <span class="c1"># The shear stuff is not too complicated, but enough so that it is worth</span>
        <span class="c1"># encapsulating in the ShearWCS class.  So here, we just create one of those</span>
        <span class="c1"># and we&#39;ll pass along any shear calculations to that.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_local_wcs</span> <span class="o">=</span> <span class="n">ShearWCS</span><span class="p">(</span><span class="n">scale</span><span class="p">,</span> <span class="n">shear</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">scale</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The pixel scale.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_local_wcs</span><span class="o">.</span><span class="n">scale</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">shear</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The applied `Shear`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_local_wcs</span><span class="o">.</span><span class="n">shear</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">origin</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The image coordinate position to use as the origin.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_origin</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">world_origin</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The world coordinate position to use as the origin.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_world_origin</span>

    <span class="k">def</span> <span class="nf">_writeHeader</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">header</span><span class="p">,</span> <span class="n">bounds</span><span class="p">):</span>
        <span class="n">header</span><span class="p">[</span><span class="s2">&quot;GS_WCS&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;OffsetShearWCS&quot;</span><span class="p">,</span> <span class="s2">&quot;GalSim WCS name&quot;</span><span class="p">)</span>
        <span class="n">header</span><span class="p">[</span><span class="s2">&quot;GS_SCALE&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">,</span> <span class="s2">&quot;GalSim image scale&quot;</span><span class="p">)</span>
        <span class="n">header</span><span class="p">[</span><span class="s2">&quot;GS_G1&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shear</span><span class="o">.</span><span class="n">g1</span><span class="p">,</span> <span class="s2">&quot;GalSim image shear g1&quot;</span><span class="p">)</span>
        <span class="n">header</span><span class="p">[</span><span class="s2">&quot;GS_G2&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shear</span><span class="o">.</span><span class="n">g2</span><span class="p">,</span> <span class="s2">&quot;GalSim image shear g2&quot;</span><span class="p">)</span>
        <span class="n">header</span><span class="p">[</span><span class="s2">&quot;GS_X0&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">origin</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="s2">&quot;GalSim image origin x coordinate&quot;</span><span class="p">)</span>
        <span class="n">header</span><span class="p">[</span><span class="s2">&quot;GS_Y0&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">origin</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="s2">&quot;GalSim image origin y coordinate&quot;</span><span class="p">)</span>
        <span class="n">header</span><span class="p">[</span><span class="s2">&quot;GS_U0&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">world_origin</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="s2">&quot;GalSim world origin u coordinate&quot;</span><span class="p">)</span>
        <span class="n">header</span><span class="p">[</span><span class="s2">&quot;GS_V0&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">world_origin</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="s2">&quot;GalSim world origin v coordinate&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">affine</span><span class="p">()</span><span class="o">.</span><span class="n">_writeLinearWCS</span><span class="p">(</span><span class="n">header</span><span class="p">,</span> <span class="n">bounds</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_readHeader</span><span class="p">(</span><span class="n">header</span><span class="p">):</span>
        <span class="n">scale</span> <span class="o">=</span> <span class="n">header</span><span class="p">[</span><span class="s2">&quot;GS_SCALE&quot;</span><span class="p">]</span>
        <span class="n">g1</span> <span class="o">=</span> <span class="n">header</span><span class="p">[</span><span class="s2">&quot;GS_G1&quot;</span><span class="p">]</span>
        <span class="n">g2</span> <span class="o">=</span> <span class="n">header</span><span class="p">[</span><span class="s2">&quot;GS_G2&quot;</span><span class="p">]</span>
        <span class="n">x0</span> <span class="o">=</span> <span class="n">header</span><span class="p">[</span><span class="s2">&quot;GS_X0&quot;</span><span class="p">]</span>
        <span class="n">y0</span> <span class="o">=</span> <span class="n">header</span><span class="p">[</span><span class="s2">&quot;GS_Y0&quot;</span><span class="p">]</span>
        <span class="n">u0</span> <span class="o">=</span> <span class="n">header</span><span class="p">[</span><span class="s2">&quot;GS_U0&quot;</span><span class="p">]</span>
        <span class="n">v0</span> <span class="o">=</span> <span class="n">header</span><span class="p">[</span><span class="s2">&quot;GS_V0&quot;</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">OffsetShearWCS</span><span class="p">(</span><span class="n">scale</span><span class="p">,</span> <span class="n">Shear</span><span class="p">(</span><span class="n">g1</span><span class="o">=</span><span class="n">g1</span><span class="p">,</span> <span class="n">g2</span><span class="o">=</span><span class="n">g2</span><span class="p">),</span> <span class="n">_PositionD</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span><span class="n">y0</span><span class="p">),</span> <span class="n">_PositionD</span><span class="p">(</span><span class="n">u0</span><span class="p">,</span><span class="n">v0</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_newOrigin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">origin</span><span class="p">,</span> <span class="n">world_origin</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">OffsetShearWCS</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shear</span><span class="p">,</span> <span class="n">origin</span><span class="p">,</span> <span class="n">world_origin</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">OffsetShearWCS</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shear</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">origin</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">world_origin</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;galsim.OffsetShearWCS(</span><span class="si">%r</span><span class="s2">, </span><span class="si">%r</span><span class="s2">, </span><span class="si">%r</span><span class="s2">, </span><span class="si">%r</span><span class="s2">)&quot;</span><span class="o">%</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shear</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">origin</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">world_origin</span><span class="p">)</span>
    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="nb">hash</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span></div>


<div class="viewcode-block" id="AffineTransform"><a class="viewcode-back" href="../../wcs.html#galsim.AffineTransform">[docs]</a><span class="k">class</span> <span class="nc">AffineTransform</span><span class="p">(</span><span class="n">UniformWCS</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;This WCS is the most general linear transformation.  It involves a 2x2 Jacobian</span>
<span class="sd">    matrix and an offset.  You can provide the offset in terms of either the ``image_pos``</span>
<span class="sd">    (x0,y0) where (u,v) = (0,0), or the ``world_pos`` (u0,v0) where (x,y) = (0,0).</span>
<span class="sd">    Or, in fact, you may provide both, in which case the ``image_pos`` (x0,y0) corresponds</span>
<span class="sd">    to the ``world_pos`` (u0,v0).</span>

<span class="sd">    The conversion functions are:</span>

<span class="sd">        u = dudx (x-x0) + dudy (y-y0) + u0</span>
<span class="sd">        v = dvdx (x-x0) + dvdy (y-y0) + v0</span>

<span class="sd">    An AffineTransform has attributes dudx, dudy, dvdx, dvdy, x0, y0, u0, v0 that you can</span>
<span class="sd">    access directly if that is convenient.</span>

<span class="sd">    An AffineTransform is initialized with the command::</span>

<span class="sd">        &gt;&gt;&gt; wcs = galsim.AffineTransform(dudx, dudy, dvdx, dvdy, origin=None, world_origin=None)</span>

<span class="sd">    Parameters:</span>
<span class="sd">        dudx:           du/dx</span>
<span class="sd">        dudy:           du/dy</span>
<span class="sd">        dvdx:           dv/dx</span>
<span class="sd">        dvdy:           dv/dy</span>
<span class="sd">        origin:         Optional origin position for the image coordinate system.</span>
<span class="sd">                        If provided, it should be a `PositionD` or `PositionI`.</span>
<span class="sd">                        [default: PositionD(0., 0.)]</span>
<span class="sd">        world_origin:   Optional origin position for the world coordinate system.</span>
<span class="sd">                        If provided, it should be a `PositionD`.</span>
<span class="sd">                        [default: PositionD(0., 0.)]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_req_params</span> <span class="o">=</span> <span class="p">{</span> <span class="s2">&quot;dudx&quot;</span> <span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="s2">&quot;dudy&quot;</span> <span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="s2">&quot;dvdx&quot;</span> <span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="s2">&quot;dvdy&quot;</span> <span class="p">:</span> <span class="nb">float</span> <span class="p">}</span>
    <span class="n">_opt_params</span> <span class="o">=</span> <span class="p">{</span> <span class="s2">&quot;origin&quot;</span> <span class="p">:</span> <span class="n">PositionD</span><span class="p">,</span> <span class="s2">&quot;world_origin&quot;</span><span class="p">:</span> <span class="n">PositionD</span> <span class="p">}</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dudx</span><span class="p">,</span> <span class="n">dudy</span><span class="p">,</span> <span class="n">dvdx</span><span class="p">,</span> <span class="n">dvdy</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">world_origin</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_color</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_origin</span><span class="p">(</span><span class="n">origin</span><span class="p">,</span> <span class="n">world_origin</span><span class="p">)</span>
        <span class="c1"># As with OffsetShearWCS, we store a JacobianWCS, rather than reimplement everything.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_local_wcs</span> <span class="o">=</span> <span class="n">JacobianWCS</span><span class="p">(</span><span class="n">dudx</span><span class="p">,</span> <span class="n">dudy</span><span class="p">,</span> <span class="n">dvdx</span><span class="p">,</span> <span class="n">dvdy</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dudx</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;du/dx</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_local_wcs</span><span class="o">.</span><span class="n">dudx</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dudy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;du/dy</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_local_wcs</span><span class="o">.</span><span class="n">dudy</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dvdx</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;dv/dx</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_local_wcs</span><span class="o">.</span><span class="n">dvdx</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dvdy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;dv/dy</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_local_wcs</span><span class="o">.</span><span class="n">dvdy</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">origin</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The image coordinate position to use as the origin.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_origin</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">world_origin</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The world coordinate position to use as the origin.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_world_origin</span>

    <span class="k">def</span> <span class="nf">_writeHeader</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">header</span><span class="p">,</span> <span class="n">bounds</span><span class="p">):</span>
        <span class="n">header</span><span class="p">[</span><span class="s2">&quot;GS_WCS&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;AffineTransform&quot;</span><span class="p">,</span> <span class="s2">&quot;GalSim WCS name&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_writeLinearWCS</span><span class="p">(</span><span class="n">header</span><span class="p">,</span> <span class="n">bounds</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_writeLinearWCS</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">header</span><span class="p">,</span> <span class="n">bounds</span><span class="p">):</span>
        <span class="n">header</span><span class="p">[</span><span class="s2">&quot;CTYPE1&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;LINEAR&quot;</span><span class="p">,</span> <span class="s2">&quot;name of the world coordinate axis&quot;</span><span class="p">)</span>
        <span class="n">header</span><span class="p">[</span><span class="s2">&quot;CTYPE2&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;LINEAR&quot;</span><span class="p">,</span> <span class="s2">&quot;name of the world coordinate axis&quot;</span><span class="p">)</span>
        <span class="n">header</span><span class="p">[</span><span class="s2">&quot;CRVAL1&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">u0</span><span class="p">,</span> <span class="s2">&quot;world coordinate at reference pixel = u0&quot;</span><span class="p">)</span>
        <span class="n">header</span><span class="p">[</span><span class="s2">&quot;CRVAL2&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">v0</span><span class="p">,</span> <span class="s2">&quot;world coordinate at reference pixel = v0&quot;</span><span class="p">)</span>
        <span class="n">header</span><span class="p">[</span><span class="s2">&quot;CRPIX1&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x0</span><span class="p">,</span> <span class="s2">&quot;image coordinate of reference pixel = x0&quot;</span><span class="p">)</span>
        <span class="n">header</span><span class="p">[</span><span class="s2">&quot;CRPIX2&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y0</span><span class="p">,</span> <span class="s2">&quot;image coordinate of reference pixel = y0&quot;</span><span class="p">)</span>
        <span class="n">header</span><span class="p">[</span><span class="s2">&quot;CD1_1&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dudx</span><span class="p">,</span> <span class="s2">&quot;CD1_1 = dudx&quot;</span><span class="p">)</span>
        <span class="n">header</span><span class="p">[</span><span class="s2">&quot;CD1_2&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dudy</span><span class="p">,</span> <span class="s2">&quot;CD1_2 = dudy&quot;</span><span class="p">)</span>
        <span class="n">header</span><span class="p">[</span><span class="s2">&quot;CD2_1&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dvdx</span><span class="p">,</span> <span class="s2">&quot;CD2_1 = dvdx&quot;</span><span class="p">)</span>
        <span class="n">header</span><span class="p">[</span><span class="s2">&quot;CD2_2&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dvdy</span><span class="p">,</span> <span class="s2">&quot;CD2_2 = dvdy&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">header</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_readHeader</span><span class="p">(</span><span class="n">header</span><span class="p">):</span>
        <span class="c1"># We try to make this work to produce a linear WCS, no matter what kinds of key words</span>
        <span class="c1"># are in the header.</span>
        <span class="k">if</span> <span class="s1">&#39;CD1_1&#39;</span> <span class="ow">in</span> <span class="n">header</span><span class="p">:</span>
            <span class="c1"># The others should be too, but use get with a default to be safe</span>
            <span class="n">dudx</span> <span class="o">=</span> <span class="n">header</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;CD1_1&quot;</span><span class="p">,</span><span class="mf">1.</span><span class="p">)</span>
            <span class="n">dudy</span> <span class="o">=</span> <span class="n">header</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;CD1_2&quot;</span><span class="p">,</span><span class="mf">0.</span><span class="p">)</span>
            <span class="n">dvdx</span> <span class="o">=</span> <span class="n">header</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;CD2_1&quot;</span><span class="p">,</span><span class="mf">0.</span><span class="p">)</span>
            <span class="n">dvdy</span> <span class="o">=</span> <span class="n">header</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;CD2_2&quot;</span><span class="p">,</span><span class="mf">1.</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dudx</span> <span class="o">=</span> <span class="n">header</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;CDELT1&quot;</span><span class="p">,</span><span class="mf">1.</span><span class="p">)</span>
            <span class="n">dudy</span> <span class="o">=</span> <span class="mf">0.</span>
            <span class="n">dvdx</span> <span class="o">=</span> <span class="mf">0.</span>
            <span class="n">dvdy</span> <span class="o">=</span> <span class="n">header</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;CDELT2&quot;</span><span class="p">,</span><span class="mf">1.</span><span class="p">)</span>
        <span class="n">x0</span> <span class="o">=</span> <span class="n">header</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;CRPIX1&quot;</span><span class="p">,</span><span class="mf">0.</span><span class="p">)</span>
        <span class="n">y0</span> <span class="o">=</span> <span class="n">header</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;CRPIX2&quot;</span><span class="p">,</span><span class="mf">0.</span><span class="p">)</span>
        <span class="n">u0</span> <span class="o">=</span> <span class="n">header</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;CRVAL1&quot;</span><span class="p">,</span><span class="mf">0.</span><span class="p">)</span>
        <span class="n">v0</span> <span class="o">=</span> <span class="n">header</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;CRVAL2&quot;</span><span class="p">,</span><span class="mf">0.</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">AffineTransform</span><span class="p">(</span><span class="n">dudx</span><span class="p">,</span> <span class="n">dudy</span><span class="p">,</span> <span class="n">dvdx</span><span class="p">,</span> <span class="n">dvdy</span><span class="p">,</span> <span class="n">_PositionD</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span><span class="n">y0</span><span class="p">),</span> <span class="n">_PositionD</span><span class="p">(</span><span class="n">u0</span><span class="p">,</span><span class="n">v0</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_newOrigin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">origin</span><span class="p">,</span> <span class="n">world_origin</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">AffineTransform</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dudx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dudy</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dvdx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dvdy</span><span class="p">,</span>
                               <span class="n">origin</span><span class="p">,</span> <span class="n">world_origin</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">AffineTransform</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dudx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dudy</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dvdx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dvdy</span><span class="p">,</span>
                               <span class="bp">self</span><span class="o">.</span><span class="n">origin</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">world_origin</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="s2">&quot;galsim.AffineTransform(</span><span class="si">%r</span><span class="s2">, </span><span class="si">%r</span><span class="s2">, </span><span class="si">%r</span><span class="s2">, </span><span class="si">%r</span><span class="s2">, origin=</span><span class="si">%r</span><span class="s2">, world_origin=</span><span class="si">%r</span><span class="s2">)&quot;</span><span class="p">)</span><span class="o">%</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dudx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dudy</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dvdx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dvdy</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">origin</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">world_origin</span><span class="p">)</span>
    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="nb">hash</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span></div>


<span class="c1">#########################################################################################</span>
<span class="c1">#</span>
<span class="c1"># Non-uniform WCS classes are those where the pixel size and shape are not necessarily</span>
<span class="c1"># constant across the image.  There are two varieties of these, EuclideanWCS and CelestialWCS.</span>
<span class="c1">#</span>
<span class="c1"># Here, we have the following non-uniform WCS classes: (There are more in fitswcs.py)</span>
<span class="c1">#</span>
<span class="c1">#     UVFunction is a EuclideanWCS</span>
<span class="c1">#     RaDecFunction is a CelestialWCS</span>
<span class="c1">#</span>
<span class="c1"># They must define the following:</span>
<span class="c1">#</span>
<span class="c1">#     origin            attribute or property returning the origin</span>
<span class="c1">#     _writeHeader      function that writes the WCS to a fits header.</span>
<span class="c1">#     _readHeader       static function that reads the WCS from a fits header.</span>
<span class="c1">#     _newOrigin        function returning the saem WCS, but with new origin</span>
<span class="c1">#     copy              return a copy</span>
<span class="c1">#     __eq__            check if this equals another WCS</span>
<span class="c1">#     __repr__          convert to string</span>
<span class="c1">#</span>
<span class="c1"># Non-uniform EuclideanWCS classes must define the following:</span>
<span class="c1">#</span>
<span class="c1">#     world_origin      attribute or property returning the world origin</span>
<span class="c1">#     _u                function returning u(x,y)</span>
<span class="c1">#     _v                function returning v(x,y)</span>
<span class="c1">#     _x                function returning x(u,v)  (May raise a NotImplementedError)</span>
<span class="c1">#     _y                function returning y(u,v)  (May raise a NotImplementedError)</span>
<span class="c1">#</span>
<span class="c1"># CelestialWCS classes must define the following:</span>
<span class="c1">#</span>
<span class="c1">#     _radec            function returning (ra, dec) in _radians_ at position (x,y)</span>
<span class="c1">#</span>
<span class="c1"># Ideally, the above functions would work with NumPy arrays as inputs.</span>
<span class="c1">#</span>
<span class="c1">#########################################################################################</span>


<span class="c1"># Some helper functions for serializing arbitrary functions.  Used by both UVFunction and</span>
<span class="c1"># RaDecFunction.</span>
<span class="k">def</span> <span class="nf">_writeFuncToHeader</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">letter</span><span class="p">,</span> <span class="n">header</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="c1"># If we have the string version, then just write that</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">func</span>
        <span class="n">first_key</span> <span class="o">=</span> <span class="s1">&#39;GS_&#39;</span><span class="o">+</span><span class="n">letter</span><span class="o">+</span><span class="s1">&#39;_STR&#39;</span>

    <span class="k">elif</span> <span class="n">func</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Otherwise things get more interesting.  We have to serialize a python function.</span>
        <span class="c1"># I got the starting point for this code from:</span>
        <span class="c1">#     http://stackoverflow.com/questions/1253528/</span>
        <span class="c1"># In particular, marshal can serialize arbitrary code. (!)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="kn">import</span> <span class="nn">cPickle</span> <span class="k">as</span> <span class="nn">pickle</span>
        <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
            <span class="kn">import</span> <span class="nn">pickle</span>
        <span class="kn">import</span> <span class="nn">types</span><span class="o">,</span> <span class="nn">marshal</span><span class="o">,</span> <span class="nn">base64</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">func</span><span class="p">)</span> <span class="o">==</span> <span class="n">types</span><span class="o">.</span><span class="n">FunctionType</span><span class="p">:</span>
            <span class="n">code</span> <span class="o">=</span> <span class="n">marshal</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">func</span><span class="o">.</span><span class="vm">__code__</span><span class="p">)</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="vm">__name__</span>
            <span class="n">defaults</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="vm">__defaults__</span>
            <span class="n">closure</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="vm">__closure__</span>

            <span class="c1"># Functions may also have something called closure cells.  If there are any, we need</span>
            <span class="c1"># to include them as well.  Help for this part came from:</span>
            <span class="c1"># http://stackoverflow.com/questions/573569/</span>
            <span class="k">if</span> <span class="n">closure</span><span class="p">:</span>
                <span class="kn">from</span> <span class="nn">types</span> <span class="kn">import</span> <span class="n">ModuleType</span>
                <span class="n">closure_list</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">closure</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">cell_contents</span><span class="p">,</span> <span class="n">ModuleType</span><span class="p">):</span>
                        <span class="c1"># Can&#39;t really pickle the modules.  e.g. math if they use math functions.</span>
                        <span class="c1"># The modules just need to be loaded on the other side.  But we still need</span>
                        <span class="c1"># to make a cell for the module closure item, so just use its name and</span>
                        <span class="c1"># mark it as a module so we can recover it correctly.</span>
                        <span class="n">closure_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="s1">&#39;module_&#39;</span><span class="o">+</span><span class="n">c</span><span class="o">.</span><span class="n">cell_contents</span><span class="o">.</span><span class="vm">__name__</span> <span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">closure_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">c</span><span class="o">.</span><span class="n">cell_contents</span> <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">closure_list</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="nb">all</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">code</span><span class="p">,</span><span class="n">name</span><span class="p">,</span><span class="n">defaults</span><span class="p">,</span><span class="n">closure_list</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># For things other than regular functions, we can try to pickle it directly, but</span>
            <span class="c1"># it might not work.  Let pickle raise the appropriate error if it fails.</span>

            <span class="c1"># The first item in the tuple is what I&#39;m calling a type_code to indicate what to</span>
            <span class="c1"># do with the results of unpickling.  So far I just have 0 = function, 1 = other,</span>
            <span class="c1"># but this could be extended if we find a good reason to.</span>
            <span class="nb">all</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">func</span><span class="p">)</span>

        <span class="c1"># Now we can use pickle to serialize the full thing.</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="nb">all</span><span class="p">)</span>

        <span class="c1"># Fits can&#39;t handle arbitrary strings.  Shrink to a base-64 alphabet that is printable.</span>
        <span class="c1"># (This is like UUencoding for those of you who remember that...)</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">base64</span><span class="o">.</span><span class="n">b64encode</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">.</span><span class="n">decode</span><span class="p">()</span>
        <span class="n">first_key</span> <span class="o">=</span> <span class="s1">&#39;GS_&#39;</span><span class="o">+</span><span class="n">letter</span><span class="o">+</span><span class="s1">&#39;_FN&#39;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Nothing to write.</span>
        <span class="k">return</span>

    <span class="c1"># Fits header strings cannot be more than 68 characters long, so split it up.</span>
    <span class="n">fits_len</span> <span class="o">=</span> <span class="mi">68</span>
    <span class="n">n</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">//</span><span class="n">fits_len</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">s_array</span> <span class="o">=</span> <span class="p">[</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="n">fits_len</span><span class="p">:(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">fits_len</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="p">]</span>

    <span class="c1"># The total number of string splits is stored in fits key GS_U_N.</span>
    <span class="n">header</span><span class="p">[</span><span class="s2">&quot;GS_&quot;</span> <span class="o">+</span> <span class="n">letter</span> <span class="o">+</span> <span class="s2">&quot;_N&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">n</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="c1"># Use key names like GS_U0000, GS_U00001, etc. for the function versions</span>
        <span class="c1"># and like GS_SU000, GS_SU001, etc. for the string versions.</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="n">key</span> <span class="o">=</span> <span class="n">first_key</span>
        <span class="k">else</span><span class="p">:</span> <span class="n">key</span> <span class="o">=</span> <span class="s1">&#39;GS_</span><span class="si">%s%04d</span><span class="s1">&#39;</span><span class="o">%</span><span class="p">(</span><span class="n">letter</span><span class="p">,</span><span class="n">i</span><span class="p">)</span>
        <span class="n">header</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">s_array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">_makecell</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>  <span class="c1"># pragma: no cover</span>
                       <span class="c1"># (codecov gets confused, because the lambda function is never called.)</span>
    <span class="c1"># This is a little trick to make a closure cell.</span>
    <span class="c1"># We make a function that has the given value in closure, then then get the</span>
    <span class="c1"># first (only) closure item, which will be the closure cell we need.</span>
    <span class="k">return</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">:</span> <span class="n">value</span><span class="p">)</span><span class="o">.</span><span class="vm">__closure__</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">_readFuncFromHeader</span><span class="p">(</span><span class="n">letter</span><span class="p">,</span> <span class="n">header</span><span class="p">):</span>
    <span class="c1"># This undoes the process of _writeFuncToHeader.  See the comments in that code for details.</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="kn">import</span> <span class="nn">cPickle</span> <span class="k">as</span> <span class="nn">pickle</span>
    <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
        <span class="kn">import</span> <span class="nn">pickle</span>
    <span class="kn">import</span> <span class="nn">types</span><span class="o">,</span> <span class="nn">marshal</span><span class="o">,</span> <span class="nn">base64</span>
    <span class="k">if</span> <span class="s1">&#39;GS_&#39;</span><span class="o">+</span><span class="n">letter</span><span class="o">+</span><span class="s1">&#39;_STR&#39;</span> <span class="ow">in</span> <span class="n">header</span><span class="p">:</span>
        <span class="c1"># Read in a regular string</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">header</span><span class="p">[</span><span class="s2">&quot;GS_&quot;</span> <span class="o">+</span> <span class="n">letter</span> <span class="o">+</span> <span class="s2">&quot;_N&quot;</span><span class="p">]</span>
        <span class="n">s</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="n">key</span> <span class="o">=</span> <span class="s1">&#39;GS_&#39;</span><span class="o">+</span><span class="n">letter</span><span class="o">+</span><span class="s1">&#39;_STR&#39;</span>
            <span class="k">else</span><span class="p">:</span> <span class="n">key</span> <span class="o">=</span> <span class="s1">&#39;GS_</span><span class="si">%s%04d</span><span class="s1">&#39;</span><span class="o">%</span><span class="p">(</span><span class="n">letter</span><span class="p">,</span><span class="n">i</span><span class="p">)</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="n">header</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">s</span>
    <span class="k">elif</span> <span class="s1">&#39;GS_&#39;</span><span class="o">+</span><span class="n">letter</span><span class="o">+</span><span class="s1">&#39;_FN&#39;</span> <span class="ow">in</span> <span class="n">header</span><span class="p">:</span>
        <span class="c1"># Read in an encoded function</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">header</span><span class="p">[</span><span class="s2">&quot;GS_&quot;</span> <span class="o">+</span> <span class="n">letter</span> <span class="o">+</span> <span class="s2">&quot;_N&quot;</span><span class="p">]</span>
        <span class="n">s</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="n">key</span> <span class="o">=</span> <span class="s1">&#39;GS_&#39;</span><span class="o">+</span><span class="n">letter</span><span class="o">+</span><span class="s1">&#39;_FN&#39;</span>
            <span class="k">else</span><span class="p">:</span> <span class="n">key</span> <span class="o">=</span> <span class="s1">&#39;GS_</span><span class="si">%s%04d</span><span class="s1">&#39;</span><span class="o">%</span><span class="p">(</span><span class="n">letter</span><span class="p">,</span><span class="n">i</span><span class="p">)</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="n">header</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">base64</span><span class="o">.</span><span class="n">b64decode</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
        <span class="nb">all</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
        <span class="n">type_code</span> <span class="o">=</span> <span class="nb">all</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">type_code</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">code_str</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">defaults</span><span class="p">,</span> <span class="n">closure_items</span> <span class="o">=</span> <span class="nb">all</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
            <span class="n">code</span> <span class="o">=</span> <span class="n">marshal</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">code_str</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">closure_items</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">closure</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">closure</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">closure_items</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span><span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="n">value</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;module_&#39;</span><span class="p">):</span>
                        <span class="n">module_name</span> <span class="o">=</span> <span class="n">value</span><span class="p">[</span><span class="mi">7</span><span class="p">:]</span>
                        <span class="n">closure</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_makecell</span><span class="p">(</span><span class="nb">__import__</span><span class="p">(</span><span class="n">module_name</span><span class="p">)))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">closure</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_makecell</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>
                <span class="n">closure</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">closure</span><span class="p">)</span>
            <span class="n">func</span> <span class="o">=</span> <span class="n">types</span><span class="o">.</span><span class="n">FunctionType</span><span class="p">(</span><span class="n">code</span><span class="p">,</span> <span class="nb">globals</span><span class="p">(),</span> <span class="n">name</span><span class="p">,</span> <span class="n">defaults</span><span class="p">,</span> <span class="n">closure</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">func</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">all</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>

<div class="viewcode-block" id="UVFunction"><a class="viewcode-back" href="../../wcs.html#galsim.UVFunction">[docs]</a><span class="k">class</span> <span class="nc">UVFunction</span><span class="p">(</span><span class="n">EuclideanWCS</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;This WCS takes two arbitrary functions for u(x,y) and v(x,y).</span>

<span class="sd">    The ufunc and vfunc parameters may be:</span>
<span class="sd">        - python functions that take (x,y) arguments</span>
<span class="sd">        - python objects with a __call__ method that takes (x,y) arguments</span>
<span class="sd">        - strings which can be parsed with eval(&#39;lambda x,y: &#39;+str)</span>

<span class="sd">    You may also provide the inverse functions x(u,v) and y(u,v) as xfunc and yfunc.</span>
<span class="sd">    These are not required, but if you do not provide them, then any operation that requires</span>
<span class="sd">    going from world to image coordinates will raise a NotImplementedError.</span>

<span class="sd">    Note: some internal calculations will be faster if the functions can take NumPy arrays</span>
<span class="sd">    for x,y and output arrays for u,v.  Usually this does not require any change to your</span>
<span class="sd">    function, but it is worth keeping in mind.  For example, if you want to do a sqrt, you</span>
<span class="sd">    may be better off using ``numpy.sqrt`` rather than ``math.sqrt``.</span>

<span class="sd">    A UVFunction is initialized with the command::</span>

<span class="sd">        &gt;&gt;&gt; wcs = galsim.UVFunction(ufunc, vfunc, origin=None, world_origin=None)</span>

<span class="sd">    Parameters:</span>
<span class="sd">        ufunc:          The function u(x,y)</span>
<span class="sd">        vfunc:          The function v(x,y)</span>
<span class="sd">        xfunc:          The function x(u,v) (optional)</span>
<span class="sd">        yfunc:          The function y(u,v) (optional)</span>
<span class="sd">        origin:         Optional origin position for the image coordinate system.</span>
<span class="sd">                        If provided, it should be a `PositionD` or `PositionI`.</span>
<span class="sd">                        [default: PositionD(0., 0.)]</span>
<span class="sd">        world_origin    Optional origin position for the world coordinate system.</span>
<span class="sd">                        If provided, it should be a `PositionD`.</span>
<span class="sd">                        [default: PositionD(0., 0.)]</span>
<span class="sd">        uses_color:     If True, then the functions take three parameters (x,y,c) or (u,v,c)</span>
<span class="sd">                        where the third term is some kind of color value.  (The exact meaning</span>
<span class="sd">                        of &quot;color&quot; here is user-defined. You just need to be consistent with</span>
<span class="sd">                        the color values you use when using the wcs.) [default: False]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_req_params</span> <span class="o">=</span> <span class="p">{</span> <span class="s2">&quot;ufunc&quot;</span> <span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="s2">&quot;vfunc&quot;</span> <span class="p">:</span> <span class="nb">str</span> <span class="p">}</span>
    <span class="n">_opt_params</span> <span class="o">=</span> <span class="p">{</span> <span class="s2">&quot;xfunc&quot;</span> <span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="s2">&quot;yfunc&quot;</span> <span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
                    <span class="s2">&quot;origin&quot;</span> <span class="p">:</span> <span class="n">PositionD</span><span class="p">,</span> <span class="s2">&quot;world_origin&quot;</span><span class="p">:</span> <span class="n">PositionD</span> <span class="p">}</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ufunc</span><span class="p">,</span> <span class="n">vfunc</span><span class="p">,</span> <span class="n">xfunc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">yfunc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">world_origin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">uses_color</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_color</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_origin</span><span class="p">(</span><span class="n">origin</span><span class="p">,</span> <span class="n">world_origin</span><span class="p">)</span>

        <span class="c1"># Keep these to use in copies, etc.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_orig_ufunc</span> <span class="o">=</span> <span class="n">ufunc</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_orig_vfunc</span> <span class="o">=</span> <span class="n">vfunc</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_orig_xfunc</span> <span class="o">=</span> <span class="n">xfunc</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_orig_yfunc</span> <span class="o">=</span> <span class="n">yfunc</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_uses_color</span> <span class="o">=</span> <span class="n">uses_color</span>

        <span class="c1"># Turn these into the real functions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_funcs</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_initialize_funcs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">global</span> <span class="n">galsim</span>  <span class="c1"># Because if a user&#39;s function used galsim, it&#39;s probably at global scope.</span>
        <span class="kn">import</span> <span class="nn">galsim</span>
        <span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">utilities</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_orig_ufunc</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_uses_color</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ufunc</span> <span class="o">=</span> <span class="n">utilities</span><span class="o">.</span><span class="n">math_eval</span><span class="p">(</span><span class="s1">&#39;lambda x,y,c : &#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_orig_ufunc</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ufunc</span> <span class="o">=</span> <span class="n">utilities</span><span class="o">.</span><span class="n">math_eval</span><span class="p">(</span><span class="s1">&#39;lambda x,y : &#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_orig_ufunc</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ufunc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_orig_ufunc</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_orig_vfunc</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_uses_color</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_vfunc</span> <span class="o">=</span> <span class="n">utilities</span><span class="o">.</span><span class="n">math_eval</span><span class="p">(</span><span class="s1">&#39;lambda x,y,c : &#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_orig_vfunc</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_vfunc</span> <span class="o">=</span> <span class="n">utilities</span><span class="o">.</span><span class="n">math_eval</span><span class="p">(</span><span class="s1">&#39;lambda x,y : &#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_orig_vfunc</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_vfunc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_orig_vfunc</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_orig_xfunc</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_uses_color</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_xfunc</span> <span class="o">=</span> <span class="n">utilities</span><span class="o">.</span><span class="n">math_eval</span><span class="p">(</span><span class="s1">&#39;lambda u,v,c : &#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_orig_xfunc</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_xfunc</span> <span class="o">=</span> <span class="n">utilities</span><span class="o">.</span><span class="n">math_eval</span><span class="p">(</span><span class="s1">&#39;lambda u,v : &#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_orig_xfunc</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_xfunc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_orig_xfunc</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_orig_yfunc</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_uses_color</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_yfunc</span> <span class="o">=</span> <span class="n">utilities</span><span class="o">.</span><span class="n">math_eval</span><span class="p">(</span><span class="s1">&#39;lambda u,v,c : &#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_orig_yfunc</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_yfunc</span> <span class="o">=</span> <span class="n">utilities</span><span class="o">.</span><span class="n">math_eval</span><span class="p">(</span><span class="s1">&#39;lambda u,v : &#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_orig_yfunc</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_yfunc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_orig_yfunc</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ufunc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The input ufunc</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ufunc</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">vfunc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The input vfunc</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vfunc</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">xfunc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The input xfunc</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xfunc</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">yfunc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The input yfunc</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_yfunc</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">origin</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The image coordinate position to use as the origin.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_origin</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">world_origin</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The world coordinate position to use as the origin.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_world_origin</span>

    <span class="k">def</span> <span class="nf">_u</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_uses_color</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ufunc</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">color</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="c1"># If that didn&#39;t work, we have to do it manually for each position. :(  (SLOW!)</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">_ufunc</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span><span class="n">y1</span><span class="p">,</span><span class="n">color</span><span class="p">)</span> <span class="k">for</span> <span class="p">[</span><span class="n">x1</span><span class="p">,</span><span class="n">y1</span><span class="p">]</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)])</span>
                <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">e</span>  <span class="c1"># Raise the original if this fails, since it&#39;s probably more relevant.</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ufunc</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">_ufunc</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span><span class="n">y1</span><span class="p">)</span> <span class="k">for</span> <span class="p">[</span><span class="n">x1</span><span class="p">,</span><span class="n">y1</span><span class="p">]</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)])</span>
                <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">e</span>

    <span class="k">def</span> <span class="nf">_v</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_uses_color</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vfunc</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">color</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">_vfunc</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span><span class="n">y1</span><span class="p">,</span><span class="n">color</span><span class="p">)</span> <span class="k">for</span> <span class="p">[</span><span class="n">x1</span><span class="p">,</span><span class="n">y1</span><span class="p">]</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)])</span>
                <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">e</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vfunc</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">_vfunc</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span><span class="n">y1</span><span class="p">)</span> <span class="k">for</span> <span class="p">[</span><span class="n">x1</span><span class="p">,</span><span class="n">y1</span><span class="p">]</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)])</span>
                <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">e</span>

    <span class="k">def</span> <span class="nf">_x</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xfunc</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">GalSimNotImplementedError</span><span class="p">(</span>
                <span class="s2">&quot;World -&gt; Image direction not implemented for this UVFunction&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_uses_color</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xfunc</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">,</span><span class="n">color</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">_xfunc</span><span class="p">(</span><span class="n">u1</span><span class="p">,</span><span class="n">v1</span><span class="p">,</span><span class="n">color</span><span class="p">)</span> <span class="k">for</span> <span class="p">[</span><span class="n">u1</span><span class="p">,</span><span class="n">v1</span><span class="p">]</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">)])</span>
                    <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="n">e</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xfunc</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">_xfunc</span><span class="p">(</span><span class="n">u1</span><span class="p">,</span><span class="n">v1</span><span class="p">)</span> <span class="k">for</span> <span class="p">[</span><span class="n">u1</span><span class="p">,</span><span class="n">v1</span><span class="p">]</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">)])</span>
                    <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="n">e</span>

    <span class="k">def</span> <span class="nf">_y</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_yfunc</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">GalSimNotImplementedError</span><span class="p">(</span>
                <span class="s2">&quot;World -&gt; Image direction not implemented for this UVFunction&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_uses_color</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_yfunc</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">,</span><span class="n">color</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">_yfunc</span><span class="p">(</span><span class="n">u1</span><span class="p">,</span><span class="n">v1</span><span class="p">,</span><span class="n">color</span><span class="p">)</span> <span class="k">for</span> <span class="p">[</span><span class="n">u1</span><span class="p">,</span><span class="n">v1</span><span class="p">]</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">)])</span>
                    <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="n">e</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_yfunc</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">_yfunc</span><span class="p">(</span><span class="n">u1</span><span class="p">,</span><span class="n">v1</span><span class="p">)</span> <span class="k">for</span> <span class="p">[</span><span class="n">u1</span><span class="p">,</span><span class="n">v1</span><span class="p">]</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">)])</span>
                    <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="n">e</span>

    <span class="k">def</span> <span class="nf">_newOrigin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">origin</span><span class="p">,</span> <span class="n">world_origin</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">UVFunction</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_orig_ufunc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_orig_vfunc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_orig_xfunc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_orig_yfunc</span><span class="p">,</span>
                          <span class="n">origin</span><span class="p">,</span> <span class="n">world_origin</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_uses_color</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_writeHeader</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">header</span><span class="p">,</span> <span class="n">bounds</span><span class="p">):</span>
        <span class="n">header</span><span class="p">[</span><span class="s2">&quot;GS_WCS&quot;</span><span class="p">]</span>  <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;UVFunction&quot;</span><span class="p">,</span> <span class="s2">&quot;GalSim WCS name&quot;</span><span class="p">)</span>
        <span class="n">header</span><span class="p">[</span><span class="s2">&quot;GS_X0&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">origin</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="s2">&quot;GalSim image origin x&quot;</span><span class="p">)</span>
        <span class="n">header</span><span class="p">[</span><span class="s2">&quot;GS_Y0&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">origin</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="s2">&quot;GalSim image origin y&quot;</span><span class="p">)</span>
        <span class="n">header</span><span class="p">[</span><span class="s2">&quot;GS_U0&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">world_origin</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="s2">&quot;GalSim world origin u&quot;</span><span class="p">)</span>
        <span class="n">header</span><span class="p">[</span><span class="s2">&quot;GS_V0&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">world_origin</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="s2">&quot;GalSim world origin v&quot;</span><span class="p">)</span>
        <span class="n">header</span><span class="p">[</span><span class="s2">&quot;GS_COLOR&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_uses_color</span><span class="p">),</span> <span class="s2">&quot;GalSim wcs uses color?&quot;</span><span class="p">)</span>

        <span class="n">_writeFuncToHeader</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_orig_ufunc</span><span class="p">,</span> <span class="s1">&#39;U&#39;</span><span class="p">,</span> <span class="n">header</span><span class="p">)</span>
        <span class="n">_writeFuncToHeader</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_orig_vfunc</span><span class="p">,</span> <span class="s1">&#39;V&#39;</span><span class="p">,</span> <span class="n">header</span><span class="p">)</span>
        <span class="n">_writeFuncToHeader</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_orig_xfunc</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">,</span> <span class="n">header</span><span class="p">)</span>
        <span class="n">_writeFuncToHeader</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_orig_yfunc</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="n">header</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">affine</span><span class="p">(</span><span class="n">bounds</span><span class="o">.</span><span class="n">true_center</span><span class="p">)</span><span class="o">.</span><span class="n">_writeLinearWCS</span><span class="p">(</span><span class="n">header</span><span class="p">,</span> <span class="n">bounds</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_readHeader</span><span class="p">(</span><span class="n">header</span><span class="p">):</span>
        <span class="n">x0</span> <span class="o">=</span> <span class="n">header</span><span class="p">[</span><span class="s2">&quot;GS_X0&quot;</span><span class="p">]</span>
        <span class="n">y0</span> <span class="o">=</span> <span class="n">header</span><span class="p">[</span><span class="s2">&quot;GS_Y0&quot;</span><span class="p">]</span>
        <span class="n">u0</span> <span class="o">=</span> <span class="n">header</span><span class="p">[</span><span class="s2">&quot;GS_U0&quot;</span><span class="p">]</span>
        <span class="n">v0</span> <span class="o">=</span> <span class="n">header</span><span class="p">[</span><span class="s2">&quot;GS_V0&quot;</span><span class="p">]</span>
        <span class="n">uses_color</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">header</span><span class="p">[</span><span class="s2">&quot;GS_COLOR&quot;</span><span class="p">])</span>
        <span class="n">ufunc</span> <span class="o">=</span> <span class="n">_readFuncFromHeader</span><span class="p">(</span><span class="s1">&#39;U&#39;</span><span class="p">,</span> <span class="n">header</span><span class="p">)</span>
        <span class="n">vfunc</span> <span class="o">=</span> <span class="n">_readFuncFromHeader</span><span class="p">(</span><span class="s1">&#39;V&#39;</span><span class="p">,</span> <span class="n">header</span><span class="p">)</span>
        <span class="n">xfunc</span> <span class="o">=</span> <span class="n">_readFuncFromHeader</span><span class="p">(</span><span class="s1">&#39;X&#39;</span><span class="p">,</span> <span class="n">header</span><span class="p">)</span>
        <span class="n">yfunc</span> <span class="o">=</span> <span class="n">_readFuncFromHeader</span><span class="p">(</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="n">header</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">UVFunction</span><span class="p">(</span><span class="n">ufunc</span><span class="p">,</span> <span class="n">vfunc</span><span class="p">,</span> <span class="n">xfunc</span><span class="p">,</span> <span class="n">yfunc</span><span class="p">,</span> <span class="n">_PositionD</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span><span class="n">y0</span><span class="p">),</span>
                          <span class="n">_PositionD</span><span class="p">(</span><span class="n">u0</span><span class="p">,</span><span class="n">v0</span><span class="p">),</span> <span class="n">uses_color</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">UVFunction</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_orig_ufunc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_orig_vfunc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_orig_xfunc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_orig_yfunc</span><span class="p">,</span>
                          <span class="bp">self</span><span class="o">.</span><span class="n">origin</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">world_origin</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_uses_color</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span> <span class="ow">is</span> <span class="n">other</span> <span class="ow">or</span>
                <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">UVFunction</span><span class="p">)</span> <span class="ow">and</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">_orig_ufunc</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_orig_ufunc</span> <span class="ow">and</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">_orig_vfunc</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_orig_vfunc</span> <span class="ow">and</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">_orig_xfunc</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_orig_xfunc</span> <span class="ow">and</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">_orig_yfunc</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_orig_yfunc</span> <span class="ow">and</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">origin</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">origin</span> <span class="ow">and</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">world_origin</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">world_origin</span> <span class="ow">and</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">_uses_color</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_uses_color</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="s2">&quot;galsim.UVFunction(</span><span class="si">%r</span><span class="s2">, </span><span class="si">%r</span><span class="s2">, </span><span class="si">%r</span><span class="s2">, </span><span class="si">%r</span><span class="s2">, </span><span class="si">%r</span><span class="s2">, </span><span class="si">%r</span><span class="s2">, </span><span class="si">%r</span><span class="s2">)&quot;</span><span class="p">)</span><span class="o">%</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_orig_ufunc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_orig_vfunc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_orig_xfunc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_orig_yfunc</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">origin</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">world_origin</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_uses_color</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="nb">hash</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">del</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;_ufunc&#39;</span><span class="p">]</span>
        <span class="k">del</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;_vfunc&#39;</span><span class="p">]</span>
        <span class="k">del</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;_xfunc&#39;</span><span class="p">]</span>
        <span class="k">del</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;_yfunc&#39;</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">d</span>

    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span> <span class="o">=</span> <span class="n">d</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_funcs</span><span class="p">()</span></div>


<div class="viewcode-block" id="RaDecFunction"><a class="viewcode-back" href="../../wcs.html#galsim.RaDecFunction">[docs]</a><span class="k">class</span> <span class="nc">RaDecFunction</span><span class="p">(</span><span class="n">CelestialWCS</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;This WCS takes an arbitrary function for the Right Ascension (ra) and Declination (dec).</span>

<span class="sd">    In many cases, it can be more convenient to calculate both ra and dec in a single function,</span>
<span class="sd">    since there will typically be intermediate values that are common to both, so it may be more</span>
<span class="sd">    efficient to just calculate those once and thence calculate both ra and dec.  Thus, we</span>
<span class="sd">    provide the option to provide either a single function or two separate functions.</span>

<span class="sd">    The function parameters used to initialize an RaDecFunction may be:</span>
<span class="sd">        - a python functions that take (x,y) arguments</span>
<span class="sd">        - a python object with a __call__ method that takes (x,y) arguments</span>
<span class="sd">        - a string which can be parsed with eval(&#39;lambda x,y: &#39;+str)</span>

<span class="sd">    The return values, ra and dec, should be given in _radians_.</span>

<span class="sd">    The first argument is called ``ra_func``, but if ``dec_func`` is omitted, then it is assumed</span>
<span class="sd">    to calculate both ra and dec.  The two values should be returned as a tuple (ra,dec).</span>

<span class="sd">    We don&#39;t want a function that returns `Angle` instances, because we want to allow for the</span>
<span class="sd">    possibility of using NumPy arrays as inputs and outputs to speed up some calculations.  The</span>
<span class="sd">    function isn&#39;t _required_ to work with NumPy arrays, but it is possible that some things</span>
<span class="sd">    will be faster if it does.  If it were expected to return `Angle` instances, then it definitely</span>
<span class="sd">    couldn&#39;t work with arrays.</span>

<span class="sd">    An RaDecFunction is initialized with either of the following commands::</span>

<span class="sd">        &gt;&gt;&gt; wcs = galsim.RaDecFunction(radec_func, origin=None)</span>
<span class="sd">        &gt;&gt;&gt; wcs = galsim.RaDecFunction(ra_func, dec_func, origin=None)</span>

<span class="sd">    Parameters:</span>
<span class="sd">        ra_func:    If ``dec_func`` is also given: A function ra(x,y) returning ra in radians.</span>
<span class="sd">                    If ``dec_func=None``: A function returning a tuple (ra,dec), both in radians.</span>
<span class="sd">        dec_func:   Either a function dec(x,y) returning dec in radians, or None (in which</span>
<span class="sd">                    case ``ra_func`` is expected to return both ra and dec. [default: None]</span>
<span class="sd">        origin:     Optional origin position for the image coordinate system.</span>
<span class="sd">                    If provided, it should be a `PositionD` or `PositionI`.</span>
<span class="sd">                    [default: PositionD(0., 0.)]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_req_params</span> <span class="o">=</span> <span class="p">{</span> <span class="s2">&quot;ra_func&quot;</span> <span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="s2">&quot;dec_func&quot;</span> <span class="p">:</span> <span class="nb">str</span> <span class="p">}</span>
    <span class="n">_opt_params</span> <span class="o">=</span> <span class="p">{</span> <span class="s2">&quot;origin&quot;</span> <span class="p">:</span> <span class="n">PositionD</span> <span class="p">}</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ra_func</span><span class="p">,</span> <span class="n">dec_func</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_color</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_origin</span><span class="p">(</span><span class="n">origin</span><span class="p">)</span>

        <span class="c1"># Keep these to use in copies, etc.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_orig_ra_func</span> <span class="o">=</span> <span class="n">ra_func</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_orig_dec_func</span> <span class="o">=</span> <span class="n">dec_func</span>

        <span class="c1"># Turn these into the real functions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_funcs</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_initialize_funcs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">global</span> <span class="n">galsim</span>  <span class="c1"># Because if a user&#39;s function used galsim, it&#39;s probably at global scope.</span>
        <span class="kn">import</span> <span class="nn">galsim</span>
        <span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">utilities</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_orig_dec_func</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_orig_ra_func</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_radec_func</span> <span class="o">=</span> <span class="n">utilities</span><span class="o">.</span><span class="n">math_eval</span><span class="p">(</span><span class="s1">&#39;lambda x,y : &#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_orig_ra_func</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_radec_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_orig_ra_func</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_orig_ra_func</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">ra_func</span> <span class="o">=</span> <span class="n">utilities</span><span class="o">.</span><span class="n">math_eval</span><span class="p">(</span><span class="s1">&#39;lambda x,y : &#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_orig_ra_func</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ra_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_orig_ra_func</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_orig_dec_func</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">dec_func</span> <span class="o">=</span> <span class="n">utilities</span><span class="o">.</span><span class="n">math_eval</span><span class="p">(</span><span class="s1">&#39;lambda x,y : &#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_orig_dec_func</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">dec_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_orig_dec_func</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_radec_func</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span> <span class="p">:</span> <span class="p">(</span><span class="n">ra_func</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">),</span> <span class="n">dec_func</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">radec_func</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The input radec_func</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_radec_func</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">origin</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The image coordinate position to use as the origin.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_origin</span>

    <span class="k">def</span> <span class="nf">_radec</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_radec_func</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">world</span> <span class="o">=</span> <span class="p">[</span> <span class="bp">self</span><span class="o">.</span><span class="n">_radec</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span><span class="n">y1</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">x1</span><span class="p">,</span><span class="n">y1</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="p">]</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">e</span>  <span class="c1"># Raise the original one if this fails, since it&#39;s probably more relevant.</span>
            <span class="n">ra</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span> <span class="n">w</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">world</span> <span class="p">])</span>
            <span class="n">dec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span> <span class="n">w</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">world</span> <span class="p">])</span>
            <span class="k">return</span> <span class="n">ra</span><span class="p">,</span> <span class="n">dec</span>

    <span class="k">def</span> <span class="nf">_xy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ra</span><span class="p">,</span> <span class="n">dec</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">GalSimNotImplementedError</span><span class="p">(</span>
                <span class="s2">&quot;World -&gt; Image direction not implemented for RaDecFunction&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_newOrigin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">origin</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">RaDecFunction</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_orig_ra_func</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_orig_dec_func</span><span class="p">,</span> <span class="n">origin</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_writeHeader</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">header</span><span class="p">,</span> <span class="n">bounds</span><span class="p">):</span>
        <span class="n">header</span><span class="p">[</span><span class="s2">&quot;GS_WCS&quot;</span><span class="p">]</span>  <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;RaDecFunction&quot;</span><span class="p">,</span> <span class="s2">&quot;GalSim WCS name&quot;</span><span class="p">)</span>
        <span class="n">header</span><span class="p">[</span><span class="s2">&quot;GS_X0&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">origin</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="s2">&quot;GalSim image origin x&quot;</span><span class="p">)</span>
        <span class="n">header</span><span class="p">[</span><span class="s2">&quot;GS_Y0&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">origin</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="s2">&quot;GalSim image origin y&quot;</span><span class="p">)</span>

        <span class="n">_writeFuncToHeader</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_orig_ra_func</span><span class="p">,</span> <span class="s1">&#39;R&#39;</span><span class="p">,</span> <span class="n">header</span><span class="p">)</span>
        <span class="n">_writeFuncToHeader</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_orig_dec_func</span><span class="p">,</span> <span class="s1">&#39;D&#39;</span><span class="p">,</span> <span class="n">header</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">affine</span><span class="p">(</span><span class="n">bounds</span><span class="o">.</span><span class="n">true_center</span><span class="p">)</span><span class="o">.</span><span class="n">_writeLinearWCS</span><span class="p">(</span><span class="n">header</span><span class="p">,</span> <span class="n">bounds</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_readHeader</span><span class="p">(</span><span class="n">header</span><span class="p">):</span>
        <span class="n">x0</span> <span class="o">=</span> <span class="n">header</span><span class="p">[</span><span class="s2">&quot;GS_X0&quot;</span><span class="p">]</span>
        <span class="n">y0</span> <span class="o">=</span> <span class="n">header</span><span class="p">[</span><span class="s2">&quot;GS_Y0&quot;</span><span class="p">]</span>
        <span class="n">ra_func</span> <span class="o">=</span> <span class="n">_readFuncFromHeader</span><span class="p">(</span><span class="s1">&#39;R&#39;</span><span class="p">,</span> <span class="n">header</span><span class="p">)</span>
        <span class="n">dec_func</span> <span class="o">=</span> <span class="n">_readFuncFromHeader</span><span class="p">(</span><span class="s1">&#39;D&#39;</span><span class="p">,</span> <span class="n">header</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">RaDecFunction</span><span class="p">(</span><span class="n">ra_func</span><span class="p">,</span> <span class="n">dec_func</span><span class="p">,</span> <span class="n">_PositionD</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span><span class="n">y0</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">RaDecFunction</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_orig_ra_func</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_orig_dec_func</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">origin</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span> <span class="ow">is</span> <span class="n">other</span> <span class="ow">or</span>
                <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">RaDecFunction</span><span class="p">)</span> <span class="ow">and</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">_orig_ra_func</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_orig_ra_func</span> <span class="ow">and</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">_orig_dec_func</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_orig_dec_func</span> <span class="ow">and</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">origin</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">origin</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;galsim.RaDecFunction(</span><span class="si">%r</span><span class="s2">, </span><span class="si">%r</span><span class="s2">, </span><span class="si">%r</span><span class="s2">)&quot;</span><span class="o">%</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_orig_ra_func</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_orig_dec_func</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">origin</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="nb">hash</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">del</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;_radec_func&#39;</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">d</span>

    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span> <span class="o">=</span> <span class="n">d</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_funcs</span><span class="p">()</span></div>

<div class="viewcode-block" id="compatible"><a class="viewcode-back" href="../../wcs.html#galsim.compatible">[docs]</a><span class="k">def</span> <span class="nf">compatible</span><span class="p">(</span><span class="n">wcs1</span><span class="p">,</span> <span class="n">wcs2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A utility to check the compatibility of two WCS.  In particular, if two WCS are consistent with</span>
<span class="sd">    each other modulo a shifted origin, we consider them to be compatible, even though they are not</span>
<span class="sd">    equal.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">wcs1</span><span class="o">.</span><span class="n">_isUniform</span> <span class="ow">and</span> <span class="n">wcs2</span><span class="o">.</span><span class="n">_isUniform</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">wcs1</span><span class="o">.</span><span class="n">jacobian</span><span class="p">()</span> <span class="o">==</span> <span class="n">wcs2</span><span class="o">.</span><span class="n">jacobian</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">wcs1</span> <span class="o">==</span> <span class="n">wcs2</span><span class="o">.</span><span class="n">shiftOrigin</span><span class="p">(</span><span class="n">wcs1</span><span class="o">.</span><span class="n">origin</span><span class="p">,</span> <span class="n">wcs1</span><span class="o">.</span><span class="n">world_origin</span><span class="p">)</span></div>
</pre></div>

           </div>
           
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2019, GalSim-developers.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>