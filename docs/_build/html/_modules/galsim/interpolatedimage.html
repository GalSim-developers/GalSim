<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>galsim.interpolatedimage &mdash; GalSim 2.4.5 documentation</title><link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../index.html" class="icon icon-home"> GalSim
          </a>
              <div class="version">
                2.4
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../overview.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../install.html">Installation Instructions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tutorials.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../image.html">Images and Related Concepts</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../sb.html">Surface Brightness Profiles</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../chromatic.html">Wavelength-dependent Profiles</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../units.html">Units</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../wcs.html">World Coordinate Systems</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../random.html">Noise and Random Values</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../wl.html">Weak Lensing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../photon.html">Photon Shooting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../utilities.html">Helper Functions and Classes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../errors.html">Errors and Warnings</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../config.html">The Config Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../hsm.html">The HSM Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../des.html">The DES Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../roman.html">The Roman Space Telescope Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../cpp.html">C++ Layer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../shared.html">Shared Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../history.html">Revision History</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">GalSim</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../index.html">Module code</a> &raquo;</li>
      <li>galsim.interpolatedimage</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for galsim.interpolatedimage</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright (c) 2012-2022 by the GalSim developers team on GitHub</span>
<span class="c1"># https://github.com/GalSim-developers</span>
<span class="c1">#</span>
<span class="c1"># This file is part of GalSim: The modular galaxy image simulation toolkit.</span>
<span class="c1"># https://github.com/GalSim-developers/GalSim</span>
<span class="c1">#</span>
<span class="c1"># GalSim is free software: redistribution and use in source and binary forms,</span>
<span class="c1"># with or without modification, are permitted provided that the following</span>
<span class="c1"># conditions are met:</span>
<span class="c1">#</span>
<span class="c1"># 1. Redistributions of source code must retain the above copyright notice, this</span>
<span class="c1">#    list of conditions, and the disclaimer given in the accompanying LICENSE</span>
<span class="c1">#    file.</span>
<span class="c1"># 2. Redistributions in binary form must reproduce the above copyright notice,</span>
<span class="c1">#    this list of conditions, and the disclaimer given in the documentation</span>
<span class="c1">#    and/or other materials provided with the distribution.</span>
<span class="c1">#</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">math</span>

<span class="kn">from</span> <span class="nn">.gsobject</span> <span class="kn">import</span> <span class="n">GSObject</span>
<span class="kn">from</span> <span class="nn">.gsparams</span> <span class="kn">import</span> <span class="n">GSParams</span>
<span class="kn">from</span> <span class="nn">.image</span> <span class="kn">import</span> <span class="n">Image</span>
<span class="kn">from</span> <span class="nn">.bounds</span> <span class="kn">import</span> <span class="n">_BoundsI</span>
<span class="kn">from</span> <span class="nn">.position</span> <span class="kn">import</span> <span class="n">PositionD</span><span class="p">,</span> <span class="n">_PositionD</span>
<span class="kn">from</span> <span class="nn">.interpolant</span> <span class="kn">import</span> <span class="n">Quintic</span><span class="p">,</span> <span class="n">Interpolant</span><span class="p">,</span> <span class="n">SincInterpolant</span>
<span class="kn">from</span> <span class="nn">.utilities</span> <span class="kn">import</span> <span class="n">convert_interpolant</span><span class="p">,</span> <span class="n">lazy_property</span><span class="p">,</span> <span class="n">doc_inherit</span><span class="p">,</span> <span class="n">basestring</span>
<span class="kn">from</span> <span class="nn">.random</span> <span class="kn">import</span> <span class="n">BaseDeviate</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">_galsim</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">fits</span>
<span class="kn">from</span> <span class="nn">.errors</span> <span class="kn">import</span> <span class="n">GalSimError</span><span class="p">,</span> <span class="n">GalSimRangeError</span><span class="p">,</span> <span class="n">GalSimValueError</span><span class="p">,</span> <span class="n">GalSimUndefinedBoundsError</span>
<span class="kn">from</span> <span class="nn">.errors</span> <span class="kn">import</span> <span class="n">GalSimIncompatibleValuesError</span><span class="p">,</span> <span class="n">convert_cpp_errors</span><span class="p">,</span> <span class="n">galsim_warn</span>

<div class="viewcode-block" id="InterpolatedImage"><a class="viewcode-back" href="../../arbitrary.html#galsim.InterpolatedImage">[docs]</a><span class="k">class</span> <span class="nc">InterpolatedImage</span><span class="p">(</span><span class="n">GSObject</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A class describing non-parametric profiles specified using an `Image`, which can be</span>
<span class="sd">    interpolated for the purpose of carrying out transformations.</span>

<span class="sd">    The InterpolatedImage class is useful if you have a non-parametric description of an object as</span>
<span class="sd">    an `Image`, that you wish to manipulate / transform using `GSObject` methods such as</span>
<span class="sd">    `GSObject.shear`, `GSObject.magnify`, `GSObject.shift`, etc.  Note that when convolving an</span>
<span class="sd">    InterpolatedImage, the use of real-space convolution is not recommended, since it is typically</span>
<span class="sd">    a great deal slower than Fourier-space convolution for this kind of object.</span>

<span class="sd">    There are three options for determining the flux of the profile.</span>

<span class="sd">    1. You can simply specify a ``flux`` value explicitly.</span>
<span class="sd">    2. If you set ``normalization = &#39;flux&#39;``, the flux will be taken as the sum of the pixel values</span>
<span class="sd">       in the input image.  This corresponds to an image that was drawn with</span>
<span class="sd">       ``drawImage(method=&#39;no_pixel&#39;)``.  This is the default if flux is not given.</span>
<span class="sd">    3. If you set ``normalization = &#39;sb&#39;``, the pixel values are treated as samples of the surface</span>
<span class="sd">       brightness profile at each location.  This corresponds to an image drawn with</span>
<span class="sd">       ``drawImage(method=&#39;sb&#39;)``.  The flux is then the sum of the pixels in the input image</span>
<span class="sd">       multiplied by the pixel area.</span>

<span class="sd">    You can also use images that were drawn with one of the pixel-integrating methods (&#39;auto&#39;,</span>
<span class="sd">    &#39;phot&#39;, &#39;fft&#39;, or &#39;real_space&#39;), or real images where nature has integrated over the pixel for</span>
<span class="sd">    you.  However, the resulting profile will by default include a convolution by a `Pixel` (this</span>
<span class="sd">    is equivalent to integration over the pixel).  This is often acceptable, and the resulting</span>
<span class="sd">    `InterpolatedImage` object can be convolved by other profiles as usual.  One just needs to</span>
<span class="sd">    remember to draw the final convolved profile using ``method=&#39;no_pixel&#39;`` to avoid including</span>
<span class="sd">    the pixel convolution a second time.  In particular, one should not use it in conjunction</span>
<span class="sd">    with photon shooting, for the same reason.</span>

<span class="sd">    However, if you want to try to remove the effect of the pixel and have the `InterpolatedImage`</span>
<span class="sd">    model the pre-pixelized profile, then you can set ``depixelize=True``.  This will call</span>
<span class="sd">    `Image.depixelize` on the image automatically to try to remove the effect of the pixelization.</span>
<span class="sd">    We recommend using a Lanczos interpolant with this option for best results.  (Higher order</span>
<span class="sd">    tends to work better here.) This step can be rather slow and memory-demanding, so use this</span>
<span class="sd">    with caution.  But if used, the resulting profile represents the true underlying profile,</span>
<span class="sd">    without the pixel convolution.  It can therefore be rotated, sheared, etc.  And when rendering,</span>
<span class="sd">    one should use the methods that do involve integration over the pixel: ``auto``, ``phot``, etc.</span>

<span class="sd">    .. warning ::</span>

<span class="sd">        Input images that are undersampled and/or noisy may not necessarily work well with the</span>
<span class="sd">        ``depixelize=True`` option.  Users should treat this option with some care and validate</span>
<span class="sd">        that the results are sufficiently accurate for your particular use case.</span>

<span class="sd">    If the input `Image` has a ``scale`` or ``wcs`` associated with it, then there is no need to</span>
<span class="sd">    specify one as a parameter here.  But if one is provided, that will override any ``scale`` or</span>
<span class="sd">    ``wcs`` that is native to the `Image`.</span>

<span class="sd">    The user may optionally specify an interpolant, ``x_interpolant``, for real-space manipulations</span>
<span class="sd">    (e.g., shearing, resampling).  If none is specified, then by default, a `Quintic` interpolant is</span>
<span class="sd">    used.  The user may also choose to specify two quantities that can affect the Fourier space</span>
<span class="sd">    convolution: the k-space interpolant (``k_interpolant``) and the amount of padding to include</span>
<span class="sd">    around the original images (``pad_factor``).  The default values for ``x_interpolant``,</span>
<span class="sd">    ``k_interpolant``, and ``pad_factor`` were chosen based on the tests of branch #389 to reach</span>
<span class="sd">    good accuracy without being excessively slow.  Users should be particularly wary about changing</span>
<span class="sd">    ``k_interpolant`` and ``pad_factor`` from the defaults without careful testing.  The user is</span>
<span class="sd">    given complete freedom to choose interpolants and pad factors, and no warnings are raised when</span>
<span class="sd">    the code is modified to choose some combination that is known to give significant error.  More</span>
<span class="sd">    details can be found in http://arxiv.org/abs/1401.2636, especially table 1, and in comment</span>
<span class="sd">    https://github.com/GalSim-developers/GalSim/issues/389#issuecomment-26166621 and the following</span>
<span class="sd">    comments.</span>

<span class="sd">    The user can choose to pad the image with a noise profile if desired.  To do so, specify</span>
<span class="sd">    the target size for the noise padding in ``noise_pad_size``, and specify the kind of noise</span>
<span class="sd">    to use in ``noise_pad``.  The ``noise_pad`` option may be a Gaussian random noise of some</span>
<span class="sd">    variance, or a Gaussian but correlated noise field that is specified either as a</span>
<span class="sd">    `BaseCorrelatedNoise` instance, an `Image` (from which a correlated noise model is derived), or</span>
<span class="sd">    a string (interpreted as a filename of an image to use for deriving a `CorrelatedNoise`).</span>
<span class="sd">    The user can also pass in a random number generator to be used for noise generation.  Finally,</span>
<span class="sd">    the user can pass in a ``pad_image`` for deterministic image padding.</span>

<span class="sd">    By default, the InterpolatedImage recalculates the Fourier-space step and number of points to</span>
<span class="sd">    use for further manipulations, rather than using the most conservative possibility.  For typical</span>
<span class="sd">    objects representing galaxies and PSFs this can easily make the difference between several</span>
<span class="sd">    seconds (conservative) and 0.04s (recalculated).  However, the user can turn off this option,</span>
<span class="sd">    and may especially wish to do so when using images that do not contain a high S/N object - e.g.,</span>
<span class="sd">    images of noise fields.</span>


<span class="sd">    Example::</span>

<span class="sd">        &gt;&gt;&gt; interpolated_image = galsim.InterpolatedImage(</span>
<span class="sd">                image, x_interpolant=None, k_interpolant=None, normalization=&#39;flux&#39;, scale=None,</span>
<span class="sd">                wcs=None, flux=None, pad_factor=4., noise_pad_size=0, noise_pad=0., use_cache=True,</span>
<span class="sd">                pad_image=None, rng=None, calculate_stepk=True, calculate_maxk=True,</span>
<span class="sd">                use_true_center=True, offset=None, hdu=None)</span>

<span class="sd">    Initializes ``interpolated_image`` as an InterpolatedImage instance.</span>

<span class="sd">    For comparison of the case of padding with noise or zero when the image itself includes noise,</span>
<span class="sd">    compare ``im1`` and ``im2`` from the following code snippet (which can be executed from the</span>
<span class="sd">    examples/ directory)::</span>

<span class="sd">        &gt;&gt;&gt; image = galsim.fits.read(&#39;data/147246.0_150.416558_1.998697_masknoise.fits&#39;)</span>
<span class="sd">        &gt;&gt;&gt; int_im1 = galsim.InterpolatedImage(image)</span>
<span class="sd">        &gt;&gt;&gt; int_im2 = galsim.InterpolatedImage(image, noise_pad=&#39;data/blankimg.fits&#39;)</span>
<span class="sd">        &gt;&gt;&gt; im1 = galsim.ImageF(1000,1000)</span>
<span class="sd">        &gt;&gt;&gt; im2 = galsim.ImageF(1000,1000)</span>
<span class="sd">        &gt;&gt;&gt; int_im1.drawImage(im1, method=&#39;no_pixel&#39;)</span>
<span class="sd">        &gt;&gt;&gt; int_im2.drawImage(im2, method=&#39;no_pixel&#39;)</span>

<span class="sd">    Examination of these two images clearly shows how padding with a correlated noise field that is</span>
<span class="sd">    similar to the one in the real data leads to a more reasonable appearance for the result when</span>
<span class="sd">    re-drawn at a different size.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        image:              The `Image` from which to construct the object.</span>
<span class="sd">                            This may be either an `Image` instance or a string indicating a fits</span>
<span class="sd">                            file from which to read the image.  In the latter case, the ``hdu``</span>
<span class="sd">                            kwarg can be used to specify a particular HDU in that file.</span>
<span class="sd">        x_interpolant:      Either an `Interpolant` instance or a string indicating which real-space</span>
<span class="sd">                            interpolant should be used.  Options are &#39;nearest&#39;, &#39;sinc&#39;, &#39;linear&#39;,</span>
<span class="sd">                            &#39;cubic&#39;, &#39;quintic&#39;, or &#39;lanczosN&#39; where N should be the integer order</span>
<span class="sd">                            to use. [default: galsim.Quintic()]</span>
<span class="sd">        k_interpolant:      Either an `Interpolant` instance or a string indicating which k-space</span>
<span class="sd">                            interpolant should be used.  Options are &#39;nearest&#39;, &#39;sinc&#39;, &#39;linear&#39;,</span>
<span class="sd">                            &#39;cubic&#39;, &#39;quintic&#39;, or &#39;lanczosN&#39; where N should be the integer order</span>
<span class="sd">                            to use.  We strongly recommend leaving this parameter at its default</span>
<span class="sd">                            value; see text above for details.  [default: galsim.Quintic()]</span>
<span class="sd">        normalization:      Two options for specifying the normalization of the input `Image`:</span>

<span class="sd">                            - &quot;flux&quot; or &quot;f&quot; means that the sum of the pixels is normalized</span>
<span class="sd">                              to be equal to the total flux.</span>
<span class="sd">                            - &quot;surface brightness&quot; or &quot;sb&quot; means that the pixels sample</span>
<span class="sd">                              the surface brightness distribution at each location.</span>

<span class="sd">                            This is overridden if you specify an explicit flux value.</span>
<span class="sd">                            [default: &quot;flux&quot;]</span>
<span class="sd">        scale:              If provided, use this as the pixel scale for the `Image`; this will</span>
<span class="sd">                            override the pixel scale stored by the provided `Image`, in any.</span>
<span class="sd">                            If ``scale`` is ``None``, then take the provided image&#39;s pixel scale.</span>
<span class="sd">                            [default: None]</span>
<span class="sd">        wcs:                If provided, use this as the wcs for the image.  At most one of</span>
<span class="sd">                            ``scale`` or ``wcs`` may be provided. [default: None]</span>
<span class="sd">        flux:               Optionally specify a total flux for the object, which overrides the</span>
<span class="sd">                            implied flux normalization from the `Image` itself. [default: None]</span>
<span class="sd">        pad_factor:         Factor by which to pad the `Image` with zeros.  We strongly recommend</span>
<span class="sd">                            leaving this parameter at its default value; see text above for</span>
<span class="sd">                            details.  [default: 4]</span>
<span class="sd">        noise_pad_size:     If provided, the image will be padded out to this size (in arcsec) with</span>
<span class="sd">                            the noise specified by ``noise_pad``. This is important if you are</span>
<span class="sd">                            planning to whiten the resulting image.  You want to make sure that the</span>
<span class="sd">                            noise-padded image is larger than the postage stamp onto which you are</span>
<span class="sd">                            drawing this object.  [default: None]</span>
<span class="sd">        noise_pad:          Noise properties to use when padding the original image with</span>
<span class="sd">                            noise.  This can be specified in several ways:</span>

<span class="sd">                            a) as a float, which is interpreted as being a variance to use when</span>
<span class="sd">                               padding with uncorrelated Gaussian noise;</span>
<span class="sd">                            b) as a `galsim.BaseCorrelatedNoise`, which contains information about</span>
<span class="sd">                               the desired noise power spectrum - any random number generator passed</span>
<span class="sd">                               to the ``rng`` keyword will take precedence over that carried in</span>
<span class="sd">                               an input `BaseCorrelatedNoise` instance;</span>
<span class="sd">                            c) as an `Image` of a noise field, which is used to calculate</span>
<span class="sd">                               the desired noise power spectrum; or</span>
<span class="sd">                            d) as a string which is interpreted as a filename containing an</span>
<span class="sd">                               example noise field with the proper noise power spectrum (as an</span>
<span class="sd">                               `Image` in the first HDU).</span>

<span class="sd">                            It is important to keep in mind that the calculation of the correlation</span>
<span class="sd">                            function that is internally stored within a `BaseCorrelatedNoise`</span>
<span class="sd">                            object is a non-negligible amount of overhead, so the recommended means</span>
<span class="sd">                            of specifying a correlated noise field for padding are (b) or (d).  In</span>
<span class="sd">                            the case of (d), if the same file is used repeatedly, then the</span>
<span class="sd">                            ``use_cache`` keyword (see below) can be used to prevent the need for</span>
<span class="sd">                            repeated `CorrelatedNoise` initializations.  [default: 0, i.e., pad</span>
<span class="sd">                            with zeros]</span>
<span class="sd">        use_cache:          Specify whether to cache ``noise_pad`` read in from a file to save</span>
<span class="sd">                            having to build a CorrelatedNoise object repeatedly from the same image.</span>
<span class="sd">                            [default: True]</span>
<span class="sd">        rng:                If padding by noise, the user can optionally supply the random noise</span>
<span class="sd">                            generator to use for drawing random numbers as ``rng`` (may be any kind</span>
<span class="sd">                            of `BaseDeviate` object).  Such a user-input random number generator</span>
<span class="sd">                            takes precedence over any stored within a user-input</span>
<span class="sd">                            `BaseCorrelatedNoise` instance (see the ``noise_pad`` parameter).</span>
<span class="sd">                            If ``rng=None``, one will be automatically created, using the time as a</span>
<span class="sd">                            seed. [default: None]</span>
<span class="sd">        pad_image:          `Image` to be used for deterministically padding the original image.</span>
<span class="sd">                            This can be specified in two ways:</span>

<span class="sd">                            - as an `Image`; or</span>
<span class="sd">                            - as a string which is interpreted as a filename containing an</span>
<span class="sd">                              image to use (in the first HDU).</span>

<span class="sd">                            The ``pad_image`` scale or wcs is ignored.  It uses the same scale or</span>
<span class="sd">                            wcs for both the ``image`` and the ``pad_image``.</span>
<span class="sd">                            The user should be careful to ensure that the image used for padding</span>
<span class="sd">                            has roughly zero mean.  The purpose of this keyword is to allow for a</span>
<span class="sd">                            more flexible representation of some noise field around an object; if</span>
<span class="sd">                            the user wishes to represent the sky level around an object, they</span>
<span class="sd">                            should do that after they have drawn the final image instead.</span>
<span class="sd">                            [default: None]</span>
<span class="sd">        calculate_stepk:    Specify whether to perform an internal determination of the extent of</span>
<span class="sd">                            the object being represented by the InterpolatedImage; often this is</span>
<span class="sd">                            useful in choosing an optimal value for the stepsize in the Fourier</span>
<span class="sd">                            space lookup table.</span>
<span class="sd">                            If you know a priori an appropriate maximum value for ``stepk``, then</span>
<span class="sd">                            you may also supply that here instead of a bool value, in which case</span>
<span class="sd">                            the ``stepk`` value is still calculated, but will not go above the</span>
<span class="sd">                            provided value.</span>
<span class="sd">                            [default: True]</span>
<span class="sd">        calculate_maxk:     Specify whether to perform an internal determination of the highest</span>
<span class="sd">                            spatial frequency needed to accurately render the object being</span>
<span class="sd">                            represented by the InterpolatedImage; often this is useful in choosing</span>
<span class="sd">                            an optimal value for the extent of the Fourier space lookup table.</span>
<span class="sd">                            If you know a priori an appropriate maximum value for ``maxk``, then</span>
<span class="sd">                            you may also supply that here instead of a bool value, in which case</span>
<span class="sd">                            the ``maxk`` value is still calculated, but will not go above the</span>
<span class="sd">                            provided value.</span>
<span class="sd">                            [default: True]</span>
<span class="sd">        use_true_center:    Similar to the same parameter in the `GSObject.drawImage` function,</span>
<span class="sd">                            this sets whether to use the true center of the provided image as the</span>
<span class="sd">                            center of the profile (if ``use_true_center=True``) or the nominal</span>
<span class="sd">                            center given by image.center (if ``use_true_center=False``)</span>
<span class="sd">                            [default: True]</span>
<span class="sd">        depixelize:         Whether to try to remove the effect of the pixelization.  If this is</span>
<span class="sd">                            True, then drawing this profile with method=&#39;auto&#39; should render an</span>
<span class="sd">                            image equivalent to the input image.  If this is False (the default),</span>
<span class="sd">                            then you would need to draw with method=&#39;no_pixel&#39; to get an equivalent</span>
<span class="sd">                            image.  See discussion above. [default: False]</span>
<span class="sd">        offset:             The location in the input image to use as the center of the profile.</span>
<span class="sd">                            This should be specified relative to the center of the input image</span>
<span class="sd">                            (either the true center if ``use_true_center=True``, or the nominal</span>
<span class="sd">                            center if ``use_true_center=False``).  [default: None]</span>
<span class="sd">        gsparams:           An optional `GSParams` argument. [default: None]</span>
<span class="sd">        hdu:                When reading in an `Image` from a file, this parameter can be used to</span>
<span class="sd">                            select a particular HDU in the file. [default: None]</span>
<span class="sd">        _force_stepk:       Override the normal stepk calculation (using gsparams.folding_threshold)</span>
<span class="sd">                            and force stepk to the given value. [default: 0]</span>
<span class="sd">        _force_maxk:        Override the normal maxk calculation (using gsparams.maxk_threshold)</span>
<span class="sd">                            and force maxk to the given value.  This option in particular can help</span>
<span class="sd">                            reduce FFT artifacts in a manner that is currently unobtainable by</span>
<span class="sd">                            lowering maxk_threshold. [default: 0]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_req_params</span> <span class="o">=</span> <span class="p">{</span> <span class="s1">&#39;image&#39;</span> <span class="p">:</span> <span class="nb">str</span> <span class="p">}</span>
    <span class="n">_opt_params</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;x_interpolant&#39;</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="s1">&#39;k_interpolant&#39;</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="s1">&#39;normalization&#39;</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="s1">&#39;scale&#39;</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="s1">&#39;flux&#39;</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="s1">&#39;pad_factor&#39;</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="s1">&#39;noise_pad_size&#39;</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="s1">&#39;noise_pad&#39;</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="s1">&#39;pad_image&#39;</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="s1">&#39;calculate_stepk&#39;</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
        <span class="s1">&#39;calculate_maxk&#39;</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
        <span class="s1">&#39;use_true_center&#39;</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
        <span class="s1">&#39;depixelize&#39;</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
        <span class="s1">&#39;offset&#39;</span><span class="p">:</span> <span class="n">PositionD</span><span class="p">,</span>
        <span class="s1">&#39;hdu&#39;</span><span class="p">:</span> <span class="nb">int</span>
    <span class="p">}</span>
    <span class="n">_takes_rng</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">_cache_noise_pad</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="n">_has_hard_edges</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">_is_axisymmetric</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">_is_analytic_x</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">_is_analytic_k</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span> <span class="n">x_interpolant</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">k_interpolant</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">normalization</span><span class="o">=</span><span class="s1">&#39;flux&#39;</span><span class="p">,</span>
                 <span class="n">scale</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">wcs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">flux</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pad_factor</span><span class="o">=</span><span class="mf">4.</span><span class="p">,</span> <span class="n">noise_pad_size</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">noise_pad</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span>
                 <span class="n">rng</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pad_image</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">calculate_stepk</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">calculate_maxk</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                 <span class="n">use_cache</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">use_true_center</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">depixelize</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">gsparams</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">_force_stepk</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span> <span class="n">_force_maxk</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span> <span class="n">hdu</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="kn">from</span> <span class="nn">.wcs</span> <span class="kn">import</span> <span class="n">BaseWCS</span><span class="p">,</span> <span class="n">PixelScale</span>
        <span class="kn">from</span> <span class="nn">.random</span> <span class="kn">import</span> <span class="n">BaseDeviate</span>

        <span class="c1"># If the &quot;image&quot; is not actually an image, try to read the image as a file.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">image</span> <span class="o">=</span> <span class="n">fits</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">hdu</span><span class="o">=</span><span class="n">hdu</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">Image</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Supplied image must be an Image or file name&quot;</span><span class="p">)</span>

        <span class="c1"># it must have well-defined bounds, otherwise seg fault in SBInterpolatedImage constructor</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">image</span><span class="o">.</span><span class="n">bounds</span><span class="o">.</span><span class="n">isDefined</span><span class="p">():</span>
            <span class="k">raise</span> <span class="n">GalSimUndefinedBoundsError</span><span class="p">(</span><span class="s2">&quot;Supplied image does not have bounds defined.&quot;</span><span class="p">)</span>

        <span class="c1"># check what normalization was specified for the image: is it an image of surface</span>
        <span class="c1"># brightness, or flux?</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">normalization</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;flux&quot;</span><span class="p">,</span> <span class="s2">&quot;f&quot;</span><span class="p">,</span> <span class="s2">&quot;surface brightness&quot;</span><span class="p">,</span> <span class="s2">&quot;sb&quot;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">GalSimValueError</span><span class="p">(</span><span class="s2">&quot;Invalid normalization requested.&quot;</span><span class="p">,</span> <span class="n">normalization</span><span class="p">,</span>
                                   <span class="p">(</span><span class="s1">&#39;flux&#39;</span><span class="p">,</span> <span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="s1">&#39;surface brightness&#39;</span><span class="p">,</span> <span class="s1">&#39;sb&#39;</span><span class="p">))</span>

        <span class="c1"># Set up the interpolants if none was provided by user, or check that the user-provided ones</span>
        <span class="c1"># are of a valid type</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_gsparams</span> <span class="o">=</span> <span class="n">GSParams</span><span class="o">.</span><span class="n">check</span><span class="p">(</span><span class="n">gsparams</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">x_interpolant</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_x_interpolant</span> <span class="o">=</span> <span class="n">Quintic</span><span class="p">(</span><span class="n">gsparams</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_gsparams</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_x_interpolant</span> <span class="o">=</span> <span class="n">convert_interpolant</span><span class="p">(</span><span class="n">x_interpolant</span><span class="p">)</span><span class="o">.</span><span class="n">withGSParams</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_gsparams</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">k_interpolant</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_k_interpolant</span> <span class="o">=</span> <span class="n">Quintic</span><span class="p">(</span><span class="n">gsparams</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_gsparams</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_k_interpolant</span> <span class="o">=</span> <span class="n">convert_interpolant</span><span class="p">(</span><span class="n">k_interpolant</span><span class="p">)</span><span class="o">.</span><span class="n">withGSParams</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_gsparams</span><span class="p">)</span>

        <span class="c1"># Store the image as an attribute and make sure we don&#39;t change the original image</span>
        <span class="c1"># in anything we do here.  (e.g. set scale, etc.)</span>
        <span class="k">if</span> <span class="n">depixelize</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_image</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span><span class="o">.</span><span class="n">depixelize</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_x_interpolant</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_image</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">contiguous</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_image</span><span class="o">.</span><span class="n">setCenter</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># Set the wcs if necessary</span>
        <span class="k">if</span> <span class="n">scale</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">wcs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">GalSimIncompatibleValuesError</span><span class="p">(</span>
                    <span class="s2">&quot;Cannot provide both scale and wcs to InterpolatedImage&quot;</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">,</span> <span class="n">wcs</span><span class="o">=</span><span class="n">wcs</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_image</span><span class="o">.</span><span class="n">wcs</span> <span class="o">=</span> <span class="n">PixelScale</span><span class="p">(</span><span class="n">scale</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">wcs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">wcs</span><span class="p">,</span> <span class="n">BaseWCS</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;wcs parameter is not a galsim.BaseWCS instance&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_image</span><span class="o">.</span><span class="n">wcs</span> <span class="o">=</span> <span class="n">wcs</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_image</span><span class="o">.</span><span class="n">wcs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">GalSimIncompatibleValuesError</span><span class="p">(</span>
                <span class="s2">&quot;No information given with Image or keywords about pixel scale!&quot;</span><span class="p">,</span>
                <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">,</span> <span class="n">wcs</span><span class="o">=</span><span class="n">wcs</span><span class="p">,</span> <span class="n">image</span><span class="o">=</span><span class="n">image</span><span class="p">)</span>

        <span class="c1"># Figure out the offset to apply based on the original image (not the padded one).</span>
        <span class="c1"># We will apply this below in _sbp.</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_offset</span><span class="p">(</span><span class="n">offset</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_offset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_adjust_offset</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_image</span><span class="o">.</span><span class="n">bounds</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">use_true_center</span><span class="p">)</span>

        <span class="n">im_cen</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">true_center</span> <span class="k">if</span> <span class="n">use_true_center</span> <span class="k">else</span> <span class="n">image</span><span class="o">.</span><span class="n">center</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_wcs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_image</span><span class="o">.</span><span class="n">wcs</span><span class="o">.</span><span class="n">local</span><span class="p">(</span><span class="n">image_pos</span><span class="o">=</span><span class="n">im_cen</span><span class="p">)</span>

        <span class="c1"># Build the fully padded real-space image according to the various pad options.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_buildRealImage</span><span class="p">(</span><span class="n">pad_factor</span><span class="p">,</span> <span class="n">pad_image</span><span class="p">,</span> <span class="n">noise_pad_size</span><span class="p">,</span> <span class="n">noise_pad</span><span class="p">,</span> <span class="n">rng</span><span class="p">,</span> <span class="n">use_cache</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_image_flux</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_image</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

        <span class="c1"># I think the only things that will mess up if flux == 0 are the</span>
        <span class="c1"># calculateStepK and calculateMaxK functions, and rescaling the flux to some value.</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">calculate_stepk</span> <span class="ow">or</span> <span class="n">calculate_maxk</span> <span class="ow">or</span> <span class="n">flux</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_image_flux</span> <span class="o">==</span> <span class="mf">0.</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">GalSimValueError</span><span class="p">(</span><span class="s2">&quot;This input image has zero total flux. It does not define a &quot;</span>
                                   <span class="s2">&quot;valid surface brightness profile.&quot;</span><span class="p">,</span> <span class="n">image</span><span class="p">)</span>

        <span class="c1"># Process the different options for flux, stepk, maxk</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_flux</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getFlux</span><span class="p">(</span><span class="n">flux</span><span class="p">,</span> <span class="n">normalization</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_calculate_stepk</span> <span class="o">=</span> <span class="n">calculate_stepk</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_calculate_maxk</span> <span class="o">=</span> <span class="n">calculate_maxk</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_stepk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getStepK</span><span class="p">(</span><span class="n">calculate_stepk</span><span class="p">,</span> <span class="n">_force_stepk</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_maxk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getMaxK</span><span class="p">(</span><span class="n">calculate_maxk</span><span class="p">,</span> <span class="n">_force_maxk</span><span class="p">)</span>

<div class="viewcode-block" id="InterpolatedImage.withGSParams"><a class="viewcode-back" href="../../arbitrary.html#galsim.InterpolatedImage.withGSParams">[docs]</a>    <span class="nd">@doc_inherit</span>
    <span class="k">def</span> <span class="nf">withGSParams</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gsparams</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">gsparams</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">gsparams</span><span class="p">:</span> <span class="k">return</span> <span class="bp">self</span>
        <span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">copy</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">_gsparams</span> <span class="o">=</span> <span class="n">GSParams</span><span class="o">.</span><span class="n">check</span><span class="p">(</span><span class="n">gsparams</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gsparams</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">_x_interpolant</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x_interpolant</span><span class="o">.</span><span class="n">withGSParams</span><span class="p">(</span><span class="n">ret</span><span class="o">.</span><span class="n">_gsparams</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">_k_interpolant</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_k_interpolant</span><span class="o">.</span><span class="n">withGSParams</span><span class="p">(</span><span class="n">ret</span><span class="o">.</span><span class="n">_gsparams</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ret</span><span class="o">.</span><span class="n">_gsparams</span><span class="o">.</span><span class="n">folding_threshold</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gsparams</span><span class="o">.</span><span class="n">folding_threshold</span><span class="p">:</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">_stepk</span> <span class="o">=</span> <span class="n">ret</span><span class="o">.</span><span class="n">_getStepK</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_calculate_stepk</span><span class="p">,</span> <span class="mf">0.</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ret</span><span class="o">.</span><span class="n">_gsparams</span><span class="o">.</span><span class="n">maxk_threshold</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gsparams</span><span class="o">.</span><span class="n">maxk_threshold</span><span class="p">:</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">_maxk</span> <span class="o">=</span> <span class="n">ret</span><span class="o">.</span><span class="n">_getMaxK</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_calculate_maxk</span><span class="p">,</span> <span class="mf">0.</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ret</span></div>

    <span class="nd">@lazy_property</span>
    <span class="k">def</span> <span class="nf">_sbp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">min_scale</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wcs</span><span class="o">.</span><span class="n">_minScale</span><span class="p">()</span>
        <span class="n">max_scale</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wcs</span><span class="o">.</span><span class="n">_maxScale</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sbii</span> <span class="o">=</span> <span class="n">_galsim</span><span class="o">.</span><span class="n">SBInterpolatedImage</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_xim</span><span class="o">.</span><span class="n">_image</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_image</span><span class="o">.</span><span class="n">bounds</span><span class="o">.</span><span class="n">_b</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pad_image</span><span class="o">.</span><span class="n">bounds</span><span class="o">.</span><span class="n">_b</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_x_interpolant</span><span class="o">.</span><span class="n">_i</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_k_interpolant</span><span class="o">.</span><span class="n">_i</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_stepk</span><span class="o">*</span><span class="n">min_scale</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_maxk</span><span class="o">*</span><span class="n">max_scale</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">gsparams</span><span class="o">.</span><span class="n">_gsp</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_sbp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sbii</span>  <span class="c1"># Temporary.  Will overwrite this with the return value.</span>

        <span class="c1"># Apply the offset</span>
        <span class="n">prof</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_offset</span> <span class="o">!=</span> <span class="n">_PositionD</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">):</span>
            <span class="c1"># Opposite direction of what drawImage does.</span>
            <span class="n">prof</span> <span class="o">=</span> <span class="n">prof</span><span class="o">.</span><span class="n">_shift</span><span class="p">(</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">_offset</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">_offset</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>

        <span class="c1"># If the user specified a flux, then set to that flux value.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flux</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_image_flux</span><span class="p">:</span>
            <span class="n">flux_ratio</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flux</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_image_flux</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">flux_ratio</span> <span class="o">=</span> <span class="mf">1.</span>

        <span class="c1"># Bring the profile from image coordinates into world coordinates</span>
        <span class="c1"># Note: offset needs to happen first before the transformation, so can&#39;t bundle it here.</span>
        <span class="n">prof</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wcs</span><span class="o">.</span><span class="n">_profileToWorld</span><span class="p">(</span><span class="n">prof</span><span class="p">,</span> <span class="n">flux_ratio</span><span class="p">,</span> <span class="n">_PositionD</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">prof</span><span class="o">.</span><span class="n">_sbp</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">x_interpolant</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The real-space `Interpolant` for this profile.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x_interpolant</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">k_interpolant</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The Fourier-space `Interpolant` for this profile.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_k_interpolant</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">image</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The underlying `Image` being interpolated.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_image</span>

    <span class="k">def</span> <span class="nf">_buildRealImage</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pad_factor</span><span class="p">,</span> <span class="n">pad_image</span><span class="p">,</span> <span class="n">noise_pad_size</span><span class="p">,</span> <span class="n">noise_pad</span><span class="p">,</span> <span class="n">rng</span><span class="p">,</span> <span class="n">use_cache</span><span class="p">):</span>
        <span class="c1"># Check that given pad_image is valid:</span>
        <span class="k">if</span> <span class="n">pad_image</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pad_image</span><span class="p">,</span> <span class="n">basestring</span><span class="p">):</span>
                <span class="n">pad_image</span> <span class="o">=</span> <span class="n">fits</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">pad_image</span><span class="p">)</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pad_image</span><span class="p">,</span> <span class="n">Image</span><span class="p">):</span>
                <span class="n">pad_image</span> <span class="o">=</span> <span class="n">pad_image</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">contiguous</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Supplied pad_image must be an Image.&quot;</span><span class="p">,</span> <span class="n">pad_image</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">pad_factor</span> <span class="o">&lt;=</span> <span class="mf">0.</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">GalSimRangeError</span><span class="p">(</span><span class="s2">&quot;Invalid pad_factor &lt;= 0 in InterpolatedImage&quot;</span><span class="p">,</span> <span class="n">pad_factor</span><span class="p">,</span> <span class="mf">0.</span><span class="p">)</span>

        <span class="c1"># Convert noise_pad_size from arcsec to pixels according to the local wcs.</span>
        <span class="c1"># Use the minimum scale, since we want to make sure noise_pad_size is</span>
        <span class="c1"># as large as we need in any direction.</span>
        <span class="k">if</span> <span class="n">noise_pad_size</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">noise_pad_size</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">GalSimValueError</span><span class="p">(</span><span class="s2">&quot;noise_pad_size may not be negative&quot;</span><span class="p">,</span> <span class="n">noise_pad_size</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">noise_pad</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">GalSimIncompatibleValuesError</span><span class="p">(</span>
                        <span class="s2">&quot;Must provide noise_pad if noise_pad_size &gt; 0&quot;</span><span class="p">,</span>
                        <span class="n">noise_pad</span><span class="o">=</span><span class="n">noise_pad</span><span class="p">,</span> <span class="n">noise_pad_size</span><span class="o">=</span><span class="n">noise_pad_size</span><span class="p">)</span>
            <span class="n">noise_pad_size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">noise_pad_size</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wcs</span><span class="o">.</span><span class="n">_minScale</span><span class="p">()))</span>
            <span class="n">noise_pad_size</span> <span class="o">=</span> <span class="n">Image</span><span class="o">.</span><span class="n">good_fft_size</span><span class="p">(</span><span class="n">noise_pad_size</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">noise_pad</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">GalSimIncompatibleValuesError</span><span class="p">(</span>
                        <span class="s2">&quot;Must provide noise_pad_size if noise_pad != 0&quot;</span><span class="p">,</span>
                        <span class="n">noise_pad</span><span class="o">=</span><span class="n">noise_pad</span><span class="p">,</span> <span class="n">noise_pad_size</span><span class="o">=</span><span class="n">noise_pad_size</span><span class="p">)</span>

        <span class="c1"># The size of the final padded image is the largest of the various size specifications</span>
        <span class="n">pad_size</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_image</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">pad_factor</span> <span class="o">&gt;</span> <span class="mf">1.</span><span class="p">:</span>
            <span class="n">pad_size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">pad_factor</span> <span class="o">*</span> <span class="n">pad_size</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">noise_pad_size</span><span class="p">:</span>
            <span class="n">pad_size</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">pad_size</span><span class="p">,</span> <span class="n">noise_pad_size</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">pad_image</span><span class="p">:</span>
            <span class="n">pad_image</span><span class="o">.</span><span class="n">setCenter</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">pad_size</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">pad_size</span><span class="p">,</span> <span class="o">*</span><span class="n">pad_image</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="c1"># And round up to a good fft size</span>
        <span class="n">pad_size</span> <span class="o">=</span> <span class="n">Image</span><span class="o">.</span><span class="n">good_fft_size</span><span class="p">(</span><span class="n">pad_size</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_xim</span> <span class="o">=</span> <span class="n">Image</span><span class="p">(</span><span class="n">pad_size</span><span class="p">,</span> <span class="n">pad_size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">wcs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_wcs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_xim</span><span class="o">.</span><span class="n">setCenter</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># If requested, fill (some of) this image with noise padding.</span>
        <span class="n">nz_bounds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_image</span><span class="o">.</span><span class="n">bounds</span>
        <span class="k">if</span> <span class="n">noise_pad</span><span class="p">:</span>
            <span class="c1"># This is a bit involved, so pass this off to another helper function.</span>
            <span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_buildNoisePadImage</span><span class="p">(</span><span class="n">noise_pad_size</span><span class="p">,</span> <span class="n">noise_pad</span><span class="p">,</span> <span class="n">rng</span><span class="p">,</span> <span class="n">use_cache</span><span class="p">)</span>
            <span class="n">nz_bounds</span> <span class="o">+=</span> <span class="n">b</span>

        <span class="c1"># The the user gives us a pad image to use, fill the relevant portion with that.</span>
        <span class="k">if</span> <span class="n">pad_image</span><span class="p">:</span>
            <span class="c1">#assert self._xim.bounds.includes(pad_image.bounds)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_xim</span><span class="p">[</span><span class="n">pad_image</span><span class="o">.</span><span class="n">bounds</span><span class="p">]</span> <span class="o">=</span> <span class="n">pad_image</span>
            <span class="n">nz_bounds</span> <span class="o">+=</span> <span class="n">pad_image</span><span class="o">.</span><span class="n">bounds</span>

        <span class="c1"># Now place the given image in the center of the padding image:</span>
        <span class="c1">#assert self._xim.bounds.includes(self._image.bounds)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_xim</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_image</span><span class="o">.</span><span class="n">bounds</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_image</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_xim</span><span class="o">.</span><span class="n">wcs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wcs</span>

        <span class="c1"># And update the _image to be that portion of the full real image rather than the</span>
        <span class="c1"># input image.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_image</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xim</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_image</span><span class="o">.</span><span class="n">bounds</span><span class="p">]</span>

        <span class="c1"># These next two allow for easy pickling/repring.  We don&#39;t need to serialize all the</span>
        <span class="c1"># zeros around the edge.  But we do need to keep any non-zero padding as a pad_image.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pad_image</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xim</span><span class="p">[</span><span class="n">nz_bounds</span><span class="p">]</span>
        <span class="c1">#self._pad_factor = (max(self._xim.array.shape)-1.e-6) / max(self._image.array.shape)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pad_factor</span> <span class="o">=</span> <span class="n">pad_factor</span>

    <span class="k">def</span> <span class="nf">_buildNoisePadImage</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">noise_pad_size</span><span class="p">,</span> <span class="n">noise_pad</span><span class="p">,</span> <span class="n">rng</span><span class="p">,</span> <span class="n">use_cache</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;A helper function that builds the ``pad_image`` from the given ``noise_pad``</span>
<span class="sd">        specification.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.random</span> <span class="kn">import</span> <span class="n">BaseDeviate</span>
        <span class="kn">from</span> <span class="nn">.noise</span> <span class="kn">import</span> <span class="n">GaussianNoise</span>
        <span class="kn">from</span> <span class="nn">.correlatednoise</span> <span class="kn">import</span> <span class="n">BaseCorrelatedNoise</span><span class="p">,</span> <span class="n">CorrelatedNoise</span>

        <span class="c1"># Make sure we make rng a BaseDeviate if rng is None</span>
        <span class="n">rng1</span> <span class="o">=</span> <span class="n">BaseDeviate</span><span class="p">(</span><span class="n">rng</span><span class="p">)</span>

        <span class="c1"># Figure out what kind of noise to apply to the image</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">noise_pad</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">noise_pad</span><span class="p">)</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">noise_pad</span><span class="p">,</span> <span class="n">BaseCorrelatedNoise</span><span class="p">):</span>
                <span class="n">noise</span> <span class="o">=</span> <span class="n">noise_pad</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">rng</span><span class="o">=</span><span class="n">rng1</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">noise_pad</span><span class="p">,</span> <span class="n">Image</span><span class="p">):</span>
                <span class="n">noise</span> <span class="o">=</span> <span class="n">CorrelatedNoise</span><span class="p">(</span><span class="n">noise_pad</span><span class="p">,</span> <span class="n">rng1</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">use_cache</span> <span class="ow">and</span> <span class="n">noise_pad</span> <span class="ow">in</span> <span class="n">InterpolatedImage</span><span class="o">.</span><span class="n">_cache_noise_pad</span><span class="p">:</span>
                <span class="n">noise</span> <span class="o">=</span> <span class="n">InterpolatedImage</span><span class="o">.</span><span class="n">_cache_noise_pad</span><span class="p">[</span><span class="n">noise_pad</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">rng</span><span class="p">:</span>
                    <span class="c1"># Make sure that we are using a specified RNG by resetting that in this cached</span>
                    <span class="c1"># CorrelatedNoise instance, otherwise preserve the cached RNG</span>
                    <span class="n">noise</span> <span class="o">=</span> <span class="n">noise</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">rng</span><span class="o">=</span><span class="n">rng1</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">noise_pad</span><span class="p">,</span> <span class="n">basestring</span><span class="p">):</span>
                <span class="n">noise</span> <span class="o">=</span> <span class="n">CorrelatedNoise</span><span class="p">(</span><span class="n">fits</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">noise_pad</span><span class="p">),</span> <span class="n">rng1</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">use_cache</span><span class="p">:</span>
                    <span class="n">InterpolatedImage</span><span class="o">.</span><span class="n">_cache_noise_pad</span><span class="p">[</span><span class="n">noise_pad</span><span class="p">]</span> <span class="o">=</span> <span class="n">noise</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">GalSimValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Input noise_pad must be a float/int, a CorrelatedNoise, Image, or filename &quot;</span>
                    <span class="s2">&quot;containing an image to use to make a CorrelatedNoise.&quot;</span><span class="p">,</span> <span class="n">noise_pad</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">noise_pad</span> <span class="o">&lt;</span> <span class="mf">0.</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">GalSimRangeError</span><span class="p">(</span><span class="s2">&quot;Noise variance may not be negative.&quot;</span><span class="p">,</span> <span class="n">noise_pad</span><span class="p">,</span> <span class="mf">0.</span><span class="p">)</span>
            <span class="n">noise</span> <span class="o">=</span> <span class="n">GaussianNoise</span><span class="p">(</span><span class="n">rng1</span><span class="p">,</span> <span class="n">sigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">noise_pad</span><span class="p">))</span>

        <span class="c1"># Find the portion of xim to fill with noise.</span>
        <span class="c1"># It&#39;s allowed for the noise padding to not cover the whole pad image</span>
        <span class="n">half_size</span> <span class="o">=</span> <span class="n">noise_pad_size</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">_BoundsI</span><span class="p">(</span><span class="o">-</span><span class="n">half_size</span><span class="p">,</span> <span class="o">-</span><span class="n">half_size</span> <span class="o">+</span> <span class="n">noise_pad_size</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span>
                     <span class="o">-</span><span class="n">half_size</span><span class="p">,</span> <span class="o">-</span><span class="n">half_size</span> <span class="o">+</span> <span class="n">noise_pad_size</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1">#assert self._xim.bounds.includes(b)</span>
        <span class="n">noise_image</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xim</span><span class="p">[</span><span class="n">b</span><span class="p">]</span>
        <span class="c1"># Add the noise</span>
        <span class="n">noise_image</span><span class="o">.</span><span class="n">addNoise</span><span class="p">(</span><span class="n">noise</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">b</span>

    <span class="k">def</span> <span class="nf">_getFlux</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">flux</span><span class="p">,</span> <span class="n">normalization</span><span class="p">):</span>
        <span class="c1"># If the user specified a surface brightness normalization for the input Image, then</span>
        <span class="c1"># need to rescale flux by the pixel area to get proper normalization.</span>
        <span class="k">if</span> <span class="n">flux</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">flux</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_image_flux</span>
            <span class="k">if</span> <span class="n">normalization</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;surface brightness&#39;</span><span class="p">,</span><span class="s1">&#39;sb&#39;</span><span class="p">):</span>
                <span class="n">flux</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wcs</span><span class="o">.</span><span class="n">pixelArea</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">flux</span>

    <span class="k">def</span> <span class="nf">_getStepK</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">calculate_stepk</span><span class="p">,</span> <span class="n">_force_stepk</span><span class="p">):</span>
        <span class="c1"># GalSim cannot automatically know what stepK and maxK are appropriate for the</span>
        <span class="c1"># input image.  So it is usually worth it to do a manual calculation (below).</span>
        <span class="c1">#</span>
        <span class="c1"># However, there is also a hidden option to force it to use specific values of stepK and</span>
        <span class="c1"># maxK (caveat user!).  The values of _force_stepk and _force_maxk should be provided in</span>
        <span class="c1"># terms of physical scale, e.g., for images that have a scale length of 0.1 arcsec, the</span>
        <span class="c1"># stepK and maxK should be provided in units of 1/arcsec.  Then we convert to the 1/pixel</span>
        <span class="c1"># units required by the C++ layer below.  Also note that profile recentering for even-sized</span>
        <span class="c1"># images (see the ._adjust_offset step below) leads to automatic reduction of stepK slightly</span>
        <span class="c1"># below what is provided here, while maxK is preserved.</span>
        <span class="k">if</span> <span class="n">_force_stepk</span> <span class="o">&gt;</span> <span class="mf">0.</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_force_stepk</span>
        <span class="k">elif</span> <span class="n">calculate_stepk</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">calculate_stepk</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">im</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_image</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># If not a bool, then value is max_stepk</span>
                <span class="n">R</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="n">calculate_stepk</span><span class="p">))</span>
                <span class="n">b</span> <span class="o">=</span> <span class="n">_BoundsI</span><span class="p">(</span><span class="o">-</span><span class="n">R</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="o">-</span><span class="n">R</span><span class="p">,</span> <span class="n">R</span><span class="p">)</span>
                <span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_image</span><span class="o">.</span><span class="n">bounds</span> <span class="o">&amp;</span> <span class="n">b</span>
                <span class="n">im</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_image</span><span class="p">[</span><span class="n">b</span><span class="p">]</span>
            <span class="n">thresh</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">gsparams</span><span class="o">.</span><span class="n">folding_threshold</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_image_flux</span>
            <span class="n">R</span> <span class="o">=</span> <span class="n">_galsim</span><span class="o">.</span><span class="n">CalculateSizeContainingFlux</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_image</span><span class="o">.</span><span class="n">_image</span><span class="p">,</span> <span class="n">thresh</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_image</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.</span> <span class="o">-</span> <span class="mf">0.5</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getSimpleStepK</span><span class="p">(</span><span class="n">R</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_getSimpleStepK</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">R</span><span class="p">):</span>
        <span class="n">min_scale</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wcs</span><span class="o">.</span><span class="n">_minScale</span><span class="p">()</span>
        <span class="c1"># Add xInterp range in quadrature just like convolution:</span>
        <span class="n">R2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x_interpolant</span><span class="o">.</span><span class="n">xrange</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">hypot</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">R2</span><span class="p">)</span>
        <span class="n">stepk</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="p">(</span><span class="n">R</span> <span class="o">*</span> <span class="n">min_scale</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">stepk</span>

    <span class="k">def</span> <span class="nf">_getMaxK</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">calculate_maxk</span><span class="p">,</span> <span class="n">_force_maxk</span><span class="p">):</span>
        <span class="n">max_scale</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wcs</span><span class="o">.</span><span class="n">_maxScale</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">_force_maxk</span> <span class="o">&gt;</span> <span class="mf">0.</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_force_maxk</span>
        <span class="k">elif</span> <span class="n">calculate_maxk</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_maxk</span> <span class="o">=</span> <span class="mf">0.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_sbp</span>
            <span class="k">if</span> <span class="n">calculate_maxk</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_sbii</span><span class="o">.</span><span class="n">calculateMaxK</span><span class="p">(</span><span class="mf">0.</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># If not a bool, then value is max_maxk</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_sbii</span><span class="o">.</span><span class="n">calculateMaxK</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">calculate_maxk</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;_sbp&#39;</span><span class="p">)</span>  <span class="c1"># Need to remake it.</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sbii</span><span class="o">.</span><span class="n">maxK</span><span class="p">()</span> <span class="o">/</span> <span class="n">max_scale</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x_interpolant</span><span class="o">.</span><span class="n">krange</span> <span class="o">/</span> <span class="n">max_scale</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span> <span class="ow">is</span> <span class="n">other</span> <span class="ow">or</span>
                <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">InterpolatedImage</span><span class="p">)</span> <span class="ow">and</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">_xim</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_xim</span> <span class="ow">and</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">x_interpolant</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">x_interpolant</span> <span class="ow">and</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">k_interpolant</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">k_interpolant</span> <span class="ow">and</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">flux</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">flux</span> <span class="ow">and</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">_offset</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_offset</span> <span class="ow">and</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">gsparams</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">gsparams</span> <span class="ow">and</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">_stepk</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_stepk</span> <span class="ow">and</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">_maxk</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_maxk</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Definitely want to cache this, since the size of the image could be large.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_hash&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_hash</span> <span class="o">=</span> <span class="nb">hash</span><span class="p">((</span><span class="s2">&quot;galsim.InterpolatedImage&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_interpolant</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_interpolant</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_hash</span> <span class="o">^=</span> <span class="nb">hash</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">flux</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stepk</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_maxk</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pad_factor</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_hash</span> <span class="o">^=</span> <span class="nb">hash</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">_xim</span><span class="o">.</span><span class="n">bounds</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_image</span><span class="o">.</span><span class="n">bounds</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pad_image</span><span class="o">.</span><span class="n">bounds</span><span class="p">))</span>
            <span class="c1"># A common offset is 0.5,0.5, and *sometimes* this produces the same hash as 0,0</span>
            <span class="c1"># (which is also common).  I guess because they are only different in 2 bits.</span>
            <span class="c1"># This mucking of the numbers seems to help make the hash more reliably different for</span>
            <span class="c1"># these two cases.  Note: &quot;sometiems&quot; because of this:</span>
            <span class="c1"># https://stackoverflow.com/questions/27522626/hash-function-in-python-3-3-returns-different-results-between-sessions</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_hash</span> <span class="o">^=</span> <span class="nb">hash</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">_offset</span><span class="o">.</span><span class="n">x</span> <span class="o">*</span> <span class="mf">1.234</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_offset</span><span class="o">.</span><span class="n">y</span> <span class="o">*</span> <span class="mf">0.23424</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_hash</span> <span class="o">^=</span> <span class="nb">hash</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_gsparams</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_hash</span> <span class="o">^=</span> <span class="nb">hash</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_xim</span><span class="o">.</span><span class="n">wcs</span><span class="p">)</span>
            <span class="c1"># Just hash the diagonal.  Much faster, and usually is unique enough.</span>
            <span class="c1"># (Let python handle collisions as needed if multiple similar IIs are used as keys.)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_hash</span> <span class="o">^=</span> <span class="nb">hash</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_pad_image</span><span class="o">.</span><span class="n">array</span><span class="p">)))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hash</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">s</span> <span class="o">=</span> <span class="s1">&#39;galsim.InterpolatedImage(</span><span class="si">%r</span><span class="s1">, </span><span class="si">%r</span><span class="s1">, </span><span class="si">%r</span><span class="s1">&#39;</span><span class="o">%</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_image</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_interpolant</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_interpolant</span><span class="p">)</span>
        <span class="c1"># Most things we keep even if not required, but the pad_image is large, so skip it</span>
        <span class="c1"># if it&#39;s really just the same as the main image.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pad_image</span><span class="o">.</span><span class="n">bounds</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_image</span><span class="o">.</span><span class="n">bounds</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="s1">&#39;, pad_image=</span><span class="si">%r</span><span class="s1">&#39;</span><span class="o">%</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_pad_image</span><span class="p">)</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="s1">&#39;, pad_factor=</span><span class="si">%f</span><span class="s1">, flux=</span><span class="si">%r</span><span class="s1">, offset=</span><span class="si">%r</span><span class="s1">&#39;</span><span class="o">%</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_pad_factor</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">flux</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_offset</span><span class="p">)</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="s1">&#39;, use_true_center=False, gsparams=</span><span class="si">%r</span><span class="s1">, _force_stepk=</span><span class="si">%r</span><span class="s1">, _force_maxk=</span><span class="si">%r</span><span class="s1">)&#39;</span><span class="o">%</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">gsparams</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stepk</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_maxk</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">s</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="s1">&#39;galsim.InterpolatedImage(image=</span><span class="si">%s</span><span class="s1">, flux=</span><span class="si">%s</span><span class="s1">)&#39;</span><span class="o">%</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">flux</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">d</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;_sbii&#39;</span><span class="p">,</span><span class="kc">None</span><span class="p">)</span>
        <span class="n">d</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;_sbp&#39;</span><span class="p">,</span><span class="kc">None</span><span class="p">)</span>
        <span class="c1"># Only pickle _pad_image.  Not _xim or _image</span>
        <span class="n">d</span><span class="p">[</span><span class="s1">&#39;_xim_bounds&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xim</span><span class="o">.</span><span class="n">bounds</span>
        <span class="n">d</span><span class="p">[</span><span class="s1">&#39;_image_bounds&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_image</span><span class="o">.</span><span class="n">bounds</span>
        <span class="n">d</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;_xim&#39;</span><span class="p">,</span><span class="kc">None</span><span class="p">)</span>
        <span class="n">d</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;_image&#39;</span><span class="p">,</span><span class="kc">None</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">d</span>

    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
        <span class="n">xim_bounds</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;_xim_bounds&#39;</span><span class="p">)</span>
        <span class="n">image_bounds</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;_image_bounds&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span> <span class="o">=</span> <span class="n">d</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pad_image</span><span class="o">.</span><span class="n">bounds</span> <span class="o">==</span> <span class="n">xim_bounds</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_xim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pad_image</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_xim</span> <span class="o">=</span> <span class="n">Image</span><span class="p">(</span><span class="n">xim_bounds</span><span class="p">,</span> <span class="n">wcs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_wcs</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_xim</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_pad_image</span><span class="o">.</span><span class="n">bounds</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pad_image</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_image</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xim</span><span class="p">[</span><span class="n">image_bounds</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_centroid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">PositionD</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_sbp</span><span class="o">.</span><span class="n">centroid</span><span class="p">())</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_positive_flux</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sbp</span><span class="o">.</span><span class="n">getPositiveFlux</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_negative_flux</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sbp</span><span class="o">.</span><span class="n">getNegativeFlux</span><span class="p">()</span>

    <span class="nd">@lazy_property</span>
    <span class="k">def</span> <span class="nf">_flux_per_photon</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calculate_flux_per_photon</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_max_sb</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sbp</span><span class="o">.</span><span class="n">maxSB</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_xValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pos</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sbp</span><span class="o">.</span><span class="n">xValue</span><span class="p">(</span><span class="n">pos</span><span class="o">.</span><span class="n">_p</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_kValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kpos</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sbp</span><span class="o">.</span><span class="n">kValue</span><span class="p">(</span><span class="n">kpos</span><span class="o">.</span><span class="n">_p</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_shoot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">photons</span><span class="p">,</span> <span class="n">rng</span><span class="p">):</span>
        <span class="k">with</span> <span class="n">convert_cpp_errors</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_sbp</span><span class="o">.</span><span class="n">shoot</span><span class="p">(</span><span class="n">photons</span><span class="o">.</span><span class="n">_pa</span><span class="p">,</span> <span class="n">rng</span><span class="o">.</span><span class="n">_rng</span><span class="p">)</span>
        <span class="n">photons</span><span class="o">.</span><span class="n">flux</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flux_per_photon</span>

    <span class="k">def</span> <span class="nf">_drawReal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span> <span class="n">jac</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="p">(</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">),</span> <span class="n">flux_scaling</span><span class="o">=</span><span class="mf">1.</span><span class="p">):</span>
        <span class="n">dx</span><span class="p">,</span><span class="n">dy</span> <span class="o">=</span> <span class="n">offset</span>
        <span class="n">_jac</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">jac</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">jac</span><span class="o">.</span><span class="n">__array_interface__</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sbp</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">_image</span><span class="p">,</span> <span class="n">image</span><span class="o">.</span><span class="n">scale</span><span class="p">,</span> <span class="n">_jac</span><span class="p">,</span> <span class="n">dx</span><span class="p">,</span> <span class="n">dy</span><span class="p">,</span> <span class="n">flux_scaling</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_drawKImage</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span> <span class="n">jac</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">_jac</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">jac</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">jac</span><span class="o">.</span><span class="n">__array_interface__</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sbp</span><span class="o">.</span><span class="n">drawK</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">_image</span><span class="p">,</span> <span class="n">image</span><span class="o">.</span><span class="n">scale</span><span class="p">,</span> <span class="n">_jac</span><span class="p">)</span></div>


<div class="viewcode-block" id="_InterpolatedImage"><a class="viewcode-back" href="../../arbitrary.html#galsim._InterpolatedImage">[docs]</a><span class="k">def</span> <span class="nf">_InterpolatedImage</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">x_interpolant</span><span class="o">=</span><span class="n">Quintic</span><span class="p">(),</span> <span class="n">k_interpolant</span><span class="o">=</span><span class="n">Quintic</span><span class="p">(),</span>
                       <span class="n">use_true_center</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">gsparams</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                       <span class="n">force_stepk</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span> <span class="n">force_maxk</span><span class="o">=</span><span class="mf">0.</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Approximately equivalent to `InterpolatedImage`, but with fewer options and no sanity checks.</span>

<span class="sd">    Some notable reductions in functionality relative to `InterpolatedImage`:</span>

<span class="sd">    1. There are no padding options. The image must be provided with all padding already applied.</span>
<span class="sd">    2. The stepk and maxk values will not be calculated.  If you want to use values for these other</span>
<span class="sd">       than the default, you may provide them as force_stepk and force_maxk.  Otherwise</span>
<span class="sd">       stepk ~= 2pi / image_size and maxk ~= x_interpolant.krange() / pixel_scale.</span>
<span class="sd">    3. The flux is just the flux of the image.  It cannot be rescaled to a different flux value.</span>
<span class="sd">    4. The input image must have a defined wcs.</span>
<span class="sd">    5. The image is not recentered to have its center at (0,0).  The returned profile will be</span>
<span class="sd">       centered wherever the (0,0) location is in the image, possibly with an offset governed</span>
<span class="sd">       by ``offset`` and ``use_true_center``.  If you want to mimic the behavior of the regular</span>
<span class="sd">       `InterpolatedImage` initializer, you can call ``image.setCenter(0,0)`` before calling this</span>
<span class="sd">       function.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        image:              The `Image` from which to construct the object.</span>
<span class="sd">        x_interpolant:      An `Interpolant` instance for real-space interpolation</span>
<span class="sd">                            [default: Quintic]</span>
<span class="sd">        k_interpolant:      An `Interpolant` instance for k-space interpolation [default: Quintic]</span>
<span class="sd">        use_true_center:    Whether to adjust the offset by the difference between the integer</span>
<span class="sd">                            center and the true center. For odd-sized images, this does nothing,</span>
<span class="sd">                            but for even-sized dimensions, it adjusts the offset by -0.5.</span>
<span class="sd">                            [default: True]</span>
<span class="sd">        offset:             The location in the input image to use as the center of the profile</span>
<span class="sd">                            relative to position (0,0). [default: None]</span>
<span class="sd">        gsparams:           An optional `GSParams` argument. [default: None]</span>
<span class="sd">        force_stepk:        A stepk value to use rather than the default value. [default: 0.]</span>
<span class="sd">        force_maxk:         A maxk value to use rather than the default value. [default: 0.]</span>

<span class="sd">    Returns:</span>
<span class="sd">        an `InterpolatedImage` instance</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">InterpolatedImage</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="n">InterpolatedImage</span><span class="p">)</span>

    <span class="c1"># We need to set all the various attributes that are expected to be in an InterpolatedImage:</span>
    <span class="n">ret</span><span class="o">.</span><span class="n">_image</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">contiguous</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">ret</span><span class="o">.</span><span class="n">_gsparams</span> <span class="o">=</span> <span class="n">GSParams</span><span class="o">.</span><span class="n">check</span><span class="p">(</span><span class="n">gsparams</span><span class="p">)</span>
    <span class="n">ret</span><span class="o">.</span><span class="n">_x_interpolant</span> <span class="o">=</span> <span class="n">x_interpolant</span><span class="o">.</span><span class="n">withGSParams</span><span class="p">(</span><span class="n">ret</span><span class="o">.</span><span class="n">_gsparams</span><span class="p">)</span>
    <span class="n">ret</span><span class="o">.</span><span class="n">_k_interpolant</span> <span class="o">=</span> <span class="n">k_interpolant</span><span class="o">.</span><span class="n">withGSParams</span><span class="p">(</span><span class="n">ret</span><span class="o">.</span><span class="n">_gsparams</span><span class="p">)</span>

    <span class="n">offset</span> <span class="o">=</span> <span class="n">ret</span><span class="o">.</span><span class="n">_parse_offset</span><span class="p">(</span><span class="n">offset</span><span class="p">)</span>
    <span class="n">ret</span><span class="o">.</span><span class="n">_offset</span> <span class="o">=</span> <span class="n">ret</span><span class="o">.</span><span class="n">_adjust_offset</span><span class="p">(</span><span class="n">ret</span><span class="o">.</span><span class="n">_image</span><span class="o">.</span><span class="n">bounds</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">use_true_center</span><span class="p">)</span>
    <span class="n">im_cen</span> <span class="o">=</span> <span class="n">ret</span><span class="o">.</span><span class="n">_image</span><span class="o">.</span><span class="n">true_center</span> <span class="k">if</span> <span class="n">use_true_center</span> <span class="k">else</span> <span class="n">ret</span><span class="o">.</span><span class="n">_image</span><span class="o">.</span><span class="n">center</span>
    <span class="n">ret</span><span class="o">.</span><span class="n">_wcs</span> <span class="o">=</span> <span class="n">ret</span><span class="o">.</span><span class="n">_image</span><span class="o">.</span><span class="n">wcs</span><span class="o">.</span><span class="n">local</span><span class="p">(</span><span class="n">image_pos</span> <span class="o">=</span> <span class="n">im_cen</span><span class="p">)</span>
    <span class="n">ret</span><span class="o">.</span><span class="n">_pad_factor</span> <span class="o">=</span> <span class="mf">1.</span>
    <span class="n">ret</span><span class="o">.</span><span class="n">_image_flux</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ret</span><span class="o">.</span><span class="n">_image</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
    <span class="n">ret</span><span class="o">.</span><span class="n">_flux</span> <span class="o">=</span> <span class="n">ret</span><span class="o">.</span><span class="n">_image_flux</span>

    <span class="c1"># If image isn&#39;t a good fft size, we may still need to pad it out.</span>
    <span class="n">size</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">ret</span><span class="o">.</span><span class="n">_image</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">pad_size</span> <span class="o">=</span> <span class="n">Image</span><span class="o">.</span><span class="n">good_fft_size</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">size</span> <span class="o">==</span> <span class="n">pad_size</span><span class="p">:</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">_xim</span> <span class="o">=</span> <span class="n">ret</span><span class="o">.</span><span class="n">_image</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">_xim</span> <span class="o">=</span> <span class="n">Image</span><span class="p">(</span><span class="n">pad_size</span><span class="p">,</span> <span class="n">pad_size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">_xim</span><span class="o">.</span><span class="n">setCenter</span><span class="p">(</span><span class="n">ret</span><span class="o">.</span><span class="n">_image</span><span class="o">.</span><span class="n">center</span><span class="p">)</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">_xim</span><span class="p">[</span><span class="n">ret</span><span class="o">.</span><span class="n">_image</span><span class="o">.</span><span class="n">bounds</span><span class="p">]</span> <span class="o">=</span> <span class="n">ret</span><span class="o">.</span><span class="n">_image</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">_xim</span><span class="o">.</span><span class="n">wcs</span> <span class="o">=</span> <span class="n">ret</span><span class="o">.</span><span class="n">_wcs</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">_image</span> <span class="o">=</span> <span class="n">ret</span><span class="o">.</span><span class="n">_xim</span><span class="p">[</span><span class="n">ret</span><span class="o">.</span><span class="n">_image</span><span class="o">.</span><span class="n">bounds</span><span class="p">]</span>
    <span class="n">ret</span><span class="o">.</span><span class="n">_pad_image</span> <span class="o">=</span> <span class="n">ret</span><span class="o">.</span><span class="n">_image</span>

    <span class="k">if</span> <span class="n">force_stepk</span> <span class="o">==</span> <span class="mf">0.</span><span class="p">:</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">_stepk</span> <span class="o">=</span> <span class="n">ret</span><span class="o">.</span><span class="n">_getSimpleStepK</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">ret</span><span class="o">.</span><span class="n">_image</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">_stepk</span> <span class="o">=</span> <span class="n">force_stepk</span>
    <span class="k">if</span> <span class="n">force_maxk</span> <span class="o">==</span> <span class="mf">0.</span><span class="p">:</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">_maxk</span> <span class="o">=</span> <span class="n">ret</span><span class="o">.</span><span class="n">_x_interpolant</span><span class="o">.</span><span class="n">krange</span> <span class="o">/</span> <span class="n">ret</span><span class="o">.</span><span class="n">_wcs</span><span class="o">.</span><span class="n">_maxScale</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">_maxk</span> <span class="o">=</span> <span class="n">force_maxk</span>
    <span class="k">return</span> <span class="n">ret</span></div>


<div class="viewcode-block" id="InterpolatedKImage"><a class="viewcode-back" href="../../arbitrary.html#galsim.InterpolatedKImage">[docs]</a><span class="k">class</span> <span class="nc">InterpolatedKImage</span><span class="p">(</span><span class="n">GSObject</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A class describing non-parametric profiles specified by samples of their complex Fourier</span>
<span class="sd">    transform.</span>

<span class="sd">    The InterpolatedKImage class is useful if you have a non-parametric description of the Fourier</span>
<span class="sd">    transform of the profile (provided as either a complex `Image` or two images giving the real</span>
<span class="sd">    and imaginary parts) that you wish to manipulate / transform using `GSObject` methods such as</span>
<span class="sd">    `GSObject.shear`, `GSObject.magnify`, `GSObject.shift`, etc.  Note that neither real-space</span>
<span class="sd">    convolution nor photon-shooting of InterpolatedKImages is currently implemented.  Please submit</span>
<span class="sd">    an issue at http://github.com/GalSim-developers/GalSim/issues if you require either of these</span>
<span class="sd">    use cases.</span>

<span class="sd">    The images required for creating an InterpolatedKImage are precisely those returned by the</span>
<span class="sd">    `GSObject.drawKImage` method.  The ``a`` and ``b`` objects in the following command will</span>
<span class="sd">    produce essentially equivalent images when drawn with the `GSObject.drawImage` method::</span>

<span class="sd">    &gt;&gt;&gt; a = returns_a_GSObject()</span>
<span class="sd">    &gt;&gt;&gt; b = galsim.InterpolatedKImage(a.drawKImage())</span>

<span class="sd">    The input ``kimage`` must have dtype=numpy.complex64 or dtype=numpy.complex128, which are also</span>
<span class="sd">    known as `ImageCF` and `ImageCD` objects respectively.</span>
<span class="sd">    The only wcs permitted is a simple `PixelScale` (or `OffsetWCS`), in which case ``kimage.scale``</span>
<span class="sd">    is used for the ``stepk`` value unless overridden by the ``stepk`` initialization argument.</span>

<span class="sd">    Furthermore, the complex-valued Fourier profile given by ``kimage`` must be Hermitian, since it</span>
<span class="sd">    represents a real-valued real-space profile.  (To see an example of valid input to</span>
<span class="sd">    InterpolatedKImage, you can look at the output of `GSObject.drawKImage`).</span>

<span class="sd">    The user may optionally specify an interpolant, ``k_interpolant``, for Fourier-space</span>
<span class="sd">    manipulations (e.g., shearing, resampling).  If none is specified, then by default, a `Quintic`</span>
<span class="sd">    interpolant is used.  The `Quintic` interpolant has been found to be a good compromise between</span>
<span class="sd">    speed and accuracy for real-and Fourier-space interpolation of objects specified by samples of</span>
<span class="sd">    their real-space profiles (e.g., in `InterpolatedImage`), though no extensive testing has been</span>
<span class="sd">    performed for objects specified by samples of their Fourier-space profiles (e.g., this</span>
<span class="sd">    class).</span>

<span class="sd">    Example::</span>

<span class="sd">        &gt;&gt;&gt; interpolated_kimage = galsim.InterpolatedKImage(kimage, k_interpolant=None, stepk=0.,</span>
<span class="sd">                                                            gsparams=None)</span>

<span class="sd">    Initializes ``interpolated_kimage`` as an InterpolatedKImage instance.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        kimage:         The complex `Image` corresponding to the Fourier-space samples.</span>
<span class="sd">        k_interpolant:  Either an `Interpolant` instance or a string indicating which k-space</span>
<span class="sd">                        interpolant should be used.  Options are &#39;nearest&#39;, &#39;sinc&#39;, &#39;linear&#39;,</span>
<span class="sd">                        &#39;cubic&#39;, &#39;quintic&#39;, or &#39;lanczosN&#39; where N should be the integer order</span>
<span class="sd">                        to use.  [default: galsim.Quintic()]</span>
<span class="sd">        stepk:          By default, the stepk value (the sampling frequency in Fourier-space)</span>
<span class="sd">                        of the profile is set by the ``scale`` attribute of the supplied images.</span>
<span class="sd">                        This keyword allows the user to specify a coarser sampling in Fourier-</span>
<span class="sd">                        space, which may increase efficiency at the expense of decreasing the</span>
<span class="sd">                        separation between neighboring copies of the DFT-rendered real-space</span>
<span class="sd">                        profile.  (See the `GSParams` docstring for the parameter</span>
<span class="sd">                        ``folding_threshold`` for more information). [default: kimage.scale]</span>
<span class="sd">        gsparams:       An optional `GSParams` argument. [default: None]</span>
<span class="sd">        real_kimage:    Optionally, rather than provide kimage, you may provide the real</span>
<span class="sd">                        and imaginary parts separately.  These separate real-valued images</span>
<span class="sd">                        may be strings, in which case they refer to FITS files from which</span>
<span class="sd">                        to read the images. [default: None]</span>
<span class="sd">        imag_kimage:    The imaginary image corresponding to real_kimage. [default: None]</span>
<span class="sd">        real_hdu:       When reading in real_kimage from a file, this parameter can be used to</span>
<span class="sd">                        select a particular HDU in the file. [default: None]</span>
<span class="sd">        imag_hdu:       When reading in imag_kimage from a file, this parameter can be used to</span>
<span class="sd">                        select a particular HDU in the file. [default: None]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_req_params</span> <span class="o">=</span> <span class="p">{</span> <span class="s1">&#39;real_kimage&#39;</span> <span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
                    <span class="s1">&#39;imag_kimage&#39;</span> <span class="p">:</span> <span class="nb">str</span> <span class="p">}</span>
    <span class="n">_opt_params</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;k_interpolant&#39;</span> <span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="s1">&#39;stepk&#39;</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="s1">&#39;real_hdu&#39;</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="s1">&#39;imag_hdu&#39;</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="n">_has_hard_edges</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">_is_axisymmetric</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">_is_analytic_x</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">_is_analytic_k</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kimage</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">k_interpolant</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">stepk</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">gsparams</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">real_kimage</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">imag_kimage</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">real_hdu</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">imag_hdu</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">kimage</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">real_kimage</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">imag_kimage</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">GalSimIncompatibleValuesError</span><span class="p">(</span>
                    <span class="s2">&quot;Must provide either kimage or real_kimage/imag_kimage&quot;</span><span class="p">,</span>
                    <span class="n">kimage</span><span class="o">=</span><span class="n">kimage</span><span class="p">,</span> <span class="n">real_kimage</span><span class="o">=</span><span class="n">real_kimage</span><span class="p">,</span> <span class="n">imag_kimage</span><span class="o">=</span><span class="n">imag_kimage</span><span class="p">)</span>

            <span class="c1"># If the &quot;image&quot; is not actually an image, try to read the image as a file.</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">real_kimage</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">real_kimage</span> <span class="o">=</span> <span class="n">fits</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">real_kimage</span><span class="p">,</span> <span class="n">hdu</span><span class="o">=</span><span class="n">real_hdu</span><span class="p">)</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">real_kimage</span><span class="p">,</span> <span class="n">Image</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;real_kimage must be either an Image or a file name&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">imag_kimage</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">imag_kimage</span> <span class="o">=</span> <span class="n">fits</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">imag_kimage</span><span class="p">,</span> <span class="n">hdu</span><span class="o">=</span><span class="n">imag_hdu</span><span class="p">)</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">imag_kimage</span><span class="p">,</span> <span class="n">Image</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;imag_kimage must be either an Image or a file name&quot;</span><span class="p">)</span>

            <span class="c1"># make sure real_kimage, imag_kimage are congruent.</span>
            <span class="k">if</span> <span class="n">real_kimage</span><span class="o">.</span><span class="n">bounds</span> <span class="o">!=</span> <span class="n">imag_kimage</span><span class="o">.</span><span class="n">bounds</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">GalSimIncompatibleValuesError</span><span class="p">(</span>
                    <span class="s2">&quot;Real and Imag kimages must have same bounds.&quot;</span><span class="p">,</span>
                    <span class="n">real_kimage</span><span class="o">=</span><span class="n">real_kimage</span><span class="p">,</span> <span class="n">imag_kimage</span><span class="o">=</span><span class="n">imag_kimage</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">real_kimage</span><span class="o">.</span><span class="n">wcs</span> <span class="o">!=</span> <span class="n">imag_kimage</span><span class="o">.</span><span class="n">wcs</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">GalSimIncompatibleValuesError</span><span class="p">(</span>
                    <span class="s2">&quot;Real and Imag kimages must have same scale/wcs.&quot;</span><span class="p">,</span>
                    <span class="n">real_kimage</span><span class="o">=</span><span class="n">real_kimage</span><span class="p">,</span> <span class="n">imag_kimage</span><span class="o">=</span><span class="n">imag_kimage</span><span class="p">)</span>

            <span class="n">kimage</span> <span class="o">=</span> <span class="n">real_kimage</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">imag_kimage</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">real_kimage</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">imag_kimage</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">GalSimIncompatibleValuesError</span><span class="p">(</span>
                    <span class="s2">&quot;Cannot provide both kimage and real_kimage/imag_kimage&quot;</span><span class="p">,</span>
                    <span class="n">kimage</span><span class="o">=</span><span class="n">kimage</span><span class="p">,</span> <span class="n">real_kimage</span><span class="o">=</span><span class="n">real_kimage</span><span class="p">,</span> <span class="n">imag_kimage</span><span class="o">=</span><span class="n">imag_kimage</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">kimage</span><span class="p">,</span> <span class="n">Image</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;kimage must be a galsim.Image isntance&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">kimage</span><span class="o">.</span><span class="n">iscomplex</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">GalSimValueError</span><span class="p">(</span><span class="s2">&quot;Supplied kimage is not complex&quot;</span><span class="p">,</span> <span class="n">kimage</span><span class="p">)</span>

        <span class="c1"># Make sure wcs is a PixelScale.</span>
        <span class="k">if</span> <span class="n">kimage</span><span class="o">.</span><span class="n">wcs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">kimage</span><span class="o">.</span><span class="n">wcs</span><span class="o">.</span><span class="n">_isPixelScale</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">GalSimValueError</span><span class="p">(</span><span class="s2">&quot;kimage wcs must be PixelScale or None.&quot;</span><span class="p">,</span> <span class="n">kimage</span><span class="o">.</span><span class="n">wcs</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">kimage</span><span class="o">.</span><span class="n">bounds</span><span class="o">.</span><span class="n">isDefined</span><span class="p">():</span>
            <span class="k">raise</span> <span class="n">GalSimUndefinedBoundsError</span><span class="p">(</span><span class="s2">&quot;Supplied image does not have bounds defined.&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_gsparams</span> <span class="o">=</span> <span class="n">GSParams</span><span class="o">.</span><span class="n">check</span><span class="p">(</span><span class="n">gsparams</span><span class="p">)</span>

        <span class="c1"># Check for Hermitian symmetry properties of kimage</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="n">kimage</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span>
        <span class="c1"># If image is even-sized, ignore first row/column since in this case not every pixel has</span>
        <span class="c1"># a symmetric partner to which to compare.</span>
        <span class="n">bd</span> <span class="o">=</span> <span class="n">_BoundsI</span><span class="p">(</span><span class="n">kimage</span><span class="o">.</span><span class="n">xmin</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="k">if</span> <span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">%</span><span class="mi">2</span><span class="o">==</span><span class="mi">0</span> <span class="k">else</span> <span class="mi">0</span><span class="p">),</span>
                      <span class="n">kimage</span><span class="o">.</span><span class="n">xmax</span><span class="p">,</span>
                      <span class="n">kimage</span><span class="o">.</span><span class="n">ymin</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="k">if</span> <span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">%</span><span class="mi">2</span><span class="o">==</span><span class="mi">0</span> <span class="k">else</span> <span class="mi">0</span><span class="p">),</span>
                      <span class="n">kimage</span><span class="o">.</span><span class="n">ymax</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">kimage</span><span class="p">[</span><span class="n">bd</span><span class="p">]</span><span class="o">.</span><span class="n">real</span><span class="o">.</span><span class="n">array</span><span class="p">,</span>
                            <span class="n">kimage</span><span class="p">[</span><span class="n">bd</span><span class="p">]</span><span class="o">.</span><span class="n">real</span><span class="o">.</span><span class="n">array</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">,::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="ow">and</span>
                <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">kimage</span><span class="p">[</span><span class="n">bd</span><span class="p">]</span><span class="o">.</span><span class="n">imag</span><span class="o">.</span><span class="n">array</span><span class="p">,</span>
                            <span class="o">-</span><span class="n">kimage</span><span class="p">[</span><span class="n">bd</span><span class="p">]</span><span class="o">.</span><span class="n">imag</span><span class="o">.</span><span class="n">array</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">,::</span><span class="o">-</span><span class="mi">1</span><span class="p">])):</span>
            <span class="k">raise</span> <span class="n">GalSimIncompatibleValuesError</span><span class="p">(</span>
                <span class="s2">&quot;Real and Imag kimages must form a Hermitian complex matrix.&quot;</span><span class="p">,</span> <span class="n">kimage</span><span class="o">=</span><span class="n">kimage</span><span class="p">)</span>

        <span class="c1"># Make sure the image is complex128 and contiguous</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_kimage</span> <span class="o">=</span> <span class="n">kimage</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">,</span> <span class="n">contiguous</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_kimage</span><span class="o">.</span><span class="n">setCenter</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">stepk</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kimage</span><span class="o">.</span><span class="n">scale</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># Defaults to 1.0 if no scale is set.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_kimage</span><span class="o">.</span><span class="n">scale</span> <span class="o">=</span> <span class="mf">1.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_stepk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kimage</span><span class="o">.</span><span class="n">scale</span>
        <span class="k">elif</span> <span class="n">stepk</span> <span class="o">&lt;</span> <span class="n">kimage</span><span class="o">.</span><span class="n">scale</span><span class="p">:</span>
            <span class="n">galsim_warn</span><span class="p">(</span>
                <span class="s2">&quot;Provided stepk is smaller than kimage.scale; overriding with kimage.scale.&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_stepk</span> <span class="o">=</span> <span class="n">kimage</span><span class="o">.</span><span class="n">scale</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_stepk</span> <span class="o">=</span> <span class="n">stepk</span>

        <span class="c1"># set up k_interpolant if none was provided by user, or check that the user-provided one</span>
        <span class="c1"># is of a valid type</span>
        <span class="k">if</span> <span class="n">k_interpolant</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_k_interpolant</span> <span class="o">=</span> <span class="n">Quintic</span><span class="p">(</span><span class="n">gsparams</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_gsparams</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_k_interpolant</span> <span class="o">=</span> <span class="n">convert_interpolant</span><span class="p">(</span><span class="n">k_interpolant</span><span class="p">)</span><span class="o">.</span><span class="n">withGSParams</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_gsparams</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">kimage</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The underlying `Image` being interpolated.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kimage</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">k_interpolant</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The Fourier-space `Interpolant` for this profile.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_k_interpolant</span>

<div class="viewcode-block" id="InterpolatedKImage.withGSParams"><a class="viewcode-back" href="../../arbitrary.html#galsim.InterpolatedKImage.withGSParams">[docs]</a>    <span class="nd">@doc_inherit</span>
    <span class="k">def</span> <span class="nf">withGSParams</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gsparams</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">gsparams</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">gsparams</span><span class="p">:</span> <span class="k">return</span> <span class="bp">self</span>
        <span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">copy</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">_gsparams</span> <span class="o">=</span> <span class="n">GSParams</span><span class="o">.</span><span class="n">check</span><span class="p">(</span><span class="n">gsparams</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gsparams</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">_k_interpolant</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_k_interpolant</span><span class="o">.</span><span class="n">withGSParams</span><span class="p">(</span><span class="n">ret</span><span class="o">.</span><span class="n">_gsparams</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ret</span></div>

    <span class="nd">@lazy_property</span>
    <span class="k">def</span> <span class="nf">_sbp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">stepk_image</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stepk</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">kimage</span><span class="o">.</span><span class="n">scale</span>  <span class="c1"># usually 1, but could be larger</span>

        <span class="c1"># C++ layer needs Bounds that look like 0, N/2, -N/2, N/2-1</span>
        <span class="c1"># So find the biggest N that works like that.</span>
        <span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kimage</span><span class="o">.</span><span class="n">bounds</span>
        <span class="n">N</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">xmax</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="n">b</span><span class="o">.</span><span class="n">ymin</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span> <span class="n">b</span><span class="o">.</span><span class="n">ymax</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">_BoundsI</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">N</span><span class="o">//</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="p">(</span><span class="n">N</span><span class="o">//</span><span class="mi">2</span><span class="p">),</span> <span class="n">N</span><span class="o">//</span><span class="mi">2</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">posx_kimage</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kimage</span><span class="p">[</span><span class="n">b</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sbiki</span> <span class="o">=</span> <span class="n">_galsim</span><span class="o">.</span><span class="n">SBInterpolatedKImage</span><span class="p">(</span>
                <span class="n">posx_kimage</span><span class="o">.</span><span class="n">_image</span><span class="p">,</span> <span class="n">stepk_image</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_interpolant</span><span class="o">.</span><span class="n">_i</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gsparams</span><span class="o">.</span><span class="n">_gsp</span><span class="p">)</span>

        <span class="n">scale</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kimage</span><span class="o">.</span><span class="n">scale</span>
        <span class="n">jac</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="mf">1.</span><span class="o">/</span><span class="n">scale</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="o">/</span><span class="n">scale</span><span class="p">))</span>
        <span class="n">_jac</span> <span class="o">=</span> <span class="n">jac</span><span class="o">.</span><span class="n">__array_interface__</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">scale</span> <span class="o">!=</span> <span class="mf">1.</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_galsim</span><span class="o">.</span><span class="n">SBTransform</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_sbiki</span><span class="p">,</span> <span class="n">_jac</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="n">scale</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gsparams</span><span class="o">.</span><span class="n">_gsp</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sbiki</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span> <span class="ow">is</span> <span class="n">other</span> <span class="ow">or</span>
                <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">InterpolatedKImage</span><span class="p">)</span> <span class="ow">and</span>
                 <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kimage</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">kimage</span><span class="o">.</span><span class="n">array</span><span class="p">)</span> <span class="ow">and</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">kimage</span><span class="o">.</span><span class="n">scale</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">kimage</span><span class="o">.</span><span class="n">scale</span> <span class="ow">and</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">k_interpolant</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">k_interpolant</span> <span class="ow">and</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">stepk</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">stepk</span> <span class="ow">and</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">gsparams</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">gsparams</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Definitely want to cache this, since the kimage could be large.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_hash&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_hash</span> <span class="o">=</span> <span class="nb">hash</span><span class="p">((</span><span class="s2">&quot;galsim.InterpolatedKImage&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_interpolant</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stepk</span><span class="p">,</span>
                               <span class="bp">self</span><span class="o">.</span><span class="n">gsparams</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_hash</span> <span class="o">^=</span> <span class="nb">hash</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kimage</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">ravel</span><span class="p">()))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_hash</span> <span class="o">^=</span> <span class="nb">hash</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">kimage</span><span class="o">.</span><span class="n">bounds</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">kimage</span><span class="o">.</span><span class="n">wcs</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hash</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="s1">&#39;galsim.InterpolatedKImage(</span><span class="se">\n</span><span class="si">%r</span><span class="s1">,</span><span class="se">\n</span><span class="si">%r</span><span class="s1">, stepk=</span><span class="si">%r</span><span class="s1">, gsparams=</span><span class="si">%r</span><span class="s1">)&#39;</span><span class="p">)</span><span class="o">%</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">kimage</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_interpolant</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">stepk</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gsparams</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;galsim.InterpolatedKImage(kimage=</span><span class="si">%s</span><span class="s1">)&#39;</span><span class="o">%</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kimage</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># The SBInterpolatedKImage is picklable, but that is pretty inefficient, due to the large</span>
        <span class="c1"># images being written as strings.  Better to pickle the intermediate products and then</span>
        <span class="c1"># call init again on the other side.  There&#39;s still an image to be pickled, but at least</span>
        <span class="c1"># it will be through the normal pickling rules, rather than the repr.</span>
        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">d</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;_sbiki&#39;</span><span class="p">,</span><span class="kc">None</span><span class="p">)</span>
        <span class="n">d</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;_sbp&#39;</span><span class="p">,</span><span class="kc">None</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">d</span>

    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span> <span class="o">=</span> <span class="n">d</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_maxk</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sbp</span><span class="o">.</span><span class="n">maxK</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_centroid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">with</span> <span class="n">convert_cpp_errors</span><span class="p">():</span>
            <span class="k">return</span> <span class="n">PositionD</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_sbp</span><span class="o">.</span><span class="n">centroid</span><span class="p">())</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_flux</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sbp</span><span class="o">.</span><span class="n">getFlux</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_positive_flux</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sbp</span><span class="o">.</span><span class="n">getPositiveFlux</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_negative_flux</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sbp</span><span class="o">.</span><span class="n">getNegativeFlux</span><span class="p">()</span>

    <span class="nd">@lazy_property</span>
    <span class="k">def</span> <span class="nf">_flux_per_photon</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calculate_flux_per_photon</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_kValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kpos</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sbp</span><span class="o">.</span><span class="n">kValue</span><span class="p">(</span><span class="n">kpos</span><span class="o">.</span><span class="n">_p</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_drawKImage</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span> <span class="n">jac</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">_jac</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">jac</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">jac</span><span class="o">.</span><span class="n">__array_interface__</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sbp</span><span class="o">.</span><span class="n">drawK</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">_image</span><span class="p">,</span> <span class="n">image</span><span class="o">.</span><span class="n">scale</span><span class="p">,</span> <span class="n">_jac</span><span class="p">)</span></div>


<div class="viewcode-block" id="_InterpolatedKImage"><a class="viewcode-back" href="../../arbitrary.html#galsim._InterpolatedKImage">[docs]</a><span class="k">def</span> <span class="nf">_InterpolatedKImage</span><span class="p">(</span><span class="n">kimage</span><span class="p">,</span> <span class="n">k_interpolant</span><span class="p">,</span> <span class="n">gsparams</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Approximately equivalent to `InterpolatedKImage`, but with fewer options and no sanity</span>
<span class="sd">    checks.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        kimage:         The complex `Image` corresponding to the Fourier-space samples.</span>
<span class="sd">        k_interpolant:  An `Interpolant` instance indicating which k-space interpolant should be</span>
<span class="sd">                        used.</span>
<span class="sd">        gsparams:       An optional `GSParams` argument. [default: None]</span>
<span class="sd">     &quot;&quot;&quot;</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">InterpolatedKImage</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="n">InterpolatedKImage</span><span class="p">)</span>
    <span class="n">ret</span><span class="o">.</span><span class="n">_kimage</span> <span class="o">=</span> <span class="n">kimage</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">,</span> <span class="n">contiguous</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">ret</span><span class="o">.</span><span class="n">_kimage</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span><span class="o">-</span><span class="n">kimage</span><span class="o">.</span><span class="n">center</span><span class="p">)</span>
    <span class="n">ret</span><span class="o">.</span><span class="n">_stepk</span> <span class="o">=</span> <span class="n">kimage</span><span class="o">.</span><span class="n">scale</span>
    <span class="n">ret</span><span class="o">.</span><span class="n">_gsparams</span> <span class="o">=</span> <span class="n">GSParams</span><span class="o">.</span><span class="n">check</span><span class="p">(</span><span class="n">gsparams</span><span class="p">)</span>
    <span class="n">ret</span><span class="o">.</span><span class="n">_k_interpolant</span> <span class="o">=</span> <span class="n">k_interpolant</span><span class="o">.</span><span class="n">withGSParams</span><span class="p">(</span><span class="n">gsparams</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ret</span></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2019, GalSim-developers.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>