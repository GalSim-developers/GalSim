<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>galsim.table &mdash; GalSim 2.5.0 documentation</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/sphinx_highlight.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            GalSim
          </a>
              <div class="version">
                2.5
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../overview.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../install.html">Installation Instructions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tutorials.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../image.html">Images and Related Concepts</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../sb.html">Surface Brightness Profiles</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../chromatic.html">Wavelength-dependent Profiles</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../units.html">Units</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../wcs.html">World Coordinate Systems</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../random.html">Noise and Random Values</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../wl.html">Weak Lensing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../photon.html">Photon Shooting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../utilities.html">Helper Functions and Classes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../errors.html">Errors and Warnings</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../config.html">The Config Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../hsm.html">The HSM Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../des.html">The DES Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../roman.html">The Roman Space Telescope Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../cpp.html">C++ Layer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../shared.html">Shared Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../history.html">Revision History</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">GalSim</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">galsim.table</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for galsim.table</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright (c) 2012-2023 by the GalSim developers team on GitHub</span>
<span class="c1"># https://github.com/GalSim-developers</span>
<span class="c1">#</span>
<span class="c1"># This file is part of GalSim: The modular galaxy image simulation toolkit.</span>
<span class="c1"># https://github.com/GalSim-developers/GalSim</span>
<span class="c1">#</span>
<span class="c1"># GalSim is free software: redistribution and use in source and binary forms,</span>
<span class="c1"># with or without modification, are permitted provided that the following</span>
<span class="c1"># conditions are met:</span>
<span class="c1">#</span>
<span class="c1"># 1. Redistributions of source code must retain the above copyright notice, this</span>
<span class="c1">#    list of conditions, and the disclaimer given in the accompanying LICENSE</span>
<span class="c1">#    file.</span>
<span class="c1"># 2. Redistributions in binary form must reproduce the above copyright notice,</span>
<span class="c1">#    this list of conditions, and the disclaimer given in the documentation</span>
<span class="c1">#    and/or other materials provided with the distribution.</span>
<span class="c1">#</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span> <span class="s1">&#39;LookupTable&#39;</span><span class="p">,</span> <span class="s1">&#39;LookupTable2D&#39;</span><span class="p">,</span> <span class="s1">&#39;_LookupTable&#39;</span><span class="p">,</span> <span class="s1">&#39;_LookupTable2D&#39;</span><span class="p">,</span> <span class="s1">&#39;trapz&#39;</span><span class="p">,</span> <span class="p">]</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">numbers</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">_galsim</span>
<span class="kn">from</span> <span class="nn">._utilities</span> <span class="kn">import</span> <span class="n">lazy_property</span><span class="p">,</span> <span class="n">basestring</span>
<span class="kn">from</span> <span class="nn">.bounds</span> <span class="kn">import</span> <span class="n">BoundsD</span>
<span class="kn">from</span> <span class="nn">.position</span> <span class="kn">import</span> <span class="n">_PositionD</span>
<span class="kn">from</span> <span class="nn">.errors</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">.interpolant</span> <span class="kn">import</span> <span class="n">convert_interpolant</span>

<span class="k">def</span> <span class="nf">_str_array</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="c1"># Used by both LookupTable.__str__ and LookupTable2D.__str__</span>
    <span class="c1"># to write the x, f, etc. numpy arrays in an abbreviated form so they don&#39;t fill the</span>
    <span class="c1"># screen with numbers.</span>
    <span class="c1"># 1. Write the whole array if it has at most 5 values,</span>
    <span class="c1"># 2. Just write the first two and last two values in the array if longer.</span>
    <span class="c1"># 3. linewidth defaults to 75, which adds annoying linebreaks here.</span>
    <span class="c1">#    1000 should be big enough to mean &quot;never&quot;.</span>
    <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">printoptions</span><span class="p">(</span><span class="n">threshold</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">edgeitems</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">1000</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">repr</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

<div class="viewcode-block" id="LookupTable"><a class="viewcode-back" href="../../table.html#galsim.utilities.LookupTable">[docs]</a><span class="k">class</span> <span class="nc">LookupTable</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    LookupTable represents a lookup table to store function values that may be slow to calculate,</span>
<span class="sd">    for which interpolating from a lookup table is sufficiently accurate.</span>

<span class="sd">    A LookupTable may be constructed from two arrays (lists, tuples, or NumPy arrays of</span>
<span class="sd">    floats/doubles)::</span>

<span class="sd">        &gt;&gt;&gt; args = [...]</span>
<span class="sd">        &gt;&gt;&gt; vals = []</span>
<span class="sd">        &gt;&gt;&gt; for arg in args:</span>
<span class="sd">        ...     val = calculateVal(arg)</span>
<span class="sd">        ...     vals.append(val)</span>
<span class="sd">        &gt;&gt;&gt; table = galsim.LookupTable(x=args,f=vals)</span>

<span class="sd">    Then you can use this table as a replacement for the slow calculation::</span>

<span class="sd">        &gt;&gt;&gt; other_args = [...]</span>
<span class="sd">        &gt;&gt;&gt; for arg in other_args:</span>
<span class="sd">        ...     val = table(arg)</span>
<span class="sd">        ...     [... use val ...]</span>


<span class="sd">    The default interpolation method is a natural cubic spline.  This is usually the best choice,</span>
<span class="sd">    but we also provide other options, which can be specified by the ``interpolant`` kwarg.  The</span>
<span class="sd">    choices include &#39;floor&#39;, &#39;ceil&#39;, &#39;linear&#39;, &#39;spline&#39;, or a `galsim.Interpolant` object:</span>

<span class="sd">    - &#39;floor&#39; takes the value from the previous argument in the table.</span>
<span class="sd">    - &#39;ceil&#39; takes the value from the next argument in the table.</span>
<span class="sd">    - &#39;nearest&#39; takes the value from the nearest argument in the table.</span>
<span class="sd">    - &#39;linear&#39; does linear interpolation between these two values.</span>
<span class="sd">    - &#39;spline&#39; uses a cubic spline interpolation, so the interpolated values are smooth at</span>
<span class="sd">      each argument in the table.</span>
<span class="sd">    - a `galsim.Interpolant` object or a string convertible to one.  This option can be used for</span>
<span class="sd">      `Lanczos` or `Quintic` interpolation, for example.</span>

<span class="sd">    Note that specifying the string &#39;nearest&#39; or &#39;linear&#39; will use a LookupTable-optimized</span>
<span class="sd">    interpolant instead of `galsim.Nearest` or `galsim.Linear`, though the latter options can still</span>
<span class="sd">    be used by passing an `Interpolant` object instead of a string.  Also note that to use a</span>
<span class="sd">    `galsim.Interpolant` in a LookupTable, the input data must be equally spaced, or logarithmically</span>
<span class="sd">    spaced if ``x_log`` is set to True (see below).  Finally, although natural cubic spline used</span>
<span class="sd">    when interpolant=&#39;spline&#39; and the cubic convolution interpolant used when the interpolant</span>
<span class="sd">    is `galsim.Cubic` both produce piecewise cubic polynomial interpolations, their treatments of</span>
<span class="sd">    the continuity of derivatives are different (the natural spline is smoother).</span>

<span class="sd">    There are also two factory functions which can be used to build a LookupTable:</span>

<span class="sd">        `LookupTable.from_func`</span>
<span class="sd">                makes a LookupTable from a callable function</span>

<span class="sd">        `LookupTable.from_file`</span>
<span class="sd">                reads in a file of x and f values.</span>

<span class="sd">    The user can also opt to interpolate in log(x) and/or log(f) (if not using a</span>
<span class="sd">    `galsim.Interpolant`), though this is not the default.  It may be a wise choice depending on the</span>
<span class="sd">    particular function, e.g., for a nearly power-law f(x) (or at least one that is locally</span>
<span class="sd">    power-law-ish for much of the x range) then it might be a good idea to interpolate in log(x) and</span>
<span class="sd">    log(f) rather than x and f.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        x:              The list, tuple, or NumPy array of ``x`` values.</span>
<span class="sd">        f:              The list, tuple, or NumPy array of ``f(x)`` values.</span>
<span class="sd">        interpolant:    Type of interpolation to use, with the options being &#39;floor&#39;, &#39;ceil&#39;,</span>
<span class="sd">                        &#39;nearest&#39;, &#39;linear&#39;, &#39;spline&#39;, or a `galsim.Interpolant` or string</span>
<span class="sd">                        convertible to one.  [default: &#39;spline&#39;]</span>
<span class="sd">        x_log:          Set to True if you wish to interpolate using log(x) rather than x.  Note</span>
<span class="sd">                        that all inputs / outputs will still be x, it&#39;s just a question of how the</span>
<span class="sd">                        interpolation is done. [default: False]</span>
<span class="sd">        f_log:          Set to True if you wish to interpolate using log(f) rather than f.  Note</span>
<span class="sd">                        that all inputs / outputs will still be f, it&#39;s just a question of how the</span>
<span class="sd">                        interpolation is done. [default: False]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">interpolant</span><span class="o">=</span><span class="s1">&#39;spline&#39;</span><span class="p">,</span> <span class="n">x_log</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">f_log</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x_log</span> <span class="o">=</span> <span class="n">x_log</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">f_log</span> <span class="o">=</span> <span class="n">f_log</span>

        <span class="c1"># Check if interpolant is a string that we understand.  If not, try convert_interpolant</span>
        <span class="k">if</span> <span class="n">interpolant</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;nearest&#39;</span><span class="p">,</span> <span class="s1">&#39;linear&#39;</span><span class="p">,</span> <span class="s1">&#39;ceil&#39;</span><span class="p">,</span> <span class="s1">&#39;floor&#39;</span><span class="p">,</span> <span class="s1">&#39;spline&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_interp1d</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_interp1d</span> <span class="o">=</span> <span class="n">convert_interpolant</span><span class="p">(</span><span class="n">interpolant</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">interpolant</span> <span class="o">=</span> <span class="n">interpolant</span>

        <span class="c1"># Sanity checks</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">GalSimIncompatibleValuesError</span><span class="p">(</span><span class="s2">&quot;Input array lengths don&#39;t match&quot;</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">f</span><span class="o">=</span><span class="n">f</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">GalSimValueError</span><span class="p">(</span><span class="s2">&quot;Input arrays too small to interpolate&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>

        <span class="c1"># turn x and f into numpy arrays so that all subsequent math is possible (unlike for</span>
        <span class="c1"># lists, tuples).  Also make sure the dtype is float</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">&gt;=</span> <span class="n">x</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
            <span class="c1"># Already sorted (a common case, so avoid the sort.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">s</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="n">s</span><span class="p">])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_x_min</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_x_max</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x_min</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x_max</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">GalSimValueError</span><span class="p">(</span><span class="s2">&quot;All x values are equal&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_log</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mf">0.</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">GalSimValueError</span><span class="p">(</span><span class="s2">&quot;Cannot interpolate in log(x) when table contains x&lt;=0.&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">f_log</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">f</span> <span class="o">&lt;=</span> <span class="mf">0.</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">GalSimValueError</span><span class="p">(</span><span class="s2">&quot;Cannot interpolate in log(f) when table contains f&lt;=0.&quot;</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>

        <span class="c1"># inf causes problems in some cases, so avoid it if used as the maximum x value.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x_max</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x_max</span> <span class="o">=</span> <span class="mf">1.e300</span>

        <span class="c1"># Check equal-spaced arrays</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_interp1d</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_log</span><span class="p">:</span>
                <span class="n">ratio</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">ratio</span><span class="p">,</span> <span class="n">ratio</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                    <span class="k">raise</span> <span class="n">GalSimIncompatibleValuesError</span><span class="p">(</span>
                        <span class="s2">&quot;Cannot use a galsim.Interpolant with x_log=True unless log(x) is &quot;</span>
                        <span class="s2">&quot;equally spaced.&quot;</span><span class="p">,</span>
                        <span class="n">interpolant</span><span class="o">=</span><span class="n">interpolant</span><span class="p">,</span> <span class="n">x_log</span><span class="o">=</span><span class="n">x_log</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">dx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">dx</span><span class="p">,</span> <span class="n">dx</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                    <span class="k">raise</span> <span class="n">GalSimIncompatibleValuesError</span><span class="p">(</span>
                        <span class="s2">&quot;Cannot use a galsim.Interpolant with x_log=False unless x is &quot;</span>
                        <span class="s2">&quot;equally spaced.&quot;</span><span class="p">,</span>
                        <span class="n">interpolant</span><span class="o">=</span><span class="n">interpolant</span><span class="p">,</span> <span class="n">x_log</span><span class="o">=</span><span class="n">x_log</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">)</span>

    <span class="nd">@lazy_property</span>
    <span class="k">def</span> <span class="nf">_tab</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Store these as attributes, so don&#39;t need to worry about C++ layer persisting them.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_log</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">f_log</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span>

        <span class="n">_x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x</span><span class="o">.</span><span class="n">__array_interface__</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">_f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_f</span><span class="o">.</span><span class="n">__array_interface__</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_interp1d</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_galsim</span><span class="o">.</span><span class="n">LookupTable</span><span class="p">(</span><span class="n">_x</span><span class="p">,</span> <span class="n">_f</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_x</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_interp1d</span><span class="o">.</span><span class="n">_i</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_galsim</span><span class="o">.</span><span class="n">LookupTable</span><span class="p">(</span><span class="n">_x</span><span class="p">,</span> <span class="n">_f</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_x</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">interpolant</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">x_min</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The minimum x value in the lookup table.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x_min</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">x_max</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The maximum x value in the lookup table.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x_max</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>

<div class="viewcode-block" id="LookupTable.__call__"><a class="viewcode-back" href="../../table.html#galsim.utilities.LookupTable.__call__">[docs]</a>    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Interpolate the `LookupTable` to get ``f(x)`` at some ``x`` value(s).</span>

<span class="sd">        When the `LookupTable` object is called with a single argument, it returns the value at that</span>
<span class="sd">        argument.  An exception will be thrown automatically if the ``x`` value is outside the</span>
<span class="sd">        range of the original tabulated values.  The value that is returned is the same type as</span>
<span class="sd">        that provided as an argument, e.g., if a single value ``x`` is provided then a single value</span>
<span class="sd">        of ``f`` is returned; if a tuple of ``x`` values is provided then a tuple of ``f`` values</span>
<span class="sd">        is returned; and so on.  Even if interpolation was done using the ``x_log`` option, the</span>
<span class="sd">        user should still provide ``x`` rather than ``log(x)``.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            x:      The ``x`` value(s) for which ``f(x)`` should be calculated via interpolation on</span>
<span class="sd">                    the original ``(x,f)`` lookup table.  ``x`` can be a single float/double, or a</span>
<span class="sd">                    tuple, list, or arbitrarily shaped 1- or 2-dimensional NumPy array.</span>

<span class="sd">        Returns:</span>
<span class="sd">            the interpolated ``f(x)`` value(s).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">orig_x</span> <span class="o">=</span> <span class="n">x</span>
        <span class="c1"># Handle the log(x) if necessary</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_log</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">():</span>
                <span class="n">f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tab</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">dimen</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">dimen</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
                    <span class="n">xx</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span><span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
                    <span class="n">_xx</span> <span class="o">=</span> <span class="n">xx</span><span class="o">.</span><span class="n">__array_interface__</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">_f</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">__array_interface__</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_tab</span><span class="o">.</span><span class="n">interpMany</span><span class="p">(</span><span class="n">_xx</span><span class="p">,</span> <span class="n">_f</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">xx</span><span class="p">))</span>
                    <span class="n">f</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
                    <span class="n">xx</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span><span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                    <span class="n">_xx</span> <span class="o">=</span> <span class="n">xx</span><span class="o">.</span><span class="n">__array_interface__</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">_f</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">__array_interface__</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_tab</span><span class="o">.</span><span class="n">interpMany</span><span class="p">(</span><span class="n">_xx</span><span class="p">,</span> <span class="n">_f</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">xx</span><span class="p">))</span>
        <span class="k">except</span> <span class="ne">RuntimeError</span><span class="p">:</span>
            <span class="c1"># If there were points outside the valid range, this will have raised an exception.</span>
            <span class="c1"># so call _check_range to give a better error message.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check_range</span><span class="p">(</span><span class="n">orig_x</span><span class="p">)</span>
            <span class="k">raise</span>  <span class="c1"># pragma: no cover (shouldn&#39;t be able to reach here, but just in case.)</span>

        <span class="c1"># Handle the log(f) if necessary</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">f_log</span><span class="p">:</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">f</span></div>

<div class="viewcode-block" id="LookupTable.integrate"><a class="viewcode-back" href="../../table.html#galsim.utilities.LookupTable.integrate">[docs]</a>    <span class="k">def</span> <span class="nf">integrate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x_min</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">x_max</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Calculate an estimate of the integral of the tabulated function from x_min to x_max:</span>

<span class="sd">        .. math::</span>

<span class="sd">            \int_{x_\mathrm{min}}^{x_\mathrm{max}} f(x) dx</span>

<span class="sd">        This function is not implemented for LookupTables that use log for either x or f,</span>
<span class="sd">        or that use a ``galsim.Interpolant``.  Also, if x_min or x_max are beyond the range</span>
<span class="sd">        of the tabulated function, the function will be considered to be zero there.</span>

<span class="sd">        .. note::</span>

<span class="sd">            The simplest version of this function is equivalent in functionality to the numpy</span>
<span class="sd">            ``trapz`` function.  However, it is usually significantly faster.  If you have a</span>
<span class="sd">            time-critical integration for which you are currently using ``np.trapz``::</span>

<span class="sd">                &gt;&gt;&gt; ans = np.trapz(f, x)</span>

<span class="sd">            the following replacement may be faster::</span>

<span class="sd">                &gt;&gt;&gt; ans = galsim.trapz(f, x)</span>

<span class="sd">            which is an alias for::</span>

<span class="sd">                &gt;&gt;&gt; ans = galsim._LookupTable(x, f, &#39;linear&#39;).integrate()</span>

<span class="sd">        Parameters:</span>
<span class="sd">            x_min:      The minimum abscissa to use for the integral.  [default: None, which</span>
<span class="sd">                        means to use self.x_min]</span>
<span class="sd">            x_max:      The maximum abscissa to use for the integral.  [default: None, which</span>
<span class="sd">                        means to use self.x_max]</span>

<span class="sd">        Returns:</span>
<span class="sd">            an estimate of the integral</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_log</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">GalSimNotImplementedError</span><span class="p">(</span><span class="s2">&quot;log x spacing not implemented yet.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">f_log</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">GalSimNotImplementedError</span><span class="p">(</span><span class="s2">&quot;log f values not implemented yet.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">interpolant</span><span class="p">,</span> <span class="n">basestring</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">GalSimNotImplementedError</span><span class="p">(</span>
                <span class="s2">&quot;Integration with interpolant=</span><span class="si">%s</span><span class="s2"> is not implemented.&quot;</span><span class="o">%</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">interpolant</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">x_min</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">x_min</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_min</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">x_min</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">x_min</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_min</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">x_max</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">x_max</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_max</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">x_max</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">x_max</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_max</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">x_min</span> <span class="o">&lt;</span> <span class="n">x_max</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tab</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span><span class="n">x_min</span><span class="p">,</span> <span class="n">x_max</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">x_min</span> <span class="o">==</span> <span class="n">x_max</span><span class="p">:</span>
            <span class="k">return</span> <span class="mf">0.</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span><span class="n">x_max</span><span class="p">,</span> <span class="n">x_min</span><span class="p">)</span></div>

<div class="viewcode-block" id="LookupTable.integrate_product"><a class="viewcode-back" href="../../table.html#galsim.utilities.LookupTable.integrate_product">[docs]</a>    <span class="k">def</span> <span class="nf">integrate_product</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">x_min</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">x_max</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">x_factor</span><span class="o">=</span><span class="mf">1.</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Calculate an estimate of the integral of the tabulated function multiplied by a second</span>
<span class="sd">        function from x_min to x_max:</span>

<span class="sd">        .. math::</span>

<span class="sd">            \int_{x_\mathrm{min}}^{x_\mathrm{max}} f(x) g(x) dx</span>

<span class="sd">        If the second function, :math:`g(x)`, is another `LookupTable`, then the quadrature will</span>
<span class="sd">        use the abscissae from both that function and :math:`f(x)` (i.e. ``self``).</span>
<span class="sd">        Otherwise, the second function will be evaluated at the abscissae of :math:`f(x)`.</span>

<span class="sd">        This function is not implemented for LookupTables that use log for either x or f,</span>
<span class="sd">        or that use a ``galsim.Interpolant``.  Also, if x_min or x_max are beyond the range</span>
<span class="sd">        of either tabulated function, the function will be considered to be zero there.</span>

<span class="sd">        Also, the second function :math:`g(x)` is always approximated with linear interpolation</span>
<span class="sd">        between the abscissae, even if it is a `LookupTable` with a different specified</span>
<span class="sd">        interpolation.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            g:          The function to multiply by the current function for the integral.</span>
<span class="sd">            x_min:      The minimum abscissa to use for the integral.  [default: None, which</span>
<span class="sd">                        means to use self.x_min]</span>
<span class="sd">            x_max:      The maximum abscissa to use for the integral.  [default: None, which</span>
<span class="sd">                        means to use self.x_max]</span>
<span class="sd">            x_factor:   Optionally scale the x values of f by this factor when doing the integral.</span>
<span class="sd">                        I.e. Find :math:`\int f(x x_\mathrm{factor}) g(x) dx`. [default: 1]</span>

<span class="sd">        Returns:</span>
<span class="sd">            an estimate of the integral</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_log</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">GalSimNotImplementedError</span><span class="p">(</span><span class="s2">&quot;log x spacing not implemented yet.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">f_log</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">GalSimNotImplementedError</span><span class="p">(</span><span class="s2">&quot;log f values not implemented yet.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">interpolant</span><span class="p">,</span> <span class="n">basestring</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">GalSimNotImplementedError</span><span class="p">(</span>
                <span class="s2">&quot;Integration with interpolant=</span><span class="si">%s</span><span class="s2"> is not implemented.&quot;</span><span class="o">%</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">interpolant</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">x_min</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">x_min</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_min</span> <span class="o">/</span> <span class="n">x_factor</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">x_min</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">x_min</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_min</span> <span class="o">/</span> <span class="n">x_factor</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">x_max</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">x_max</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_max</span> <span class="o">/</span> <span class="n">x_factor</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">x_max</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">x_max</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_max</span> <span class="o">/</span> <span class="n">x_factor</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">x_min</span> <span class="o">&gt;</span> <span class="n">x_max</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">integrate_product</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">x_max</span><span class="p">,</span> <span class="n">x_min</span><span class="p">,</span> <span class="n">x_factor</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">x_min</span> <span class="o">==</span> <span class="n">x_max</span><span class="p">:</span>
            <span class="k">return</span> <span class="mf">0.</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">LookupTable</span><span class="p">):</span>
            <span class="n">x_min</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">x_min</span><span class="p">,</span> <span class="n">g</span><span class="o">.</span><span class="n">x_min</span><span class="p">)</span>
            <span class="n">x_max</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">x_max</span><span class="p">,</span> <span class="n">g</span><span class="o">.</span><span class="n">x_max</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">x_min</span> <span class="o">&gt;=</span> <span class="n">x_max</span><span class="p">:</span>
                <span class="k">return</span> <span class="mf">0.</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">gx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">/</span> <span class="n">x_factor</span>
            <span class="n">gx</span> <span class="o">=</span> <span class="n">gx</span><span class="p">[(</span><span class="n">gx</span> <span class="o">&gt;=</span> <span class="n">x_min</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">gx</span> <span class="o">&lt;=</span> <span class="n">x_max</span><span class="p">)]</span>
            <span class="n">gx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">union1d</span><span class="p">(</span><span class="n">gx</span><span class="p">,</span> <span class="p">[</span><span class="n">x_min</span><span class="p">,</span> <span class="n">x_max</span><span class="p">])</span>
            <span class="c1"># Let this raise an appropriate error if g is not a valid function over this domain.</span>
            <span class="n">gf</span> <span class="o">=</span> <span class="n">g</span><span class="p">(</span><span class="n">gx</span><span class="p">)</span>
            <span class="c1"># If g is a constant function (like lambda wave: 1), then this doesn&#39;t return</span>
            <span class="c1"># an array.  Make it one.</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="nb">len</span><span class="p">(</span><span class="n">gf</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="n">gf1</span> <span class="o">=</span> <span class="n">gf</span>
                <span class="n">gf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">gx</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
                <span class="n">gf</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">gf1</span><span class="p">)</span>
            <span class="n">g</span> <span class="o">=</span> <span class="n">_LookupTable</span><span class="p">(</span><span class="n">gx</span><span class="p">,</span> <span class="n">gf</span><span class="p">,</span> <span class="s1">&#39;linear&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tab</span><span class="o">.</span><span class="n">integrate_product</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">_tab</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="n">x_min</span><span class="p">),</span> <span class="nb">float</span><span class="p">(</span><span class="n">x_max</span><span class="p">),</span> <span class="nb">float</span><span class="p">(</span><span class="n">x_factor</span><span class="p">))</span></div>

    <span class="k">def</span> <span class="nf">_check_range</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="n">slop</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x_max</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_min</span><span class="p">)</span> <span class="o">*</span> <span class="mf">1.e-6</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">initial</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">x_min</span><span class="p">)</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_min</span> <span class="o">-</span> <span class="n">slop</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">GalSimRangeError</span><span class="p">(</span><span class="s2">&quot;x value(s) below the range of the LookupTable.&quot;</span><span class="p">,</span>
                                   <span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_min</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_max</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">initial</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">x_max</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_max</span> <span class="o">+</span> <span class="n">slop</span><span class="p">:</span>  <span class="c1"># pragma: no branch</span>
            <span class="k">raise</span> <span class="n">GalSimRangeError</span><span class="p">(</span><span class="s2">&quot;x value(s) above the range of the LookupTable.&quot;</span><span class="p">,</span>
                                   <span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_min</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_max</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">getArgs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span>

    <span class="k">def</span> <span class="nf">getVals</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span>

    <span class="k">def</span> <span class="nf">getInterp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">interpolant</span>

    <span class="k">def</span> <span class="nf">isLogX</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_log</span>

    <span class="k">def</span> <span class="nf">isLogF</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">f_log</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span> <span class="ow">is</span> <span class="n">other</span> <span class="ow">or</span>
                <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">LookupTable</span><span class="p">)</span> <span class="ow">and</span>
                 <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span><span class="n">other</span><span class="o">.</span><span class="n">x</span><span class="p">)</span> <span class="ow">and</span>
                 <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">,</span><span class="n">other</span><span class="o">.</span><span class="n">f</span><span class="p">)</span> <span class="ow">and</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">x_log</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">x_log</span> <span class="ow">and</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">f_log</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">f_log</span> <span class="ow">and</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">interpolant</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">interpolant</span><span class="p">))</span>
    <span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span> <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__eq__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Cache this in case self.x, self.f are long.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_hash&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_hash</span> <span class="o">=</span> <span class="nb">hash</span><span class="p">((</span><span class="s2">&quot;galsim.LookupTable&quot;</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">),</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_log</span><span class="p">,</span>
                               <span class="bp">self</span><span class="o">.</span><span class="n">f_log</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">interpolant</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hash</span>


    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;galsim.LookupTable(x=array(</span><span class="si">%r</span><span class="s1">), f=array(</span><span class="si">%r</span><span class="s1">), interpolant=</span><span class="si">%r</span><span class="s1">, x_log=</span><span class="si">%r</span><span class="s1">, f_log=</span><span class="si">%r</span><span class="s1">)&#39;</span><span class="o">%</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">interpolant</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_log</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">f_log</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">s</span> <span class="o">=</span> <span class="s1">&#39;galsim.LookupTable(x=</span><span class="si">%s</span><span class="s1">, f=</span><span class="si">%s</span><span class="s1">&#39;</span><span class="o">%</span><span class="p">(</span><span class="n">_str_array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">),</span> <span class="n">_str_array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">interpolant</span> <span class="o">!=</span> <span class="s1">&#39;spline&#39;</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="s1">&#39;, interpolant=</span><span class="si">%r</span><span class="s1">&#39;</span><span class="o">%</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">interpolant</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_log</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="s1">&#39;, x_log=True&#39;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">f_log</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="s1">&#39;, f_log=True&#39;</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="s1">&#39;)&#39;</span>
        <span class="k">return</span> <span class="n">s</span>

<div class="viewcode-block" id="LookupTable.from_file"><a class="viewcode-back" href="../../table.html#galsim.utilities.LookupTable.from_file">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_file</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">file_name</span><span class="p">,</span> <span class="n">interpolant</span><span class="o">=</span><span class="s1">&#39;spline&#39;</span><span class="p">,</span> <span class="n">x_log</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">f_log</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">amplitude</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a `LookupTable` from a file of x, f values.</span>

<span class="sd">        This reads in a file, which should contain two columns with the x and f values.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            file_name:      A file from which to read the ``(x,f)`` pairs.</span>
<span class="sd">            interpolant:    Type of interpolation to use. [default: &#39;spline&#39;]</span>
<span class="sd">            x_log:          Whether the x values should be uniform in log rather than lienar.</span>
<span class="sd">                            [default: False]</span>
<span class="sd">            f_log:          Whether the f values should be interpolated using their logarithms</span>
<span class="sd">                            rather than their raw values. [default: False]</span>
<span class="sd">            amplitude:      An optional scaling of the f values relative to the values in the file</span>
<span class="sd">                            [default: 1.0]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># We don&#39;t require pandas as a dependency, but if it&#39;s available, this is much faster.</span>
        <span class="c1"># cf. http://stackoverflow.com/questions/15096269/the-fastest-way-to-read-input-in-python</span>
        <span class="n">ParserError</span> <span class="o">=</span> <span class="ne">AttributeError</span> <span class="c1"># In case we don&#39;t get to the line below where we import</span>
                                     <span class="c1"># it from pandas.</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">warnings</span><span class="o">.</span><span class="n">catch_warnings</span><span class="p">():</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">simplefilter</span><span class="p">(</span><span class="s2">&quot;ignore&quot;</span><span class="p">)</span>
                <span class="kn">import</span> <span class="nn">pandas</span>
                <span class="kn">from</span> <span class="nn">pandas.errors</span> <span class="kn">import</span> <span class="n">ParserError</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">pandas</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">file_name</span><span class="p">,</span> <span class="n">comment</span><span class="o">=</span><span class="s1">&#39;#&#39;</span><span class="p">,</span> <span class="n">delim_whitespace</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">ImportError</span><span class="p">,</span> <span class="ne">AttributeError</span><span class="p">,</span> <span class="n">ParserError</span><span class="p">):</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="n">file_name</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">GalSimValueError</span><span class="p">(</span><span class="s2">&quot;File provided for LookupTable does not have 2 columns&quot;</span><span class="p">,</span>
                                   <span class="n">file_name</span><span class="p">)</span>
        <span class="n">x</span><span class="o">=</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">f</span><span class="o">=</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">amplitude</span> <span class="o">!=</span> <span class="mf">1.0</span><span class="p">:</span>
            <span class="n">f</span><span class="p">[:]</span> <span class="o">*=</span> <span class="n">amplitude</span>
        <span class="k">return</span> <span class="n">LookupTable</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">interpolant</span><span class="o">=</span><span class="n">interpolant</span><span class="p">,</span> <span class="n">x_log</span><span class="o">=</span><span class="n">x_log</span><span class="p">,</span> <span class="n">f_log</span><span class="o">=</span><span class="n">f_log</span><span class="p">)</span></div>

<div class="viewcode-block" id="LookupTable.from_func"><a class="viewcode-back" href="../../table.html#galsim.utilities.LookupTable.from_func">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_func</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">x_min</span><span class="p">,</span> <span class="n">x_max</span><span class="p">,</span> <span class="n">npoints</span><span class="o">=</span><span class="mi">2000</span><span class="p">,</span> <span class="n">interpolant</span><span class="o">=</span><span class="s1">&#39;spline&#39;</span><span class="p">,</span>
                  <span class="n">x_log</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">f_log</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a `LookupTable` from a callable function</span>

<span class="sd">        This constructs a `LookupTable` over the given range from x_min and x_max, calculating the</span>
<span class="sd">        corresponding f values from the given function (technically any callable object).</span>

<span class="sd">        Parameters:</span>
<span class="sd">            func:           A callable function.</span>
<span class="sd">            x_min:          The minimum x value at which to evalue the function and store in the</span>
<span class="sd">                            lookup table.</span>
<span class="sd">            x_max:          The maximum x value at which to evalue the function and store in the</span>
<span class="sd">                            lookup table.</span>
<span class="sd">            npoints:        Number of x values at which to evaluate the function. [default: 2000]</span>
<span class="sd">            interpolant:    Type of interpolation to use. [default: &#39;spline&#39;]</span>
<span class="sd">            x_log:          Whether the x values should be uniform in log rather than lienar.</span>
<span class="sd">                            [default: False]</span>
<span class="sd">            f_log:          Whether the f values should be interpolated using their logarithms</span>
<span class="sd">                            rather than their raw values. [default: False]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">x_log</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">x_min</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">x_max</span><span class="p">),</span> <span class="n">npoints</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">x_min</span><span class="p">,</span> <span class="n">x_max</span><span class="p">,</span> <span class="n">npoints</span><span class="p">)</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">func</span><span class="p">(</span><span class="n">xx</span><span class="p">)</span> <span class="k">for</span> <span class="n">xx</span> <span class="ow">in</span> <span class="n">x</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">interpolant</span><span class="o">=</span><span class="n">interpolant</span><span class="p">,</span> <span class="n">x_log</span><span class="o">=</span><span class="n">x_log</span><span class="p">,</span> <span class="n">f_log</span><span class="o">=</span><span class="n">f_log</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">d</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;_tab&#39;</span><span class="p">,</span><span class="kc">None</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">d</span>

    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span> <span class="o">=</span> <span class="n">d</span></div>

<span class="k">def</span> <span class="nf">_LookupTable</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">interpolant</span><span class="o">=</span><span class="s1">&#39;spline&#39;</span><span class="p">,</span> <span class="n">x_log</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">f_log</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Make a `LookupTable` but without using any of the sanity checks or array manipulation used</span>
<span class="sd">    in the normal initializer.</span>

<span class="sd">    The input x values must be already sorted.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        x:              Strictly increasing NumPy array of ``x`` values.</span>
<span class="sd">        f:              NumPy array of ``f(x)`` values.</span>
<span class="sd">        interpolant:    Type of interpolation to use, with the options being &#39;floor&#39;, &#39;ceil&#39;,</span>
<span class="sd">                        &#39;nearest&#39;, &#39;linear&#39;, &#39;spline&#39;, or a `galsim.Interpolant` or string</span>
<span class="sd">                        convertible to one.  [default: &#39;spline&#39;]</span>
<span class="sd">        x_log:          Set to True if you wish to interpolate using log(x) rather than x.  Note</span>
<span class="sd">                        that all inputs / outputs will still be x, it&#39;s just a question of how the</span>
<span class="sd">                        interpolation is done. [default: False]</span>
<span class="sd">        f_log:          Set to True if you wish to interpolate using log(f) rather than f.  Note</span>
<span class="sd">                        that all inputs / outputs will still be f, it&#39;s just a question of how the</span>
<span class="sd">                        interpolation is done. [default: False]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">LookupTable</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="n">LookupTable</span><span class="p">)</span>
    <span class="n">ret</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">ret</span><span class="o">.</span><span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">ret</span><span class="o">.</span><span class="n">interpolant</span> <span class="o">=</span> <span class="n">interpolant</span>
    <span class="n">ret</span><span class="o">.</span><span class="n">x_log</span> <span class="o">=</span> <span class="n">x_log</span>
    <span class="n">ret</span><span class="o">.</span><span class="n">f_log</span> <span class="o">=</span> <span class="n">f_log</span>
    <span class="n">ret</span><span class="o">.</span><span class="n">_x_min</span> <span class="o">=</span> <span class="n">ret</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">ret</span><span class="o">.</span><span class="n">_x_max</span> <span class="o">=</span> <span class="n">ret</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">interpolant</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;nearest&#39;</span><span class="p">,</span> <span class="s1">&#39;linear&#39;</span><span class="p">,</span> <span class="s1">&#39;ceil&#39;</span><span class="p">,</span> <span class="s1">&#39;floor&#39;</span><span class="p">,</span> <span class="s1">&#39;spline&#39;</span><span class="p">):</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">_interp1d</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">_interp1d</span> <span class="o">=</span> <span class="n">convert_interpolant</span><span class="p">(</span><span class="n">interpolant</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ret</span>


<div class="viewcode-block" id="trapz"><a class="viewcode-back" href="../../table.html#galsim.utilities.trapz">[docs]</a><span class="k">def</span> <span class="nf">trapz</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Integrate f(x) using the trapezoidal rule.</span>

<span class="sd">    Equivalent to np.trapz(f,x) for 1d array inputs.  Intended as a drop-in replacement,</span>
<span class="sd">    which is usually faster.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        f:      The ordinates of the function to integrate.</span>
<span class="sd">        x:      The abscissae of the function to integrate.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Estimate of the integral.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_LookupTable</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">f</span><span class="p">,</span><span class="s1">&#39;linear&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">integrate</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="mf">0.</span></div>


<div class="viewcode-block" id="LookupTable2D"><a class="viewcode-back" href="../../table.html#galsim.utilities.LookupTable2D">[docs]</a><span class="k">class</span> <span class="nc">LookupTable2D</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    LookupTable2D represents a 2-dimensional lookup table to store function values that may be slow</span>
<span class="sd">    to calculate, for which interpolating from a lookup table is sufficiently accurate.  A</span>
<span class="sd">    LookupTable2D is also useful for evaluating periodic 2-d functions given samples from a single</span>
<span class="sd">    period.</span>

<span class="sd">    A LookupTable2D representing the function f(x, y) may be constructed from a list or array of</span>
<span class="sd">    ``x`` values, a list or array of ``y`` values, and a 2D array of function evaluations at all</span>
<span class="sd">    combinations of x and y values.  For instance::</span>

<span class="sd">        &gt;&gt;&gt; x = np.arange(5)</span>
<span class="sd">        &gt;&gt;&gt; y = np.arange(8)</span>
<span class="sd">        &gt;&gt;&gt; z = x + y[:, np.newaxis]  # function is x + y, dimensions of z are (8, 5)</span>
<span class="sd">        &gt;&gt;&gt; tab2d = galsim.LookupTable2D(x, y, z)</span>

<span class="sd">    To evaluate new function values with the lookup table, use the () operator::</span>

<span class="sd">        &gt;&gt;&gt; print tab2d(2.2, 3.3)</span>
<span class="sd">        5.5</span>

<span class="sd">    The () operator can also accept sequences (lists, tuples, numpy arrays, ...) for the x and y</span>
<span class="sd">    arguments at which to evaluate the LookupTable2D.  Normally, the x and y sequences should have</span>
<span class="sd">    the same length, which will also be the length of the output sequence::</span>

<span class="sd">        &gt;&gt;&gt; print tab2d([1, 2], [3, 5])</span>
<span class="sd">        array([ 4., 7.])</span>

<span class="sd">    If you add ``grid=True`` as an additional kwarg, however, then the () operator will generate</span>
<span class="sd">    interpolated values at the outer product of x-values and y-values.  So in this case, the x and</span>
<span class="sd">    y sequences can have different lengths Nx and Ny, and the result will be a 2D array with</span>
<span class="sd">    dimensions (Nx, Ny)::</span>

<span class="sd">        &gt;&gt;&gt; print tab2d([1, 2], [3, 5], grid=True)</span>
<span class="sd">        array([[ 4., 6.],</span>
<span class="sd">               [ 5., 7.]])</span>

<span class="sd">    The default interpolation method is linear.  Other choices for the interpolant are:</span>

<span class="sd">        - &#39;floor&#39;</span>
<span class="sd">        - &#39;ceil&#39;</span>
<span class="sd">        - &#39;nearest&#39;</span>
<span class="sd">        - &#39;spline&#39; (a Catmull-Rom cubic spline).</span>
<span class="sd">        - a `galsim.Interpolant` or string convertible to one.</span>

<span class="sd">    ::</span>

<span class="sd">        &gt;&gt;&gt; tab2d = galsim.LookupTable2D(x, y, z, interpolant=&#39;floor&#39;)</span>
<span class="sd">        &gt;&gt;&gt; tab2d(2.2, 3.7)</span>
<span class="sd">        5.0</span>
<span class="sd">        &gt;&gt;&gt; tab2d = galsim.LookupTable2D(x, y, z, interpolant=&#39;ceil&#39;)</span>
<span class="sd">        &gt;&gt;&gt; tab2d(2.2, 3.7)</span>
<span class="sd">        7.0</span>
<span class="sd">        &gt;&gt;&gt; tab2d = galsim.LookupTable2D(x, y, z, interpolant=&#39;nearest&#39;)</span>
<span class="sd">        &gt;&gt;&gt; tab2d(2.2, 3.7)</span>
<span class="sd">        6.0</span>

<span class="sd">    For interpolant=&#39;spline&#39; or a `galsim.Interpolant`, the input arrays must be uniformly spaced.</span>
<span class="sd">    For interpolant=&#39;spline&#39;, the derivatives df / dx, df / dy, and d^2 f / dx dy at grid-points may</span>
<span class="sd">    also optionally be provided if they&#39;re known, which will generally yield a more accurate</span>
<span class="sd">    interpolation (these derivatives will be estimated from finite differences if they&#39;re not</span>
<span class="sd">    provided).</span>

<span class="sd">    The ``edge_mode`` keyword describes how to handle extrapolation beyond the initial input range.</span>
<span class="sd">    Possibilities include:</span>

<span class="sd">      - &#39;raise&#39;: raise an exception.  (This is the default.)</span>
<span class="sd">      - &#39;warn&#39;: issues a warning, then falls back to edge_mode=&#39;constant&#39;.</span>
<span class="sd">      - &#39;constant&#39;: Return a constant specified by the ``constant`` keyword.</span>
<span class="sd">      - &#39;wrap&#39;: infinitely wrap the initial range in both directions.</span>

<span class="sd">    In order for LookupTable2D to determine the wrapping period when edge_mode=&#39;wrap&#39;, either the</span>
<span class="sd">    x and y grid points need to be equally spaced (in which case the x-period is inferred as</span>
<span class="sd">    len(x)*(x[1]-x[0]) and similarly for y), or the first/last row/column of f must be identical,</span>
<span class="sd">    in which case the x-period is inferred as x[-1] - x[0].  (If both conditions are satisfied</span>
<span class="sd">    (equally-spaced x and y and identical first/last row/column of f, then the x-period is inferred</span>
<span class="sd">    as len(x)*(x[1]-x[0]))::</span>

<span class="sd">        &gt;&gt;&gt; x = np.arange(5)</span>
<span class="sd">        &gt;&gt;&gt; y = np.arange(8)</span>
<span class="sd">        &gt;&gt;&gt; z = x + y[:, np.newaxis]  # function is x + y, dimensions of z are (8, 5)</span>
<span class="sd">        &gt;&gt;&gt; tab2d = galsim.LookupTable2D(x, y, z, edge_mode=&#39;raise&#39;)</span>
<span class="sd">        &gt;&gt;&gt; tab2d(7, 7)</span>
<span class="sd">        ValueError: Extrapolating beyond input range.</span>

<span class="sd">        &gt;&gt;&gt; tab2d = galsim.LookupTable2D(x, y, z, edge_mode=&#39;constant&#39;, constant=1.0)</span>
<span class="sd">        1.0</span>

<span class="sd">        &gt;&gt;&gt; tab2d = galsim.LookupTable2D(x, y, z, edge_mode=&#39;wrap&#39;)</span>
<span class="sd">        ValueError: Cannot wrap `f` array with unequal first/last column/row.</span>

<span class="sd">    We extend the x and y arrays with a uniform spacing, though any monotonic spacing would work.</span>
<span class="sd">    Note that the [(0,1), (0,1)] argument in np.pad below extends the z array by 0 rows/columns in</span>
<span class="sd">    the leading direction, and 1 row/column in the trailing direction::</span>

<span class="sd">        &gt;&gt;&gt; x = np.append(x, x[-1] + (x[-1]-x[-2]))</span>
<span class="sd">        &gt;&gt;&gt; y = np.append(y, y[-1] + (y[-1]-y[-2]))</span>
<span class="sd">        &gt;&gt;&gt; z = np.pad(z, [(0,1), (0,1)], mode=&#39;wrap&#39;)</span>
<span class="sd">        &gt;&gt;&gt; tab2d = galsim.LookupTable2D(x, y, z, edge_mode=&#39;wrap&#39;)</span>
<span class="sd">        &gt;&gt;&gt; tab2d(2., 2.)</span>
<span class="sd">        4.0</span>
<span class="sd">        &gt;&gt;&gt; tab2d(2.+5, 2.)  # The period is 5 in the x direction</span>
<span class="sd">        4.0</span>
<span class="sd">        &gt;&gt;&gt; tab2d(2.+3*5, 2.+4*8)  # The period is 8 in the y direction</span>
<span class="sd">        4.0</span>

<span class="sd">    Parameters:</span>
<span class="sd">        x:              Strictly increasing array of ``x`` positions at which to create table.</span>
<span class="sd">        y:              Strictly increasing array of ``y`` positions at which to create table.</span>
<span class="sd">        f:              Nx by Ny input array of function values.</span>
<span class="sd">        dfdx:           Optional first derivative of f wrt x.  Only used if interpolant=&#39;spline&#39;.</span>
<span class="sd">                        [default: None]</span>
<span class="sd">        dfdy:           Optional first derivative of f wrt y.  Only used if interpolant=&#39;spline&#39;.</span>
<span class="sd">                        [default: None]</span>
<span class="sd">        d2fdxdy:        Optional cross derivative of f wrt x and y.  Only used if</span>
<span class="sd">                        interpolant=&#39;spline&#39;.  [default: None]</span>
<span class="sd">        interpolant:    Type of interpolation to use.  One of &#39;floor&#39;, &#39;ceil&#39;, &#39;nearest&#39;, &#39;linear&#39;,</span>
<span class="sd">                        &#39;spline&#39;, or a `galsim.Interpolant` or string convertible to one.</span>
<span class="sd">                        [default: &#39;linear&#39;]</span>
<span class="sd">        edge_mode:      Keyword controlling how extrapolation beyond the input range is handled.</span>
<span class="sd">                        See above for details.  [default: &#39;raise&#39;]</span>
<span class="sd">        constant:       A constant to return when extrapolating beyond the input range and</span>
<span class="sd">                        ``edge_mode=&#39;constant&#39;``.  [default: 0]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">dfdx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dfdy</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">d2fdxdy</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">interpolant</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">,</span> <span class="n">edge_mode</span><span class="o">=</span><span class="s1">&#39;raise&#39;</span><span class="p">,</span> <span class="n">constant</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">edge_mode</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;raise&#39;</span><span class="p">,</span> <span class="s1">&#39;warn&#39;</span><span class="p">,</span> <span class="s1">&#39;wrap&#39;</span><span class="p">,</span> <span class="s1">&#39;constant&#39;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">GalSimValueError</span><span class="p">(</span><span class="s2">&quot;Unknown edge_mode.&quot;</span><span class="p">,</span> <span class="n">edge_mode</span><span class="p">,</span>
                                   <span class="p">(</span><span class="s1">&#39;raise&#39;</span><span class="p">,</span> <span class="s1">&#39;warn&#39;</span><span class="p">,</span> <span class="s1">&#39;wrap&#39;</span><span class="p">,</span> <span class="s1">&#39;constant&#39;</span><span class="p">))</span>

        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

        <span class="n">dx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">dy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="n">equal_spaced</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">dx</span><span class="p">,</span> <span class="n">dx</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">dy</span><span class="p">,</span> <span class="n">dy</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">dx</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">GalSimValueError</span><span class="p">(</span><span class="s2">&quot;x input grids is not strictly increasing.&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">dy</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">GalSimValueError</span><span class="p">(</span><span class="s2">&quot;y input grids is not strictly increasing.&quot;</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

        <span class="n">fshape</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">if</span> <span class="n">fshape</span> <span class="o">!=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="n">GalSimIncompatibleValuesError</span><span class="p">(</span>
                <span class="s2">&quot;Shape of f incompatible with lengths of x,y&quot;</span><span class="p">,</span> <span class="n">f</span><span class="o">=</span><span class="n">f</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">)</span>

        <span class="c1"># Check if interpolant is a string that we understand.  If not, try convert_interpolant</span>
        <span class="k">if</span> <span class="n">interpolant</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;nearest&#39;</span><span class="p">,</span> <span class="s1">&#39;linear&#39;</span><span class="p">,</span> <span class="s1">&#39;ceil&#39;</span><span class="p">,</span> <span class="s1">&#39;floor&#39;</span><span class="p">,</span> <span class="s1">&#39;spline&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_interp2d</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">padrange</span> <span class="o">=</span> <span class="mi">2</span> <span class="k">if</span> <span class="n">interpolant</span> <span class="o">==</span> <span class="s1">&#39;spline&#39;</span> <span class="k">else</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_interp2d</span> <span class="o">=</span> <span class="n">convert_interpolant</span><span class="p">(</span><span class="n">interpolant</span><span class="p">)</span>
            <span class="n">padrange</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_interp2d</span><span class="o">.</span><span class="n">xrange</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">interpolant</span> <span class="o">=</span> <span class="n">interpolant</span>

        <span class="c1"># Check if need equal-spaced arrays</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_interp2d</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">interpolant</span>  <span class="o">==</span> <span class="s1">&#39;spline&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">equal_spaced</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">GalSimIncompatibleValuesError</span><span class="p">(</span>
                <span class="s2">&quot;Cannot use a galsim.Interpolant in LookupTable2D unless x and y are &quot;</span>
                <span class="s2">&quot;equally spaced.&quot;</span><span class="p">,</span> <span class="n">interpolant</span><span class="o">=</span><span class="n">interpolant</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">edge_mode</span> <span class="o">=</span> <span class="n">edge_mode</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">constant</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">constant</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge_mode</span> <span class="o">==</span> <span class="s1">&#39;wrap&#39;</span><span class="p">:</span>
            <span class="c1"># Can wrap if x and y arrays are equally spaced ...</span>
            <span class="k">if</span> <span class="n">equal_spaced</span><span class="p">:</span>
                <span class="k">if</span> <span class="mi">2</span><span class="o">*</span><span class="n">padrange</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">or</span> <span class="mi">2</span><span class="o">*</span><span class="n">padrange</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="n">GalSimValueError</span><span class="p">(</span>
                        <span class="s2">&quot;Cannot wrap an image which is smaller than the Interpolant&quot;</span><span class="p">,</span>
                        <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">interpolant</span><span class="p">))</span>
                <span class="c1"># Underlying Table2D requires us to extend x, y, and f.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">xperiod</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">dx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">yperiod</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">dy</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">x0</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">y0</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">([</span><span class="n">dx</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">*</span><span class="p">(</span><span class="n">padrange</span><span class="o">-</span><span class="mi">1</span><span class="p">)),</span>
                               <span class="n">x</span><span class="p">,</span>
                               <span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">([</span><span class="n">dx</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">*</span><span class="n">padrange</span><span class="p">)])</span>
                <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">([</span><span class="n">dy</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">*</span><span class="p">(</span><span class="n">padrange</span><span class="o">-</span><span class="mi">1</span><span class="p">)),</span>
                               <span class="n">y</span><span class="p">,</span>
                               <span class="n">y</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">([</span><span class="n">dy</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">*</span><span class="n">padrange</span><span class="p">)])</span>
                <span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="p">[(</span><span class="n">padrange</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">padrange</span><span class="p">)]</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;wrap&#39;</span><span class="p">)</span>
            <span class="c1"># Can also wrap non-uniform grids if edges match</span>
            <span class="k">elif</span> <span class="p">(</span><span class="nb">all</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">f</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="n">f</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">f</span><span class="p">[:,</span><span class="o">-</span><span class="mi">1</span><span class="p">])):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">x0</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">y0</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">xperiod</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">yperiod</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">GalSimIncompatibleValuesError</span><span class="p">(</span>
                    <span class="s2">&quot;Cannot use edge_mode=&#39;wrap&#39; unless either x and y are equally &quot;</span>
                    <span class="s2">&quot;spaced or first/last row/column of f are identical.&quot;</span><span class="p">,</span>
                    <span class="n">edge_mode</span><span class="o">=</span><span class="n">edge_mode</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">f</span><span class="o">=</span><span class="n">f</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>

        <span class="n">der_exist</span> <span class="o">=</span> <span class="p">[</span><span class="n">kw</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">kw</span> <span class="ow">in</span> <span class="p">[</span><span class="n">dfdx</span><span class="p">,</span> <span class="n">dfdy</span><span class="p">,</span> <span class="n">d2fdxdy</span><span class="p">]]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">interpolant</span> <span class="o">==</span> <span class="s1">&#39;spline&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">der_exist</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">der_exist</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="n">GalSimIncompatibleValuesError</span><span class="p">(</span>
                        <span class="s2">&quot;Must specify all of dfdx, dfdy, d2fdxdy if one is specified&quot;</span><span class="p">,</span>
                        <span class="n">dfdx</span><span class="o">=</span><span class="n">dfdx</span><span class="p">,</span> <span class="n">dfdy</span><span class="o">=</span><span class="n">dfdy</span><span class="p">,</span> <span class="n">d2fdxdy</span><span class="o">=</span><span class="n">d2fdxdy</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Use finite differences if derivatives not provided</span>
                <span class="n">dfdx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
                <span class="n">diffx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
                <span class="n">dfdx</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">f</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:]</span> <span class="o">-</span> <span class="n">f</span><span class="p">[:,</span> <span class="p">:</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span><span class="o">/</span><span class="n">diffx</span>
                <span class="n">dfdx</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">f</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">f</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span><span class="o">/</span><span class="n">dx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">dfdx</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">f</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">f</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">2</span><span class="p">])</span><span class="o">/</span><span class="n">dx</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

                <span class="n">dfdy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
                <span class="n">diffy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
                <span class="n">dfdy</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="mi">2</span><span class="p">:,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">f</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="p">:])</span><span class="o">/</span><span class="n">diffy</span><span class="p">[:,</span><span class="kc">None</span><span class="p">]</span>
                <span class="n">dfdy</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:])</span><span class="o">/</span><span class="n">dy</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">dfdy</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">f</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="p">:])</span><span class="o">/</span><span class="n">dy</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

                <span class="n">d2fdxdy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
                <span class="n">d2fdxdy</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="p">(</span><span class="n">dfdx</span><span class="p">[</span><span class="mi">2</span><span class="p">:,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">dfdx</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="p">:])</span><span class="o">/</span><span class="n">diffy</span><span class="p">[:,</span><span class="kc">None</span><span class="p">]</span>
                <span class="n">d2fdxdy</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="p">(</span><span class="n">dfdx</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">dfdx</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:])</span><span class="o">/</span><span class="n">dy</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">d2fdxdy</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="p">(</span><span class="n">dfdx</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">dfdx</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="p">:])</span><span class="o">/</span><span class="n">dy</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">der_exist</span><span class="p">):</span>
                <span class="k">raise</span> <span class="n">GalSimIncompatibleValuesError</span><span class="p">(</span>
                    <span class="s2">&quot;Only specify dfdx, dfdy, d2fdxdy if interpolant is &#39;spline&#39;.&quot;</span><span class="p">,</span>
                    <span class="n">dfdx</span><span class="o">=</span><span class="n">dfdx</span><span class="p">,</span> <span class="n">dfdy</span><span class="o">=</span><span class="n">dfdy</span><span class="p">,</span> <span class="n">d2fdxdy</span><span class="o">=</span><span class="n">d2fdxdy</span><span class="p">,</span> <span class="n">interpolant</span><span class="o">=</span><span class="n">interpolant</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">dfdx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dfdx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">dfdx</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="n">dfdy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">dfdy</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="n">d2fdxdy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">d2fdxdy</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">dfdx</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">f</span><span class="o">.</span><span class="n">shape</span> <span class="ow">or</span> <span class="n">dfdy</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">f</span><span class="o">.</span><span class="n">shape</span> <span class="ow">or</span> <span class="n">d2fdxdy</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">f</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">GalSimIncompatibleValuesError</span><span class="p">(</span>
                    <span class="s2">&quot;derivative shapes must match f shape&quot;</span><span class="p">,</span>
                    <span class="n">dfdx</span><span class="o">=</span><span class="n">dfdx</span><span class="p">,</span> <span class="n">dfdy</span><span class="o">=</span><span class="n">dfdy</span><span class="p">,</span> <span class="n">d2fdxdy</span><span class="o">=</span><span class="n">d2fdxdy</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">dfdx</span> <span class="o">=</span> <span class="n">dfdx</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dfdy</span> <span class="o">=</span> <span class="n">dfdy</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">d2fdxdy</span> <span class="o">=</span> <span class="n">d2fdxdy</span>

    <span class="nd">@lazy_property</span>
    <span class="k">def</span> <span class="nf">_tab</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">_x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">__array_interface__</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">_y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="o">.</span><span class="n">__array_interface__</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">_f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="o">.</span><span class="n">__array_interface__</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_interp2d</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_galsim</span><span class="o">.</span><span class="n">LookupTable2D</span><span class="p">(</span><span class="n">_x</span><span class="p">,</span> <span class="n">_y</span><span class="p">,</span> <span class="n">_f</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">),</span>
                                         <span class="bp">self</span><span class="o">.</span><span class="n">_interp2d</span><span class="o">.</span><span class="n">_i</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">interpolant</span> <span class="o">==</span> <span class="s1">&#39;spline&#39;</span><span class="p">:</span>
            <span class="n">_dfdx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dfdx</span><span class="o">.</span><span class="n">__array_interface__</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">_dfdy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dfdy</span><span class="o">.</span><span class="n">__array_interface__</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">_d2fdxdy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">d2fdxdy</span><span class="o">.</span><span class="n">__array_interface__</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">_galsim</span><span class="o">.</span><span class="n">LookupTable2D</span><span class="p">(</span><span class="n">_x</span><span class="p">,</span> <span class="n">_y</span><span class="p">,</span> <span class="n">_f</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">),</span>
                                         <span class="n">_dfdx</span><span class="p">,</span> <span class="n">_dfdy</span><span class="p">,</span> <span class="n">_d2fdxdy</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_galsim</span><span class="o">.</span><span class="n">LookupTable2D</span><span class="p">(</span><span class="n">_x</span><span class="p">,</span> <span class="n">_y</span><span class="p">,</span> <span class="n">_f</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">),</span>
                                         <span class="bp">self</span><span class="o">.</span><span class="n">interpolant</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">getXArgs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span>

    <span class="k">def</span> <span class="nf">getYArgs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span>

    <span class="k">def</span> <span class="nf">getVals</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span>

    <span class="k">def</span> <span class="nf">_inbounds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return whether or not *all* coords specified by x and y are in bounds of the original</span>
<span class="sd">        interpolated array.&quot;&quot;&quot;</span>
        <span class="c1"># Only used if edge_mode != &#39;wrap&#39;, so original x/y arrays are unmodified.</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">and</span>
                <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">_wrap_args</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Wrap points back into the fundamental period.&quot;&quot;&quot;</span>
        <span class="c1"># Original x and y may have been modified, so need to use x0 and xperiod attributes here.</span>
        <span class="c1">#x = (x-self.x0) % self.xperiod + self.x0</span>
        <span class="c1">#y = (y-self.y0) % self.yperiod + self.y0</span>
        <span class="n">_x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">__array_interface__</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">_y</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">__array_interface__</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">_galsim</span><span class="o">.</span><span class="n">WrapArrayToPeriod</span><span class="p">(</span><span class="n">_x</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">x0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">xperiod</span><span class="p">)</span>
        <span class="n">_galsim</span><span class="o">.</span><span class="n">WrapArrayToPeriod</span><span class="p">(</span><span class="n">_y</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">y0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">yperiod</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Only meaningful if edge_mode is &#39;raise&#39; or &#39;warn&#39;, in which case original x/y arrays are</span>
        <span class="c1"># unmodified.</span>
        <span class="k">return</span> <span class="n">BoundsD</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">_call_inbounds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">grid</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="n">_x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">__array_interface__</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">_y</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">__array_interface__</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">grid</span><span class="p">:</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="n">_f</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">__array_interface__</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_tab</span><span class="o">.</span><span class="n">interpGrid</span><span class="p">(</span><span class="n">_x</span><span class="p">,</span> <span class="n">_y</span><span class="p">,</span> <span class="n">_f</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">f</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="n">_f</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">__array_interface__</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_tab</span><span class="o">.</span><span class="n">interpMany</span><span class="p">(</span><span class="n">_x</span><span class="p">,</span> <span class="n">_y</span><span class="p">,</span> <span class="n">_f</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">f</span>

    <span class="k">def</span> <span class="nf">_call_constant</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">grid</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">grid</span><span class="p">:</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="c1"># Fill in interpolated values first, then go back and fill in</span>
            <span class="c1"># constants</span>
            <span class="n">_x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">__array_interface__</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">_y</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">__array_interface__</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">_f</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">__array_interface__</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_tab</span><span class="o">.</span><span class="n">interpGrid</span><span class="p">(</span><span class="n">_x</span><span class="p">,</span> <span class="n">_y</span><span class="p">,</span> <span class="n">_f</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
            <span class="n">badx</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">|</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">bady</span> <span class="o">=</span> <span class="p">(</span><span class="n">y</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">|</span> <span class="p">(</span><span class="n">y</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">f</span><span class="p">[</span><span class="n">bady</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">constant</span>
            <span class="n">f</span><span class="p">[:,</span> <span class="n">badx</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">constant</span>
            <span class="k">return</span> <span class="n">f</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Start with constant array, then interpolate good positions</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="n">f</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">constant</span><span class="p">)</span>
            <span class="n">good</span> <span class="o">=</span> <span class="p">((</span><span class="n">x</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">x</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">&amp;</span>
                    <span class="p">(</span><span class="n">y</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">y</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
            <span class="n">xx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">good</span><span class="p">]</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="n">yy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">good</span><span class="p">]</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">xx</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="n">_xx</span> <span class="o">=</span> <span class="n">xx</span><span class="o">.</span><span class="n">__array_interface__</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">_yy</span> <span class="o">=</span> <span class="n">yy</span><span class="o">.</span><span class="n">__array_interface__</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">_tmp</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">.</span><span class="n">__array_interface__</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_tab</span><span class="o">.</span><span class="n">interpMany</span><span class="p">(</span><span class="n">_xx</span><span class="p">,</span> <span class="n">_yy</span><span class="p">,</span> <span class="n">_tmp</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">xx</span><span class="p">))</span>
            <span class="n">f</span><span class="p">[</span><span class="n">good</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span>
            <span class="k">return</span> <span class="n">f</span>

    <span class="k">def</span> <span class="nf">_call_raise</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">grid</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inbounds</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="n">find_out_of_bounds_position</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bounds</span><span class="p">,</span> <span class="n">grid</span><span class="p">)</span>
            <span class="k">raise</span> <span class="n">GalSimBoundsError</span><span class="p">(</span><span class="s2">&quot;Extrapolating beyond input range.&quot;</span><span class="p">,</span>
                                    <span class="n">pos</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bounds</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_call_inbounds</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">grid</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_call_warn</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">grid</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inbounds</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="n">find_out_of_bounds_position</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bounds</span><span class="p">,</span> <span class="n">grid</span><span class="p">)</span>
            <span class="n">galsim_warn</span><span class="p">(</span><span class="s2">&quot;Extrapolating beyond input range. </span><span class="si">{!r}</span><span class="s2"> not in </span><span class="si">{!r}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">pos</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bounds</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_call_constant</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">grid</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_call_wrap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">grid</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrap_args</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_call_inbounds</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">grid</span><span class="p">)</span>

<div class="viewcode-block" id="LookupTable2D.__call__"><a class="viewcode-back" href="../../table.html#galsim.utilities.LookupTable2D.__call__">[docs]</a>    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">grid</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Interpolate at an arbitrary point or points.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            x:      Either a single x value or an array of x values at which to interpolate.</span>
<span class="sd">            y:      Either a single y value or an array of y values at which to interpolate.</span>
<span class="sd">            grid:   Optional boolean indicating that output should be a 2D array corresponding</span>
<span class="sd">                    to the outer product of input values.  If False (default), then the output</span>
<span class="sd">                    array will be congruent to x and y.</span>

<span class="sd">        Returns:</span>
<span class="sd">            a scalar value if x and y are scalar, or a numpy array if x and y are arrays.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">edge_mode</span><span class="o">==</span><span class="s1">&#39;wrap&#39;</span><span class="p">)</span>
        <span class="n">y1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">edge_mode</span><span class="o">==</span><span class="s1">&#39;wrap&#39;</span><span class="p">)</span>
        <span class="n">x2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">x1</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">y2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">y1</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge_mode</span> <span class="o">==</span> <span class="s1">&#39;raise&#39;</span><span class="p">:</span>
            <span class="n">f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_call_raise</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">y2</span><span class="p">,</span> <span class="n">grid</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge_mode</span> <span class="o">==</span> <span class="s1">&#39;warn&#39;</span><span class="p">:</span>
            <span class="n">f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_call_warn</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">y2</span><span class="p">,</span> <span class="n">grid</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge_mode</span> <span class="o">==</span> <span class="s1">&#39;wrap&#39;</span><span class="p">:</span>
            <span class="n">f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_call_wrap</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">y2</span><span class="p">,</span> <span class="n">grid</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span> <span class="c1"># constant</span>
            <span class="n">f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_call_constant</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">y2</span><span class="p">,</span> <span class="n">grid</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Real</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">grid</span><span class="p">:</span>
                <span class="n">f</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">x1</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">f</span></div>

    <span class="k">def</span> <span class="nf">_gradient_inbounds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">grid</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">grid</span><span class="p">:</span>
            <span class="n">dfdx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="n">dfdy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="n">_x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">__array_interface__</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">_y</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">__array_interface__</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">_dfdx</span> <span class="o">=</span> <span class="n">dfdx</span><span class="o">.</span><span class="n">__array_interface__</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">_dfdy</span> <span class="o">=</span> <span class="n">dfdy</span><span class="o">.</span><span class="n">__array_interface__</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_tab</span><span class="o">.</span><span class="n">gradientGrid</span><span class="p">(</span><span class="n">_x</span><span class="p">,</span> <span class="n">_y</span><span class="p">,</span> <span class="n">_dfdx</span><span class="p">,</span> <span class="n">_dfdy</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">dfdx</span><span class="p">,</span> <span class="n">dfdy</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dfdx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="n">dfdy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="n">_x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">__array_interface__</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">_y</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">__array_interface__</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">_dfdx</span> <span class="o">=</span> <span class="n">dfdx</span><span class="o">.</span><span class="n">__array_interface__</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">_dfdy</span> <span class="o">=</span> <span class="n">dfdy</span><span class="o">.</span><span class="n">__array_interface__</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_tab</span><span class="o">.</span><span class="n">gradientMany</span><span class="p">(</span><span class="n">_x</span><span class="p">,</span> <span class="n">_y</span><span class="p">,</span> <span class="n">_dfdx</span><span class="p">,</span> <span class="n">_dfdy</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">dfdx</span><span class="p">,</span> <span class="n">dfdy</span>

    <span class="k">def</span> <span class="nf">_gradient_raise</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">grid</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inbounds</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="n">find_out_of_bounds_position</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bounds</span><span class="p">,</span> <span class="n">grid</span><span class="p">)</span>
            <span class="k">raise</span> <span class="n">GalSimBoundsError</span><span class="p">(</span><span class="s2">&quot;Extrapolating beyond input range.&quot;</span><span class="p">,</span>
                                    <span class="n">pos</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bounds</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gradient_inbounds</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">grid</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_gradient_warn</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">grid</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inbounds</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="n">find_out_of_bounds_position</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bounds</span><span class="p">,</span> <span class="n">grid</span><span class="p">)</span>
            <span class="n">galsim_warn</span><span class="p">(</span><span class="s2">&quot;Extrapolating beyond input range. </span><span class="si">{!r}</span><span class="s2"> not in </span><span class="si">{!r}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">pos</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bounds</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gradient_constant</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">grid</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_gradient_wrap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">grid</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrap_args</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gradient_inbounds</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">grid</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_gradient_constant</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">grid</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">grid</span><span class="p">:</span>
            <span class="n">dfdx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="n">dfdy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="n">_x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">__array_interface__</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">_y</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">__array_interface__</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">_dfdx</span> <span class="o">=</span> <span class="n">dfdx</span><span class="o">.</span><span class="n">__array_interface__</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">_dfdy</span> <span class="o">=</span> <span class="n">dfdy</span><span class="o">.</span><span class="n">__array_interface__</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_tab</span><span class="o">.</span><span class="n">gradientGrid</span><span class="p">(</span><span class="n">_x</span><span class="p">,</span> <span class="n">_y</span><span class="p">,</span> <span class="n">_dfdx</span><span class="p">,</span> <span class="n">_dfdy</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
            <span class="n">badx</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">|</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">bady</span> <span class="o">=</span> <span class="p">(</span><span class="n">y</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">|</span> <span class="p">(</span><span class="n">y</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">dfdx</span><span class="p">[</span><span class="n">bady</span><span class="p">,:]</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="n">dfdx</span><span class="p">[:,</span> <span class="n">badx</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="n">dfdy</span><span class="p">[</span><span class="n">bady</span><span class="p">,:]</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="n">dfdy</span><span class="p">[:,</span> <span class="n">badx</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="k">return</span> <span class="n">dfdx</span><span class="p">,</span> <span class="n">dfdy</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dfdx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="n">dfdy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="n">dfdx</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span>
            <span class="n">dfdy</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span>
            <span class="n">good</span> <span class="o">=</span> <span class="p">((</span><span class="n">x</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">x</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">&amp;</span>
                    <span class="p">(</span><span class="n">y</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">y</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">good</span><span class="p">]</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">good</span><span class="p">]</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="n">tmp1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="n">tmp2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="n">_x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">__array_interface__</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">_y</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">__array_interface__</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">_tmp1</span> <span class="o">=</span> <span class="n">tmp1</span><span class="o">.</span><span class="n">__array_interface__</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">_tmp2</span> <span class="o">=</span> <span class="n">tmp2</span><span class="o">.</span><span class="n">__array_interface__</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_tab</span><span class="o">.</span><span class="n">gradientMany</span><span class="p">(</span><span class="n">_x</span><span class="p">,</span> <span class="n">_y</span><span class="p">,</span> <span class="n">_tmp1</span><span class="p">,</span> <span class="n">_tmp2</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
            <span class="n">dfdx</span><span class="p">[</span><span class="n">good</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp1</span>
            <span class="n">dfdy</span><span class="p">[</span><span class="n">good</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp2</span>
            <span class="k">return</span> <span class="n">dfdx</span><span class="p">,</span> <span class="n">dfdy</span>

<div class="viewcode-block" id="LookupTable2D.gradient"><a class="viewcode-back" href="../../table.html#galsim.utilities.LookupTable2D.gradient">[docs]</a>    <span class="k">def</span> <span class="nf">gradient</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">grid</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculate the gradient of the function at an arbitrary point or points.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            x:      Either a single x value or an array of x values at which to compute</span>
<span class="sd">                    the gradient.</span>
<span class="sd">            y:      Either a single y value or an array of y values at which to compute</span>
<span class="sd">                    the gradient.</span>
<span class="sd">            grid:   Optional boolean indicating that output should be a 2-tuple of 2D arrays</span>
<span class="sd">                    corresponding to the outer product of input values.  If False (default),</span>
<span class="sd">                    then the output arrays will be congruent to x and y.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A tuple of (dfdx, dfdy) where dfdx, dfdy are single values (if x,y were single</span>
<span class="sd">            values) or numpy arrays.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">edge_mode</span><span class="o">==</span><span class="s1">&#39;wrap&#39;</span><span class="p">)</span>
        <span class="n">y1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">edge_mode</span><span class="o">==</span><span class="s1">&#39;wrap&#39;</span><span class="p">)</span>
        <span class="n">x2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">x1</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">y2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">y1</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge_mode</span> <span class="o">==</span> <span class="s1">&#39;raise&#39;</span><span class="p">:</span>
            <span class="n">dfdx</span><span class="p">,</span> <span class="n">dfdy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gradient_raise</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">y2</span><span class="p">,</span> <span class="n">grid</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge_mode</span> <span class="o">==</span> <span class="s1">&#39;warn&#39;</span><span class="p">:</span>
            <span class="n">dfdx</span><span class="p">,</span> <span class="n">dfdy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gradient_warn</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">y2</span><span class="p">,</span> <span class="n">grid</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge_mode</span> <span class="o">==</span> <span class="s1">&#39;wrap&#39;</span><span class="p">:</span>
            <span class="n">dfdx</span><span class="p">,</span> <span class="n">dfdy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gradient_wrap</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">y2</span><span class="p">,</span> <span class="n">grid</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span> <span class="c1"># constant</span>
            <span class="n">dfdx</span><span class="p">,</span> <span class="n">dfdy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gradient_constant</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">y2</span><span class="p">,</span> <span class="n">grid</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Real</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">dfdx</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dfdy</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">grid</span><span class="p">:</span>
                <span class="n">dfdx</span> <span class="o">=</span> <span class="n">dfdx</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">x1</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
                <span class="n">dfdy</span> <span class="o">=</span> <span class="n">dfdy</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">x1</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">dfdx</span><span class="p">,</span> <span class="n">dfdy</span></div>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;galsim.LookupTable2D(x=</span><span class="si">%s</span><span class="s2">, y=</span><span class="si">%s</span><span class="s2">, f=[</span><span class="si">%s</span><span class="s2">,...,</span><span class="si">%s</span><span class="s2">], interpolant=</span><span class="si">%r</span><span class="s2">, edge_mode=</span><span class="si">%r</span><span class="s2">)&quot;</span><span class="o">%</span><span class="p">(</span>
            <span class="n">_str_array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">),</span> <span class="n">_str_array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">),</span>
            <span class="n">_str_array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">_str_array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">interpolant</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge_mode</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="s2">&quot;galsim.LookupTable2D(x=array(</span><span class="si">%r</span><span class="s2">), y=array(</span><span class="si">%r</span><span class="s2">), &quot;</span>
                <span class="s2">&quot;f=array(</span><span class="si">%r</span><span class="s2">), interpolant=</span><span class="si">%r</span><span class="s2">, edge_mode=</span><span class="si">%r</span><span class="s2">, constant=</span><span class="si">%r</span><span class="s2">)&quot;</span><span class="o">%</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">interpolant</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge_mode</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">constant</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span> <span class="ow">is</span> <span class="n">other</span><span class="p">:</span> <span class="k">return</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">LookupTable2D</span><span class="p">)</span> <span class="ow">and</span>
                <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span><span class="n">other</span><span class="o">.</span><span class="n">x</span><span class="p">)</span> <span class="ow">and</span>
                <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">,</span><span class="n">other</span><span class="o">.</span><span class="n">y</span><span class="p">)</span> <span class="ow">and</span>
                <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">,</span><span class="n">other</span><span class="o">.</span><span class="n">f</span><span class="p">)</span> <span class="ow">and</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">interpolant</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">interpolant</span> <span class="ow">and</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">edge_mode</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">edge_mode</span> <span class="ow">and</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">constant</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">constant</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">interpolant</span> <span class="o">==</span> <span class="s1">&#39;spline&#39;</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dfdx</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">dfdx</span><span class="p">)</span> <span class="ow">and</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dfdy</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">dfdy</span><span class="p">)</span> <span class="ow">and</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">d2fdxdy</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">d2fdxdy</span><span class="p">))</span>
            <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__eq__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_hash&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_hash</span> <span class="o">=</span> <span class="nb">hash</span><span class="p">((</span><span class="s2">&quot;galsim.LookupTable2D&quot;</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">ravel</span><span class="p">()),</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="o">.</span><span class="n">ravel</span><span class="p">()),</span>
                               <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="o">.</span><span class="n">ravel</span><span class="p">()),</span> <span class="bp">self</span><span class="o">.</span><span class="n">interpolant</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge_mode</span><span class="p">,</span>
                               <span class="bp">self</span><span class="o">.</span><span class="n">constant</span><span class="p">,</span>
                               <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dfdx</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dfdx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
                               <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dfdy</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dfdy</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
                               <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">d2fdxdy</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">d2fdxdy</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hash</span>

    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">d</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;_tab&#39;</span><span class="p">,</span><span class="kc">None</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">d</span>

    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span> <span class="o">=</span> <span class="n">d</span></div>


<div class="viewcode-block" id="_LookupTable2D"><a class="viewcode-back" href="../../table.html#galsim.utilities._LookupTable2D">[docs]</a><span class="k">def</span> <span class="nf">_LookupTable2D</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">interpolant</span><span class="p">,</span> <span class="n">edge_mode</span><span class="p">,</span> <span class="n">constant</span><span class="p">,</span>
                   <span class="n">dfdx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dfdy</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">d2fdxdy</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                   <span class="n">x0</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">y0</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">xperiod</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">yperiod</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Make a `LookupTable2D` but without using any of the sanity checks or array manipulation used</span>
<span class="sd">    in the normal initializer.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">LookupTable2D</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="n">LookupTable2D</span><span class="p">)</span>
    <span class="n">ret</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span>
    <span class="n">ret</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">y</span>
    <span class="n">ret</span><span class="o">.</span><span class="n">f</span> <span class="o">=</span> <span class="n">f</span>
    <span class="n">ret</span><span class="o">.</span><span class="n">interpolant</span> <span class="o">=</span> <span class="n">interpolant</span>
    <span class="n">ret</span><span class="o">.</span><span class="n">edge_mode</span> <span class="o">=</span> <span class="n">edge_mode</span>
    <span class="n">ret</span><span class="o">.</span><span class="n">constant</span> <span class="o">=</span> <span class="n">constant</span>
    <span class="n">ret</span><span class="o">.</span><span class="n">dfdx</span> <span class="o">=</span> <span class="n">dfdx</span>
    <span class="n">ret</span><span class="o">.</span><span class="n">dfdy</span> <span class="o">=</span> <span class="n">dfdy</span>
    <span class="n">ret</span><span class="o">.</span><span class="n">d2fdxdy</span> <span class="o">=</span> <span class="n">d2fdxdy</span>
    <span class="n">ret</span><span class="o">.</span><span class="n">x0</span> <span class="o">=</span> <span class="n">x0</span>
    <span class="n">ret</span><span class="o">.</span><span class="n">y0</span> <span class="o">=</span> <span class="n">y0</span>
    <span class="n">ret</span><span class="o">.</span><span class="n">xperiod</span> <span class="o">=</span> <span class="n">xperiod</span>
    <span class="n">ret</span><span class="o">.</span><span class="n">yperiod</span> <span class="o">=</span> <span class="n">yperiod</span>
    <span class="k">if</span> <span class="n">interpolant</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;nearest&#39;</span><span class="p">,</span> <span class="s1">&#39;linear&#39;</span><span class="p">,</span> <span class="s1">&#39;ceil&#39;</span><span class="p">,</span> <span class="s1">&#39;floor&#39;</span><span class="p">,</span> <span class="s1">&#39;spline&#39;</span><span class="p">):</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">_interp2d</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">_interp2d</span> <span class="o">=</span> <span class="n">convert_interpolant</span><span class="p">(</span><span class="n">interpolant</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ret</span></div>

<div class="viewcode-block" id="find_out_of_bounds_position"><a class="viewcode-back" href="../../misc.html#galsim.utilities.find_out_of_bounds_position">[docs]</a><span class="k">def</span> <span class="nf">find_out_of_bounds_position</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">bounds</span><span class="p">,</span> <span class="n">grid</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Given arrays of x and y values that are known to contain at least one</span>
<span class="sd">    position that is out-of-bounds of the given bounds instance, return one</span>
<span class="sd">    such PositionD.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        x:          Array of x values</span>
<span class="sd">        y:          Array of y values</span>
<span class="sd">        bounds:     `Bounds` instance</span>
<span class="sd">        grid:       Bool indicating whether to check the outer product of x and y</span>
<span class="sd">                    (grid=True), or each sequential pair of x and y (grid=False).</span>
<span class="sd">                    If the latter, then x and y should have the same shape.</span>

<span class="sd">    Returns:</span>
<span class="sd">        a `PositionD` from x and y that is out-of-bounds of bounds.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">grid</span><span class="p">:</span>
        <span class="c1"># It&#39;s enough to check corners for grid input</span>
        <span class="k">for</span> <span class="n">x_</span> <span class="ow">in</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">x</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">y_</span> <span class="ow">in</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">y</span><span class="p">)):</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">x_</span> <span class="o">&lt;</span> <span class="n">bounds</span><span class="o">.</span><span class="n">xmin</span> <span class="ow">or</span> <span class="n">x_</span> <span class="o">&gt;</span> <span class="n">bounds</span><span class="o">.</span><span class="n">xmax</span> <span class="ow">or</span>
                    <span class="n">y_</span> <span class="o">&lt;</span> <span class="n">bounds</span><span class="o">.</span><span class="n">ymin</span> <span class="ow">or</span> <span class="n">y_</span> <span class="o">&gt;</span> <span class="n">bounds</span><span class="o">.</span><span class="n">ymax</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">_PositionD</span><span class="p">(</span><span class="n">x_</span><span class="p">,</span> <span class="n">y_</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Faster to check all points than to iterate through them one-by-one?</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">x</span> <span class="o">&lt;</span> <span class="n">bounds</span><span class="o">.</span><span class="n">xmin</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;</span> <span class="n">bounds</span><span class="o">.</span><span class="n">xmax</span><span class="p">)</span> <span class="o">|</span>
                     <span class="p">(</span><span class="n">y</span> <span class="o">&lt;</span> <span class="n">bounds</span><span class="o">.</span><span class="n">ymin</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">y</span> <span class="o">&gt;</span> <span class="n">bounds</span><span class="o">.</span><span class="n">ymax</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">w</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_PositionD</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">w</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]],</span> <span class="n">y</span><span class="p">[</span><span class="n">w</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]])</span>
    <span class="k">raise</span> <span class="n">GalSimError</span><span class="p">(</span><span class="s2">&quot;No out-of-bounds position&quot;</span><span class="p">)</span></div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, GalSim-developers.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>