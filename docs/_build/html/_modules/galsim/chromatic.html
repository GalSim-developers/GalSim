

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>galsim.chromatic &mdash; GalSim 2.3.0-rc.2 documentation</title>
  

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home"> GalSim
          

          
          </a>

          
            
            
              <div class="version">
                2.3
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../overview.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../install.html">Installation Instructions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tutorials.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../image.html">Images and Related Concepts</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../sb.html">Surface Brightness Profiles</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../chromatic.html">Wavelength-dependent Profiles</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../units.html">Units</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../wcs.html">World Coordinate Systems</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../random.html">Noise and Random Values</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../wl.html">Weak Lensing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../photon.html">Photon Shooting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../utilities.html">Helper Functions and Classes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../errors.html">Errors and Warnings</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../config.html">The Config Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../hsm.html">The HSM Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../des.html">The DES Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../roman.html">The Roman Space Telescope Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../shared.html">Shared Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../history.html">Revision History</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">GalSim</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
      <li>galsim.chromatic</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for galsim.chromatic</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright (c) 2012-2021 by the GalSim developers team on GitHub</span>
<span class="c1"># https://github.com/GalSim-developers</span>
<span class="c1">#</span>
<span class="c1"># This file is part of GalSim: The modular galaxy image simulation toolkit.</span>
<span class="c1"># https://github.com/GalSim-developers/GalSim</span>
<span class="c1">#</span>
<span class="c1"># GalSim is free software: redistribution and use in source and binary forms,</span>
<span class="c1"># with or without modification, are permitted provided that the following</span>
<span class="c1"># conditions are met:</span>
<span class="c1">#</span>
<span class="c1"># 1. Redistributions of source code must retain the above copyright notice, this</span>
<span class="c1">#    list of conditions, and the disclaimer given in the accompanying LICENSE</span>
<span class="c1">#    file.</span>
<span class="c1"># 2. Redistributions in binary form must reproduce the above copyright notice,</span>
<span class="c1">#    this list of conditions, and the disclaimer given in the documentation</span>
<span class="c1">#    and/or other materials provided with the distribution.</span>
<span class="c1">#</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">division</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">.gsobject</span> <span class="kn">import</span> <span class="n">GSObject</span>
<span class="kn">from</span> <span class="nn">.sed</span> <span class="kn">import</span> <span class="n">SED</span>
<span class="kn">from</span> <span class="nn">.bandpass</span> <span class="kn">import</span> <span class="n">Bandpass</span>
<span class="kn">from</span> <span class="nn">.position</span> <span class="kn">import</span> <span class="n">Position</span><span class="p">,</span> <span class="n">PositionD</span><span class="p">,</span> <span class="n">_PositionD</span>
<span class="kn">from</span> <span class="nn">.utilities</span> <span class="kn">import</span> <span class="n">lazy_property</span><span class="p">,</span> <span class="n">doc_inherit</span>
<span class="kn">from</span> <span class="nn">.gsparams</span> <span class="kn">import</span> <span class="n">GSParams</span>
<span class="kn">from</span> <span class="nn">.phase_psf</span> <span class="kn">import</span> <span class="n">OpticalPSF</span>
<span class="kn">from</span> <span class="nn">.table</span> <span class="kn">import</span> <span class="n">_LookupTable</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">utilities</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">integ</span>
<span class="kn">from</span> <span class="nn">.errors</span> <span class="kn">import</span> <span class="n">GalSimError</span><span class="p">,</span> <span class="n">GalSimRangeError</span><span class="p">,</span> <span class="n">GalSimSEDError</span><span class="p">,</span> <span class="n">GalSimValueError</span>
<span class="kn">from</span> <span class="nn">.errors</span> <span class="kn">import</span> <span class="n">GalSimIncompatibleValuesError</span><span class="p">,</span> <span class="n">GalSimNotImplementedError</span><span class="p">,</span> <span class="n">galsim_warn</span>

<div class="viewcode-block" id="ChromaticObject"><a class="viewcode-back" href="../../chromaticobject.html#galsim.ChromaticObject">[docs]</a><span class="k">class</span> <span class="nc">ChromaticObject</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Base class for defining wavelength-dependent objects.</span>

<span class="sd">    This class primarily serves as the base class for chromatic subclasses.  See the docstrings for</span>
<span class="sd">    subclasses for more details.</span>

<span class="sd">    A ChromaticObject can be instantiated directly from an existing `GSObject`.  In this case, the</span>
<span class="sd">    newly created ChromaticObject will act in nearly the same way as the original `GSObject` works,</span>
<span class="sd">    except that it has access to the ChromaticObject transformation methods described below (e.g.,</span>
<span class="sd">    expand(), dilate(), shift(), withFlux(), ...)  These can all take functions as arguments to</span>
<span class="sd">    describe wavelength-dependent transformations.  E.g.,::</span>

<span class="sd">        &gt;&gt;&gt; gsobj = galsim.Gaussian(fwhm=1)</span>
<span class="sd">        &gt;&gt;&gt; chrom_obj = galsim.ChromaticObject(gsobj).dilate(lambda wave: (wave/500.)**(-0.2))</span>

<span class="sd">    In this and similar cases, the argument to the transformation method should be a python callable</span>
<span class="sd">    that accepts wavelength in nanometers and returns whatever type the transformation method</span>
<span class="sd">    normally accepts (so an int or float above).</span>

<span class="sd">    One caveat to creating a ChromaticObject directly from a `GSObject` like this is that even</span>
<span class="sd">    though the source `GSObject` instance has flux units in photons/s/cm^2, the newly formed</span>
<span class="sd">    ChromaticObject will be interpreted as dimensionless, i.e., it will have a dimensionless `SED`</span>
<span class="sd">    (and have its .dimensionless attribute set to True).  See below for more discussion about the</span>
<span class="sd">    dimensions of ChromaticObjects.</span>

<span class="sd">    Another way to instantiate a ChromaticObject from a `GSObject` is to multiply by an `SED`.</span>
<span class="sd">    This can be useful to consistently generate the same galaxy observed through different filters,</span>
<span class="sd">    or, with `ChromaticSum`, to construct multi-component galaxies, each component with a different</span>
<span class="sd">    `SED`.  For example, a bulge+disk galaxy could be constructed::</span>

<span class="sd">        &gt;&gt;&gt; bulge_SED = user_function_to_get_bulge_spectrum()</span>
<span class="sd">        &gt;&gt;&gt; disk_SED = user_function_to_get_disk_spectrum()</span>
<span class="sd">        &gt;&gt;&gt; bulge_mono = galsim.DeVaucouleurs(half_light_radius=1.0)</span>
<span class="sd">        &gt;&gt;&gt; disk_mono = galsim.Exponential(half_light_radius=2.0)</span>
<span class="sd">        &gt;&gt;&gt; bulge = bulge_mono * bulge_SED</span>
<span class="sd">        &gt;&gt;&gt; disk = disk_mono * disk_SED</span>
<span class="sd">        &gt;&gt;&gt; gal = bulge + disk</span>

<span class="sd">    The `SED` instances above describe the flux density in photons/nm/cm^2/s of an object, possibly</span>
<span class="sd">    normalized with either the `SED.withFlux` or `SED.withMagnitude` methods (see their docstrings</span>
<span class="sd">    for details about these and other normalization options).  Note that for dimensional</span>
<span class="sd">    consistency, in this case, the ``flux`` attribute of the multiplied `GSObject` is interpreted</span>
<span class="sd">    as being dimensionless instead of in its normal units of [photons/s/cm^2].  The photons/s/cm^2</span>
<span class="sd">    units are (optionally) carried by the `SED` instead, or even left out entirely if the `SED` is</span>
<span class="sd">    dimensionless itself (see discussion on ChromaticObject dimensions below).  The `GSObject`</span>
<span class="sd">    ``flux`` attribute *does* still contribute to the ChromaticObject normalization, though.</span>

<span class="sd">    For example, the following are equivalent::</span>

<span class="sd">        &gt;&gt;&gt; chrom_obj = (sed * 3.0) * gsobj</span>
<span class="sd">        &gt;&gt;&gt; chrom_obj2 = sed * (gsobj * 3.0)</span>

<span class="sd">    Subclasses that instantiate a ChromaticObject directly, such as `ChromaticAtmosphere`, also</span>
<span class="sd">    exist.  Even in this case, however, the underlying implementation always eventually wraps one</span>
<span class="sd">    or more `GSObject` instances.</span>

<span class="sd">    **Dimensions**:</span>

<span class="sd">    ChromaticObjects can generally be sorted into two distinct types: those that represent galaxies</span>
<span class="sd">    or stars and have dimensions of [photons/wavelength-interval/area/time/solid-angle], and those</span>
<span class="sd">    that represent other types of wavelength dependence besides flux, like chromatic PSFs (these</span>
<span class="sd">    have dimensions of [1/solid-angle]).  The former category of ChromaticObjects will have their</span>
<span class="sd">    ``.spectral`` attribute set to True, while the latter category of ChromaticObjects will have</span>
<span class="sd">    their ``.dimensionless`` attribute set to True.  These two classes of ChromaticObjects have</span>
<span class="sd">    different restrictions associated with them.  For example, only spectral ChromaticObjects can</span>
<span class="sd">    be drawn using `drawImage`, only ChromaticObjects of the same type can be added together, and</span>
<span class="sd">    at most one spectral ChromaticObject can be part of a `ChromaticConvolution`.</span>

<span class="sd">    Multiplying a dimensionless ChromaticObject a spectral `SED` produces a spectral ChromaticObject</span>
<span class="sd">    (though note that the new object&#39;s `SED` may not be equal to the SED being multiplied by since</span>
<span class="sd">    the original ChromaticObject may not have had unit normalization.)</span>

<span class="sd">    **Methods**:</span>

<span class="sd">    `evaluateAtWavelength` returns the monochromatic surface brightness profile (as a `GSObject`)</span>
<span class="sd">    at a given wavelength (in nanometers).</span>

<span class="sd">    `interpolate` can be used for non-separable ChromaticObjects to expedite the image rendering</span>
<span class="sd">    process.  See the docstring of that method for more details and discussion of when this is a</span>
<span class="sd">    useful tool (and the interplay between interpolation, object transformations, and convolutions).</span>

<span class="sd">    Also, ChromaticObject has most of the same methods as `GSObject` with the following exceptions:</span>

<span class="sd">    The `GSObject` access methods (e.g. `GSObject.xValue`, `GSObject.maxk`, etc.) are not available.</span>
<span class="sd">    Instead, you would need to evaluate the profile at a particular wavelength and access what you</span>
<span class="sd">    want from that.</span>

<span class="sd">    The `withFlux`, `withFluxDensity`, and `withMagnitude` methods will return a new chromatic</span>
<span class="sd">    object with the appropriate spatially integrated flux, flux density, or magnitude.</span>

<span class="sd">    The `drawImage` method draws the object as observed through a particular bandpass, so the</span>
<span class="sd">    arguments are somewhat different.  See the docstring of `drawImage` for more details.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># ChromaticObjects should adhere to the following invariants:</span>
    <span class="c1"># - Objects should define the attributes/properties:</span>
    <span class="c1">#   * .SED, .separable, .wave_list, .interpolated, .deinterpolated, .spectral, .dimensionless</span>
    <span class="c1"># - obj.evaluateAtWavelength(lam).drawImage().array.sum() == obj.SED(lam)</span>
    <span class="c1">#   == obj.evaluateAtWavelength(lam).flux</span>
    <span class="c1"># - if obj.spectral:</span>
    <span class="c1">#       obj.SED.calculateFlux(bandpass) == obj.calculateFlux(bandpass)</span>
    <span class="c1">#       == obj.drawImage(bandpass).array.sum()</span>
    <span class="c1"># - .separable is a boolean indicating whether or not the profile can be factored into a</span>
    <span class="c1">#   spatial part and a spectral part.</span>
    <span class="c1"># - .wave_list is a numpy array indicating wavelengths of particular interest, for instance, the</span>
    <span class="c1">#   wavelengths at which the SED is explicitly defined via a LookupTable.  These are the</span>
    <span class="c1">#   wavelengths that will be used (in addition to those in bandpass.wave_list) when drawing an</span>
    <span class="c1">#   image of the chromatic profile.</span>
    <span class="c1"># - .interpolated is a boolean indicating whether any part of the object hierarchy includes an</span>
    <span class="c1">#   InterpolatedChromaticObject.</span>
    <span class="c1"># - .spectral indicates obj.SED.spectral</span>
    <span class="c1"># - .dimensionless indicates obj.SED.dimensionless</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_obj</span> <span class="o">=</span> <span class="n">obj</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">GSObject</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">SED</span> <span class="o">=</span> <span class="n">SED</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">flux</span><span class="p">,</span> <span class="s1">&#39;nm&#39;</span><span class="p">,</span> <span class="s1">&#39;1&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">ChromaticObject</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">SED</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">SED</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Can only directly instantiate ChromaticObject with a GSObject &quot;</span>
                            <span class="s2">&quot;or ChromaticObject argument.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">separable</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">separable</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">interpolated</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">interpolated</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">wave_list</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">wave_list</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">deinterpolated</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">deinterpolated</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">gsparams</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The `GSParams` for this object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_obj</span><span class="o">.</span><span class="n">gsparams</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">redshift</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The redshift of the object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">SED</span><span class="o">.</span><span class="n">redshift</span>

<div class="viewcode-block" id="ChromaticObject.withGSParams"><a class="viewcode-back" href="../../chromaticobject.html#galsim.ChromaticObject.withGSParams">[docs]</a>    <span class="k">def</span> <span class="nf">withGSParams</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gsparams</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create a version of the current object with the given gsparams</span>

<span class="sd">        Note: if this object wraps other objects (e.g. Convolution, Sum, Transformation, etc.)</span>
<span class="sd">        those component objects will also have their gsparams updated to the new value.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">gsparams</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">gsparams</span><span class="p">:</span> <span class="k">return</span> <span class="bp">self</span>
        <span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">copy</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">_obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_obj</span><span class="o">.</span><span class="n">withGSParams</span><span class="p">(</span><span class="n">gsparams</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ret</span></div>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_get_multiplier</span><span class="p">(</span><span class="n">sed</span><span class="p">,</span> <span class="n">bandpass</span><span class="p">,</span> <span class="n">wave_list</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Cached integral of product of sed and bandpass.&quot;&quot;&quot;</span>
        <span class="n">wave_list</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">wave_list</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">wave_list</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">bp</span> <span class="o">=</span> <span class="n">_LookupTable</span><span class="p">(</span><span class="n">wave_list</span><span class="p">,</span> <span class="n">bandpass</span><span class="p">(</span><span class="n">wave_list</span><span class="p">),</span> <span class="s1">&#39;linear&#39;</span><span class="p">)</span>
            <span class="n">multiplier</span> <span class="o">=</span> <span class="n">bp</span><span class="o">.</span><span class="n">integrate_product</span><span class="p">(</span><span class="n">sed</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">multiplier</span> <span class="o">=</span> <span class="n">integ</span><span class="o">.</span><span class="n">int1d</span><span class="p">(</span><span class="k">lambda</span> <span class="n">w</span><span class="p">:</span> <span class="n">sed</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="o">*</span> <span class="n">bandpass</span><span class="p">(</span><span class="n">w</span><span class="p">),</span>
                                     <span class="n">bandpass</span><span class="o">.</span><span class="n">blue_limit</span><span class="p">,</span> <span class="n">bandpass</span><span class="o">.</span><span class="n">red_limit</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">multiplier</span>

<div class="viewcode-block" id="ChromaticObject.resize_multiplier_cache"><a class="viewcode-back" href="../../chromaticobject.html#galsim.ChromaticObject.resize_multiplier_cache">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">resize_multiplier_cache</span><span class="p">(</span><span class="n">maxsize</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Resize the cache (default size=10) containing the integral over the product of an `SED`</span>
<span class="sd">        and a `Bandpass`, which is used by `ChromaticObject.drawImage`.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            maxsize:    The new number of products to cache.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ChromaticObject</span><span class="o">.</span><span class="n">_multiplier_cache</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">maxsize</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_fiducial_profile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bandpass</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a fiducial achromatic profile of a chromatic object that can be used to estimate</span>
<span class="sd">        default output image characteristics, or in the case of separable profiles, can be scaled to</span>
<span class="sd">        give the monochromatic profile at any wavelength or the wavelength-integrated profile.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">bpwave</span> <span class="o">=</span> <span class="n">bandpass</span><span class="o">.</span><span class="n">effective_wavelength</span>
        <span class="n">bpwave</span><span class="p">,</span> <span class="n">prof0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_approxWavelength</span><span class="p">(</span><span class="n">bpwave</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">prof0</span><span class="o">.</span><span class="n">flux</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">bpwave</span><span class="p">,</span> <span class="n">prof0</span>

        <span class="n">candidate_waves</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
            <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">bandpass</span><span class="o">.</span><span class="n">blue_limit</span> <span class="o">+</span> <span class="n">bandpass</span><span class="o">.</span><span class="n">red_limit</span><span class="p">)]),</span>
             <span class="n">bandpass</span><span class="o">.</span><span class="n">wave_list</span><span class="p">,</span>
             <span class="bp">self</span><span class="o">.</span><span class="n">wave_list</span><span class="p">])</span>
        <span class="c1"># Prioritize wavelengths near the bandpass effective wavelength.</span>
        <span class="n">candidate_waves</span> <span class="o">=</span> <span class="n">candidate_waves</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">candidate_waves</span> <span class="o">-</span> <span class="n">bpwave</span><span class="p">))]</span>
        <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">candidate_waves</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">bandpass</span><span class="o">.</span><span class="n">blue_limit</span> <span class="o">&lt;=</span> <span class="n">w</span> <span class="o">&lt;=</span> <span class="n">bandpass</span><span class="o">.</span><span class="n">red_limit</span><span class="p">:</span>
                <span class="n">prof0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluateAtWavelength</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">prof0</span><span class="o">.</span><span class="n">flux</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">w</span><span class="p">,</span> <span class="n">prof0</span>

        <span class="k">raise</span> <span class="n">GalSimError</span><span class="p">(</span><span class="s2">&quot;Could not locate fiducial wavelength where SED * Bandpass is nonzero.&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_approxWavelength</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">wave</span><span class="p">):</span>
        <span class="c1"># If a class doesn&#39;t have any more appropriate choice, just use evaluateAtWavelength</span>
        <span class="c1"># InterpolatedChromaticObject has a better choice when phot=True, so overrides this.</span>
        <span class="k">return</span> <span class="n">wave</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluateAtWavelength</span><span class="p">(</span><span class="n">wave</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span> <span class="ow">is</span> <span class="n">other</span> <span class="ow">or</span>
                <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">ChromaticObject</span><span class="p">)</span> <span class="ow">and</span>
                 <span class="nb">hasattr</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="s1">&#39;_obj&#39;</span><span class="p">)</span> <span class="ow">and</span>  <span class="c1"># not all ChromaticObjects have an _obj attribute.</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">_obj</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_obj</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span> <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__eq__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="nb">hash</span><span class="p">((</span><span class="s2">&quot;galsim.ChromaticObject&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_obj</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;galsim.ChromaticObject(</span><span class="si">%r</span><span class="s1">)&#39;</span><span class="o">%</span><span class="bp">self</span><span class="o">.</span><span class="n">_obj</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;galsim.ChromaticObject(</span><span class="si">%s</span><span class="s1">)&#39;</span><span class="o">%</span><span class="bp">self</span><span class="o">.</span><span class="n">_obj</span>

<div class="viewcode-block" id="ChromaticObject.interpolate"><a class="viewcode-back" href="../../chromaticobject.html#galsim.ChromaticObject.interpolate">[docs]</a>    <span class="k">def</span> <span class="nf">interpolate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">waves</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Build interpolation images to (possibly) speed up subsequent `drawImage` calls.</span>

<span class="sd">        This method is used as a pre-processing step that can expedite image rendering using objects</span>
<span class="sd">        that have to be built up as sums of `GSObject` instances with different parameters at each</span>
<span class="sd">        wavelength, by interpolating between images at each wavelength instead of making a more</span>
<span class="sd">        costly instantiation of the relevant `GSObject` at each value of wavelength at which the</span>
<span class="sd">        bandpass is defined.</span>

<span class="sd">        This routine does a costly initialization process to build up a grid of `Image` instances to</span>
<span class="sd">        be used for the interpolation later on.  However, the object can get reused with different</span>
<span class="sd">        bandpasses, so there should not be any need to make many versions of this object, and there</span>
<span class="sd">        is a significant savings each time it is drawn into an image.</span>

<span class="sd">        As a general rule of thumb, chromatic objects that are separable do not benefit from this</span>
<span class="sd">        particular optimization, whereas those that involve making `GSObject` instances with</span>
<span class="sd">        wavelength-dependent keywords or transformations do benefit from it.</span>

<span class="sd">        Note that the interpolation scheme is simple linear interpolation in wavelength, and no</span>
<span class="sd">        extrapolation beyond the originally-provided range of wavelengths is permitted.  However,</span>
<span class="sd">        the overall flux at each wavelength will use the exact `SED` at that wavelength to give</span>
<span class="sd">        more accurate final flux values.  You can disable this feature by setting</span>
<span class="sd">        ``use_exact_SED = False``.</span>

<span class="sd">        The speedup involved in using interpolation depends in part on the bandpass used for</span>
<span class="sd">        rendering (since that determines how many full profile evaluations are involved in rendering</span>
<span class="sd">        the image).  However, for `ChromaticAtmosphere` with simple profiles like `Kolmogorov`, the</span>
<span class="sd">        speedup in some simple example cases is roughly a factor of three, whereas for more</span>
<span class="sd">        expensive to render profiles like the `ChromaticOpticalPSF`, the speedup is more typically a</span>
<span class="sd">        factor of 10-50.</span>

<span class="sd">        Achromatic transformations can be applied either before or after setting up interpolation,</span>
<span class="sd">        with the best option depending on the application.  For example, when rendering many times</span>
<span class="sd">        with the same achromatic transformation applied, it is typically advantageous to apply the</span>
<span class="sd">        transformation before setting up the interpolation.  But there is no value in this when</span>
<span class="sd">        applying different achromatic transformation to each object.  Chromatic transformations</span>
<span class="sd">        should be applied before setting up interpolation; attempts to render images of</span>
<span class="sd">        `ChromaticObject` instances with interpolation followed by a chromatic transformation will</span>
<span class="sd">        result in the interpolation being unset and the full calculation being done.</span>

<span class="sd">        Because of the clever way that the `ChromaticConvolution` routine works, convolutions of</span>
<span class="sd">        separable chromatic objects with non-separable ones that use interpolation will still</span>
<span class="sd">        benefit from these optimizations.  For example, a non-separable chromatic PSF that uses</span>
<span class="sd">        interpolation, when convolved with a sum of two separable galaxy components each with their</span>
<span class="sd">        own `SED`, will be able to take advantage of this optimization.  In contrast, when</span>
<span class="sd">        convolving two non-separable profiles that already have interpolation set up, there is no</span>
<span class="sd">        way to take advantage of that interpolation optimization, so it will be ignored and the</span>
<span class="sd">        full calculation will be done.  However, interpolation can be set up for the convolution of</span>
<span class="sd">        two non-separable profiles, after the convolution step.  This could be beneficial for</span>
<span class="sd">        example when convolving a chromatic optical PSF and chromatic atmosphere, before convolving</span>
<span class="sd">        with multiple galaxy profiles.</span>

<span class="sd">        For use cases requiring a high level of precision, we recommend a comparison between the</span>
<span class="sd">        interpolated and the more accurate calculation for at least one case, to ensure that the</span>
<span class="sd">        required precision has been reached.</span>

<span class="sd">        The input parameter ``waves`` determines the input grid on which images are precomputed.  It</span>
<span class="sd">        is difficult to give completely general guidance as to how many wavelengths to choose or how</span>
<span class="sd">        they should be spaced; some experimentation compared with the exact calculation is warranted</span>
<span class="sd">        for each particular application.  The best choice of settings might depend on how strongly</span>
<span class="sd">        the parameters of the object depend on wavelength.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            waves:              The list, tuple, or NumPy array of wavelengths to be used when</span>
<span class="sd">                                building up the grid of images for interpolation.  The wavelengths</span>
<span class="sd">                                should be given in nanometers, and they should span the full range</span>
<span class="sd">                                of wavelengths covered by any bandpass to be used for drawing an</span>
<span class="sd">                                `Image` (i.e., this class will not extrapolate beyond the given</span>
<span class="sd">                                range of wavelengths).  They can be spaced any way the user likes,</span>
<span class="sd">                                not necessarily linearly, though interpolation will be linear in</span>
<span class="sd">                                wavelength between the specified wavelengths.</span>
<span class="sd">            oversample_fac:     Factor by which to oversample the stored profiles compared to the</span>
<span class="sd">                                default, which is to sample them at the Nyquist frequency for</span>
<span class="sd">                                whichever wavelength has the highest Nyquist frequency.</span>
<span class="sd">                                ``oversample_fac``&gt;1 results in higher accuracy but costlier</span>
<span class="sd">                                pre-computations (more memory and time). [default: 1]</span>
<span class="sd">            use_exact_SED:      If true, then rescale the interpolated image for a given wavelength</span>
<span class="sd">                                by the ratio of the exact `SED` at that wavelength to the linearly</span>
<span class="sd">                                interpolated `SED` at that wavelength.  Thus, the flux of the</span>
<span class="sd">                                interpolated object should be correct, at the possible expense of</span>
<span class="sd">                                other features. [default: True]</span>

<span class="sd">        Returns:</span>
<span class="sd">            the version of the Chromatic object that uses interpolation</span>
<span class="sd">            (This will be an `InterpolatedChromaticObject` instance.)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">InterpolatedChromaticObject</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">waves</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">spectral</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Boolean indicating if the `ChromaticObject` has units compatible with a spectral density.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">SED</span><span class="o">.</span><span class="n">spectral</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dimensionless</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Boolean indicating if the `ChromaticObject` is dimensionless.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">SED</span><span class="o">.</span><span class="n">dimensionless</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_get_integrator</span><span class="p">(</span><span class="n">integrator</span><span class="p">,</span> <span class="n">wave_list</span><span class="p">):</span>
        <span class="c1"># Decide on integrator.  If the user passed one of the integrators from galsim.integ, that&#39;s</span>
        <span class="c1"># fine.  Otherwise we decide based on the adopted integration rule and the presence/absence</span>
        <span class="c1"># of `wave_list`.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">integrator</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">integrator</span> <span class="o">==</span> <span class="s1">&#39;quadratic&#39;</span><span class="p">:</span>
                <span class="n">rule</span> <span class="o">=</span> <span class="n">integ</span><span class="o">.</span><span class="n">quadRule</span>
            <span class="k">elif</span> <span class="n">integrator</span> <span class="o">==</span> <span class="s1">&#39;trapezoidal&#39;</span><span class="p">:</span>
                <span class="n">rule</span> <span class="o">=</span> <span class="n">integ</span><span class="o">.</span><span class="n">trapzRule</span>
            <span class="k">elif</span> <span class="n">integrator</span> <span class="o">==</span> <span class="s1">&#39;midpoint&#39;</span><span class="p">:</span>
                <span class="n">rule</span> <span class="o">=</span> <span class="n">integ</span><span class="o">.</span><span class="n">midptRule</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">GalSimValueError</span><span class="p">(</span><span class="s2">&quot;Unrecognized integration rule&quot;</span><span class="p">,</span> <span class="n">integrator</span><span class="p">,</span>
                                       <span class="p">(</span><span class="s1">&#39;trapezoidal&#39;</span><span class="p">,</span> <span class="s1">&#39;midpoint&#39;</span><span class="p">,</span> <span class="s1">&#39;quadratic&#39;</span><span class="p">))</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">wave_list</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">integrator</span> <span class="o">=</span> <span class="n">integ</span><span class="o">.</span><span class="n">SampleIntegrator</span><span class="p">(</span><span class="n">rule</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">integrator</span> <span class="o">=</span> <span class="n">integ</span><span class="o">.</span><span class="n">ContinuousIntegrator</span><span class="p">(</span><span class="n">rule</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">integrator</span><span class="p">,</span> <span class="n">integ</span><span class="o">.</span><span class="n">ImageIntegrator</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Invalid type passed in for integrator!&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">integrator</span>

<div class="viewcode-block" id="ChromaticObject.drawImage"><a class="viewcode-back" href="../../chromaticobject.html#galsim.ChromaticObject.drawImage">[docs]</a>    <span class="k">def</span> <span class="nf">drawImage</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bandpass</span><span class="p">,</span> <span class="n">image</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">integrator</span><span class="o">=</span><span class="s1">&#39;quadratic&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Base implementation for drawing an image of a `ChromaticObject`.</span>

<span class="sd">        Some subclasses may choose to override this for specific efficiency gains.  For instance,</span>
<span class="sd">        most GalSim use cases will probably finish with a convolution, in which case</span>
<span class="sd">        `ChromaticConvolution.drawImage` will be used.</span>

<span class="sd">        The task of drawImage() in a chromatic context is to integrate a chromatic surface</span>
<span class="sd">        brightness profile multiplied by the throughput of ``bandpass``, over the wavelength</span>
<span class="sd">        interval indicated by ``bandpass``.</span>

<span class="sd">        Several integrators are available in galsim.integ to do this integration when using the</span>
<span class="sd">        first method (non-interpolated integration).  By default, `galsim.integ.SampleIntegrator`</span>
<span class="sd">        will be used if either ``bandpass.wave_list`` or ``self.wave_list`` have len() &gt; 0.</span>

<span class="sd">        If lengths of both are zero, which may happen if both the bandpass throughput and the `SED`</span>
<span class="sd">        associated with ``self`` are analytic python functions for example, then</span>
<span class="sd">        `galsim.integ.ContinuousIntegrator` will be used instead.  This latter case by default will</span>
<span class="sd">        evaluate the integrand at 250 equally-spaced wavelengths between ``bandpass.blue_limit``</span>
<span class="sd">        and ``bandpass.red_limit``.</span>

<span class="sd">        By default, the above two integrators will use the ``rule`` `galsim.integ.quadRule`</span>
<span class="sd">        for integration.  The midpoint rule for integration can be specified instead by passing an</span>
<span class="sd">        integrator that has been initialized with the ``rule`` set to `galsim.integ.midptRule`.</span>
<span class="sd">        When creating a `ContinuousIntegrator`, the number of samples ``N`` is also an argument.</span>
<span class="sd">        For example::</span>

<span class="sd">            &gt;&gt;&gt; integrator = galsim.integ.ContinuousIntegrator(rule=galsim.integ.midptRule, N=100)</span>
<span class="sd">            &gt;&gt;&gt; image = chromatic_obj.drawImage(bandpass, integrator=integrator)</span>

<span class="sd">        Finally, this method uses a cache to avoid recomputing the integral over the product of</span>
<span class="sd">        the bandpass and object `SED` when possible (i.e., for separable profiles).  Because the</span>
<span class="sd">        cache size is finite, users may find that it is more efficient when drawing many images</span>
<span class="sd">        to group images using the same SEDs and bandpasses together in order to hit the cache more</span>
<span class="sd">        often.  The default cache size is 10, but may be resized using the</span>
<span class="sd">        `ChromaticObject.resize_multiplier_cache` method.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            bandpass:       A `Bandpass` object representing the filter against which to</span>
<span class="sd">                            integrate.</span>
<span class="sd">            image:          Optionally, the Image to draw onto.  (See `GSObject.drawImage`</span>
<span class="sd">                            for details.)  [default: None]</span>
<span class="sd">            integrator:     When doing the exact evaluation of the profile, this argument should</span>
<span class="sd">                            be one of the image integrators from galsim.integ, or a string</span>
<span class="sd">                            &#39;trapezoidal&#39;, &#39;midpoint&#39;, or &#39;quadratic&#39;, in which case the routine</span>
<span class="sd">                            will use a `SampleIntegrator` or `ContinuousIntegrator` depending on</span>
<span class="sd">                            whether or not the object has a ``wave_list``.  [default: &#39;quadratic&#39;,</span>
<span class="sd">                            which will try to select an appropriate integrator using the</span>
<span class="sd">                            quadratic integration rule automatically.]</span>
<span class="sd">            **kwargs:       For all other kwarg options, see `GSObject.drawImage`</span>

<span class="sd">        Returns:</span>
<span class="sd">            the drawn `Image`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.photon_array</span> <span class="kn">import</span> <span class="n">WavelengthSampler</span>

        <span class="c1"># Store the last bandpass used and any extra kwargs.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_last_bp</span> <span class="o">=</span> <span class="n">bandpass</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">SED</span><span class="o">.</span><span class="n">dimensionless</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">GalSimSEDError</span><span class="p">(</span><span class="s2">&quot;Can only draw ChromaticObjects with spectral SEDs.&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">SED</span><span class="p">)</span>

        <span class="c1"># setup output image using fiducial profile</span>
        <span class="n">wave0</span><span class="p">,</span> <span class="n">prof0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fiducial_profile</span><span class="p">(</span><span class="n">bandpass</span><span class="p">)</span>
        <span class="n">image</span> <span class="o">=</span> <span class="n">prof0</span><span class="o">.</span><span class="n">drawImage</span><span class="p">(</span><span class="n">image</span><span class="o">=</span><span class="n">image</span><span class="p">,</span> <span class="n">setup_only</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">_remove_setup_kwargs</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># determine combined self.wave_list and bandpass.wave_list</span>
        <span class="n">wave_list</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">utilities</span><span class="o">.</span><span class="n">combine_wave_list</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bandpass</span><span class="p">)</span>

        <span class="c1"># If there are photon ops, they&#39;ll probably need valid wavelengths, so add</span>
        <span class="c1"># WavelengthSampler as the first op in the list.</span>
        <span class="k">if</span> <span class="s1">&#39;photon_ops&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">wave_sampler</span> <span class="o">=</span> <span class="n">WavelengthSampler</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">SED</span><span class="p">,</span> <span class="n">bandpass</span><span class="p">)</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;photon_ops&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">wave_sampler</span><span class="p">]</span> <span class="o">+</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;photon_ops&#39;</span><span class="p">]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">separable</span><span class="p">:</span>
            <span class="n">multiplier</span> <span class="o">=</span> <span class="n">ChromaticObject</span><span class="o">.</span><span class="n">_multiplier_cache</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">SED</span><span class="p">,</span> <span class="n">bandpass</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">wave_list</span><span class="p">))</span>
            <span class="n">prof0</span> <span class="o">*=</span> <span class="n">multiplier</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">SED</span><span class="p">(</span><span class="n">wave0</span><span class="p">)</span>
            <span class="n">image</span> <span class="o">=</span> <span class="n">prof0</span><span class="o">.</span><span class="n">drawImage</span><span class="p">(</span><span class="n">image</span><span class="o">=</span><span class="n">image</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">image</span>

        <span class="n">integrator</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_integrator</span><span class="p">(</span><span class="n">integrator</span><span class="p">,</span> <span class="n">wave_list</span><span class="p">)</span>

        <span class="c1"># merge self.wave_list into bandpass.wave_list if using a sampling integrator</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">integrator</span><span class="p">,</span> <span class="n">integ</span><span class="o">.</span><span class="n">SampleIntegrator</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">wave_list</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">GalSimIncompatibleValuesError</span><span class="p">(</span>
                    <span class="s2">&quot;Cannot use SampleIntegrator when Bandpass and SED are both analytic.&quot;</span><span class="p">,</span>
                    <span class="n">integrator</span><span class="o">=</span><span class="n">integrator</span><span class="p">,</span> <span class="n">bandpass</span><span class="o">=</span><span class="n">bandpass</span><span class="p">,</span> <span class="n">sed</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">SED</span><span class="p">)</span>
            <span class="n">bandpass</span> <span class="o">=</span> <span class="n">Bandpass</span><span class="p">(</span><span class="n">_LookupTable</span><span class="p">(</span><span class="n">wave_list</span><span class="p">,</span> <span class="n">bandpass</span><span class="p">(</span><span class="n">wave_list</span><span class="p">),</span> <span class="s1">&#39;linear&#39;</span><span class="p">),</span> <span class="s1">&#39;nm&#39;</span><span class="p">)</span>

        <span class="n">add_to_image</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;add_to_image&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="n">integral</span> <span class="o">=</span> <span class="n">integrator</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">evaluateAtWavelength</span><span class="p">,</span> <span class="n">bandpass</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># For performance profiling, store the number of evaluations used for the last integration</span>
        <span class="c1"># performed.  Note that this might not be very useful for ChromaticSum instances, which are</span>
        <span class="c1"># drawn one profile at a time, and hence _last_n_eval will only represent the final</span>
        <span class="c1"># component drawn.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_last_n_eval</span> <span class="o">=</span> <span class="n">integrator</span><span class="o">.</span><span class="n">last_n_eval</span>

        <span class="c1"># Apply integral to the initial image appropriately.</span>
        <span class="c1"># Note: Don&#39;t do image = integral and return that for add_to_image==False.</span>
        <span class="c1">#       Remember that python doesn&#39;t actually do assignments, so this won&#39;t update the</span>
        <span class="c1">#       original image if the user provided one.  The following procedure does work.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">add_to_image</span><span class="p">:</span>
            <span class="n">image</span><span class="o">.</span><span class="n">setZero</span><span class="p">()</span>
        <span class="n">image</span> <span class="o">+=</span> <span class="n">integral</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_last_wcs</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">wcs</span>
        <span class="k">return</span> <span class="n">image</span></div>

<div class="viewcode-block" id="ChromaticObject.drawKImage"><a class="viewcode-back" href="../../chromaticobject.html#galsim.ChromaticObject.drawKImage">[docs]</a>    <span class="k">def</span> <span class="nf">drawKImage</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bandpass</span><span class="p">,</span> <span class="n">image</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">integrator</span><span class="o">=</span><span class="s1">&#39;quadratic&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Base implementation for drawing the Fourier transform of a `ChromaticObject`.</span>

<span class="sd">        The task of drawKImage() in a chromatic context is exactly analogous to the task of</span>
<span class="sd">        `drawImage` in a chromatic context: to integrate the ``sed * bandpass`` weighted Fourier</span>
<span class="sd">        profiles over wavelength.</span>

<span class="sd">        See `drawImage` for details on integration options.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            bandpass:   A `Bandpass` object representing the filter against which to integrate.</span>
<span class="sd">            image:      If provided, this will be the complex `Image` onto which to draw the</span>
<span class="sd">                        k-space image.  If ``image`` is None, then an automatically-sized image</span>
<span class="sd">                        will be created.  If ``image`` is given, but its bounds are undefined,</span>
<span class="sd">                        then it will be resized appropriately based on the profile&#39;s size.</span>
<span class="sd">                        [default: None]</span>
<span class="sd">            integrator: When doing the exact evaluation of the profile, this argument should be</span>
<span class="sd">                        one of the image integrators from galsim.integ, or a string</span>
<span class="sd">                        &#39;trapezoidal&#39;, &#39;midpoint&#39;, or &#39;quadratic&#39;, in which case the routine will</span>
<span class="sd">                        use a `SampleIntegrator` or `ContinuousIntegrator` depending on whether or</span>
<span class="sd">                        not the object has a ``wave_list``.  [default: &#39;quadratic&#39;, which will try</span>
<span class="sd">                        to select an appropriate integrator using the quadratic integration rule</span>
<span class="sd">                        automatically.]</span>
<span class="sd">            **kwargs:   For all other kwarg options, see `GSObject.drawKImage`.</span>

<span class="sd">        Returns:</span>
<span class="sd">            a complex `Image` instance (created if necessary)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">SED</span><span class="o">.</span><span class="n">dimensionless</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">GalSimSEDError</span><span class="p">(</span><span class="s2">&quot;Can only drawK ChromaticObjects with spectral SEDs.&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">SED</span><span class="p">)</span>

        <span class="c1"># setup output image (semi-arbitrarily using the bandpass effective wavelength)</span>
        <span class="n">prof0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluateAtWavelength</span><span class="p">(</span><span class="n">bandpass</span><span class="o">.</span><span class="n">effective_wavelength</span><span class="p">)</span>
        <span class="n">image</span> <span class="o">=</span> <span class="n">prof0</span><span class="o">.</span><span class="n">drawKImage</span><span class="p">(</span><span class="n">image</span><span class="o">=</span><span class="n">image</span><span class="p">,</span> <span class="n">setup_only</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">_remove_setup_kwargs</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># determine combined self.wave_list and bandpass.wave_list</span>
        <span class="n">wave_list</span><span class="p">,</span> <span class="n">_</span> <span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">utilities</span><span class="o">.</span><span class="n">combine_wave_list</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bandpass</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">separable</span><span class="p">:</span>
            <span class="n">multiplier</span> <span class="o">=</span> <span class="n">ChromaticObject</span><span class="o">.</span><span class="n">_multiplier_cache</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">SED</span><span class="p">,</span> <span class="n">bandpass</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">wave_list</span><span class="p">))</span>
            <span class="n">prof0</span> <span class="o">*=</span> <span class="n">multiplier</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">SED</span><span class="p">(</span><span class="n">bandpass</span><span class="o">.</span><span class="n">effective_wavelength</span><span class="p">)</span>
            <span class="n">image</span> <span class="o">=</span> <span class="n">prof0</span><span class="o">.</span><span class="n">drawKImage</span><span class="p">(</span><span class="n">image</span><span class="o">=</span><span class="n">image</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">image</span>

        <span class="n">integrator</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_integrator</span><span class="p">(</span><span class="n">integrator</span><span class="p">,</span> <span class="n">wave_list</span><span class="p">)</span>

        <span class="c1"># merge self.wave_list into bandpass.wave_list if using a sampling integrator</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">integrator</span><span class="p">,</span> <span class="n">integ</span><span class="o">.</span><span class="n">SampleIntegrator</span><span class="p">):</span>
            <span class="n">bandpass</span> <span class="o">=</span> <span class="n">Bandpass</span><span class="p">(</span><span class="n">_LookupTable</span><span class="p">(</span><span class="n">wave_list</span><span class="p">,</span> <span class="n">bandpass</span><span class="p">(</span><span class="n">wave_list</span><span class="p">),</span> <span class="s1">&#39;linear&#39;</span><span class="p">),</span> <span class="s1">&#39;nm&#39;</span><span class="p">)</span>

        <span class="n">add_to_image</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;add_to_image&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="n">image_int</span> <span class="o">=</span> <span class="n">integrator</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">evaluateAtWavelength</span><span class="p">,</span> <span class="n">bandpass</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">,</span> <span class="n">doK</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># For performance profiling, store the number of evaluations used for the last integration</span>
        <span class="c1"># performed.  Note that this might not be very useful for ChromaticSum instances, which are</span>
        <span class="c1"># drawn one profile at a time, and hence _last_n_eval will only represent the final</span>
        <span class="c1"># component drawn.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_last_n_eval</span> <span class="o">=</span> <span class="n">integrator</span><span class="o">.</span><span class="n">last_n_eval</span>

        <span class="c1"># Apply integral to the initial image appropriately.</span>
        <span class="c1"># Note: Don&#39;t do image = integral and return that for add_to_image==False.</span>
        <span class="c1">#       Remember that python doesn&#39;t actually do assignments, so this won&#39;t update the</span>
        <span class="c1">#       original image if the user provided one.  The following procedure does work.</span>
        <span class="k">if</span> <span class="n">add_to_image</span><span class="p">:</span>
            <span class="n">image</span> <span class="o">+=</span> <span class="n">image_int</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">image</span><span class="o">.</span><span class="n">copyFrom</span><span class="p">(</span><span class="n">image_int</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">image</span></div>

<div class="viewcode-block" id="ChromaticObject.evaluateAtWavelength"><a class="viewcode-back" href="../../chromaticobject.html#galsim.ChromaticObject.evaluateAtWavelength">[docs]</a>    <span class="k">def</span> <span class="nf">evaluateAtWavelength</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">wave</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Evaluate this chromatic object at a particular wavelength.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            wave:   Wavelength in nanometers.</span>

<span class="sd">        Returns:</span>
<span class="sd">            the monochromatic object at the given wavelength.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Subclasses all override this.</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_obj</span><span class="o">.</span><span class="n">evaluateAtWavelength</span><span class="p">(</span><span class="n">wave</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_shoot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">photons</span><span class="p">,</span> <span class="n">rng</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_obj</span><span class="o">.</span><span class="n">_shoot</span><span class="p">(</span><span class="n">photons</span><span class="p">,</span> <span class="n">rng</span><span class="p">)</span>

<div class="viewcode-block" id="ChromaticObject.applyTo"><a class="viewcode-back" href="../../chromaticobject.html#galsim.ChromaticObject.applyTo">[docs]</a>    <span class="k">def</span> <span class="nf">applyTo</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">photon_array</span><span class="p">,</span> <span class="n">local_wcs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rng</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Apply the chromatic profile as a convolution to an existing photon array.</span>

<span class="sd">        This method allows instances of this class to duck type as a PhotonOp, so one can apply it</span>
<span class="sd">        in a photon_ops list.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            photon_array:   A `PhotonArray` to apply the operator to.</span>
<span class="sd">            local_wcs:      A `LocalWCS` instance defining the local WCS for the current photon</span>
<span class="sd">                            bundle in case the operator needs this information.  [default: None]</span>
<span class="sd">            rng:            A random number generator to use to effect the convolution.</span>
<span class="sd">                            [default: None]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.photon_array</span> <span class="kn">import</span> <span class="n">PhotonArray</span>
        <span class="kn">from</span> <span class="nn">.random</span> <span class="kn">import</span> <span class="n">BaseDeviate</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">photon_array</span><span class="o">.</span><span class="n">hasAllocatedWavelengths</span><span class="p">():</span>
            <span class="k">raise</span> <span class="n">GalSimError</span><span class="p">(</span><span class="s2">&quot;Using ChromaticObject as a PhotonOp requires wavelengths be set&quot;</span><span class="p">)</span>
        <span class="n">p1</span> <span class="o">=</span> <span class="n">PhotonArray</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">photon_array</span><span class="p">))</span>
        <span class="n">p1</span><span class="o">.</span><span class="n">wavelength</span> <span class="o">=</span> <span class="n">photon_array</span><span class="o">.</span><span class="n">wavelength</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="n">local_wcs</span><span class="o">.</span><span class="n">toImage</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="k">if</span> <span class="n">local_wcs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span>
        <span class="n">rng</span> <span class="o">=</span> <span class="n">BaseDeviate</span><span class="p">(</span><span class="n">rng</span><span class="p">)</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">_shoot</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">rng</span><span class="p">)</span>
        <span class="n">photon_array</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">rng</span><span class="p">)</span></div>

    <span class="c1"># Make op* and op*= work to adjust the flux of the object</span>
<div class="viewcode-block" id="ChromaticObject.__mul__"><a class="viewcode-back" href="../../chromaticobject.html#galsim.ChromaticObject.__mul__">[docs]</a>    <span class="k">def</span> <span class="fm">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">flux_ratio</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Scale the flux of the object by the given flux ratio, which may be an `SED`, a float, or</span>
<span class="sd">        a univariate callable function (of wavelength in nanometers) that returns a float.</span>

<span class="sd">        The normalization of a `ChromaticObject` is tracked through its ``.SED`` attribute, which</span>
<span class="sd">        may have dimensions of either [photons/wavelength-interval/area/time/solid-angle] or</span>
<span class="sd">        [1/solid-angle].</span>

<span class="sd">        If ``flux_ratio`` is a spectral `SED` (i.e., ``flux_ratio.spectral==True``), then self.SED</span>
<span class="sd">        must be dimensionless for dimensional consistency.  The returned object will have a</span>
<span class="sd">        spectral SED attribute.  On the other hand, if ``flux_ratio`` is a dimensionless `SED`,</span>
<span class="sd">        float, or univariate callable function, then the returned object will have ``.spectral``</span>
<span class="sd">        and ``.dimensionless`` matching ``self.spectral`` and ``self.dimensionless``.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            flux_ratio:     The factor by which to scale the normalization of the object.</span>
<span class="sd">                            ``flux_ratio`` may be a float, univariate callable function, in which</span>
<span class="sd">                            case the argument should be wavelength in nanometers and return value</span>
<span class="sd">                            the flux ratio for that wavelength, or an `SED`.</span>

<span class="sd">        Returns:</span>
<span class="sd">            a new object with scaled flux.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">withScaledFlux</span><span class="p">(</span><span class="n">flux_ratio</span><span class="p">)</span></div>

    <span class="fm">__rmul__</span> <span class="o">=</span> <span class="fm">__mul__</span>

    <span class="c1"># Likewise for op/ and op/=</span>
    <span class="k">def</span> <span class="nf">__div__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__mul__</span><span class="p">(</span><span class="mf">1.</span><span class="o">/</span><span class="n">other</span><span class="p">)</span>

    <span class="fm">__truediv__</span> <span class="o">=</span> <span class="n">__div__</span>

<div class="viewcode-block" id="ChromaticObject.withScaledFlux"><a class="viewcode-back" href="../../chromaticobject.html#galsim.ChromaticObject.withScaledFlux">[docs]</a>    <span class="k">def</span> <span class="nf">withScaledFlux</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">flux_ratio</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Multiply the flux of the object by ``flux_ratio``</span>

<span class="sd">        Parameters:</span>
<span class="sd">            flux_ratio:     The factor by which to scale the normalization of the object.</span>
<span class="sd">                            ``flux_ratio`` may be a float, univariate callable function, in which</span>
<span class="sd">                            case the argument should be wavelength in nanometers and return value</span>
<span class="sd">                            the flux ratio for that wavelength, or an `SED`.</span>

<span class="sd">        Returns:</span>
<span class="sd">            a new object with scaled flux.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.transform</span> <span class="kn">import</span> <span class="n">Transform</span>
        <span class="k">return</span> <span class="n">Transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">flux_ratio</span><span class="o">=</span><span class="n">flux_ratio</span><span class="p">)</span></div>

<div class="viewcode-block" id="ChromaticObject.withFlux"><a class="viewcode-back" href="../../chromaticobject.html#galsim.ChromaticObject.withFlux">[docs]</a>    <span class="k">def</span> <span class="nf">withFlux</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target_flux</span><span class="p">,</span> <span class="n">bandpass</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a new `ChromaticObject` with flux through the `Bandpass` ``bandpass`` set to</span>
<span class="sd">        ``target_flux``.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            target_flux:    The desired flux normalization of the `ChromaticObject`.</span>
<span class="sd">            bandpass:       A `Bandpass` object defining a filter bandpass.</span>

<span class="sd">        Returns:</span>
<span class="sd">            the new normalized `ChromaticObject`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">current_flux</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculateFlux</span><span class="p">(</span><span class="n">bandpass</span><span class="p">)</span>
        <span class="n">norm</span> <span class="o">=</span> <span class="n">target_flux</span><span class="o">/</span><span class="n">current_flux</span>
        <span class="k">return</span> <span class="bp">self</span> <span class="o">*</span> <span class="n">norm</span></div>

<div class="viewcode-block" id="ChromaticObject.withMagnitude"><a class="viewcode-back" href="../../chromaticobject.html#galsim.ChromaticObject.withMagnitude">[docs]</a>    <span class="k">def</span> <span class="nf">withMagnitude</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target_magnitude</span><span class="p">,</span> <span class="n">bandpass</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a new `ChromaticObject` with magnitude through ``bandpass`` set to</span>
<span class="sd">        ``target_magnitude``.  Note that this requires ``bandpass`` to have been assigned a</span>
<span class="sd">        zeropoint using `Bandpass.withZeropoint`.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            target_magnitude:   The desired magnitude of the `ChromaticObject`.</span>
<span class="sd">            bandpass:           A `Bandpass` object defining a filter bandpass.</span>

<span class="sd">        Returns:</span>
<span class="sd">            the new normalized `ChromaticObject`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">bandpass</span><span class="o">.</span><span class="n">zeropoint</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">GalSimError</span><span class="p">(</span><span class="s2">&quot;Cannot call ChromaticObject.withMagnitude on this bandpass, because&quot;</span>
                              <span class="s2">&quot; it does not have a zeropoint.  See `Bandpass.withZeropoint`&quot;</span><span class="p">)</span>
        <span class="n">current_magnitude</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculateMagnitude</span><span class="p">(</span><span class="n">bandpass</span><span class="p">)</span>
        <span class="n">norm</span> <span class="o">=</span> <span class="mi">10</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="mf">0.4</span><span class="o">*</span><span class="p">(</span><span class="n">target_magnitude</span> <span class="o">-</span> <span class="n">current_magnitude</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span> <span class="o">*</span> <span class="n">norm</span></div>

<div class="viewcode-block" id="ChromaticObject.withFluxDensity"><a class="viewcode-back" href="../../chromaticobject.html#galsim.ChromaticObject.withFluxDensity">[docs]</a>    <span class="k">def</span> <span class="nf">withFluxDensity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target_flux_density</span><span class="p">,</span> <span class="n">wavelength</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a new `ChromaticObject` with flux density set to ``target_flux_density`` at</span>
<span class="sd">        wavelength ``wavelength``.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            target_flux_density:    The target normalization in photons/nm/cm^2/s.</span>
<span class="sd">            wavelength:             The wavelength, in nm, at which the flux density will be set.</span>

<span class="sd">        Returns:</span>
<span class="sd">            the new normalized `SED`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">astropy</span> <span class="kn">import</span> <span class="n">units</span>
        <span class="n">_photons</span> <span class="o">=</span> <span class="n">units</span><span class="o">.</span><span class="n">astrophys</span><span class="o">.</span><span class="n">photon</span><span class="o">/</span><span class="p">(</span><span class="n">units</span><span class="o">.</span><span class="n">s</span> <span class="o">*</span> <span class="n">units</span><span class="o">.</span><span class="n">cm</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">units</span><span class="o">.</span><span class="n">nm</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensionless</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">GalSimSEDError</span><span class="p">(</span><span class="s2">&quot;Cannot set flux density of dimensionless ChromaticObject.&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">wavelength</span><span class="p">,</span> <span class="n">units</span><span class="o">.</span><span class="n">Quantity</span><span class="p">):</span>
            <span class="n">wavelength_nm</span> <span class="o">=</span> <span class="n">wavelength</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">units</span><span class="o">.</span><span class="n">nm</span><span class="p">,</span> <span class="n">units</span><span class="o">.</span><span class="n">spectral</span><span class="p">())</span>
            <span class="n">current_flux_density</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">SED</span><span class="p">(</span><span class="n">wavelength_nm</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">wavelength_nm</span> <span class="o">=</span> <span class="n">wavelength</span> <span class="o">*</span> <span class="n">units</span><span class="o">.</span><span class="n">nm</span>
            <span class="n">current_flux_density</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">SED</span><span class="p">(</span><span class="n">wavelength</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">target_flux_density</span><span class="p">,</span> <span class="n">units</span><span class="o">.</span><span class="n">Quantity</span><span class="p">):</span>
            <span class="n">target_flux_density</span> <span class="o">=</span> <span class="n">target_flux_density</span><span class="o">.</span><span class="n">to</span><span class="p">(</span>
                    <span class="n">_photons</span><span class="p">,</span> <span class="n">units</span><span class="o">.</span><span class="n">spectral_density</span><span class="p">(</span><span class="n">wavelength_nm</span><span class="p">))</span><span class="o">.</span><span class="n">value</span>
        <span class="n">factor</span> <span class="o">=</span> <span class="n">target_flux_density</span> <span class="o">/</span> <span class="n">current_flux_density</span>
        <span class="k">return</span> <span class="bp">self</span> <span class="o">*</span> <span class="n">factor</span></div>

<div class="viewcode-block" id="ChromaticObject.atRedshift"><a class="viewcode-back" href="../../chromaticobject.html#galsim.ChromaticObject.atRedshift">[docs]</a>    <span class="k">def</span> <span class="nf">atRedshift</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">redshift</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create a version of the current object with a different redshift.</span>

<span class="sd">        This will both adjust the SED to have the given redshift and set a ``redshift`` attribute</span>
<span class="sd">        with the given value.</span>

<span class="sd">        Returns:</span>
<span class="sd">            the object with the new redshift</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">ChromaticTransformation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">redshift</span><span class="o">=</span><span class="n">redshift</span><span class="p">)</span></div>

<div class="viewcode-block" id="ChromaticObject.calculateCentroid"><a class="viewcode-back" href="../../chromaticobject.html#galsim.ChromaticObject.calculateCentroid">[docs]</a>    <span class="k">def</span> <span class="nf">calculateCentroid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bandpass</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Determine the centroid of the wavelength-integrated surface brightness profile.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            bandpass:   The bandpass through which the observation is made.</span>

<span class="sd">        Returns:</span>
<span class="sd">            the centroid of the integrated surface brightness profile, as a PositionD.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># if either the Bandpass or self maintain a wave_list, evaluate integrand only at</span>
        <span class="c1"># those wavelengths.</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">bandpass</span><span class="o">.</span><span class="n">wave_list</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wave_list</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">w</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">utilities</span><span class="o">.</span><span class="n">combine_wave_list</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bandpass</span><span class="p">)</span>
            <span class="n">objs</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">evaluateAtWavelength</span><span class="p">(</span><span class="n">ww</span><span class="p">)</span> <span class="k">for</span> <span class="n">ww</span> <span class="ow">in</span> <span class="n">w</span><span class="p">]</span>
            <span class="n">fluxes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">o</span><span class="o">.</span><span class="n">flux</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">objs</span><span class="p">])</span>
            <span class="n">centroids</span> <span class="o">=</span> <span class="p">[</span><span class="n">o</span><span class="o">.</span><span class="n">centroid</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">objs</span><span class="p">]</span>
            <span class="n">xcentroids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">c</span><span class="o">.</span><span class="n">x</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">centroids</span><span class="p">])</span>
            <span class="n">ycentroids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">c</span><span class="o">.</span><span class="n">y</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">centroids</span><span class="p">])</span>
            <span class="n">bp</span> <span class="o">=</span> <span class="n">_LookupTable</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">bandpass</span><span class="p">(</span><span class="n">w</span><span class="p">),</span> <span class="s1">&#39;linear&#39;</span><span class="p">)</span>
            <span class="n">flux</span> <span class="o">=</span> <span class="n">bp</span><span class="o">.</span><span class="n">integrate_product</span><span class="p">(</span><span class="n">_LookupTable</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">fluxes</span><span class="p">,</span> <span class="s1">&#39;linear&#39;</span><span class="p">))</span>
            <span class="n">xcentroid</span> <span class="o">=</span> <span class="n">bp</span><span class="o">.</span><span class="n">integrate_product</span><span class="p">(</span><span class="n">_LookupTable</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">fluxes</span> <span class="o">*</span> <span class="n">xcentroids</span><span class="p">,</span> <span class="s1">&#39;linear&#39;</span><span class="p">))</span> <span class="o">/</span> <span class="n">flux</span>
            <span class="n">ycentroid</span> <span class="o">=</span> <span class="n">bp</span><span class="o">.</span><span class="n">integrate_product</span><span class="p">(</span><span class="n">_LookupTable</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">fluxes</span> <span class="o">*</span> <span class="n">ycentroids</span><span class="p">,</span> <span class="s1">&#39;linear&#39;</span><span class="p">))</span> <span class="o">/</span> <span class="n">flux</span>
            <span class="k">return</span> <span class="n">_PositionD</span><span class="p">(</span><span class="n">xcentroid</span><span class="p">,</span> <span class="n">ycentroid</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">flux_integrand</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">w</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluateAtWavelength</span><span class="p">(</span><span class="n">w</span><span class="p">)</span><span class="o">.</span><span class="n">flux</span> <span class="o">*</span> <span class="n">bandpass</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
            <span class="k">def</span> <span class="nf">xcentroid_integrand</span><span class="p">(</span><span class="n">w</span><span class="p">):</span>
                <span class="n">mono</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluateAtWavelength</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">mono</span><span class="o">.</span><span class="n">centroid</span><span class="o">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">mono</span><span class="o">.</span><span class="n">flux</span> <span class="o">*</span> <span class="n">bandpass</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
            <span class="k">def</span> <span class="nf">ycentroid_integrand</span><span class="p">(</span><span class="n">w</span><span class="p">):</span>
                <span class="n">mono</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluateAtWavelength</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">mono</span><span class="o">.</span><span class="n">centroid</span><span class="o">.</span><span class="n">y</span> <span class="o">*</span> <span class="n">mono</span><span class="o">.</span><span class="n">flux</span> <span class="o">*</span> <span class="n">bandpass</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
            <span class="n">flux</span> <span class="o">=</span> <span class="n">integ</span><span class="o">.</span><span class="n">int1d</span><span class="p">(</span><span class="n">flux_integrand</span><span class="p">,</span> <span class="n">bandpass</span><span class="o">.</span><span class="n">blue_limit</span><span class="p">,</span> <span class="n">bandpass</span><span class="o">.</span><span class="n">red_limit</span><span class="p">)</span>
            <span class="n">xcentroid</span> <span class="o">=</span> <span class="mf">1.</span><span class="o">/</span><span class="n">flux</span> <span class="o">*</span> <span class="n">integ</span><span class="o">.</span><span class="n">int1d</span><span class="p">(</span><span class="n">xcentroid_integrand</span><span class="p">,</span>
                                              <span class="n">bandpass</span><span class="o">.</span><span class="n">blue_limit</span><span class="p">,</span>
                                              <span class="n">bandpass</span><span class="o">.</span><span class="n">red_limit</span><span class="p">)</span>
            <span class="n">ycentroid</span> <span class="o">=</span> <span class="mf">1.</span><span class="o">/</span><span class="n">flux</span> <span class="o">*</span> <span class="n">integ</span><span class="o">.</span><span class="n">int1d</span><span class="p">(</span><span class="n">ycentroid_integrand</span><span class="p">,</span>
                                              <span class="n">bandpass</span><span class="o">.</span><span class="n">blue_limit</span><span class="p">,</span>
                                              <span class="n">bandpass</span><span class="o">.</span><span class="n">red_limit</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">_PositionD</span><span class="p">(</span><span class="n">xcentroid</span><span class="p">,</span> <span class="n">ycentroid</span><span class="p">)</span></div>

<div class="viewcode-block" id="ChromaticObject.calculateFlux"><a class="viewcode-back" href="../../chromaticobject.html#galsim.ChromaticObject.calculateFlux">[docs]</a>    <span class="k">def</span> <span class="nf">calculateFlux</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bandpass</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the flux (photons/cm^2/s) of the `ChromaticObject` through a `Bandpass` bandpass.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            bandpass:   A `Bandpass` object representing a filter, or None to compute the bolometric</span>
<span class="sd">                        flux.  For the bolometric flux the integration limits will be set to</span>
<span class="sd">                        (0, infinity) unless overridden by non-None `SED` attributes ``blue_limit``</span>
<span class="sd">                        or ``red_limit``.  Note that an `SED` defined using a `LookupTable`</span>
<span class="sd">                        automatically has ``blue_limit`` and ``red_limit`` set.</span>

<span class="sd">        Returns:</span>
<span class="sd">            the flux through the bandpass.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">SED</span><span class="o">.</span><span class="n">dimensionless</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">GalSimSEDError</span><span class="p">(</span><span class="s2">&quot;Cannot calculate flux of dimensionless ChromaticObject.&quot;</span><span class="p">,</span>
                                 <span class="bp">self</span><span class="o">.</span><span class="n">SED</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">SED</span><span class="o">.</span><span class="n">calculateFlux</span><span class="p">(</span><span class="n">bandpass</span><span class="p">)</span></div>

<div class="viewcode-block" id="ChromaticObject.calculateMagnitude"><a class="viewcode-back" href="../../chromaticobject.html#galsim.ChromaticObject.calculateMagnitude">[docs]</a>    <span class="k">def</span> <span class="nf">calculateMagnitude</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bandpass</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the `ChromaticObject` magnitude through a `Bandpass` ``bandpass``.</span>

<span class="sd">        Note that this requires ``bandpass`` to have been assigned a zeropoint using</span>
<span class="sd">        `Bandpass.withZeropoint`.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            bandpass:   A `Bandpass` object representing a filter, or None to compute the</span>
<span class="sd">                        bolometric magnitude.  For the bolometric magnitude the integration</span>
<span class="sd">                        limits will be set to (0, infinity) unless overridden by non-None `SED`</span>
<span class="sd">                        attributes ``blue_limit`` or ``red_limit``.  Note that an `SED` defined</span>
<span class="sd">                        using a `LookupTable` automatically has ``blue_limit`` and ``red_limit``</span>
<span class="sd">                        set.</span>

<span class="sd">        Returns:</span>
<span class="sd">            the bandpass magnitude.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">SED</span><span class="o">.</span><span class="n">dimensionless</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">GalSimSEDError</span><span class="p">(</span><span class="s2">&quot;Cannot calculate magnitude of dimensionless ChromaticObject.&quot;</span><span class="p">,</span>
                                 <span class="bp">self</span><span class="o">.</span><span class="n">SED</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">SED</span><span class="o">.</span><span class="n">calculateMagnitude</span><span class="p">(</span><span class="n">bandpass</span><span class="p">)</span></div>

    <span class="c1"># Add together ChromaticObjects and/or GSObjects</span>
    <span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">ChromaticSum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="c1"># Subtract ChromaticObjects and/or GSObjects</span>
    <span class="k">def</span> <span class="fm">__sub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">ChromaticSum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">-</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__neg__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="o">-</span><span class="mf">1.</span> <span class="o">*</span> <span class="bp">self</span>

    <span class="c1"># Following functions work to apply affine transformations to a ChromaticObject.</span>
    <span class="c1">#</span>
<div class="viewcode-block" id="ChromaticObject.expand"><a class="viewcode-back" href="../../chromaticobject.html#galsim.ChromaticObject.expand">[docs]</a>    <span class="k">def</span> <span class="nf">expand</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scale</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Expand the linear size of the profile by the given (possibly wavelength-dependent)</span>
<span class="sd">        scale factor ``scale``, while preserving surface brightness.</span>

<span class="sd">        This doesn&#39;t correspond to either of the normal operations one would typically want to</span>
<span class="sd">        do to a galaxy.  The functions dilate() and magnify() are the more typical usage.  But this</span>
<span class="sd">        function is conceptually simple.  It rescales the linear dimension of the profile, while</span>
<span class="sd">        preserving surface brightness.  As a result, the flux will necessarily change as well.</span>

<span class="sd">        See dilate() for a version that applies a linear scale factor while preserving flux.</span>

<span class="sd">        See magnify() for a version that applies a scale factor to the area while preserving surface</span>
<span class="sd">        brightness.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            scale:      The factor by which to scale the linear dimension of the object.  In</span>
<span class="sd">                        addition, ``scale`` may be a callable function, in which case the argument</span>
<span class="sd">                        should be wavelength in nanometers and the return value the scale for that</span>
<span class="sd">                        wavelength.</span>

<span class="sd">        Returns:</span>
<span class="sd">            the expanded object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.transform</span> <span class="kn">import</span> <span class="n">Transform</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">scale</span><span class="p">,</span> <span class="s1">&#39;__call__&#39;</span><span class="p">):</span>
            <span class="k">def</span> <span class="nf">buildScaleJac</span><span class="p">(</span><span class="n">w</span><span class="p">):</span>
                <span class="n">s</span> <span class="o">=</span> <span class="n">scale</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">([</span><span class="n">s</span><span class="p">,</span><span class="n">s</span><span class="p">])</span>
            <span class="n">jac</span> <span class="o">=</span> <span class="n">buildScaleJac</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">jac</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">scale</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">([</span><span class="n">scale</span><span class="p">,</span> <span class="n">scale</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">Transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">jac</span><span class="o">=</span><span class="n">jac</span><span class="p">)</span></div>

<div class="viewcode-block" id="ChromaticObject.dilate"><a class="viewcode-back" href="../../chromaticobject.html#galsim.ChromaticObject.dilate">[docs]</a>    <span class="k">def</span> <span class="nf">dilate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scale</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Dilate the linear size of the profile by the given (possibly wavelength-dependent)</span>
<span class="sd">        ``scale``, while preserving flux.</span>

<span class="sd">        e.g. ``half_light_radius`` &lt;-- ``half_light_radius * scale``</span>

<span class="sd">        See expand() and magnify() for versions that preserve surface brightness, and thus</span>
<span class="sd">        change the flux.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            scale:      The linear rescaling factor to apply.  In addition, ``scale`` may be a</span>
<span class="sd">                        callable function, in which case the argument should be wavelength in</span>
<span class="sd">                        nanometers and the return value the scale for that wavelength.</span>

<span class="sd">        Returns:</span>
<span class="sd">            the dilated object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">scale</span><span class="p">,</span> <span class="s1">&#39;__call__&#39;</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="n">scale</span><span class="p">)</span><span class="o">.</span><span class="n">withScaledFlux</span><span class="p">(</span><span class="k">lambda</span> <span class="n">w</span><span class="p">:</span> <span class="mf">1.</span><span class="o">/</span><span class="n">scale</span><span class="p">(</span><span class="n">w</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="n">scale</span><span class="p">)</span><span class="o">.</span><span class="n">withScaledFlux</span><span class="p">(</span><span class="mf">1.</span><span class="o">/</span><span class="n">scale</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span></div>

<div class="viewcode-block" id="ChromaticObject.magnify"><a class="viewcode-back" href="../../chromaticobject.html#galsim.ChromaticObject.magnify">[docs]</a>    <span class="k">def</span> <span class="nf">magnify</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mu</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Apply a lensing magnification, scaling the area and flux by ``mu`` at fixed surface</span>
<span class="sd">        brightness.</span>

<span class="sd">        This process applies a lensing magnification ``mu``, which scales the linear dimensions of the</span>
<span class="sd">        image by the factor sqrt(mu), i.e., ``half_light_radius`` &lt;-- ``half_light_radius * sqrt(mu)``</span>
<span class="sd">        while increasing the flux by a factor of ``mu``.  Thus, magnify() preserves surface</span>
<span class="sd">        brightness.</span>

<span class="sd">        See dilate() for a version that applies a linear scale factor while preserving flux.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            mu:         The lensing magnification to apply.  In addition, ``mu`` may be a callable</span>
<span class="sd">                        function, in which case the argument should be wavelength in nanometers</span>
<span class="sd">                        and the return value the magnification for that wavelength.</span>

<span class="sd">        Returns:</span>
<span class="sd">            the magnified object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">math</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">mu</span><span class="p">,</span> <span class="s1">&#39;__call__&#39;</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="k">lambda</span> <span class="n">w</span><span class="p">:</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">mu</span><span class="p">(</span><span class="n">w</span><span class="p">)))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span></div>

<div class="viewcode-block" id="ChromaticObject.shear"><a class="viewcode-back" href="../../chromaticobject.html#galsim.ChromaticObject.shear">[docs]</a>    <span class="k">def</span> <span class="nf">shear</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Apply an area-preserving shear to this object, where arguments are either a `Shear`,</span>
<span class="sd">        or arguments that will be used to initialize one.</span>

<span class="sd">        For more details about the allowed keyword arguments, see the `Shear` docstring.</span>

<span class="sd">        The shear() method precisely preserves the area.  To include a lensing distortion with</span>
<span class="sd">        the appropriate change in area, either use shear() with magnify(), or use lens(), which</span>
<span class="sd">        combines both operations.</span>

<span class="sd">        Note that, while gravitational shear is monochromatic, the shear method may be used for</span>
<span class="sd">        many other use cases including some which may be wavelength-dependent, such as</span>
<span class="sd">        intrinsic galaxy shape, telescope dilation, atmospheric PSF shape, etc.  Thus, the</span>
<span class="sd">        shear argument is allowed to be a function of wavelength like other transformations.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            shear:      The shear to be applied. Or, as described above, you may instead supply</span>
<span class="sd">                        parameters to construct a `Shear` directly.  eg. ``obj.shear(g1=g1,g2=g2)``.</span>
<span class="sd">                        In addition, the ``shear`` parameter may be a callable function, in which</span>
<span class="sd">                        case the argument should be wavelength in nanometers and the return value</span>
<span class="sd">                        the shear for that wavelength, returned as a `galsim.Shear` instance.</span>

<span class="sd">        Returns:</span>
<span class="sd">            the sheared object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.transform</span> <span class="kn">import</span> <span class="n">Transform</span>
        <span class="kn">from</span> <span class="nn">.shear</span> <span class="kn">import</span> <span class="n">Shear</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Gave both unnamed and named arguments!&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;__call__&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Shear</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Unnamed argument is not a Shear or function returning Shear!&quot;</span><span class="p">)</span>
            <span class="n">shear</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Too many unnamed arguments!&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="s1">&#39;shear&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="c1"># Need to break this out specially in case it is a function of wavelength</span>
            <span class="n">shear</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;shear&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Too many kwargs provided!&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">shear</span> <span class="o">=</span> <span class="n">Shear</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">shear</span><span class="p">,</span> <span class="s1">&#39;__call__&#39;</span><span class="p">):</span>
            <span class="n">jac</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">w</span><span class="p">:</span> <span class="n">shear</span><span class="p">(</span><span class="n">w</span><span class="p">)</span><span class="o">.</span><span class="n">getMatrix</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">jac</span> <span class="o">=</span> <span class="n">shear</span><span class="o">.</span><span class="n">getMatrix</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">Transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">jac</span><span class="o">=</span><span class="n">jac</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_shear</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shear</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Equivalent to `ChromaticObject.shear`, but only valid for a galsim.Shear object,</span>
<span class="sd">        not any of the possible wavelength-dependent options.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            shear:      The `Shear` to be applied.</span>

<span class="sd">        Returns:</span>
<span class="sd">            the sheared object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.transform</span> <span class="kn">import</span> <span class="n">Transform</span>
        <span class="k">return</span> <span class="n">Transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shear</span><span class="o">.</span><span class="n">getMatrix</span><span class="p">())</span>

<div class="viewcode-block" id="ChromaticObject.lens"><a class="viewcode-back" href="../../chromaticobject.html#galsim.ChromaticObject.lens">[docs]</a>    <span class="k">def</span> <span class="nf">lens</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">g1</span><span class="p">,</span> <span class="n">g2</span><span class="p">,</span> <span class="n">mu</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Apply a lensing shear and magnification to this object.</span>

<span class="sd">        This `ChromaticObject` method applies a lensing (reduced) shear and magnification.</span>
<span class="sd">        The shear must be specified using the g1, g2 definition of shear (see `Shear` for details).</span>
<span class="sd">        This is the same definition as the outputs of the `PowerSpectrum` and `NFWHalo` classes,</span>
<span class="sd">        which compute shears according to some lensing power spectrum or lensing by an NFW dark</span>
<span class="sd">        matter halo.  The magnification determines the rescaling factor for the object area and</span>
<span class="sd">        flux, preserving surface brightness.</span>

<span class="sd">        While gravitational lensing is achromatic, we do allow the parameters ``g1``, ``g2``, and</span>
<span class="sd">        ``mu`` to be callable functions to be parallel to all the other transformations of</span>
<span class="sd">        chromatic objects.  In this case, the functions should take the wavelength in nanometers as</span>
<span class="sd">        the argument, and the return values are the corresponding value at that wavelength.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            g1:         First component of lensing (reduced) shear to apply to the object.</span>
<span class="sd">            g2:         Second component of lensing (reduced) shear to apply to the object.</span>
<span class="sd">            mu:         Lensing magnification to apply to the object.  This is the factor by which</span>
<span class="sd">                        the solid angle subtended by the object is magnified, preserving surface</span>
<span class="sd">                        brightness.</span>

<span class="sd">        Returns:</span>
<span class="sd">            the lensed object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.shear</span> <span class="kn">import</span> <span class="n">Shear</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="nb">hasattr</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="s1">&#39;__call__&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="p">(</span><span class="n">g1</span><span class="p">,</span><span class="n">g2</span><span class="p">)):</span>
            <span class="n">_g1</span> <span class="o">=</span> <span class="n">g1</span>
            <span class="n">_g2</span> <span class="o">=</span> <span class="n">g2</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">g1</span><span class="p">,</span> <span class="s1">&#39;__call__&#39;</span><span class="p">):</span> <span class="n">_g1</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">w</span><span class="p">:</span> <span class="n">g1</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">g2</span><span class="p">,</span> <span class="s1">&#39;__call__&#39;</span><span class="p">):</span> <span class="n">_g2</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">w</span><span class="p">:</span> <span class="n">g2</span>
            <span class="n">S</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">w</span><span class="p">:</span> <span class="n">Shear</span><span class="p">(</span><span class="n">g1</span><span class="o">=</span><span class="n">_g1</span><span class="p">(</span><span class="n">w</span><span class="p">),</span> <span class="n">g2</span><span class="o">=</span><span class="n">_g2</span><span class="p">(</span><span class="n">w</span><span class="p">))</span>
            <span class="n">sheared</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shear</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sheared</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shear</span><span class="p">(</span><span class="n">g1</span><span class="o">=</span><span class="n">g1</span><span class="p">,</span><span class="n">g2</span><span class="o">=</span><span class="n">g2</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">sheared</span><span class="o">.</span><span class="n">magnify</span><span class="p">(</span><span class="n">mu</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_lens</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">g1</span><span class="p">,</span> <span class="n">g2</span><span class="p">,</span> <span class="n">mu</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Equivalent to `ChromaticObject.lens`, but without the overhead of some of the sanity</span>
<span class="sd">        checks or any of the possible wavelength-dependent options.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            g1:         First component of lensing (reduced) shear to apply to the object.</span>
<span class="sd">            g2:         Second component of lensing (reduced) shear to apply to the object.</span>
<span class="sd">            mu:         Lensing magnification to apply to the object.  This is the factor by which</span>
<span class="sd">                        the solid angle subtended by the object is magnified, preserving surface</span>
<span class="sd">                        brightness.</span>

<span class="sd">        Returns:</span>
<span class="sd">            the lensed object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.shear</span> <span class="kn">import</span> <span class="n">_Shear</span>
        <span class="kn">from</span> <span class="nn">.transform</span> <span class="kn">import</span> <span class="n">Transform</span>
        <span class="kn">import</span> <span class="nn">math</span>
        <span class="n">shear</span> <span class="o">=</span> <span class="n">_Shear</span><span class="p">(</span><span class="n">g1</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">g2</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shear</span><span class="o">.</span><span class="n">getMatrix</span><span class="p">()</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span>

<div class="viewcode-block" id="ChromaticObject.rotate"><a class="viewcode-back" href="../../chromaticobject.html#galsim.ChromaticObject.rotate">[docs]</a>    <span class="k">def</span> <span class="nf">rotate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theta</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Rotate this object by an `Angle` ``theta``.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            theta:      Rotation angle (`Angle` object, +ve anticlockwise). In addition, ``theta``</span>
<span class="sd">                        may be a callable function, in which case the argument should be wavelength</span>
<span class="sd">                        in nanometers and the return value the rotation angle for that wavelength,</span>
<span class="sd">                        returned as a `galsim.Angle` instance.</span>

<span class="sd">        Returns:</span>
<span class="sd">            the rotated object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.transform</span> <span class="kn">import</span> <span class="n">Transform</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="s1">&#39;__call__&#39;</span><span class="p">):</span>
            <span class="k">def</span> <span class="nf">buildRMatrix</span><span class="p">(</span><span class="n">w</span><span class="p">):</span>
                <span class="n">sth</span><span class="p">,</span> <span class="n">cth</span> <span class="o">=</span> <span class="n">theta</span><span class="p">(</span><span class="n">w</span><span class="p">)</span><span class="o">.</span><span class="n">sincos</span><span class="p">()</span>
                <span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">cth</span><span class="p">,</span> <span class="o">-</span><span class="n">sth</span><span class="p">],</span>
                              <span class="p">[</span><span class="n">sth</span><span class="p">,</span>  <span class="n">cth</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">R</span>
            <span class="n">jac</span> <span class="o">=</span> <span class="n">buildRMatrix</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sth</span><span class="p">,</span> <span class="n">cth</span> <span class="o">=</span> <span class="n">theta</span><span class="o">.</span><span class="n">sincos</span><span class="p">()</span>
            <span class="n">jac</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">cth</span><span class="p">,</span> <span class="o">-</span><span class="n">sth</span><span class="p">],</span>
                            <span class="p">[</span><span class="n">sth</span><span class="p">,</span>  <span class="n">cth</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">jac</span><span class="o">=</span><span class="n">jac</span><span class="p">)</span></div>

<div class="viewcode-block" id="ChromaticObject.transform"><a class="viewcode-back" href="../../chromaticobject.html#galsim.ChromaticObject.transform">[docs]</a>    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dudx</span><span class="p">,</span> <span class="n">dudy</span><span class="p">,</span> <span class="n">dvdx</span><span class="p">,</span> <span class="n">dvdy</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Apply a transformation to this object defined by an arbitrary Jacobian matrix.</span>

<span class="sd">        This works the same as `GSObject.transform`, so see that method&#39;s docstring for more</span>
<span class="sd">        details.</span>

<span class="sd">        As with the other more specific chromatic trasnformations, dudx, dudy, dvdx, and dvdy</span>
<span class="sd">        may be callable functions, in which case the argument should be wavelength in nanometers</span>
<span class="sd">        and the return value the appropriate value for that wavelength.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            dudx:       du/dx, where (x,y) are the current coords, and (u,v) are the new coords.</span>
<span class="sd">            dudy:       du/dy, where (x,y) are the current coords, and (u,v) are the new coords.</span>
<span class="sd">            dvdx:       dv/dx, where (x,y) are the current coords, and (u,v) are the new coords.</span>
<span class="sd">            dvdy:       dv/dy, where (x,y) are the current coords, and (u,v) are the new coords.</span>

<span class="sd">        Returns:</span>
<span class="sd">            the transformed object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.transform</span> <span class="kn">import</span> <span class="n">Transform</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="nb">hasattr</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="s1">&#39;__call__&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">dd</span> <span class="ow">in</span> <span class="p">(</span><span class="n">dudx</span><span class="p">,</span> <span class="n">dudy</span><span class="p">,</span> <span class="n">dvdx</span><span class="p">,</span> <span class="n">dvdy</span><span class="p">)):</span>
            <span class="n">_dudx</span> <span class="o">=</span> <span class="n">dudx</span>
            <span class="n">_dudy</span> <span class="o">=</span> <span class="n">dudy</span>
            <span class="n">_dvdx</span> <span class="o">=</span> <span class="n">dvdx</span>
            <span class="n">_dvdy</span> <span class="o">=</span> <span class="n">dvdy</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">dudx</span><span class="p">,</span> <span class="s1">&#39;__call__&#39;</span><span class="p">):</span> <span class="n">_dudx</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">w</span><span class="p">:</span> <span class="n">dudx</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">dudy</span><span class="p">,</span> <span class="s1">&#39;__call__&#39;</span><span class="p">):</span> <span class="n">_dudy</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">w</span><span class="p">:</span> <span class="n">dudy</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">dvdx</span><span class="p">,</span> <span class="s1">&#39;__call__&#39;</span><span class="p">):</span> <span class="n">_dvdx</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">w</span><span class="p">:</span> <span class="n">dvdx</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">dvdy</span><span class="p">,</span> <span class="s1">&#39;__call__&#39;</span><span class="p">):</span> <span class="n">_dvdy</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">w</span><span class="p">:</span> <span class="n">dvdy</span>
            <span class="n">jac</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">w</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">_dudx</span><span class="p">(</span><span class="n">w</span><span class="p">),</span> <span class="n">_dudy</span><span class="p">(</span><span class="n">w</span><span class="p">)],</span>
                                      <span class="p">[</span><span class="n">_dvdx</span><span class="p">(</span><span class="n">w</span><span class="p">),</span> <span class="n">_dvdy</span><span class="p">(</span><span class="n">w</span><span class="p">)]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">jac</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">dudx</span><span class="p">,</span> <span class="n">dudy</span><span class="p">],</span>
                            <span class="p">[</span><span class="n">dvdx</span><span class="p">,</span> <span class="n">dvdy</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">jac</span><span class="o">=</span><span class="n">jac</span><span class="p">)</span></div>

<div class="viewcode-block" id="ChromaticObject.shift"><a class="viewcode-back" href="../../chromaticobject.html#galsim.ChromaticObject.shift">[docs]</a>    <span class="k">def</span> <span class="nf">shift</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Apply a (possibly wavelength-dependent) (dx, dy) shift to this chromatic object.</span>

<span class="sd">        For a wavelength-independent shift, you may supply ``dx,dy`` as either two arguments, as a</span>
<span class="sd">        tuple, or as a PositionD or PositionI object.</span>

<span class="sd">        For a wavelength-dependent shift, you may supply two functions of wavelength in nanometers</span>
<span class="sd">        which will be interpreted as ``dx(wave)`` and ``dy(wave)``, or a single function of</span>
<span class="sd">        wavelength in nanometers that returns either a 2-tuple, PositionD, or PositionI.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            dx:     Horizontal shift to apply (float or function).</span>
<span class="sd">            dy:     Vertical shift to apply (float or function).</span>

<span class="sd">        Returns:</span>
<span class="sd">            the shifted object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.transform</span> <span class="kn">import</span> <span class="n">Transform</span>
        <span class="c1"># This follows along the galsim.utilities.pos_args function, but has some</span>
        <span class="c1"># extra bits to account for the possibility of dx,dy being functions.</span>
        <span class="c1"># First unpack args/kwargs</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Then dx,dy need to be kwargs</span>
            <span class="c1"># If not, then python will raise an appropriate error.</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">dx</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;dx&#39;</span><span class="p">)</span>
                <span class="n">dy</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;dy&#39;</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;shift() requires exactly 2 arguments (dx, dy)&#39;</span><span class="p">)</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;__call__&#39;</span><span class="p">):</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">](</span><span class="mf">700.</span><span class="p">)</span><span class="o">.</span><span class="n">x</span>
                    <span class="c1"># If the function returns a Position, recast it as a function returning</span>
                    <span class="c1"># a numpy array.</span>
                    <span class="k">def</span> <span class="nf">offset_func</span><span class="p">(</span><span class="n">w</span><span class="p">):</span>
                        <span class="n">d</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">](</span><span class="n">w</span><span class="p">)</span>
                        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span> <span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">d</span><span class="o">.</span><span class="n">y</span><span class="p">)</span> <span class="p">)</span>
                    <span class="n">offset</span> <span class="o">=</span> <span class="n">offset_func</span>
                <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                    <span class="c1"># Then it&#39;s a function returning a tuple or list or array.</span>
                    <span class="c1"># Just make sure it is actually an array to make our life easier later.</span>
                    <span class="n">offset</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">w</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">](</span><span class="n">w</span><span class="p">))</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Position</span><span class="p">):</span>
                <span class="n">offset</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span> <span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">y</span><span class="p">)</span> <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Let python raise the appropriate exception if this isn&#39;t valid.</span>
                <span class="n">dx</span><span class="p">,</span> <span class="n">dy</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">offset</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span> <span class="p">(</span><span class="n">dx</span><span class="p">,</span> <span class="n">dy</span><span class="p">)</span> <span class="p">)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">dx</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">dy</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Too many arguments supplied!&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Got unexpected keyword arguments: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span><span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

        <span class="k">if</span> <span class="n">offset</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="n">utilities</span><span class="o">.</span><span class="n">functionize</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">:(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">))(</span><span class="n">dx</span><span class="p">,</span> <span class="n">dy</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">Transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="n">offset</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_shift</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dx</span><span class="p">,</span> <span class="n">dy</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Equivalent to `ChromaticObject.shift`, but only valid for a scalar shift (dx, dy)</span>
<span class="sd">        not any of the possible wavelength-dependent options.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            dx:         The x-component of the shift to apply</span>
<span class="sd">            dy:         The y-component of the shift to apply</span>

<span class="sd">        Returns:</span>
<span class="sd">            the shifted object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.transform</span> <span class="kn">import</span> <span class="n">Transform</span>
        <span class="k">return</span> <span class="n">Transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="n">_PositionD</span><span class="p">(</span><span class="n">dx</span><span class="p">,</span><span class="n">dy</span><span class="p">))</span></div>

<span class="n">ChromaticObject</span><span class="o">.</span><span class="n">_multiplier_cache</span> <span class="o">=</span> <span class="n">utilities</span><span class="o">.</span><span class="n">LRU_Cache</span><span class="p">(</span>
    <span class="n">ChromaticObject</span><span class="o">.</span><span class="n">_get_multiplier</span><span class="p">,</span> <span class="n">maxsize</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>


<div class="viewcode-block" id="InterpolatedChromaticObject"><a class="viewcode-back" href="../../chromaticobject.html#galsim.InterpolatedChromaticObject">[docs]</a><span class="k">class</span> <span class="nc">InterpolatedChromaticObject</span><span class="p">(</span><span class="n">ChromaticObject</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A `ChromaticObject` that uses interpolation of predrawn images to speed up subsequent</span>
<span class="sd">    rendering.</span>

<span class="sd">    This class wraps another `ChromaticObject`, which is stored in the attribute ``deinterpolated``.</span>
<span class="sd">    Any `ChromaticObject` can be used, although the interpolation procedure is most effective</span>
<span class="sd">    for non-separable objects, which can sometimes be very slow to render.</span>

<span class="sd">    Normally, you would not create an InterpolatedChromaticObject directly.  It is the</span>
<span class="sd">    return type from `ChromaticObject.interpolate`.  See the description of that function</span>
<span class="sd">    for more details.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        original:       The `ChromaticObject` to be interpolated.</span>
<span class="sd">        waves:          The list, tuple, or NumPy array of wavelengths to be used when</span>
<span class="sd">                        building up the grid of images for interpolation.  The wavelengths</span>
<span class="sd">                        should be given in nanometers, and they should span the full range</span>
<span class="sd">                        of wavelengths covered by any bandpass to be used for drawing an `Image`</span>
<span class="sd">                        (i.e., this class will not extrapolate beyond the given range of</span>
<span class="sd">                        wavelengths).  They can be spaced any way the user likes, not</span>
<span class="sd">                        necessarily linearly, though interpolation will be linear in</span>
<span class="sd">                        wavelength between the specified wavelengths.</span>
<span class="sd">        oversample_fac: Factor by which to oversample the stored profiles compared to the</span>
<span class="sd">                        default, which is to sample them at the Nyquist frequency for</span>
<span class="sd">                        whichever wavelength has the highest Nyquist frequency.</span>
<span class="sd">                        ``oversample_fac``&gt;1 results in higher accuracy but costlier</span>
<span class="sd">                        pre-computations (more memory and time). [default: 1]</span>
<span class="sd">        use_exact_SED:  If true, then rescale the interpolated image for a given wavelength by</span>
<span class="sd">                        the ratio of the exact `SED` at that wavelength to the linearly</span>
<span class="sd">                        interpolated `SED` at that wavelength.  Thus, the flux of the interpolated</span>
<span class="sd">                        object should be correct, at the possible expense of other features.</span>
<span class="sd">                        [default: True]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">original</span><span class="p">,</span> <span class="n">waves</span><span class="p">,</span> <span class="n">oversample_fac</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">use_exact_SED</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">waves</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">waves</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">oversample</span> <span class="o">=</span> <span class="n">oversample_fac</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">use_exact_SED</span> <span class="o">=</span> <span class="n">use_exact_SED</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">separable</span> <span class="o">=</span> <span class="n">original</span><span class="o">.</span><span class="n">separable</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">interpolated</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">SED</span> <span class="o">=</span> <span class="n">original</span><span class="o">.</span><span class="n">SED</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">wave_list</span> <span class="o">=</span> <span class="n">original</span><span class="o">.</span><span class="n">wave_list</span>

        <span class="c1"># Don&#39;t interpolate an interpolation.  Go back to the original.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">deinterpolated</span> <span class="o">=</span> <span class="n">original</span><span class="o">.</span><span class="n">deinterpolated</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_build_objs</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_build_objs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Make the objects between which we are going to interpolate.  Note that these do not have</span>
        <span class="c1"># to be saved for later, unlike the images.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_objs</span> <span class="o">=</span> <span class="p">[</span> <span class="bp">self</span><span class="o">.</span><span class="n">deinterpolated</span><span class="o">.</span><span class="n">evaluateAtWavelength</span><span class="p">(</span><span class="n">wave</span><span class="p">)</span> <span class="k">for</span> <span class="n">wave</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">waves</span> <span class="p">]</span>

        <span class="c1"># Find the Nyquist scale for each, and to be safe, choose the minimum value to use for the</span>
        <span class="c1"># array of images that is being stored.</span>
        <span class="n">nyquist_scale_vals</span> <span class="o">=</span> <span class="p">[</span> <span class="n">obj</span><span class="o">.</span><span class="n">nyquist_scale</span> <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_objs</span> <span class="p">]</span>
        <span class="n">scale</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">nyquist_scale_vals</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">oversample</span>

        <span class="c1"># Find the suggested image size for each object given the choice of scale, and use the</span>
        <span class="c1"># maximum just to be safe.</span>
        <span class="n">possible_im_sizes</span> <span class="o">=</span> <span class="p">[</span> <span class="n">obj</span><span class="o">.</span><span class="n">getGoodImageSize</span><span class="p">(</span><span class="n">scale</span><span class="p">)</span> <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_objs</span> <span class="p">]</span>
        <span class="n">im_size</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">possible_im_sizes</span><span class="p">)</span>

        <span class="c1"># Find the stepk and maxk values for each object.  These will be used later on, so that we</span>
        <span class="c1"># can force these values when instantiating InterpolatedImages before drawing.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stepk_vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span> <span class="n">obj</span><span class="o">.</span><span class="n">stepk</span> <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_objs</span> <span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">maxk_vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span> <span class="n">obj</span><span class="o">.</span><span class="n">maxk</span> <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_objs</span> <span class="p">])</span>

        <span class="c1"># Finally, now that we have an image scale and size, draw all the images.  Note that</span>
        <span class="c1"># `no_pixel` is used (we want the object on its own, without a pixel response).</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ims</span> <span class="o">=</span> <span class="p">[</span> <span class="n">obj</span><span class="o">.</span><span class="n">drawImage</span><span class="p">(</span><span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">,</span> <span class="n">nx</span><span class="o">=</span><span class="n">im_size</span><span class="p">,</span> <span class="n">ny</span><span class="o">=</span><span class="n">im_size</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;no_pixel&#39;</span><span class="p">)</span>
                     <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_objs</span> <span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fluxes</span> <span class="o">=</span> <span class="p">[</span> <span class="n">obj</span><span class="o">.</span><span class="n">flux</span> <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_objs</span> <span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">gsparams</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The `GSParams` for this object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">deinterpolated</span><span class="o">.</span><span class="n">gsparams</span>

<div class="viewcode-block" id="InterpolatedChromaticObject.withGSParams"><a class="viewcode-back" href="../../chromaticobject.html#galsim.InterpolatedChromaticObject.withGSParams">[docs]</a>    <span class="nd">@doc_inherit</span>
    <span class="k">def</span> <span class="nf">withGSParams</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gsparams</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">gsparams</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">gsparams</span><span class="p">:</span> <span class="k">return</span> <span class="bp">self</span>
        <span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">copy</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">deinterpolated</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">deinterpolated</span><span class="o">.</span><span class="n">withGSParams</span><span class="p">(</span><span class="n">gsparams</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">_build_objs</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">ret</span></div>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span> <span class="ow">is</span> <span class="n">other</span> <span class="ow">or</span>
                <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">InterpolatedChromaticObject</span><span class="p">)</span> <span class="ow">and</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">deinterpolated</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">deinterpolated</span> <span class="ow">and</span>
                 <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">waves</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">waves</span><span class="p">)</span> <span class="ow">and</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">oversample</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">oversample</span> <span class="ow">and</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">use_exact_SED</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">use_exact_SED</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">((</span><span class="s2">&quot;galsim.InterpolatedChromaticObject&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">deinterpolated</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">waves</span><span class="p">),</span>
                     <span class="bp">self</span><span class="o">.</span><span class="n">oversample</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_exact_SED</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">s</span> <span class="o">=</span> <span class="s1">&#39;galsim.InterpolatedChromaticObject(</span><span class="si">%r</span><span class="s1">,</span><span class="si">%r</span><span class="s1">&#39;</span><span class="o">%</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">deinterpolated</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">waves</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">oversample</span> <span class="o">!=</span> <span class="mf">1.0</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="s1">&#39;, oversample_fac=</span><span class="si">%r</span><span class="s1">&#39;</span><span class="o">%</span><span class="bp">self</span><span class="o">.</span><span class="n">oversample</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_exact_SED</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="s1">&#39;, use_exact_SED=False&#39;</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="s1">&#39;)&#39;</span>
        <span class="k">return</span> <span class="n">s</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;galsim.InterpolatedChromaticObject(</span><span class="si">%s</span><span class="s1">,</span><span class="si">%s</span><span class="s1">)&#39;</span><span class="o">%</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">deinterpolated</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">waves</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_imageAtWavelength</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">wave</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get an image of the object at a particular wavelength, using linear interpolation between</span>
<span class="sd">        the originally-stored images.  Also returns values for step_k and max_k, to be used to</span>
<span class="sd">        expedite the instantation of `InterpolatedImage`.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            wave:   Wavelength in nanometers.</span>

<span class="sd">        Returns:</span>
<span class="sd">            an `Image` of the object at the given wavelength.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># First, some wavelength-related sanity checks.</span>
        <span class="k">if</span> <span class="n">wave</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">waves</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">or</span> <span class="n">wave</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">waves</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="n">GalSimRangeError</span><span class="p">(</span><span class="s2">&quot;Requested wavelength is outside the allowed range.&quot;</span><span class="p">,</span>
                                   <span class="n">wave</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">waves</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">waves</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="c1"># Figure out where the supplied wavelength is compared to the list of wavelengths on which</span>
        <span class="c1"># images were originally tabulated.</span>
        <span class="n">lower_idx</span><span class="p">,</span> <span class="n">frac</span> <span class="o">=</span> <span class="n">_findWave</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">waves</span><span class="p">,</span> <span class="n">wave</span><span class="p">)</span>

        <span class="c1"># Actually do the interpolation for the image, stepk, and maxk.</span>
        <span class="n">im</span> <span class="o">=</span> <span class="n">_linearInterp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ims</span><span class="p">,</span> <span class="n">frac</span><span class="p">,</span> <span class="n">lower_idx</span><span class="p">)</span>
        <span class="n">stepk</span> <span class="o">=</span> <span class="n">_linearInterp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stepk_vals</span><span class="p">,</span> <span class="n">frac</span><span class="p">,</span> <span class="n">lower_idx</span><span class="p">)</span>
        <span class="n">maxk</span> <span class="o">=</span> <span class="n">_linearInterp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">maxk_vals</span><span class="p">,</span> <span class="n">frac</span><span class="p">,</span> <span class="n">lower_idx</span><span class="p">)</span>

        <span class="c1"># Rescale to use the exact flux or normalization if requested.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_exact_SED</span><span class="p">:</span>
            <span class="n">interp_norm</span> <span class="o">=</span> <span class="n">_linearInterp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fluxes</span><span class="p">,</span> <span class="n">frac</span><span class="p">,</span> <span class="n">lower_idx</span><span class="p">)</span>
            <span class="n">exact_norm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">SED</span><span class="p">(</span><span class="n">wave</span><span class="p">)</span>
            <span class="n">im</span> <span class="o">*=</span> <span class="n">exact_norm</span><span class="o">/</span><span class="n">interp_norm</span>

        <span class="k">return</span> <span class="n">im</span><span class="p">,</span> <span class="n">stepk</span><span class="p">,</span> <span class="n">maxk</span>

    <span class="k">def</span> <span class="nf">_approxWavelength</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">wave</span><span class="p">):</span>
        <span class="c1"># More efficient to use one of the original objects, not a new InterpolatedImage.</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">waves</span><span class="p">,</span> <span class="n">wave</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">waves</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">k</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">wave</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">waves</span><span class="p">[</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">waves</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">-</span><span class="n">wave</span><span class="p">):</span>
            <span class="n">k</span> <span class="o">=</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">waves</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_objs</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>

<div class="viewcode-block" id="InterpolatedChromaticObject.evaluateAtWavelength"><a class="viewcode-back" href="../../chromaticobject.html#galsim.InterpolatedChromaticObject.evaluateAtWavelength">[docs]</a>    <span class="k">def</span> <span class="nf">evaluateAtWavelength</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">wave</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluate this `ChromaticObject` at a particular wavelength using interpolation.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            wave:   Wavelength in nanometers.</span>

<span class="sd">        Returns:</span>
<span class="sd">            the monochromatic object at the given wavelength, as a `GSObject`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.interpolatedimage</span> <span class="kn">import</span> <span class="n">InterpolatedImage</span>
        <span class="n">im</span><span class="p">,</span> <span class="n">stepk</span><span class="p">,</span> <span class="n">maxk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_imageAtWavelength</span><span class="p">(</span><span class="n">wave</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">InterpolatedImage</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">_force_stepk</span><span class="o">=</span><span class="n">stepk</span><span class="p">,</span> <span class="n">_force_maxk</span><span class="o">=</span><span class="n">maxk</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_shoot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">photons</span><span class="p">,</span> <span class="n">rng</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">.photon_array</span> <span class="kn">import</span> <span class="n">PhotonArray</span>
        <span class="kn">from</span> <span class="nn">.random</span> <span class="kn">import</span> <span class="n">UniformDeviate</span>

        <span class="n">w</span> <span class="o">=</span> <span class="n">photons</span><span class="o">.</span><span class="n">wavelength</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">((</span><span class="n">w</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">waves</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">|</span> <span class="p">(</span><span class="n">w</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">waves</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])):</span>
            <span class="k">raise</span> <span class="n">GalSimRangeError</span><span class="p">(</span><span class="s2">&quot;Shooting photons outside the interpolated wave_list&quot;</span><span class="p">,</span>
                                   <span class="n">w</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">waves</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">waves</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="n">k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">waves</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
        <span class="n">k</span><span class="p">[</span><span class="n">k</span><span class="o">==</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># if k == 0, then w == min(waves). Using k=1 instead is fine for this.</span>
        <span class="c1">#assert np.all(k &gt; 0)</span>
        <span class="c1">#assert np.all(k &lt; len(self.waves))</span>

        <span class="c1"># For each w, these are the wavelengthat that bracket w:</span>
        <span class="n">w0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">waves</span><span class="p">[</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">w1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">waves</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
        <span class="c1">#assert np.all(w0 &lt;= w)</span>
        <span class="c1">#assert np.all(w &lt;= w1)</span>

        <span class="c1"># If we could get away with averaging photons shot at each wavelength,</span>
        <span class="c1"># these would be relative fractions.  So e.g. x = x0 f0 + x1 f1 would be the</span>
        <span class="c1"># right weighted average to use.</span>
        <span class="n">f0</span> <span class="o">=</span> <span class="p">(</span><span class="n">w1</span><span class="o">-</span><span class="n">w</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">w1</span><span class="o">-</span><span class="n">w0</span><span class="p">)</span>
        <span class="c1">#f1 = (w-w0) / (w1-w0)  (We don&#39;t need this quantity below.)</span>

        <span class="c1"># Instead of averaging these, we can do the averaging probabilistically by selecting</span>
        <span class="c1"># each photon with a probability equal to the relative weight we would have used</span>
        <span class="c1"># in the average.</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">photons</span><span class="p">))</span>
        <span class="n">UniformDeviate</span><span class="p">(</span><span class="n">rng</span><span class="p">)</span><span class="o">.</span><span class="n">generate</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
        <span class="n">use_k</span> <span class="o">=</span> <span class="n">k</span> <span class="o">-</span> <span class="p">(</span><span class="n">u</span><span class="o">&lt;</span><span class="n">f0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>  <span class="c1"># The second term is either 0 or 1.</span>

        <span class="c1"># Draw photons from the saved profiles according to when we have selected to use each one.</span>
        <span class="k">for</span> <span class="n">kk</span><span class="p">,</span> <span class="n">obj</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_objs</span><span class="p">):</span>
            <span class="n">use</span> <span class="o">=</span> <span class="p">(</span><span class="n">use_k</span> <span class="o">==</span> <span class="n">kk</span><span class="p">)</span>  <span class="c1"># True for each photon where this is the object to shoot from</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="n">PhotonArray</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">use</span><span class="p">))</span>
            <span class="n">obj</span><span class="o">.</span><span class="n">_shoot</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="n">rng</span><span class="p">)</span>
            <span class="n">photons</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="n">use</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span><span class="o">.</span><span class="n">x</span>
            <span class="n">photons</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="n">use</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span><span class="o">.</span><span class="n">y</span>
            <span class="c1"># It will have tried to shoot the right total flux.  But that&#39;s not correct.</span>
            <span class="c1"># Rescale it down by the fraction of the total flux we actually want in this set.</span>
            <span class="n">photons</span><span class="o">.</span><span class="n">flux</span><span class="p">[</span><span class="n">use</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span><span class="o">.</span><span class="n">flux</span> <span class="o">*</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">photons</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_get_interp_image</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bandpass</span><span class="p">,</span> <span class="n">image</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">integrator</span><span class="o">=</span><span class="s1">&#39;quadratic&#39;</span><span class="p">,</span>
                          <span class="n">_flux_ratio</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">.interpolatedimage</span> <span class="kn">import</span> <span class="n">InterpolatedImage</span>
        <span class="k">if</span> <span class="n">integrator</span> <span class="o">==</span> <span class="s1">&#39;quadratic&#39;</span><span class="p">:</span>
            <span class="n">rule</span> <span class="o">=</span> <span class="n">integ</span><span class="o">.</span><span class="n">quadRule</span>
        <span class="k">elif</span> <span class="n">integrator</span> <span class="o">==</span> <span class="s1">&#39;trapezoidal&#39;</span><span class="p">:</span>
            <span class="n">rule</span> <span class="o">=</span> <span class="n">integ</span><span class="o">.</span><span class="n">trapzRule</span>
        <span class="k">elif</span> <span class="n">integrator</span> <span class="o">==</span> <span class="s1">&#39;midpoint&#39;</span><span class="p">:</span>
            <span class="n">rule</span> <span class="o">=</span> <span class="n">integ</span><span class="o">.</span><span class="n">midptRule</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">GalSimValueError</span><span class="p">(</span><span class="s2">&quot;Unrecognized integration rule&quot;</span><span class="p">,</span> <span class="n">integrator</span><span class="p">,</span>
                                    <span class="p">(</span><span class="s1">&#39;trapezoidal&#39;</span><span class="p">,</span> <span class="s1">&#39;midpoint&#39;</span><span class="p">,</span> <span class="s1">&#39;quadratic&#39;</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">_flux_ratio</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">_flux_ratio</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">w</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
        <span class="c1"># Constant flux_ratio is already an SED at this point, so can treat as function.</span>
        <span class="c1">#assert hasattr(_flux_ratio, &#39;__call__&#39;)</span>

        <span class="c1"># setup output image (semi-arbitrarily using the bandpass effective wavelength).</span>
        <span class="c1"># Note: we cannot just use self._imageAtWavelength, because that routine returns an image</span>
        <span class="c1"># with whatever pixel scale was required to sample all the images properly.  We want to set</span>
        <span class="c1"># up an output image that has the requested pixel scale, which might change the image size</span>
        <span class="c1"># and so on.</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">prof0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fiducial_profile</span><span class="p">(</span><span class="n">bandpass</span><span class="p">)</span>
        <span class="n">image</span> <span class="o">=</span> <span class="n">prof0</span><span class="o">.</span><span class="n">drawImage</span><span class="p">(</span><span class="n">image</span><span class="o">=</span><span class="n">image</span><span class="p">,</span> <span class="n">setup_only</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">_remove_setup_kwargs</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># determine combination of self.wave_list and bandpass.wave_list</span>
        <span class="n">wave_objs</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="p">,</span> <span class="n">bandpass</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">_flux_ratio</span><span class="p">,</span> <span class="n">SED</span><span class="p">):</span>
            <span class="n">wave_objs</span> <span class="o">+=</span> <span class="p">[</span><span class="n">_flux_ratio</span><span class="p">]</span>
        <span class="n">wave_list</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">utilities</span><span class="o">.</span><span class="n">combine_wave_list</span><span class="p">(</span><span class="n">wave_objs</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">((</span><span class="n">wave_list</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">waves</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">|</span> <span class="p">(</span><span class="n">wave_list</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">waves</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])):</span>  <span class="c1"># pragma: no cover</span>
            <span class="c1"># MJ: I&#39;m pretty sure it&#39;s impossible to hit this.</span>
            <span class="c1">#     But just in case I&#39;m wrong, I&#39;m leaving it here but with pragma: no cover.</span>
            <span class="k">raise</span> <span class="n">GalSimRangeError</span><span class="p">(</span><span class="s2">&quot;Requested wavelength is outside the allowed range.&quot;</span><span class="p">,</span>
                                   <span class="n">wave_list</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">waves</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">waves</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="c1"># weights are the weights to use at each of the given wavelengths for the integration.</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="n">rule</span><span class="o">.</span><span class="n">calculateWeights</span><span class="p">(</span><span class="n">wave_list</span><span class="p">,</span> <span class="n">bandpass</span><span class="p">)</span>
        <span class="c1"># im_weights are the weights for the stored images.</span>
        <span class="n">im_weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">waves</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">w</span><span class="p">,</span> <span class="n">wt</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">wave_list</span><span class="p">,</span> <span class="n">weights</span><span class="p">):</span>
            <span class="c1"># Find where this is with respect to the wavelengths on which images are stored.</span>
            <span class="n">lower_idx</span><span class="p">,</span> <span class="n">frac</span> <span class="o">=</span> <span class="n">_findWave</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">waves</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
            <span class="k">assert</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">lower_idx</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">waves</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>

            <span class="c1"># Rescale to use the exact flux or normalization if requested.</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_exact_SED</span><span class="p">:</span>
                <span class="n">interp_norm</span> <span class="o">=</span> <span class="n">_linearInterp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fluxes</span><span class="p">,</span> <span class="n">frac</span><span class="p">,</span> <span class="n">lower_idx</span><span class="p">)</span>
                <span class="n">exact_norm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">SED</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
                <span class="n">wt</span> <span class="o">*=</span> <span class="n">exact_norm</span><span class="o">/</span><span class="n">interp_norm</span>

            <span class="n">im_weights</span><span class="p">[</span><span class="n">lower_idx</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span><span class="mf">1.</span><span class="o">-</span><span class="n">frac</span><span class="p">)</span> <span class="o">*</span> <span class="n">wt</span> <span class="o">*</span> <span class="n">_flux_ratio</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
            <span class="n">im_weights</span><span class="p">[</span><span class="n">lower_idx</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">frac</span> <span class="o">*</span> <span class="n">wt</span> <span class="o">*</span> <span class="n">_flux_ratio</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>

        <span class="c1"># Do the integral as a weighted sum.</span>
        <span class="n">integral</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">wt</span><span class="o">*</span><span class="n">im</span> <span class="k">for</span> <span class="n">wt</span><span class="p">,</span><span class="n">im</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">im_weights</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ims</span><span class="p">)</span> <span class="k">if</span> <span class="n">wt</span><span class="o">!=</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># Get the stepk, maxk using the same weights</span>
        <span class="n">stepk</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stepk_vals</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">im_weights</span><span class="p">)</span>
        <span class="n">maxk</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">maxk_vals</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">im_weights</span><span class="p">)</span>

        <span class="c1"># Instantiate the InterpolatedImage, using these conservative stepk and maxk choices.</span>
        <span class="k">return</span> <span class="n">InterpolatedImage</span><span class="p">(</span><span class="n">integral</span><span class="p">,</span> <span class="n">_force_stepk</span><span class="o">=</span><span class="n">stepk</span><span class="p">,</span> <span class="n">_force_maxk</span><span class="o">=</span><span class="n">maxk</span><span class="p">)</span>

<div class="viewcode-block" id="InterpolatedChromaticObject.drawImage"><a class="viewcode-back" href="../../chromaticobject.html#galsim.InterpolatedChromaticObject.drawImage">[docs]</a>    <span class="k">def</span> <span class="nf">drawImage</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bandpass</span><span class="p">,</span> <span class="n">image</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">integrator</span><span class="o">=</span><span class="s1">&#39;quadratic&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Draw an image as seen through a particular bandpass using the stored interpolated</span>
<span class="sd">        images at the specified wavelengths.</span>

<span class="sd">        This integration will take place using interpolation between stored images that were</span>
<span class="sd">        setup when the object was constructed.  (See interpolate() for more details.)</span>

<span class="sd">        Parameters:</span>
<span class="sd">            bandpass:       A `Bandpass` object representing the filter against which to</span>
<span class="sd">                            integrate.</span>
<span class="sd">            image:          Optionally, the `Image` to draw onto.  (See `GSObject.drawImage`</span>
<span class="sd">                            for details.)  [default: None]</span>
<span class="sd">            integrator:     The integration algorithm to use, given as a string.  Either</span>
<span class="sd">                            &#39;midpoint&#39;, &#39;trapezoidal&#39;, or &#39;quadratic&#39; is allowed.</span>
<span class="sd">                            [default: &#39;quadratic&#39;]</span>
<span class="sd">            **kwargs:       For all other kwarg options, see `GSObject.drawImage`.</span>

<span class="sd">        Returns:</span>
<span class="sd">            the drawn `Image`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Store the last bandpass used.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_last_bp</span> <span class="o">=</span> <span class="n">bandpass</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">SED</span><span class="o">.</span><span class="n">dimensionless</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">GalSimSEDError</span><span class="p">(</span><span class="s2">&quot;Can only draw ChromaticObjects with spectral SEDs.&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">SED</span><span class="p">)</span>

        <span class="n">int_im</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_interp_image</span><span class="p">(</span><span class="n">bandpass</span><span class="p">,</span> <span class="n">image</span><span class="o">=</span><span class="n">image</span><span class="p">,</span> <span class="n">integrator</span><span class="o">=</span><span class="n">integrator</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">image</span> <span class="o">=</span> <span class="n">int_im</span><span class="o">.</span><span class="n">drawImage</span><span class="p">(</span><span class="n">image</span><span class="o">=</span><span class="n">image</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_last_wcs</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">wcs</span>
        <span class="k">return</span> <span class="n">image</span></div></div>


<div class="viewcode-block" id="ChromaticAtmosphere"><a class="viewcode-back" href="../../chromaticobject.html#galsim.ChromaticAtmosphere">[docs]</a><span class="k">class</span> <span class="nc">ChromaticAtmosphere</span><span class="p">(</span><span class="n">ChromaticObject</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A `ChromaticObject` implementing two atmospheric chromatic effects: differential</span>
<span class="sd">    chromatic refraction (DCR) and wavelength-dependent seeing.</span>

<span class="sd">    Due to DCR, blue photons land closer to the zenith than red photons.  Kolmogorov turbulence</span>
<span class="sd">    also predicts that blue photons get spread out more by the atmosphere than red photons,</span>
<span class="sd">    specifically FWHM is proportional to wavelength^(-0.2).  Both of these effects can be</span>
<span class="sd">    implemented by wavelength-dependent shifts and dilations.</span>

<span class="sd">    Since DCR depends on the zenith angle and the parallactic angle (which is the position angle of</span>
<span class="sd">    the zenith measured from North through East) of the object being drawn, these must be specified</span>
<span class="sd">    via keywords.  There are four ways to specify these values:</span>

<span class="sd">      1) explicitly provide ``zenith_angle`` as a keyword of type `Angle`, and</span>
<span class="sd">         ``parallactic_angle`` will be assumed to be 0 by default.</span>
<span class="sd">      2) explicitly provide both ``zenith_angle`` and ``parallactic_angle`` as keywords of type</span>
<span class="sd">         `Angle`.</span>
<span class="sd">      3) provide the coordinates of the object ``obj_coord`` and the coordinates of the zenith</span>
<span class="sd">         ``zenith_coord`` as keywords of type `CelestialCoord`.</span>
<span class="sd">      4) provide the coordinates of the object ``obj_coord`` as a `CelestialCoord`, the hour angle</span>
<span class="sd">         of the object ``HA`` as an `Angle`, and the latitude of the observer ``latitude`` as an</span>
<span class="sd">         `Angle`.</span>

<span class="sd">    DCR also depends on temperature, pressure and water vapor pressure of the atmosphere.  The</span>
<span class="sd">    default values for these are expected to be appropriate for LSST at Cerro Pachon, Chile, but</span>
<span class="sd">    they are broadly reasonable for most observatories.</span>

<span class="sd">    Note that a ChromaticAtmosphere by itself is NOT the correct thing to use to draw an image of a</span>
<span class="sd">    star. Stars (and galaxies too, of course) have an `SED` that is not flat. To draw a real star,</span>
<span class="sd">    you should either multiply the ChromaticAtmosphere object by an `SED`, or convolve it with a</span>
<span class="sd">    point source multiplied by an `SED`::</span>

<span class="sd">        &gt;&gt;&gt; psf = galsim.ChromaticAtmosphere(...)</span>
<span class="sd">        &gt;&gt;&gt; star = galsim.DeltaFunction() * psf_sed</span>
<span class="sd">        &gt;&gt;&gt; final_star = galsim.Convolve( [psf, star] )</span>
<span class="sd">        &gt;&gt;&gt; final_star.drawImage(bandpass = bp, ...)</span>

<span class="sd">    Parameters:</span>
<span class="sd">        base_obj:           Fiducial PSF, equal to the monochromatic PSF at ``base_wavelength``</span>
<span class="sd">        base_wavelength:    Wavelength represented by the fiducial PSF, in nanometers.</span>
<span class="sd">        scale_unit:         Units used by base_obj for its linear dimensions.</span>
<span class="sd">                            [default: galsim.arcsec]</span>
<span class="sd">        alpha:              Power law index for wavelength-dependent seeing.  [default: -0.2,</span>
<span class="sd">                            the prediction for Kolmogorov turbulence]</span>
<span class="sd">        zenith_angle:       `Angle` from object to zenith [default: 0]</span>
<span class="sd">        parallactic_angle:  Parallactic angle, i.e. the position angle of the zenith, measured</span>
<span class="sd">                            from North through East.  [default: 0]</span>
<span class="sd">        obj_coord:          Celestial coordinates of the object being drawn as a</span>
<span class="sd">                            `CelestialCoord`. [default: None]</span>
<span class="sd">        zenith_coord:       Celestial coordinates of the zenith as a `CelestialCoord`.</span>
<span class="sd">                            [default: None]</span>
<span class="sd">        HA:                 Hour angle of the object as an `Angle`. [default: None]</span>
<span class="sd">        latitude:           Latitude of the observer as an `Angle`. [default: None]</span>
<span class="sd">        pressure:           Air pressure in kiloPascals.  [default: 69.328 kPa]</span>
<span class="sd">        temperature:        Temperature in Kelvins.  [default: 293.15 K]</span>
<span class="sd">        H2O_pressure:       Water vapor pressure in kiloPascals.  [default: 1.067 kPa]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">base_obj</span><span class="p">,</span> <span class="n">base_wavelength</span><span class="p">,</span> <span class="n">scale_unit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">.angle</span> <span class="kn">import</span> <span class="n">Angle</span><span class="p">,</span> <span class="n">_Angle</span><span class="p">,</span> <span class="n">AngleUnit</span><span class="p">,</span> <span class="n">arcsec</span>
        <span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">dcr</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">separable</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">interpolated</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">deinterpolated</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">SED</span> <span class="o">=</span> <span class="n">SED</span><span class="p">(</span><span class="n">base_obj</span><span class="o">.</span><span class="n">flux</span><span class="p">,</span> <span class="s1">&#39;nm&#39;</span><span class="p">,</span> <span class="s1">&#39;1&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">wave_list</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">base_obj</span> <span class="o">=</span> <span class="n">base_obj</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">base_wavelength</span> <span class="o">=</span> <span class="n">base_wavelength</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_gsparams</span> <span class="o">=</span> <span class="n">base_obj</span><span class="o">.</span><span class="n">gsparams</span>

        <span class="k">if</span> <span class="n">scale_unit</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">scale_unit</span> <span class="o">=</span> <span class="n">arcsec</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">scale_unit</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">scale_unit</span> <span class="o">=</span> <span class="n">AngleUnit</span><span class="o">.</span><span class="n">from_name</span><span class="p">(</span><span class="n">scale_unit</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scale_unit</span> <span class="o">=</span> <span class="n">scale_unit</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;alpha&#39;</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.2</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">zenith_angle</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">parallactic_angle</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">kw</span> <span class="o">=</span> <span class="n">dcr</span><span class="o">.</span><span class="n">parse_dcr_angles</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Any remaining kwargs will get forwarded to galsim.dcr.get_refraction</span>
        <span class="c1"># Check that they&#39;re valid</span>
        <span class="k">for</span> <span class="n">kw</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">kw</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">kw</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;temperature&#39;</span><span class="p">,</span> <span class="s1">&#39;pressure&#39;</span><span class="p">,</span> <span class="s1">&#39;H2O_pressure&#39;</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Got unexpected keyword: </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">kw</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">base_refraction</span> <span class="o">=</span> <span class="n">dcr</span><span class="o">.</span><span class="n">get_refraction</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base_wavelength</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">zenith_angle</span><span class="p">,</span>
                                                  <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">kw</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">gsparams</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The `GSParams` for this object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_obj</span><span class="o">.</span><span class="n">gsparams</span>

<div class="viewcode-block" id="ChromaticAtmosphere.withGSParams"><a class="viewcode-back" href="../../chromaticobject.html#galsim.ChromaticAtmosphere.withGSParams">[docs]</a>    <span class="nd">@doc_inherit</span>
    <span class="k">def</span> <span class="nf">withGSParams</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gsparams</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">gsparams</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">gsparams</span><span class="p">:</span> <span class="k">return</span> <span class="bp">self</span>
        <span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">copy</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">base_obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_obj</span><span class="o">.</span><span class="n">withGSParams</span><span class="p">(</span><span class="n">gsparams</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ret</span></div>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span> <span class="ow">is</span> <span class="n">other</span> <span class="ow">or</span>
                <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">ChromaticAtmosphere</span><span class="p">)</span> <span class="ow">and</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">base_obj</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">base_obj</span> <span class="ow">and</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">base_wavelength</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">base_wavelength</span> <span class="ow">and</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">alpha</span> <span class="ow">and</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">zenith_angle</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">zenith_angle</span> <span class="ow">and</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">parallactic_angle</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">parallactic_angle</span> <span class="ow">and</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">scale_unit</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">scale_unit</span> <span class="ow">and</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">kw</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">kw</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">((</span><span class="s2">&quot;galsim.ChromaticAtmosphere&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_obj</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_wavelength</span><span class="p">,</span>
                     <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">zenith_angle</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">parallactic_angle</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale_unit</span><span class="p">,</span>
                     <span class="nb">frozenset</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kw</span><span class="o">.</span><span class="n">items</span><span class="p">())))</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">s</span> <span class="o">=</span> <span class="s1">&#39;galsim.ChromaticAtmosphere(</span><span class="si">%r</span><span class="s1">, base_wavelength=</span><span class="si">%r</span><span class="s1">, alpha=</span><span class="si">%r</span><span class="s1">&#39;</span><span class="o">%</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">base_obj</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_wavelength</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">)</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="s1">&#39;, zenith_angle=</span><span class="si">%r</span><span class="s1">, parallactic_angle=</span><span class="si">%r</span><span class="s1">&#39;</span><span class="o">%</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">zenith_angle</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">parallactic_angle</span><span class="p">)</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="s1">&#39;, scale_unit=</span><span class="si">%r</span><span class="s1">&#39;</span><span class="o">%</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scale_unit</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">kw</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="s1">&#39;, </span><span class="si">%s</span><span class="s1">=</span><span class="si">%r</span><span class="s1">&#39;</span><span class="o">%</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">)</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="s1">&#39;)&#39;</span>
        <span class="k">return</span> <span class="n">s</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;galsim.ChromaticAtmosphere(</span><span class="si">%s</span><span class="s1">, base_wavelength=</span><span class="si">%s</span><span class="s1">, alpha=</span><span class="si">%s</span><span class="s1">)&#39;</span><span class="o">%</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">base_obj</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_wavelength</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">)</span>

<div class="viewcode-block" id="ChromaticAtmosphere.build_obj"><a class="viewcode-back" href="../../chromaticobject.html#galsim.ChromaticAtmosphere.build_obj">[docs]</a>    <span class="k">def</span> <span class="nf">build_obj</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Build a `ChromaticTransformation` object for this `ChromaticAtmosphere`.</span>

<span class="sd">        We don&#39;t do this right away to help make `ChromaticAtmosphere` objects be picklable.</span>
<span class="sd">        Building this is quite fast, so we do it on the fly in `evaluateAtWavelength` and</span>
<span class="sd">        `ChromaticObject.drawImage`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">dcr</span>
        <span class="kn">from</span> <span class="nn">.angle</span> <span class="kn">import</span> <span class="n">radians</span>
        <span class="k">def</span> <span class="nf">shift_fn</span><span class="p">(</span><span class="n">w</span><span class="p">):</span>
            <span class="n">shift_magnitude</span> <span class="o">=</span> <span class="n">dcr</span><span class="o">.</span><span class="n">get_refraction</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">zenith_angle</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">kw</span><span class="p">)</span>
            <span class="n">shift_magnitude</span> <span class="o">-=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_refraction</span>
            <span class="n">shift_magnitude</span> <span class="o">=</span> <span class="n">shift_magnitude</span> <span class="o">*</span> <span class="n">radians</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale_unit</span>
            <span class="n">sinp</span><span class="p">,</span> <span class="n">cosp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parallactic_angle</span><span class="o">.</span><span class="n">sincos</span><span class="p">()</span>
            <span class="n">shift</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">shift_magnitude</span> <span class="o">*</span> <span class="n">sinp</span><span class="p">,</span> <span class="n">shift_magnitude</span> <span class="o">*</span> <span class="n">cosp</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">shift</span>

        <span class="k">def</span> <span class="nf">jac_fn</span><span class="p">(</span><span class="n">w</span><span class="p">):</span>
            <span class="n">scale</span> <span class="o">=</span> <span class="p">(</span><span class="n">w</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">base_wavelength</span><span class="p">)</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">([</span><span class="n">scale</span><span class="p">,</span> <span class="n">scale</span><span class="p">])</span>

        <span class="n">flux_ratio</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">w</span><span class="p">:</span> <span class="p">(</span><span class="n">w</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">base_wavelength</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="mf">2.</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">ChromaticTransformation</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base_obj</span><span class="p">,</span> <span class="n">jac</span><span class="o">=</span><span class="n">jac_fn</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="n">shift_fn</span><span class="p">,</span>
                                       <span class="n">flux_ratio</span><span class="o">=</span><span class="n">flux_ratio</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_shoot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">photons</span><span class="p">,</span> <span class="n">rng</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">dcr</span>
        <span class="kn">from</span> <span class="nn">.angle</span> <span class="kn">import</span> <span class="n">radians</span>

        <span class="c1"># Start with the base PSF</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">base_obj</span><span class="o">.</span><span class="n">_shoot</span><span class="p">(</span><span class="n">photons</span><span class="p">,</span> <span class="n">rng</span><span class="p">)</span>

        <span class="n">w</span> <span class="o">=</span> <span class="n">photons</span><span class="o">.</span><span class="n">wavelength</span>

        <span class="c1"># Apply the wavelength-dependent scaling</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span> <span class="o">!=</span> <span class="mf">0.</span><span class="p">:</span>
            <span class="n">scale</span> <span class="o">=</span> <span class="p">(</span><span class="n">w</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">base_wavelength</span><span class="p">)</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha</span>
            <span class="n">photons</span><span class="o">.</span><span class="n">x</span> <span class="o">*=</span> <span class="n">scale</span>
            <span class="n">photons</span><span class="o">.</span><span class="n">y</span> <span class="o">*=</span> <span class="n">scale</span>

        <span class="c1"># Apply DCR</span>
        <span class="n">shift_magnitude</span> <span class="o">=</span> <span class="n">dcr</span><span class="o">.</span><span class="n">get_refraction</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">zenith_angle</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">kw</span><span class="p">)</span>
        <span class="n">shift_magnitude</span> <span class="o">-=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_refraction</span>
        <span class="n">shift_magnitude</span> <span class="o">*=</span> <span class="n">radians</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale_unit</span>
        <span class="n">sinp</span><span class="p">,</span> <span class="n">cosp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parallactic_angle</span><span class="o">.</span><span class="n">sincos</span><span class="p">()</span>
        <span class="n">photons</span><span class="o">.</span><span class="n">x</span> <span class="o">+=</span> <span class="o">-</span><span class="n">shift_magnitude</span> <span class="o">*</span> <span class="n">sinp</span>
        <span class="n">photons</span><span class="o">.</span><span class="n">y</span> <span class="o">+=</span> <span class="n">shift_magnitude</span> <span class="o">*</span> <span class="n">cosp</span>

<div class="viewcode-block" id="ChromaticAtmosphere.evaluateAtWavelength"><a class="viewcode-back" href="../../chromaticobject.html#galsim.ChromaticAtmosphere.evaluateAtWavelength">[docs]</a>    <span class="k">def</span> <span class="nf">evaluateAtWavelength</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">wave</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Evaluate this chromatic object at a particular wavelength.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            wave:   Wavelength in nanometers.</span>

<span class="sd">        Returns:</span>
<span class="sd">            the monochromatic object at the given wavelength.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">build_obj</span><span class="p">()</span><span class="o">.</span><span class="n">evaluateAtWavelength</span><span class="p">(</span><span class="n">wave</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="ChromaticTransformation"><a class="viewcode-back" href="../../chromaticobject.html#galsim.ChromaticTransformation">[docs]</a><span class="k">class</span> <span class="nc">ChromaticTransformation</span><span class="p">(</span><span class="n">ChromaticObject</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A class for modeling a wavelength-dependent affine transformation of a `ChromaticObject`</span>
<span class="sd">    instance.</span>

<span class="sd">    Typically, you do not need to construct a ChromaticTransformation object explicitly.</span>
<span class="sd">    This is the type returned by the various transformation methods of `ChromaticObject` such as</span>
<span class="sd">    `ChromaticObject.shear`, `ChromaticObject.rotate`, `ChromaticObject.shift`, etc.</span>

<span class="sd">    All the various transformations can be described as a combination of a jacobian matrix</span>
<span class="sd">    (i.e. `ChromaticObject.transform`) and a translation (`ChromaticObject.shift`), which are</span>
<span class="sd">    described by (dudx,dudy,dvdx,dvdy) and (dx,dy) respectively.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        obj:                The object to be transformed.</span>
<span class="sd">        jac:                A list or tuple (dudx, dudy, dvdx, dvdy), or a numpy.array object</span>
<span class="sd">                            [[dudx, dudy], [dvdx, dvdy]] describing the Jacobian to apply.  May</span>
<span class="sd">                            also be a function of wavelength returning a numpy array.</span>
<span class="sd">                            Use None to indicate that the Jacobian is the 2x2 unit matrix.</span>
<span class="sd">                            [default: None]</span>
<span class="sd">        offset:             A galsim.PositionD or list or tuple or numpy array giving the offset</span>
<span class="sd">                            (dx,dy) by which to shift the profile.  May also be a function of</span>
<span class="sd">                            wavelength returning a numpy array.  [default: None]</span>
<span class="sd">        flux_ratio:         A factor by which to multiply the flux of the object. [default: 1]</span>
<span class="sd">        redshift:           A redshift to apply to the wavelength when evaluating. [default: None]</span>
<span class="sd">        gsparams:           An optional `GSParams` argument.  See the docstring for `GSParams` for</span>
<span class="sd">                            details. [default: None]</span>
<span class="sd">        propagate_gsparams: Whether to propagate gsparams to each of the components.  This</span>
<span class="sd">                            is normally a good idea, but there may be use cases where one</span>
<span class="sd">                            would not want to do this. [default: True]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">jac</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="p">(</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">),</span> <span class="n">flux_ratio</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span> <span class="n">redshift</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">gsparams</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">propagate_gsparams</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="n">Position</span><span class="p">):</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="p">(</span><span class="n">offset</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">offset</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">jac</span><span class="p">,</span><span class="s1">&#39;__call__&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">jac</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">jac</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">jac</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span><span class="s1">&#39;__call__&#39;</span><span class="p">):</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">offset</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">chromatic</span> <span class="o">=</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">jac</span><span class="p">,</span><span class="s1">&#39;__call__&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span><span class="s1">&#39;__call__&#39;</span><span class="p">)</span>
        <span class="c1"># Technically, if the only chromatic transformation is a flux_ratio, and the original object</span>
        <span class="c1"># is separable, then the transformation is still separable (for instance, galsim.Chromatic),</span>
        <span class="c1"># but we&#39;ll ignore that here.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">separable</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">separable</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">chromatic</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">SED</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">SED</span> <span class="o">*</span> <span class="n">flux_ratio</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">wave_list</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">utilities</span><span class="o">.</span><span class="n">combine_wave_list</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">SED</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_redshift</span> <span class="o">=</span> <span class="n">redshift</span>
        <span class="k">if</span> <span class="n">redshift</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">SED</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">SED</span><span class="o">.</span><span class="n">atRedshift</span><span class="p">(</span><span class="n">redshift</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">wave_list</span> <span class="o">*=</span> <span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">redshift</span><span class="p">)</span>

        <span class="c1"># Need to account for non-unit determinant jacobian in normalization.</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">jac</span><span class="p">,</span> <span class="s1">&#39;__call__&#39;</span><span class="p">):</span>
            <span class="nd">@np</span><span class="o">.</span><span class="n">vectorize</span>
            <span class="k">def</span> <span class="nf">detjac</span><span class="p">(</span><span class="n">w</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">jac</span><span class="p">(</span><span class="n">w</span><span class="p">))</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">SED</span> <span class="o">*=</span> <span class="n">detjac</span>
        <span class="k">elif</span> <span class="n">jac</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">SED</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">jac</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">obj</span><span class="o">.</span><span class="n">interpolated</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">chromatic</span><span class="p">:</span>
            <span class="n">galsim_warn</span><span class="p">(</span><span class="s2">&quot;Cannot render image with chromatic transformation applied to it &quot;</span>
                        <span class="s2">&quot;using interpolation between stored images.  Reverting to &quot;</span>
                        <span class="s2">&quot;non-interpolated version.&quot;</span><span class="p">)</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">deinterpolated</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">interpolated</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">interpolated</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_gsparams</span> <span class="o">=</span> <span class="n">GSParams</span><span class="o">.</span><span class="n">check</span><span class="p">(</span><span class="n">gsparams</span><span class="p">,</span> <span class="n">obj</span><span class="o">.</span><span class="n">gsparams</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_propagate_gsparams</span> <span class="o">=</span> <span class="n">propagate_gsparams</span>

        <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">ChromaticTransformation</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">chromatic</span>
                <span class="ow">and</span> <span class="ow">not</span> <span class="n">obj</span><span class="o">.</span><span class="n">chromatic</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_redshift</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">obj</span><span class="o">.</span><span class="n">_redshift</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="c1"># If both transformations are not chromatic, then it is useful to combine them.</span>
            <span class="c1"># Especially if the original object is interpolated, since we have special handling</span>
            <span class="c1"># for that case in drawImage.</span>
            <span class="c1"># However, if either one is chromatic, then it&#39;s hard to combine them in a way that</span>
            <span class="c1"># preserves the ability to call the functions on either numpy arrays or scalars,</span>
            <span class="c1"># so just leave this as two consecutive transformations in that case.</span>
            <span class="c1"># Similarly, if there are redshifts involved, then the flux_ratio function needs to</span>
            <span class="c1"># be called on two different wavelengths, so again just leave it separate.</span>
            <span class="c1"># (I think this last case could be remedied, so if there is a use case where it</span>
            <span class="c1"># is important, we could try to implement it.)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_original</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">original</span>
            <span class="k">if</span> <span class="n">jac</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_jac</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">_jac</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_offset</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">_offset</span> <span class="o">+</span> <span class="n">offset</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_jac</span> <span class="o">=</span> <span class="n">jac</span> <span class="k">if</span> <span class="n">obj</span><span class="o">.</span><span class="n">_jac</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">jac</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">_jac</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_offset</span> <span class="o">=</span> <span class="n">jac</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">_offset</span><span class="p">)</span> <span class="o">+</span> <span class="n">offset</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">flux_ratio</span><span class="p">,</span> <span class="s1">&#39;__call__&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">_flux_ratio</span><span class="p">,</span> <span class="s1">&#39;__call__&#39;</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_flux_ratio</span> <span class="o">=</span> <span class="n">SED</span><span class="p">(</span><span class="n">flux_ratio</span><span class="p">,</span> <span class="s1">&#39;nm&#39;</span><span class="p">,</span> <span class="s1">&#39;1&#39;</span><span class="p">)</span> <span class="o">*</span> <span class="n">obj</span><span class="o">.</span><span class="n">_flux_ratio</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_flux_ratio</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">_flux_ratio</span> <span class="o">*</span> <span class="n">flux_ratio</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_original</span> <span class="o">=</span> <span class="n">obj</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_jac</span> <span class="o">=</span> <span class="n">jac</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_offset</span> <span class="o">=</span> <span class="n">offset</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_flux_ratio</span> <span class="o">=</span> <span class="n">flux_ratio</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_propagate_gsparams</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_original</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_original</span><span class="o">.</span><span class="n">withGSParams</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_gsparams</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">interpolated</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">deinterpolated</span> <span class="o">=</span> <span class="n">ChromaticTransformation</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_original</span><span class="o">.</span><span class="n">deinterpolated</span><span class="p">,</span>
                    <span class="n">jac</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_jac</span><span class="p">,</span>
                    <span class="n">offset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_offset</span><span class="p">,</span>
                    <span class="n">flux_ratio</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flux_ratio</span><span class="p">,</span>
                    <span class="n">redshift</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_redshift</span><span class="p">,</span>
                    <span class="n">gsparams</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gsparams</span><span class="p">,</span>
                    <span class="n">propagate_gsparams</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_propagate_gsparams</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">deinterpolated</span> <span class="o">=</span> <span class="bp">self</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">gsparams</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The `GSParams` for this object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gsparams</span>

<div class="viewcode-block" id="ChromaticTransformation.withGSParams"><a class="viewcode-back" href="../../chromaticobject.html#galsim.ChromaticTransformation.withGSParams">[docs]</a>    <span class="nd">@doc_inherit</span>
    <span class="k">def</span> <span class="nf">withGSParams</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gsparams</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">gsparams</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">gsparams</span><span class="p">:</span> <span class="k">return</span> <span class="bp">self</span>
        <span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">copy</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">_gsparams</span> <span class="o">=</span> <span class="n">GSParams</span><span class="o">.</span><span class="n">check</span><span class="p">(</span><span class="n">gsparams</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gsparams</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_propagate_gsparams</span><span class="p">:</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">_original</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_original</span><span class="o">.</span><span class="n">withGSParams</span><span class="p">(</span><span class="n">ret</span><span class="o">.</span><span class="n">_gsparams</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">interpolated</span><span class="p">:</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">deinterpolated</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">deinterpolated</span><span class="o">.</span><span class="n">withGSParams</span><span class="p">(</span><span class="n">ret</span><span class="o">.</span><span class="n">_gsparams</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">deinterpolated</span> <span class="o">=</span> <span class="n">ret</span>
        <span class="k">return</span> <span class="n">ret</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">original</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The original object that was transformed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_original</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span> <span class="ow">is</span> <span class="n">other</span><span class="p">:</span> <span class="k">return</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">ChromaticTransformation</span><span class="p">)</span> <span class="ow">and</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">original</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">original</span> <span class="ow">and</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_gsparams</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_gsparams</span> <span class="ow">and</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_propagate_gsparams</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_propagate_gsparams</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="c1"># There&#39;s really no good way to check that two callables are equal, except if they literally</span>
        <span class="c1"># point to the same object.  So we&#39;ll just check for that for _jac, _offset, _flux_ratio.</span>
        <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;_jac&#39;</span><span class="p">,</span> <span class="s1">&#39;_offset&#39;</span><span class="p">,</span> <span class="s1">&#39;_flux_ratio&#39;</span><span class="p">):</span>
            <span class="n">selfattr</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span>
            <span class="n">otherattr</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span>
            <span class="c1"># For this attr, either both need to be chromatic or neither.</span>
            <span class="k">if</span> <span class="p">((</span><span class="nb">hasattr</span><span class="p">(</span><span class="n">selfattr</span><span class="p">,</span> <span class="s1">&#39;__call__&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">otherattr</span><span class="p">,</span> <span class="s1">&#39;__call__&#39;</span><span class="p">))</span> <span class="ow">or</span>
                <span class="p">(</span><span class="nb">hasattr</span><span class="p">(</span><span class="n">otherattr</span><span class="p">,</span> <span class="s1">&#39;__call__&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">selfattr</span><span class="p">,</span> <span class="s1">&#39;__call__&#39;</span><span class="p">))):</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="c1"># If chromatic, then check that attrs compare equal</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">selfattr</span><span class="p">,</span> <span class="s1">&#39;__call__&#39;</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">selfattr</span> <span class="o">!=</span> <span class="n">otherattr</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">False</span>
            <span class="k">else</span><span class="p">:</span> <span class="c1"># Otherwise, check that attr arrays are equal.</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">selfattr</span><span class="p">,</span> <span class="n">otherattr</span><span class="p">):</span>
                    <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># This one&#39;s a bit complicated, so we&#39;ll go ahead and cache the hash.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_hash&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_hash</span> <span class="o">=</span> <span class="nb">hash</span><span class="p">((</span><span class="s2">&quot;galsim.ChromaticTransformation&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">original</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gsparams</span><span class="p">,</span>
                               <span class="bp">self</span><span class="o">.</span><span class="n">_propagate_gsparams</span><span class="p">))</span>
            <span class="c1"># achromatic _jac and _offset are ndarrays, so need to be handled separately.</span>
            <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;_jac&#39;</span><span class="p">,</span> <span class="s1">&#39;_offset&#39;</span><span class="p">):</span>
                <span class="n">selfattr</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">selfattr</span><span class="p">,</span> <span class="s1">&#39;__call__&#39;</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_hash</span> <span class="o">^=</span> <span class="nb">hash</span><span class="p">(</span><span class="n">selfattr</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">selfattr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_hash</span> <span class="o">^=</span> <span class="nb">hash</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">selfattr</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_hash</span> <span class="o">^=</span> <span class="nb">hash</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_flux_ratio</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hash</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_jac</span><span class="p">,</span> <span class="s1">&#39;__call__&#39;</span><span class="p">):</span>
            <span class="n">jac</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_jac</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_jac</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">jac</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">jac</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_jac</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_offset</span><span class="p">,</span> <span class="s1">&#39;__call__&#39;</span><span class="p">):</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_offset</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="n">_PositionD</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_offset</span><span class="o">.</span><span class="n">tolist</span><span class="p">()))</span>
        <span class="k">return</span> <span class="p">(</span><span class="s1">&#39;galsim.ChromaticTransformation(</span><span class="si">%r</span><span class="s1">, jac=</span><span class="si">%r</span><span class="s1">, offset=</span><span class="si">%r</span><span class="s1">, flux_ratio=</span><span class="si">%r</span><span class="s1">, &#39;</span>
                <span class="s1">&#39;redshift=</span><span class="si">%r</span><span class="s1">, gsparams=</span><span class="si">%r</span><span class="s1">, propagate_gsparams=</span><span class="si">%r</span><span class="s1">)&#39;</span><span class="p">)</span><span class="o">%</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">original</span><span class="p">,</span> <span class="n">jac</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flux_ratio</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_redshift</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_gsparams</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_propagate_gsparams</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">.transform</span> <span class="kn">import</span> <span class="n">Transformation</span>
        <span class="n">s</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">original</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_jac</span><span class="p">,</span> <span class="s1">&#39;__call__&#39;</span><span class="p">):</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="s1">&#39;.transform(</span><span class="si">%s</span><span class="s1">)&#39;</span><span class="o">%</span><span class="bp">self</span><span class="o">.</span><span class="n">_jac</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_jac</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="n">Transformation</span><span class="o">.</span><span class="n">_str_from_jac</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_jac</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_offset</span><span class="p">,</span> <span class="s1">&#39;__call__&#39;</span><span class="p">):</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="s1">&#39;.shift(</span><span class="si">%s</span><span class="s1">)&#39;</span><span class="o">%</span><span class="bp">self</span><span class="o">.</span><span class="n">_offset</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_offset</span><span class="p">,(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)):</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="s1">&#39;.shift(</span><span class="si">%s</span><span class="s1">,</span><span class="si">%s</span><span class="s1">)&#39;</span><span class="o">%</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_offset</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">_offset</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flux_ratio</span> <span class="o">!=</span> <span class="mf">1.</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="s1">&#39;.withScaledFlux(</span><span class="si">%s</span><span class="s1">)&#39;</span><span class="o">%</span><span class="bp">self</span><span class="o">.</span><span class="n">_flux_ratio</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_redshift</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="s1">&#39;.atRedshift(</span><span class="si">%s</span><span class="s1">)&#39;</span><span class="o">%</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_redshift</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">s</span>

    <span class="k">def</span> <span class="nf">_getTransformations</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">wave</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_jac</span><span class="p">,</span> <span class="s1">&#39;__call__&#39;</span><span class="p">):</span>
            <span class="n">jac</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_jac</span><span class="p">(</span><span class="n">wave</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">jac</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_jac</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_offset</span><span class="p">,</span> <span class="s1">&#39;__call__&#39;</span><span class="p">):</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_offset</span><span class="p">(</span><span class="n">wave</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_offset</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_flux_ratio</span><span class="p">,</span> <span class="s1">&#39;__call__&#39;</span><span class="p">):</span>
            <span class="n">flux_ratio</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flux_ratio</span><span class="p">(</span><span class="n">wave</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">flux_ratio</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flux_ratio</span>
        <span class="k">return</span> <span class="n">jac</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">flux_ratio</span>

    <span class="k">def</span> <span class="nf">_approxWavelength</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">wave</span><span class="p">):</span>
        <span class="c1"># Same as evaluateAtWavelength, except the starting point is also _approxWavelength</span>
        <span class="kn">from</span> <span class="nn">.transform</span> <span class="kn">import</span> <span class="n">Transformation</span>
        <span class="n">wave1</span> <span class="o">=</span> <span class="n">wave</span> <span class="o">/</span> <span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">_redshift</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_redshift</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">wave</span>
        <span class="n">wave2</span><span class="p">,</span> <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">original</span><span class="o">.</span><span class="n">_approxWavelength</span><span class="p">(</span><span class="n">wave1</span><span class="p">)</span>
        <span class="n">wave</span> <span class="o">=</span> <span class="n">wave2</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">_redshift</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_redshift</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">wave2</span>
        <span class="n">jac</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">flux_ratio</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getTransformations</span><span class="p">(</span><span class="n">wave</span><span class="p">)</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="n">_PositionD</span><span class="p">(</span><span class="o">*</span><span class="n">offset</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">wave</span><span class="p">,</span> <span class="n">Transformation</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span> <span class="n">jac</span><span class="o">=</span><span class="n">jac</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="n">offset</span><span class="p">,</span> <span class="n">flux_ratio</span><span class="o">=</span><span class="n">flux_ratio</span><span class="p">,</span>
                                    <span class="n">gsparams</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_gsparams</span><span class="p">,</span>
                                    <span class="n">propagate_gsparams</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_propagate_gsparams</span><span class="p">)</span>

<div class="viewcode-block" id="ChromaticTransformation.evaluateAtWavelength"><a class="viewcode-back" href="../../chromaticobject.html#galsim.ChromaticTransformation.evaluateAtWavelength">[docs]</a>    <span class="k">def</span> <span class="nf">evaluateAtWavelength</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">wave</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Evaluate this chromatic object at a particular wavelength.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            wave:   Wavelength in nanometers.</span>

<span class="sd">        Returns:</span>
<span class="sd">            the monochromatic object at the given wavelength.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.transform</span> <span class="kn">import</span> <span class="n">Transformation</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_redshift</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">wave1</span> <span class="o">=</span> <span class="n">wave</span> <span class="o">/</span> <span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">_redshift</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">wave1</span> <span class="o">=</span> <span class="n">wave</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">original</span><span class="o">.</span><span class="n">evaluateAtWavelength</span><span class="p">(</span><span class="n">wave1</span><span class="p">)</span>
        <span class="n">jac</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">flux_ratio</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getTransformations</span><span class="p">(</span><span class="n">wave</span><span class="p">)</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="n">_PositionD</span><span class="p">(</span><span class="o">*</span><span class="n">offset</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Transformation</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span> <span class="n">jac</span><span class="o">=</span><span class="n">jac</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="n">offset</span><span class="p">,</span> <span class="n">flux_ratio</span><span class="o">=</span><span class="n">flux_ratio</span><span class="p">,</span>
                              <span class="n">gsparams</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_gsparams</span><span class="p">,</span> <span class="n">propagate_gsparams</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_propagate_gsparams</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_shoot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">photons</span><span class="p">,</span> <span class="n">rng</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_original</span><span class="o">.</span><span class="n">_shoot</span><span class="p">(</span><span class="n">photons</span><span class="p">,</span> <span class="n">rng</span><span class="p">)</span>
        <span class="n">wave</span> <span class="o">=</span> <span class="n">photons</span><span class="o">.</span><span class="n">wavelength</span>
        <span class="n">jac</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">flux_ratio</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getTransformations</span><span class="p">(</span><span class="n">wave</span><span class="p">)</span>

        <span class="c1"># cf. Transformation._fwd_normal</span>
        <span class="k">if</span> <span class="n">jac</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="n">jac</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">photons</span><span class="o">.</span><span class="n">y</span>
            <span class="n">photons</span><span class="o">.</span><span class="n">y</span> <span class="o">*=</span> <span class="n">jac</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">photons</span><span class="o">.</span><span class="n">y</span> <span class="o">+=</span> <span class="n">jac</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">photons</span><span class="o">.</span><span class="n">x</span>
            <span class="n">photons</span><span class="o">.</span><span class="n">x</span> <span class="o">*=</span> <span class="n">jac</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">photons</span><span class="o">.</span><span class="n">x</span> <span class="o">+=</span> <span class="n">temp</span>

            <span class="n">det</span> <span class="o">=</span> <span class="n">jac</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">jac</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">jac</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">jac</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">flux_ratio</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">det</span><span class="p">)</span>

        <span class="n">photons</span><span class="o">.</span><span class="n">x</span> <span class="o">+=</span> <span class="n">offset</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">photons</span><span class="o">.</span><span class="n">y</span> <span class="o">+=</span> <span class="n">offset</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">photons</span><span class="o">.</span><span class="n">flux</span> <span class="o">*=</span> <span class="n">flux_ratio</span>

<div class="viewcode-block" id="ChromaticTransformation.drawImage"><a class="viewcode-back" href="../../chromaticobject.html#galsim.ChromaticTransformation.drawImage">[docs]</a>    <span class="k">def</span> <span class="nf">drawImage</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bandpass</span><span class="p">,</span> <span class="n">image</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">integrator</span><span class="o">=</span><span class="s1">&#39;quadratic&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        See `ChromaticObject.drawImage` for a full description.</span>

<span class="sd">        This version usually just calls that one, but if the transformed object (self.original) is</span>
<span class="sd">        an `InterpolatedChromaticObject`, and the transformation is achromatic, then it will still</span>
<span class="sd">        be able to use the interpolation.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            bandpass:       A `Bandpass` object representing the filter against which to</span>
<span class="sd">                            integrate.</span>
<span class="sd">            image:          Optionally, the `Image` to draw onto.  (See `GSObject.drawImage`</span>
<span class="sd">                            for details.)  [default: None]</span>
<span class="sd">            integrator:     When doing the exact evaluation of the profile, this argument should</span>
<span class="sd">                            be one of the image integrators from galsim.integ, or a string</span>
<span class="sd">                            &#39;trapezoidal&#39;, &#39;midpoint&#39;, &#39;quadratic&#39;, in which case the routine will</span>
<span class="sd">                            use a `SampleIntegrator` or `ContinuousIntegrator` depending on whether</span>
<span class="sd">                            or not the object has a ``wave_list``.  [default: &#39;quadratic&#39;,</span>
<span class="sd">                            which will try to select an appropriate integrator using the</span>
<span class="sd">                            quadratic integration rule automatically.]</span>
<span class="sd">                            If the object being transformed is an `InterpolatedChromaticObject`,</span>
<span class="sd">                            then ``integrator`` can only be a string, either &#39;midpoint&#39;,</span>
<span class="sd">                            &#39;trapezoidal&#39;, or &#39;quadratic&#39;.</span>
<span class="sd">            **kwargs:       For all other kwarg options, see `GSObject.drawImage`.</span>

<span class="sd">        Returns:</span>
<span class="sd">            the drawn `Image`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.transform</span> <span class="kn">import</span> <span class="n">Transform</span>
        <span class="c1"># Store the last bandpass used.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_last_bp</span> <span class="o">=</span> <span class="n">bandpass</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">SED</span><span class="o">.</span><span class="n">dimensionless</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">GalSimSEDError</span><span class="p">(</span><span class="s2">&quot;Can only draw ChromaticObjects with spectral SEDs.&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">SED</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">original</span><span class="p">,</span> <span class="n">InterpolatedChromaticObject</span><span class="p">):</span>
            <span class="c1"># Pass self._flux_ratio, which *could* depend on wavelength, to _get_interp_image,</span>
            <span class="c1"># where it will be used to reweight the stored images.</span>
            <span class="n">int_im</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">original</span><span class="o">.</span><span class="n">_get_interp_image</span><span class="p">(</span><span class="n">bandpass</span><span class="p">,</span> <span class="n">image</span><span class="o">=</span><span class="n">image</span><span class="p">,</span> <span class="n">integrator</span><span class="o">=</span><span class="n">integrator</span><span class="p">,</span>
                                                     <span class="n">_flux_ratio</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_flux_ratio</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="c1"># Get shape transformations at bandpass.red_limit (they are achromatic so it doesn&#39;t</span>
            <span class="c1"># matter where you get them).</span>
            <span class="n">jac</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getTransformations</span><span class="p">(</span><span class="n">bandpass</span><span class="o">.</span><span class="n">red_limit</span><span class="p">)</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="n">_PositionD</span><span class="p">(</span><span class="o">*</span><span class="n">offset</span><span class="p">)</span>
            <span class="n">int_im</span> <span class="o">=</span> <span class="n">Transform</span><span class="p">(</span><span class="n">int_im</span><span class="p">,</span> <span class="n">jac</span><span class="o">=</span><span class="n">jac</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="n">offset</span><span class="p">,</span> <span class="n">gsparams</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_gsparams</span><span class="p">,</span>
                               <span class="n">propagate_gsparams</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_propagate_gsparams</span><span class="p">)</span>
            <span class="n">image</span> <span class="o">=</span> <span class="n">int_im</span><span class="o">.</span><span class="n">drawImage</span><span class="p">(</span><span class="n">image</span><span class="o">=</span><span class="n">image</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_last_wcs</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">wcs</span>
            <span class="k">return</span> <span class="n">image</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">image</span> <span class="o">=</span> <span class="n">ChromaticObject</span><span class="o">.</span><span class="n">drawImage</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bandpass</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span> <span class="n">integrator</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_last_wcs</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">wcs</span>
            <span class="k">return</span> <span class="n">image</span></div>

    <span class="nd">@lazy_property</span>
    <span class="k">def</span> <span class="nf">noise</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;An estimate of the noise already in the profile.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.transform</span> <span class="kn">import</span> <span class="n">_Transform</span>
        <span class="kn">from</span> <span class="nn">.correlatednoise</span> <span class="kn">import</span> <span class="n">BaseCorrelatedNoise</span>
        <span class="c1"># Condition for being able to propagate noise:</span>
        <span class="c1"># 1) All transformations are achromatic.</span>
        <span class="c1"># 2) This ChromaticTransformation wraps a ChromaticConvolution with a valid noise property.</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_jac</span><span class="p">,</span> <span class="s1">&#39;__call__&#39;</span><span class="p">)</span> <span class="ow">or</span>
            <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_offset</span><span class="p">,</span> <span class="s1">&#39;__call__&#39;</span><span class="p">)</span> <span class="ow">or</span>
            <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_flux_ratio</span><span class="p">,</span> <span class="s1">&#39;__call__&#39;</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="n">GalSimError</span><span class="p">(</span><span class="s2">&quot;Cannot propagate noise through chromatic transformation&quot;</span><span class="p">)</span>
        <span class="n">noise</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">original</span><span class="o">.</span><span class="n">noise</span>
        <span class="n">jac</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_jac</span>
        <span class="n">flux_ratio</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flux_ratio</span>
        <span class="k">return</span> <span class="n">BaseCorrelatedNoise</span><span class="p">(</span><span class="n">noise</span><span class="o">.</span><span class="n">rng</span><span class="p">,</span>
                                   <span class="n">_Transform</span><span class="p">(</span><span class="n">noise</span><span class="o">.</span><span class="n">_profile</span><span class="p">,</span> <span class="n">jac</span><span class="p">,</span> <span class="n">flux_ratio</span><span class="o">=</span><span class="n">flux_ratio</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span>
                                   <span class="n">noise</span><span class="o">.</span><span class="n">wcs</span><span class="p">)</span></div>


<div class="viewcode-block" id="ChromaticSum"><a class="viewcode-back" href="../../chromaticobject.html#galsim.ChromaticSum">[docs]</a><span class="k">class</span> <span class="nc">ChromaticSum</span><span class="p">(</span><span class="n">ChromaticObject</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A sum of several `ChromaticObject` and/or `GSObject` instances.</span>

<span class="sd">    Any `GSObject` in the sum is assumed to have a flat `SED` with spectral density of 1</span>
<span class="sd">    photon/s/cm**2/nm.</span>

<span class="sd">    This is the type returned from `galsim.Add` if any of the objects are a `ChromaticObject`.</span>

<span class="sd">    Typically, you do not need to construct a ChromaticSum object explicitly.  Normally, you</span>
<span class="sd">    would just use the + operator, which returns a ChromaticSum when used with chromatic objects::</span>

<span class="sd">        &gt;&gt;&gt; bulge = galsim.Sersic(n=3, half_light_radius=0.8) * bulge_sed</span>
<span class="sd">        &gt;&gt;&gt; disk = galsim.Exponential(half_light_radius=1.4) * disk_sed</span>
<span class="sd">        &gt;&gt;&gt; gal = bulge + disk</span>

<span class="sd">    You can also use the `Add` factory function, which returns a ChromaticSum object if any of</span>
<span class="sd">    the individual objects are chromatic::</span>

<span class="sd">        &gt;&gt;&gt; gal = galsim.Add([bulge,disk])</span>

<span class="sd">    Parameters:</span>
<span class="sd">        args:               Unnamed args should be a list of objects to add.</span>
<span class="sd">        gsparams:           An optional `GSParams` argument.  See the docstring for `GSParams` for</span>
<span class="sd">                            details. [default: None]</span>
<span class="sd">        propagate_gsparams: Whether to propagate gsparams to each of the components.  This</span>
<span class="sd">                            is normally a good idea, but there may be use cases where one</span>
<span class="sd">                            would not want to do this. [default: True]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># Check kwargs first:</span>
        <span class="n">gsparams</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;gsparams&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_propagate_gsparams</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;propagate_gsparams&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Make sure there is nothing left in the dict.</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Got unexpected keyword argument(s): </span><span class="si">%s</span><span class="s2">&quot;</span><span class="o">%</span><span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># No arguments. Could initialize with an empty list but draw then segfaults. Raise an</span>
            <span class="c1"># exception instead.</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Must provide at least one GSObject or ChromaticObject.&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># 1 argument.  Should be either a GSObject, ChromaticObject or a list of these.</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">(</span><span class="n">GSObject</span><span class="p">,</span> <span class="n">ChromaticObject</span><span class="p">)):</span>
                <span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">list</span><span class="p">):</span>
                <span class="n">args</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Single input argument must be a GSObject, a ChromaticObject,&quot;</span>
                                <span class="s2">&quot; or list of them.&quot;</span><span class="p">)</span>
        <span class="c1"># else args is already the list of objects</span>

        <span class="c1"># Figure out what gsparams to use</span>
        <span class="k">if</span> <span class="n">gsparams</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># If none is given, take the most restrictive combination from the obj_list.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_gsparams</span> <span class="o">=</span> <span class="n">GSParams</span><span class="o">.</span><span class="n">combine</span><span class="p">([</span><span class="n">obj</span><span class="o">.</span><span class="n">gsparams</span> <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">args</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># If something explicitly given, then use that.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_gsparams</span> <span class="o">=</span> <span class="n">GSParams</span><span class="o">.</span><span class="n">check</span><span class="p">(</span><span class="n">gsparams</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">interpolated</span> <span class="o">=</span> <span class="nb">any</span><span class="p">(</span><span class="n">arg</span><span class="o">.</span><span class="n">interpolated</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">interpolated</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">deinterpolated</span> <span class="o">=</span> <span class="n">ChromaticSum</span><span class="p">([</span><span class="n">arg</span><span class="o">.</span><span class="n">deinterpolated</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span><span class="p">],</span>
                                               <span class="n">gsparams</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_gsparams</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">deinterpolated</span> <span class="o">=</span> <span class="bp">self</span>

        <span class="c1"># We can only add ChromaticObjects together if they&#39;re either all SED&#39;d or all non-SED&#39;d</span>
        <span class="n">dimensionless</span> <span class="o">=</span> <span class="nb">all</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">dimensionless</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">args</span><span class="p">)</span>
        <span class="n">spectral</span> <span class="o">=</span> <span class="nb">all</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">spectral</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">args</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">dimensionless</span> <span class="ow">or</span> <span class="n">spectral</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">GalSimIncompatibleValuesError</span><span class="p">(</span>
                <span class="s2">&quot;Cannot add dimensionless and spectral ChromaticObjects.&quot;</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="n">args</span><span class="p">)</span>

        <span class="c1"># Sort arguments into inseparable objects and groups of separable objects.  Note that</span>
        <span class="c1"># separable groups are only identified if the constituent objects have the *same* SED even</span>
        <span class="c1"># though a proportional SED is mathematically sufficient for separability.  It&#39;s basically</span>
        <span class="c1"># impossible to identify if two SEDs are proportional (or even equal) unless they point to</span>
        <span class="c1"># the same memory, so we just accept this limitation.</span>

        <span class="c1"># Each input summand will either end up in SED_dict if it&#39;s separable, or in self._obj_list</span>
        <span class="c1"># if it&#39;s inseparable.  Use an OrderedDict to ensure deterministic results.</span>
        <span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">OrderedDict</span>
        <span class="n">SED_dict</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_obj_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_propagate_gsparams</span><span class="p">:</span>
                <span class="n">obj</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">withGSParams</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_gsparams</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">obj</span><span class="o">.</span><span class="n">separable</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">obj</span><span class="o">.</span><span class="n">SED</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">SED_dict</span><span class="p">:</span>
                    <span class="n">SED_dict</span><span class="p">[</span><span class="n">obj</span><span class="o">.</span><span class="n">SED</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">SED_dict</span><span class="p">[</span><span class="n">obj</span><span class="o">.</span><span class="n">SED</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_obj_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>

        <span class="c1"># If everything ended up in a single SED_dict entry (and self._obj_list is empty) then this</span>
        <span class="c1"># ChromaticSum is separable.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">separable</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_obj_list</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">SED_dict</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">separable</span><span class="p">:</span>
            <span class="n">the_one_SED</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">SED_dict</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_obj_list</span> <span class="o">=</span> <span class="n">SED_dict</span><span class="p">[</span><span class="n">the_one_SED</span><span class="p">]</span>
            <span class="c1"># Since we know that the chromatic objects&#39; SEDs already include all relevant</span>
            <span class="c1"># normalizations, we can just multiply the_one_SED by the number of objects.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">SED</span> <span class="o">=</span> <span class="n">the_one_SED</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">SED_dict</span><span class="p">[</span><span class="n">the_one_SED</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Sum is not separable, put partial sums might be.  Search for them.</span>
            <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">SED_dict</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_obj_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_obj_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ChromaticSum</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>
            <span class="c1"># and assemble self normalization:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">SED</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_obj_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">SED</span>
            <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_obj_list</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">SED</span> <span class="o">+=</span> <span class="n">obj</span><span class="o">.</span><span class="n">SED</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">wave_list</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">utilities</span><span class="o">.</span><span class="n">combine_wave_list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_obj_list</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">gsparams</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The `GSParams` for this object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gsparams</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">obj_list</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The list of objects being added.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_obj_list</span>

<div class="viewcode-block" id="ChromaticSum.withGSParams"><a class="viewcode-back" href="../../chromaticobject.html#galsim.ChromaticSum.withGSParams">[docs]</a>    <span class="nd">@doc_inherit</span>
    <span class="k">def</span> <span class="nf">withGSParams</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gsparams</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">gsparams</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">gsparams</span><span class="p">:</span> <span class="k">return</span> <span class="bp">self</span>
        <span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">copy</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">_gsparams</span> <span class="o">=</span> <span class="n">GSParams</span><span class="o">.</span><span class="n">check</span><span class="p">(</span><span class="n">gsparams</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gsparams</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_propagate_gsparams</span><span class="p">:</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">_obj_list</span> <span class="o">=</span> <span class="p">[</span> <span class="n">obj</span><span class="o">.</span><span class="n">withGSParams</span><span class="p">(</span><span class="n">ret</span><span class="o">.</span><span class="n">_gsparams</span><span class="p">)</span> <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">obj_list</span> <span class="p">]</span>
        <span class="k">return</span> <span class="n">ret</span></div>

<div class="viewcode-block" id="ChromaticSum.atRedshift"><a class="viewcode-back" href="../../chromaticobject.html#galsim.ChromaticSum.atRedshift">[docs]</a>    <span class="nd">@doc_inherit</span>
    <span class="k">def</span> <span class="nf">atRedshift</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">redshift</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">copy</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">_obj_list</span> <span class="o">=</span> <span class="p">[</span> <span class="n">obj</span><span class="o">.</span><span class="n">atRedshift</span><span class="p">(</span><span class="n">redshift</span><span class="p">)</span> <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">obj_list</span> <span class="p">]</span>
        <span class="k">return</span> <span class="n">ret</span></div>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span> <span class="ow">is</span> <span class="n">other</span> <span class="ow">or</span>
                <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">ChromaticSum</span><span class="p">)</span> <span class="ow">and</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">obj_list</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">obj_list</span> <span class="ow">and</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">_gsparams</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_gsparams</span> <span class="ow">and</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">_propagate_gsparams</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_propagate_gsparams</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">((</span><span class="s2">&quot;galsim.ChromaticSum&quot;</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj_list</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gsparams</span><span class="p">,</span>
                     <span class="bp">self</span><span class="o">.</span><span class="n">_propagate_gsparams</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;galsim.ChromaticSum(</span><span class="si">%r</span><span class="s1">, gsparams=</span><span class="si">%r</span><span class="s1">, propagate_gsparams=</span><span class="si">%r</span><span class="s1">)&#39;</span><span class="o">%</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">obj_list</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gsparams</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_propagate_gsparams</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">str_list</span> <span class="o">=</span> <span class="p">[</span> <span class="nb">str</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">obj_list</span> <span class="p">]</span>
        <span class="k">return</span> <span class="s1">&#39;galsim.ChromaticSum([</span><span class="si">%s</span><span class="s1">])&#39;</span><span class="o">%</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">str_list</span><span class="p">)</span>

<div class="viewcode-block" id="ChromaticSum.evaluateAtWavelength"><a class="viewcode-back" href="../../chromaticobject.html#galsim.ChromaticSum.evaluateAtWavelength">[docs]</a>    <span class="k">def</span> <span class="nf">evaluateAtWavelength</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">wave</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Evaluate this chromatic object at a particular wavelength ``wave``.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            wave:   Wavelength in nanometers.</span>

<span class="sd">        Returns:</span>
<span class="sd">            the monochromatic object at the given wavelength.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.sum</span> <span class="kn">import</span> <span class="n">Add</span>
        <span class="k">return</span> <span class="n">Add</span><span class="p">([</span><span class="n">obj</span><span class="o">.</span><span class="n">evaluateAtWavelength</span><span class="p">(</span><span class="n">wave</span><span class="p">)</span> <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">obj_list</span><span class="p">],</span>
                   <span class="n">gsparams</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_gsparams</span><span class="p">,</span> <span class="n">propagate_gsparams</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_propagate_gsparams</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_shoot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">photons</span><span class="p">,</span> <span class="n">rng</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">GalSimNotImplementedError</span><span class="p">(</span><span class="s2">&quot;ChromaticSum cannot be used as a PhotonOp&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="ChromaticSum.drawImage"><a class="viewcode-back" href="../../chromaticobject.html#galsim.ChromaticSum.drawImage">[docs]</a>    <span class="k">def</span> <span class="nf">drawImage</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bandpass</span><span class="p">,</span> <span class="n">image</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">integrator</span><span class="o">=</span><span class="s1">&#39;quadratic&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Slightly optimized draw method for `ChromaticSum` instances.</span>

<span class="sd">        Draws each summand individually and add resulting images together.  This might waste time if</span>
<span class="sd">        two or more summands are separable and have the same `SED`, and another summand with a</span>
<span class="sd">        different `SED` is also added, in which case the summands should be added together first and</span>
<span class="sd">        the resulting `Sum` object can then be chromaticized.  In general, however, drawing</span>
<span class="sd">        individual sums independently can help with speed by identifying chromatic profiles that</span>
<span class="sd">        are separable into spectral and spatial factors.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            bandpass:       A `Bandpass` object representing the filter against which to</span>
<span class="sd">                            integrate.</span>
<span class="sd">            image:          Optionally, the `Image` to draw onto.  (See `GSObject.drawImage`</span>
<span class="sd">                            for details.)  [default: None]</span>
<span class="sd">            integrator:     When doing the exact evaluation of the profile, this argument should</span>
<span class="sd">                            be one of the image integrators from galsim.integ, or a string</span>
<span class="sd">                            &#39;trapezoidal&#39;, &#39;midpoint&#39;, &#39;quadratic&#39;, in which case the routine will</span>
<span class="sd">                            use a `SampleIntegrator` or `ContinuousIntegrator` depending on whether</span>
<span class="sd">                            or not the object has a ``wave_list``.  [default: &#39;quadratic&#39;,</span>
<span class="sd">                            which will try to select an appropriate integrator using the</span>
<span class="sd">                            quadratic integration rule automatically.]</span>
<span class="sd">            **kwargs:       For all other kwarg options, see `GSObject.drawImage`.</span>

<span class="sd">        Returns:</span>
<span class="sd">            the drawn `Image`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Store the last bandpass used.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_last_bp</span> <span class="o">=</span> <span class="n">bandpass</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">SED</span><span class="o">.</span><span class="n">dimensionless</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">GalSimSEDError</span><span class="p">(</span><span class="s2">&quot;Can only draw ChromaticObjects with spectral SEDs.&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">SED</span><span class="p">)</span>
        <span class="n">add_to_image</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;add_to_image&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="c1"># Use given add_to_image for the first one, then add_to_image=True for the rest.</span>
        <span class="n">image</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">obj_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">drawImage</span><span class="p">(</span>
                <span class="n">bandpass</span><span class="p">,</span> <span class="n">image</span><span class="o">=</span><span class="n">image</span><span class="p">,</span> <span class="n">add_to_image</span><span class="o">=</span><span class="n">add_to_image</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">_remove_setup_kwargs</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">obj_list</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="n">image</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">drawImage</span><span class="p">(</span><span class="n">bandpass</span><span class="p">,</span> <span class="n">image</span><span class="o">=</span><span class="n">image</span><span class="p">,</span> <span class="n">add_to_image</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_last_wcs</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">wcs</span>
        <span class="k">return</span> <span class="n">image</span></div>

<div class="viewcode-block" id="ChromaticSum.withScaledFlux"><a class="viewcode-back" href="../../chromaticobject.html#galsim.ChromaticSum.withScaledFlux">[docs]</a>    <span class="k">def</span> <span class="nf">withScaledFlux</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">flux_ratio</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Multiply the flux of the object by ``flux_ratio``</span>

<span class="sd">        Parameters:</span>
<span class="sd">            flux_ratio:     The factor by which to scale the flux.</span>

<span class="sd">        Returns:</span>
<span class="sd">            the object with the new flux.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new_obj</span> <span class="o">=</span> <span class="n">ChromaticSum</span><span class="p">([</span> <span class="n">obj</span><span class="o">.</span><span class="n">withScaledFlux</span><span class="p">(</span><span class="n">flux_ratio</span><span class="p">)</span> <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">obj_list</span> <span class="p">])</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;covspec&#39;</span><span class="p">):</span>
            <span class="n">new_covspec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">covspec</span> <span class="o">*</span> <span class="n">flux_ratio</span><span class="o">**</span><span class="mi">2</span>
            <span class="n">new_obj</span><span class="o">.</span><span class="n">covspec</span> <span class="o">=</span> <span class="n">new_covspec</span>
        <span class="k">return</span> <span class="n">new_obj</span></div></div>


<div class="viewcode-block" id="ChromaticConvolution"><a class="viewcode-back" href="../../chromaticobject.html#galsim.ChromaticConvolution">[docs]</a><span class="k">class</span> <span class="nc">ChromaticConvolution</span><span class="p">(</span><span class="n">ChromaticObject</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A convolution of several `ChromaticObject` and/or `GSObject` instances.</span>

<span class="sd">    Any `GSObject` in the convolution is assumed to have a flat `SED` with spectral density of 1</span>
<span class="sd">    photon/s/cm**2/nm.</span>

<span class="sd">    This is the type returned from `galsim.Convolve` if any of the objects is a `ChromaticObject`.</span>

<span class="sd">    The normal way to use this class is to use the `Convolve` factory function::</span>

<span class="sd">        &gt;&gt;&gt; gal = galsim.Sersic(n, half_light_radius) * galsim.SED(sed_file, &#39;nm&#39;, &#39;flambda&#39;)</span>
<span class="sd">        &gt;&gt;&gt; psf = galsim.ChromaticAtmosphere(...)</span>
<span class="sd">        &gt;&gt;&gt; final = galsim.Convolve([gal, psf])</span>

<span class="sd">    The objects to be convolved may be provided either as multiple unnamed arguments (e.g.</span>
<span class="sd">    ``Convolve(psf, gal, pix)``) or as a list (e.g. ``Convolve([psf, gal, pix])``).  Any number of</span>
<span class="sd">    objects may be provided using either syntax.  (Well, the list has to include at least 1 item.)</span>

<span class="sd">    Parameters:</span>
<span class="sd">        args:               Unnamed args should be a list of objects to convolve.</span>
<span class="sd">        real_space:         Whether to use real space convolution.  [default: None, which means</span>
<span class="sd">                            to automatically decide this according to whether the objects have hard</span>
<span class="sd">                            edges.]</span>
<span class="sd">        gsparams:           An optional `GSParams` argument.  See the docstring for `GSParams` for</span>
<span class="sd">                            details. [default: None]</span>
<span class="sd">        propagate_gsparams: Whether to propagate gsparams to each of the components.  This</span>
<span class="sd">                            is normally a good idea, but there may be use cases where one</span>
<span class="sd">                            would not want to do this. [default: True]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># First check for number of arguments != 0</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># No arguments. Could initialize with an empty list but draw then segfaults. Raise an</span>
            <span class="c1"># exception instead.</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Must provide at least one GSObject or ChromaticObject&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">(</span><span class="n">GSObject</span><span class="p">,</span> <span class="n">ChromaticObject</span><span class="p">)):</span>
                <span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">list</span><span class="p">):</span>
                <span class="n">args</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Single input argument must be a GSObject, or a ChromaticObject,&quot;</span>
                                <span class="s2">&quot; or list of them.&quot;</span><span class="p">)</span>
        <span class="c1"># else args is already the list of objects</span>

        <span class="c1"># Check kwargs</span>
        <span class="c1"># real space convolution is not implemented for chromatic objects.</span>
        <span class="n">real_space</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;real_space&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">real_space</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">GalSimNotImplementedError</span><span class="p">(</span>
                <span class="s2">&quot;Real space convolution of chromatic objects not implemented.&quot;</span><span class="p">)</span>
        <span class="n">gsparams</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;gsparams&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_propagate_gsparams</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;propagate_gsparams&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Figure out what gsparams to use</span>
        <span class="k">if</span> <span class="n">gsparams</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># If none is given, take the most restrictive combination from the obj_list.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_gsparams</span> <span class="o">=</span> <span class="n">GSParams</span><span class="o">.</span><span class="n">combine</span><span class="p">([</span><span class="n">obj</span><span class="o">.</span><span class="n">gsparams</span> <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">args</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># If something explicitly given, then use that.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_gsparams</span> <span class="o">=</span> <span class="n">GSParams</span><span class="o">.</span><span class="n">check</span><span class="p">(</span><span class="n">gsparams</span><span class="p">)</span>

        <span class="c1"># Make sure there is nothing left in the dict.</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Got unexpected keyword argument(s): </span><span class="si">%s</span><span class="s2">&quot;</span><span class="o">%</span><span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

        <span class="c1"># Accumulate convolutant .SEDs.  Check if more than one is spectral.</span>
        <span class="n">nspectral</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">arg</span><span class="o">.</span><span class="n">spectral</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">nspectral</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">GalSimIncompatibleValuesError</span><span class="p">(</span>
                <span class="s2">&quot;Cannot convolve more than one spectral ChromaticObject.&quot;</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="n">args</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">SED</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">SED</span>
        <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">SED</span> <span class="o">*=</span> <span class="n">obj</span><span class="o">.</span><span class="n">SED</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_obj_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># Unfold convolution of convolution.</span>
        <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_propagate_gsparams</span><span class="p">:</span>
                <span class="n">obj</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">withGSParams</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_gsparams</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">ChromaticConvolution</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_obj_list</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">obj_list</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_obj_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">separable</span> <span class="o">=</span> <span class="nb">all</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">separable</span> <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_obj_list</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">interpolated</span> <span class="o">=</span> <span class="nb">any</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">interpolated</span> <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_obj_list</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">interpolated</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">deinterpolated</span> <span class="o">=</span> <span class="n">ChromaticConvolution</span><span class="p">(</span>
                    <span class="p">[</span><span class="n">obj</span><span class="o">.</span><span class="n">deinterpolated</span> <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_obj_list</span><span class="p">],</span>
                    <span class="n">gsparams</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_gsparams</span><span class="p">,</span> <span class="n">propagate_gsparams</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_propagate_gsparams</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">deinterpolated</span> <span class="o">=</span> <span class="bp">self</span>

        <span class="c1"># Check quickly whether we are convolving two non-separable things that aren&#39;t</span>
        <span class="c1"># ChromaticSums, &gt;1 of which uses interpolation.  If so, emit a warning that the</span>
        <span class="c1"># interpolation optimization is being ignored and full evaluation is necessary.</span>
        <span class="c1"># For the case of ChromaticSums, as long as each object in the sum is separable (even if the</span>
        <span class="c1"># entire object is not) then interpolation can still be used.  So we do not warn about this</span>
        <span class="c1"># here.</span>
        <span class="n">n_nonsep</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">n_interp</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_obj_list</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">obj</span><span class="o">.</span><span class="n">separable</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">ChromaticSum</span><span class="p">):</span> <span class="n">n_nonsep</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">obj</span><span class="o">.</span><span class="n">interpolated</span><span class="p">:</span> <span class="n">n_interp</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">n_nonsep</span><span class="o">&gt;</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">n_interp</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">galsim_warn</span><span class="p">(</span>
                <span class="s2">&quot;Image rendering for this convolution cannot take advantage of &quot;</span>
                <span class="s2">&quot;interpolation-related optimization.  Will use full profile evaluation.&quot;</span><span class="p">)</span>

        <span class="c1"># Assemble wave_lists</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">wave_list</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">utilities</span><span class="o">.</span><span class="n">combine_wave_list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_obj_list</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">gsparams</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The `GSParams` for this object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gsparams</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">obj_list</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The list of objects being convolved.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_obj_list</span>

<div class="viewcode-block" id="ChromaticConvolution.withGSParams"><a class="viewcode-back" href="../../chromaticobject.html#galsim.ChromaticConvolution.withGSParams">[docs]</a>    <span class="nd">@doc_inherit</span>
    <span class="k">def</span> <span class="nf">withGSParams</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gsparams</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">gsparams</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">gsparams</span><span class="p">:</span> <span class="k">return</span> <span class="bp">self</span>
        <span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">copy</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">_gsparams</span> <span class="o">=</span> <span class="n">GSParams</span><span class="o">.</span><span class="n">check</span><span class="p">(</span><span class="n">gsparams</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gsparams</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_propagate_gsparams</span><span class="p">:</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">_obj_list</span> <span class="o">=</span> <span class="p">[</span> <span class="n">obj</span><span class="o">.</span><span class="n">withGSParams</span><span class="p">(</span><span class="n">ret</span><span class="o">.</span><span class="n">_gsparams</span><span class="p">)</span> <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">obj_list</span> <span class="p">]</span>
        <span class="k">return</span> <span class="n">ret</span></div>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_get_effective_prof</span><span class="p">(</span><span class="n">insep_obj</span><span class="p">,</span> <span class="n">bandpass</span><span class="p">,</span> <span class="n">iimult</span><span class="p">,</span> <span class="n">integrator</span><span class="p">,</span> <span class="n">gsparams</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">.interpolatedimage</span> <span class="kn">import</span> <span class="n">InterpolatedImage</span>
        <span class="c1"># Find scale at which to draw effective profile</span>
        <span class="c1"># Use smallest nyquist scale among the fiducial profile and at the two limits of the bp.</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">prof0</span> <span class="o">=</span> <span class="n">insep_obj</span><span class="o">.</span><span class="n">_fiducial_profile</span><span class="p">(</span><span class="n">bandpass</span><span class="p">)</span>
        <span class="n">prof1</span> <span class="o">=</span> <span class="n">insep_obj</span><span class="o">.</span><span class="n">evaluateAtWavelength</span><span class="p">(</span><span class="n">bandpass</span><span class="o">.</span><span class="n">red_limit</span><span class="p">)</span>
        <span class="n">prof2</span> <span class="o">=</span> <span class="n">insep_obj</span><span class="o">.</span><span class="n">evaluateAtWavelength</span><span class="p">(</span><span class="n">bandpass</span><span class="o">.</span><span class="n">blue_limit</span><span class="p">)</span>
        <span class="n">iiscale</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">prof0</span><span class="o">.</span><span class="n">nyquist_scale</span><span class="p">,</span> <span class="n">prof1</span><span class="o">.</span><span class="n">nyquist_scale</span><span class="p">,</span> <span class="n">prof2</span><span class="o">.</span><span class="n">nyquist_scale</span><span class="p">)</span>
        <span class="n">iiscale</span> <span class="o">/=</span> <span class="mi">2</span>  <span class="c1"># This seems to be required to make test_monochromatic_sed to pass.</span>
                      <span class="c1"># Not sure why, since I thought straight nyquist should be good enough.</span>
                      <span class="c1"># But if it&#39;s needed there, it&#39;s probably worth always doing, rather than</span>
                      <span class="c1"># having that test use iimult=2.  And definitions of Nyquist are somewhat</span>
                      <span class="c1"># confusing, so it&#39;s possible that we should expect to need a factor of</span>
                      <span class="c1"># 2 smaller than nyquist for the pixel scale.  :-S</span>
        <span class="k">if</span> <span class="n">iimult</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">iiscale</span> <span class="o">/=</span> <span class="n">iimult</span>

        <span class="c1"># Prevent infinite recursive loop by using ChromaticObject.drawImage() on a</span>
        <span class="c1"># ChromaticConvolution.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">insep_obj</span><span class="p">,</span> <span class="n">ChromaticConvolution</span><span class="p">):</span>
            <span class="n">effective_prof_image</span> <span class="o">=</span> <span class="n">ChromaticObject</span><span class="o">.</span><span class="n">drawImage</span><span class="p">(</span>
                    <span class="n">insep_obj</span><span class="p">,</span> <span class="n">bandpass</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">iiscale</span><span class="p">,</span>
                    <span class="n">integrator</span><span class="o">=</span><span class="n">integrator</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;no_pixel&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">effective_prof_image</span> <span class="o">=</span> <span class="n">insep_obj</span><span class="o">.</span><span class="n">drawImage</span><span class="p">(</span>
                    <span class="n">bandpass</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">iiscale</span><span class="p">,</span> <span class="n">integrator</span><span class="o">=</span><span class="n">integrator</span><span class="p">,</span>
                    <span class="n">method</span><span class="o">=</span><span class="s1">&#39;no_pixel&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">InterpolatedImage</span><span class="p">(</span><span class="n">effective_prof_image</span><span class="p">,</span> <span class="n">gsparams</span><span class="o">=</span><span class="n">gsparams</span><span class="p">)</span>

<div class="viewcode-block" id="ChromaticConvolution.resize_effective_prof_cache"><a class="viewcode-back" href="../../chromaticobject.html#galsim.ChromaticConvolution.resize_effective_prof_cache">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">resize_effective_prof_cache</span><span class="p">(</span><span class="n">maxsize</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Resize the cache containing effective profiles.</span>

<span class="sd">        These are wavelength-integrated products of separable profile SEDs, inseparable profiles,</span>
<span class="sd">        and Bandpasses) used by `ChromaticConvolution.drawImage`.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            maxsize:    The new number of effective profiles to cache.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ChromaticConvolution</span><span class="o">.</span><span class="n">_effective_prof_cache</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">maxsize</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span> <span class="ow">is</span> <span class="n">other</span> <span class="ow">or</span>
                <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">ChromaticConvolution</span><span class="p">)</span> <span class="ow">and</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">obj_list</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">obj_list</span> <span class="ow">and</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">_gsparams</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_gsparams</span> <span class="ow">and</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">_propagate_gsparams</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_propagate_gsparams</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">((</span><span class="s2">&quot;galsim.ChromaticConvolution&quot;</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj_list</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gsparams</span><span class="p">,</span>
                     <span class="bp">self</span><span class="o">.</span><span class="n">_propagate_gsparams</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;galsim.ChromaticConvolution(</span><span class="si">%r</span><span class="s1">, gsparams=</span><span class="si">%r</span><span class="s1">, propagate_gsparams=</span><span class="si">%r</span><span class="s1">)&#39;</span><span class="o">%</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">obj_list</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gsparams</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_propagate_gsparams</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">str_list</span> <span class="o">=</span> <span class="p">[</span> <span class="nb">str</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">obj_list</span> <span class="p">]</span>
        <span class="k">return</span> <span class="s1">&#39;galsim.ChromaticConvolution([</span><span class="si">%s</span><span class="s1">])&#39;</span><span class="o">%</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">str_list</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_approxWavelength</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">wave</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">.convolve</span> <span class="kn">import</span> <span class="n">Convolve</span>
        <span class="c1"># If any of the components prefer a different wavelength, use that for all.</span>
        <span class="n">achrom_objs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">obj</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj_list</span><span class="p">):</span>
            <span class="n">new_wave</span><span class="p">,</span> <span class="n">aobj</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">_approxWavelength</span><span class="p">(</span><span class="n">wave</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">new_wave</span> <span class="o">!=</span> <span class="n">wave</span><span class="p">:</span>
                <span class="c1"># Break the loop and use evaluateAtWavelength for everything else.</span>
                <span class="n">achrom_objs</span> <span class="o">=</span> <span class="p">([</span><span class="n">o</span><span class="o">.</span><span class="n">evaluateAtWavelength</span><span class="p">(</span><span class="n">new_wave</span><span class="p">)</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">obj_list</span><span class="p">[:</span><span class="n">k</span><span class="p">]]</span> <span class="o">+</span>
                               <span class="p">[</span><span class="n">aobj</span><span class="p">]</span> <span class="o">+</span>
                               <span class="p">[</span><span class="n">o</span><span class="o">.</span><span class="n">evaluateAtWavelength</span><span class="p">(</span><span class="n">new_wave</span><span class="p">)</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">obj_list</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">:]])</span>
                <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">achrom_objs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">aobj</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">new_wave</span><span class="p">,</span> <span class="n">Convolve</span><span class="p">(</span><span class="n">achrom_objs</span><span class="p">,</span> <span class="n">gsparams</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_gsparams</span><span class="p">,</span>
                                  <span class="n">propagate_gsparams</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_propagate_gsparams</span><span class="p">)</span>

<div class="viewcode-block" id="ChromaticConvolution.evaluateAtWavelength"><a class="viewcode-back" href="../../chromaticobject.html#galsim.ChromaticConvolution.evaluateAtWavelength">[docs]</a>    <span class="k">def</span> <span class="nf">evaluateAtWavelength</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">wave</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Evaluate this chromatic object at a particular wavelength ``wave``.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            wave:   Wavelength in nanometers.</span>

<span class="sd">        Returns:</span>
<span class="sd">            the monochromatic object at the given wavelength.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.convolve</span> <span class="kn">import</span> <span class="n">Convolve</span>
        <span class="k">return</span> <span class="n">Convolve</span><span class="p">([</span><span class="n">obj</span><span class="o">.</span><span class="n">evaluateAtWavelength</span><span class="p">(</span><span class="n">wave</span><span class="p">)</span> <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">obj_list</span><span class="p">],</span>
                        <span class="n">gsparams</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_gsparams</span><span class="p">,</span> <span class="n">propagate_gsparams</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_propagate_gsparams</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_shoot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">photons</span><span class="p">,</span> <span class="n">rng</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">GalSimNotImplementedError</span><span class="p">(</span><span class="s2">&quot;ChromaticConvolution cannot be used as a PhotonOp&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="ChromaticConvolution.drawImage"><a class="viewcode-back" href="../../chromaticobject.html#galsim.ChromaticConvolution.drawImage">[docs]</a>    <span class="k">def</span> <span class="nf">drawImage</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bandpass</span><span class="p">,</span> <span class="n">image</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">integrator</span><span class="o">=</span><span class="s1">&#39;quadratic&#39;</span><span class="p">,</span> <span class="n">iimult</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Optimized draw method for the `ChromaticConvolution` class.</span>

<span class="sd">        Works by finding sums of profiles which include separable portions, which can then be</span>
<span class="sd">        integrated before doing any convolutions, which are pushed to the end.</span>

<span class="sd">        This method uses a cache to avoid recomputing &#39;effective&#39; profiles, which are the</span>
<span class="sd">        wavelength-integrated products of inseparable profiles, the spectral components of</span>
<span class="sd">        separable profiles, and the bandpass.  Because the cache size is finite, users may find</span>
<span class="sd">        that it is more efficient when drawing many images to group images using the same</span>
<span class="sd">        SEDs, bandpasses, and inseparable profiles (generally PSFs) together in order to hit the</span>
<span class="sd">        cache more often.  The default cache size is 10, but may be resized using the</span>
<span class="sd">        `ChromaticConvolution.resize_effective_prof_cache` method.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            bandpass:       A `Bandpass` object representing the filter against which to</span>
<span class="sd">                            integrate.</span>
<span class="sd">            image:          Optionally, the `Image` to draw onto.  (See `GSObject.drawImage`</span>
<span class="sd">                            for details.)  [default: None]</span>
<span class="sd">            integrator:     When doing the exact evaluation of the profile, this argument should</span>
<span class="sd">                            be one of the image integrators from galsim.integ, or a string</span>
<span class="sd">                            &#39;trapezoidal&#39;, &#39;midpoint&#39;, or &#39;quadratic&#39;, in which case the routine</span>
<span class="sd">                            will use a `SampleIntegrator` or `ContinuousIntegrator` depending on</span>
<span class="sd">                            whether or not the object has a ``wave_list``.  [default: &#39;quadratic&#39;,</span>
<span class="sd">                            which will try to select an appropriate integrator using the</span>
<span class="sd">                            quadratic integration rule automatically.]</span>
<span class="sd">            iimult:         Oversample any intermediate `InterpolatedImage` created to hold</span>
<span class="sd">                            effective profiles by this amount. [default: None]</span>
<span class="sd">            **kwargs:       For all other kwarg options, see `GSObject.drawImage`.</span>

<span class="sd">        Returns:</span>
<span class="sd">            the drawn `Image`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.convolve</span> <span class="kn">import</span> <span class="n">Convolve</span>
        <span class="kn">from</span> <span class="nn">.random</span> <span class="kn">import</span> <span class="n">BaseDeviate</span>
        <span class="c1"># Store the last bandpass used.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_last_bp</span> <span class="o">=</span> <span class="n">bandpass</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">SED</span><span class="o">.</span><span class="n">dimensionless</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">GalSimSEDError</span><span class="p">(</span><span class="s2">&quot;Can only draw ChromaticObjects with spectral SEDs.&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">SED</span><span class="p">)</span>
        <span class="c1"># `ChromaticObject.drawImage()` can just as efficiently handle separable cases.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">separable</span><span class="p">:</span>
            <span class="n">image</span> <span class="o">=</span> <span class="n">ChromaticObject</span><span class="o">.</span><span class="n">drawImage</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bandpass</span><span class="p">,</span> <span class="n">image</span><span class="o">=</span><span class="n">image</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_last_wcs</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">wcs</span>
            <span class="k">return</span> <span class="n">image</span>

        <span class="c1"># Now split up any `ChromaticSum`s:</span>
        <span class="c1"># This is the tricky part.  Some notation first:</span>
        <span class="c1">#     int(f(x,y,lambda)) denotes the integral over wavelength of chromatic surface</span>
        <span class="c1">#         brightness profile f(x,y,lambda).</span>
        <span class="c1">#     (f1 * f2) denotes the convolution of surface brightness profiles f1 &amp; f2.</span>
        <span class="c1">#     (f1 + f2) denotes the addition of surface brightness profiles f1 &amp; f2.</span>
        <span class="c1">#</span>
        <span class="c1"># In general, chromatic s.b. profiles can be classified as either separable or inseparable,</span>
        <span class="c1"># depending on whether they can be factored into spatial and spectral components or not.</span>
        <span class="c1"># Write separable profiles as g(x,y) * h(lambda), and leave inseparable profiles as</span>
        <span class="c1"># f(x,y,lambda).</span>
        <span class="c1"># We will suppress the arguments `x`, `y`, `lambda`, hereforward, but generally an `f`</span>
        <span class="c1"># refers to an inseparable profile, a `g` refers to the spatial part of a separable</span>
        <span class="c1"># profile, and an `h` refers to the spectral part of a separable profile.</span>
        <span class="c1">#</span>
        <span class="c1"># Now, analyze a typical scenario, a bulge+disk galaxy model (each of which is separable,</span>
        <span class="c1"># e.g., an SED times an exponential profile for the disk, and a different SED times a DeV</span>
        <span class="c1"># profile for the bulge).  Suppose the PSF is inseparable.  (Chromatic PSF&#39;s will generally</span>
        <span class="c1"># be inseparable since we usually think of the spatial part of the PSF being normalized to</span>
        <span class="c1"># unit integral for any fixed wavelength.)  Say there&#39;s also an achromatic pixel to</span>
        <span class="c1"># convolve with.</span>
        <span class="c1"># The formula for this might look like:</span>
        <span class="c1">#</span>
        <span class="c1"># img = int((bulge + disk) * PSF * pix)</span>
        <span class="c1">#     = int((g1 h1 + g2 h2) * f3 * g4)               # note pix is lambda-independent</span>
        <span class="c1">#     = int(g1 h1 * f3 * g4 + g2 h2 * f3 * g4)       # distribute the + over the *</span>
        <span class="c1">#     = int(g1 h1 * f3 * g4) + int(g2 h2 * f3 * g4)  # distribute the + over the int</span>
        <span class="c1">#     = g1 * g4 * int(h1 f3) + g2 * g4 * int(h2 f3)  # move lambda-indep terms out of int</span>
        <span class="c1">#</span>
        <span class="c1"># The result is that the integral is now inside the convolution, meaning we only have to</span>
        <span class="c1"># compute two convolutions instead of a convolution for each wavelength at which we evaluate</span>
        <span class="c1"># the integrand.  This technique, making an &quot;effective&quot; PSF profile for each of the bulge</span>
        <span class="c1"># and disk, is a significant time savings in most cases.</span>
        <span class="c1">#</span>
        <span class="c1"># In general, we make effective profiles by splitting up ChromaticSum items and collecting</span>
        <span class="c1"># the inseparable terms on which to do integration first, and then finish with convolution</span>
        <span class="c1"># last.</span>

        <span class="c1"># Here is the logic to turn int((g1 h1 + g2 h2) * f3) -&gt; g1 * int(h1 f3) + g2 * int(h2 f3)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">obj</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj_list</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">ChromaticSum</span><span class="p">):</span>
                <span class="c1"># say obj.obj_list = [A,B,C], where obj is a ChromaticSum object</span>
                <span class="c1"># Assemble temporary list of convolutants excluding the ChromaticSum in question.</span>
                <span class="n">tmplist</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj_list</span><span class="p">)</span>
                <span class="k">del</span> <span class="n">tmplist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>  <span class="c1"># remove ChromaticSum object from obj_list</span>
                <span class="n">tmplist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">obj_list</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>  <span class="c1"># Append first summand, i.e., A, to convolutants</span>
                <span class="c1"># now draw this image</span>
                <span class="n">tmpobj</span> <span class="o">=</span> <span class="n">ChromaticConvolution</span><span class="p">(</span><span class="n">tmplist</span><span class="p">)</span>
                <span class="n">add_to_image</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;add_to_image&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
                <span class="n">image</span> <span class="o">=</span> <span class="n">tmpobj</span><span class="o">.</span><span class="n">drawImage</span><span class="p">(</span><span class="n">bandpass</span><span class="p">,</span> <span class="n">image</span><span class="o">=</span><span class="n">image</span><span class="p">,</span> <span class="n">integrator</span><span class="o">=</span><span class="n">integrator</span><span class="p">,</span>
                                         <span class="n">iimult</span><span class="o">=</span><span class="n">iimult</span><span class="p">,</span> <span class="n">add_to_image</span><span class="o">=</span><span class="n">add_to_image</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                <span class="c1"># Now add in the rest of the summands in turn, i.e., B and C</span>
                <span class="k">for</span> <span class="n">summand</span> <span class="ow">in</span> <span class="n">obj</span><span class="o">.</span><span class="n">obj_list</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                    <span class="n">tmplist</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj_list</span><span class="p">)</span>
                    <span class="k">del</span> <span class="n">tmplist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="n">tmplist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">summand</span><span class="p">)</span>
                    <span class="n">tmpobj</span> <span class="o">=</span> <span class="n">ChromaticConvolution</span><span class="p">(</span><span class="n">tmplist</span><span class="p">)</span>
                    <span class="c1"># add to previously started image</span>
                    <span class="n">_remove_setup_kwargs</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
                    <span class="n">image</span> <span class="o">=</span> <span class="n">tmpobj</span><span class="o">.</span><span class="n">drawImage</span><span class="p">(</span><span class="n">bandpass</span><span class="p">,</span> <span class="n">image</span><span class="o">=</span><span class="n">image</span><span class="p">,</span> <span class="n">integrator</span><span class="o">=</span><span class="n">integrator</span><span class="p">,</span>
                                             <span class="n">iimult</span><span class="o">=</span><span class="n">iimult</span><span class="p">,</span> <span class="n">add_to_image</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                <span class="c1"># Return the image here, breaking the loop early.  If there are two ChromaticSum</span>
                <span class="c1"># instances in obj_list, then the above procedure will repeat in the recursion,</span>
                <span class="c1"># effectively distributing the multiplication over both sums.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_last_wcs</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">wcs</span>
                <span class="k">return</span> <span class="n">image</span>

        <span class="c1"># If program gets this far, the objects in obj_list should be atomic (non-ChromaticSum</span>
        <span class="c1"># and non-ChromaticConvolution).  (The latter case was dealt with in the constructor.)</span>

        <span class="c1"># setup output image (semi-arbitrarily using the bandpass effective wavelength)</span>
        <span class="n">wave0</span><span class="p">,</span> <span class="n">prof0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fiducial_profile</span><span class="p">(</span><span class="n">bandpass</span><span class="p">)</span>
        <span class="n">image</span> <span class="o">=</span> <span class="n">prof0</span><span class="o">.</span><span class="n">drawImage</span><span class="p">(</span><span class="n">image</span><span class="o">=</span><span class="n">image</span><span class="p">,</span> <span class="n">setup_only</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">_remove_setup_kwargs</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># If we are photon shooting, then we can move all non-spectral objects to the photon_ops</span>
        <span class="c1"># list and deal with them that way.  This both more accurate and more efficient for most</span>
        <span class="c1"># chromatic PSFs.</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;method&#39;</span><span class="p">,</span> <span class="s1">&#39;auto&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="s1">&#39;phot&#39;</span><span class="p">:</span>
            <span class="n">psfs</span> <span class="o">=</span> <span class="p">[</span><span class="n">obj</span> <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">obj_list</span> <span class="k">if</span> <span class="n">obj</span><span class="o">.</span><span class="n">dimensionless</span><span class="p">]</span>
            <span class="n">gals</span> <span class="o">=</span> <span class="p">[</span><span class="n">obj</span> <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">obj_list</span> <span class="k">if</span> <span class="n">obj</span><span class="o">.</span><span class="n">spectral</span><span class="p">]</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">gals</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>  <span class="c1"># Should have been checked by constructor.</span>
            <span class="n">gal</span> <span class="o">=</span> <span class="n">gals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;photon_ops&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">psfs</span> <span class="o">+</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;photon_ops&#39;</span><span class="p">,</span> <span class="p">[])</span>

            <span class="c1"># Need to calculate n_photons now using the fiducial profile, not gal, in case the</span>
            <span class="c1"># PSF has an interpolated image (e.g. OpticalPSF) which needs more photons.</span>
            <span class="n">flux</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculateFlux</span><span class="p">(</span><span class="n">bandpass</span><span class="p">)</span>
            <span class="n">prof1</span> <span class="o">=</span> <span class="n">prof0</span><span class="o">.</span><span class="n">withFlux</span><span class="p">(</span><span class="n">flux</span><span class="p">)</span>
            <span class="n">n_photons</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;n_photons&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">poisson_flux</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;poisson_flux&#39;</span><span class="p">,</span> <span class="n">n_photons</span> <span class="o">==</span> <span class="mf">0.</span><span class="p">)</span>
            <span class="n">max_extra_noise</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;max_extra_noise&#39;</span><span class="p">,</span> <span class="mf">0.</span><span class="p">)</span>
            <span class="n">rng</span> <span class="o">=</span> <span class="n">BaseDeviate</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;rng&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
            <span class="n">n_photons</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">prof1</span><span class="o">.</span><span class="n">_calculate_nphotons</span><span class="p">(</span><span class="n">n_photons</span><span class="p">,</span> <span class="n">poisson_flux</span><span class="p">,</span> <span class="n">max_extra_noise</span><span class="p">,</span> <span class="n">rng</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">gal</span><span class="o">.</span><span class="n">drawImage</span><span class="p">(</span><span class="n">bandpass</span><span class="p">,</span> <span class="n">image</span><span class="o">=</span><span class="n">image</span><span class="p">,</span> <span class="n">integrator</span><span class="o">=</span><span class="n">integrator</span><span class="p">,</span>
                                 <span class="n">n_photons</span><span class="o">=</span><span class="n">n_photons</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Separate convolutants into a Convolution of inseparable profiles multiplied by the</span>
        <span class="c1"># wavelength-dependent normalization of separable profiles, and the achromatic part of</span>
        <span class="c1"># separable profiles.</span>
        <span class="n">insep_obj</span> <span class="o">=</span> <span class="p">[</span><span class="n">obj</span> <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">obj_list</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">obj</span><span class="o">.</span><span class="n">separable</span><span class="p">]</span>

        <span class="c1"># Note that len(insep_obj) &gt; 0, since purely separable ChromaticConvolutions were</span>
        <span class="c1"># already handled above.</span>
        <span class="c1"># Don&#39;t wrap in Convolution if not needed.  Single item can draw itself better than</span>
        <span class="c1"># Convolution can.</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">insep_obj</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">insep_obj</span> <span class="o">=</span> <span class="n">insep_obj</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">insep_obj</span> <span class="o">=</span> <span class="n">Convolve</span><span class="p">(</span><span class="n">insep_obj</span><span class="p">,</span> <span class="n">gsparams</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_gsparams</span><span class="p">,</span>
                                 <span class="n">propagate_gsparams</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_propagate_gsparams</span><span class="p">)</span>

        <span class="n">sep_profs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">obj_list</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">obj</span><span class="o">.</span><span class="n">separable</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">wave0</span><span class="p">,</span> <span class="n">prof0</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">_fiducial_profile</span><span class="p">(</span><span class="n">bandpass</span><span class="p">)</span>
            <span class="n">sep_profs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">prof0</span> <span class="o">/</span> <span class="n">obj</span><span class="o">.</span><span class="n">SED</span><span class="p">(</span><span class="n">wave0</span><span class="p">))</span>
            <span class="n">insep_obj</span> <span class="o">*=</span> <span class="n">obj</span><span class="o">.</span><span class="n">SED</span>

        <span class="c1"># Collapse inseparable profiles and chromatic normalizations into one effective profile</span>
        <span class="c1"># Note that at this point, insep_obj.SED should *not* be None.</span>
        <span class="n">effective_prof</span> <span class="o">=</span> <span class="n">ChromaticConvolution</span><span class="o">.</span><span class="n">_effective_prof_cache</span><span class="p">(</span>
                <span class="n">insep_obj</span><span class="p">,</span> <span class="n">bandpass</span><span class="p">,</span> <span class="n">iimult</span><span class="p">,</span> <span class="n">integrator</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gsparams</span><span class="p">)</span>

        <span class="c1"># append effective profile to separable profiles (which should all be GSObjects)</span>
        <span class="n">sep_profs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">effective_prof</span><span class="p">)</span>
        <span class="c1"># finally, convolve and draw.</span>
        <span class="n">final_prof</span> <span class="o">=</span> <span class="n">Convolve</span><span class="p">(</span><span class="n">sep_profs</span><span class="p">,</span> <span class="n">gsparams</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_gsparams</span><span class="p">,</span>
                              <span class="n">propagate_gsparams</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_propagate_gsparams</span><span class="p">)</span>
        <span class="n">image</span> <span class="o">=</span> <span class="n">final_prof</span><span class="o">.</span><span class="n">drawImage</span><span class="p">(</span><span class="n">image</span><span class="o">=</span><span class="n">image</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_last_wcs</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">wcs</span>
        <span class="k">return</span> <span class="n">image</span></div>

    <span class="nd">@lazy_property</span>
    <span class="k">def</span> <span class="nf">noise</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;An estimate of the noise already in the profile.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.convolve</span> <span class="kn">import</span> <span class="n">Convolve</span>
        <span class="c1"># Condition for being able to propagate noise:</span>
        <span class="c1"># Exactly one of the convolutants has a .covspec attribute.</span>
        <span class="n">covspecs</span> <span class="o">=</span> <span class="p">[</span> <span class="n">obj</span><span class="o">.</span><span class="n">covspec</span> <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">obj_list</span> <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s1">&#39;covspec&#39;</span><span class="p">)</span> <span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">covspecs</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">GalSimError</span><span class="p">(</span><span class="s2">&quot;Cannot compute noise for ChromaticConvolution for which number &quot;</span>
                              <span class="s2">&quot;of convolutants with covspec attribute is not 1.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_last_bp&#39;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">GalSimError</span><span class="p">(</span><span class="s2">&quot;Cannot compute noise for ChromaticConvolution until after drawImage &quot;</span>
                              <span class="s2">&quot;has been called.&quot;</span><span class="p">)</span>
        <span class="n">covspec</span> <span class="o">=</span> <span class="n">covspecs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">other</span> <span class="o">=</span> <span class="n">Convolve</span><span class="p">([</span><span class="n">obj</span> <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">obj_list</span> <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s1">&#39;covspec&#39;</span><span class="p">)])</span>
        <span class="k">return</span> <span class="n">covspec</span><span class="o">.</span><span class="n">toNoise</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_last_bp</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_last_wcs</span><span class="p">)</span>  <span class="c1"># rng=?</span></div>


<span class="n">ChromaticConvolution</span><span class="o">.</span><span class="n">_effective_prof_cache</span> <span class="o">=</span> <span class="n">utilities</span><span class="o">.</span><span class="n">LRU_Cache</span><span class="p">(</span>
    <span class="n">ChromaticConvolution</span><span class="o">.</span><span class="n">_get_effective_prof</span><span class="p">,</span> <span class="n">maxsize</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>


<div class="viewcode-block" id="ChromaticDeconvolution"><a class="viewcode-back" href="../../chromaticobject.html#galsim.ChromaticDeconvolution">[docs]</a><span class="k">class</span> <span class="nc">ChromaticDeconvolution</span><span class="p">(</span><span class="n">ChromaticObject</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A class for deconvolving a `ChromaticObject`.</span>

<span class="sd">    The ChromaticDeconvolution class represents a wavelength-dependent deconvolution kernel.</span>

<span class="sd">    You may also specify a gsparams argument.  See the docstring for `GSParams` for more</span>
<span class="sd">    information about this option.  Note: if ``gsparams`` is unspecified (or None), then the</span>
<span class="sd">    ChromaticDeconvolution instance inherits the same `GSParams` as the object being deconvolved.</span>

<span class="sd">    This is the type returned from `galsim.Deconvolve` if the argument is a `ChromaticObject`.</span>
<span class="sd">    This is the normal way to construct this class.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        obj:                The object to deconvolve.</span>
<span class="sd">        gsparams:           An optional `GSParams` argument.  See the docstring for `GSParams` for</span>
<span class="sd">                            details. [default: None]</span>
<span class="sd">        propagate_gsparams: Whether to propagate gsparams to each of the components.  This</span>
<span class="sd">                            is normally a good idea, but there may be use cases where one</span>
<span class="sd">                            would not want to do this. [default: True]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">gsparams</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">propagate_gsparams</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">obj</span><span class="o">.</span><span class="n">SED</span><span class="o">.</span><span class="n">dimensionless</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">GalSimSEDError</span><span class="p">(</span><span class="s2">&quot;Cannot deconvolve by spectral ChromaticObject.&quot;</span><span class="p">,</span> <span class="n">obj</span><span class="o">.</span><span class="n">SED</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_gsparams</span> <span class="o">=</span> <span class="n">GSParams</span><span class="o">.</span><span class="n">check</span><span class="p">(</span><span class="n">gsparams</span><span class="p">,</span> <span class="n">obj</span><span class="o">.</span><span class="n">gsparams</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_propagate_gsparams</span> <span class="o">=</span> <span class="n">propagate_gsparams</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_propagate_gsparams</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_obj</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">withGSParams</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_gsparams</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_obj</span> <span class="o">=</span> <span class="n">obj</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">separable</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">separable</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">interpolated</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">interpolated</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">interpolated</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">deinterpolated</span> <span class="o">=</span> <span class="n">ChromaticDeconvolution</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_obj</span><span class="o">.</span><span class="n">deinterpolated</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gsparams</span><span class="p">,</span>
                                                         <span class="bp">self</span><span class="o">.</span><span class="n">_propagate_gsparams</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">deinterpolated</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">SED</span> <span class="o">=</span> <span class="n">SED</span><span class="p">(</span><span class="k">lambda</span> <span class="n">w</span><span class="p">:</span> <span class="mf">1.</span><span class="o">/</span><span class="n">obj</span><span class="o">.</span><span class="n">SED</span><span class="p">(</span><span class="n">w</span><span class="p">),</span> <span class="s1">&#39;nm&#39;</span><span class="p">,</span> <span class="s1">&#39;1&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">wave_list</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">wave_list</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">gsparams</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The `GSParams` for this object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gsparams</span>

<div class="viewcode-block" id="ChromaticDeconvolution.withGSParams"><a class="viewcode-back" href="../../chromaticobject.html#galsim.ChromaticDeconvolution.withGSParams">[docs]</a>    <span class="nd">@doc_inherit</span>
    <span class="k">def</span> <span class="nf">withGSParams</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gsparams</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">gsparams</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">gsparams</span><span class="p">:</span> <span class="k">return</span> <span class="bp">self</span>
        <span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">copy</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">_gsparams</span> <span class="o">=</span> <span class="n">GSParams</span><span class="o">.</span><span class="n">check</span><span class="p">(</span><span class="n">gsparams</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gsparams</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_propagate_gsparams</span><span class="p">:</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">_obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_obj</span><span class="o">.</span><span class="n">withGSParams</span><span class="p">(</span><span class="n">ret</span><span class="o">.</span><span class="n">_gsparams</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ret</span></div>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span> <span class="ow">is</span> <span class="n">other</span> <span class="ow">or</span>
                <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">ChromaticDeconvolution</span><span class="p">)</span> <span class="ow">and</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">_obj</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_obj</span> <span class="ow">and</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">gsparams</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">gsparams</span> <span class="ow">and</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">_propagate_gsparams</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_propagate_gsparams</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">((</span><span class="s2">&quot;galsim.ChromaticDeconvolution&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_obj</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gsparams</span><span class="p">,</span>
                     <span class="bp">self</span><span class="o">.</span><span class="n">_propagate_gsparams</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;galsim.ChromaticDeconvolution(</span><span class="si">%r</span><span class="s1">, gsparams=</span><span class="si">%r</span><span class="s1">, propagate_gsparams=</span><span class="si">%r</span><span class="s1">)&#39;</span><span class="o">%</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_obj</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gsparams</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_propagate_gsparams</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;galsim.ChromaticDeconvolution(</span><span class="si">%s</span><span class="s1">)&#39;</span><span class="o">%</span><span class="bp">self</span><span class="o">.</span><span class="n">_obj</span>

<div class="viewcode-block" id="ChromaticDeconvolution.evaluateAtWavelength"><a class="viewcode-back" href="../../chromaticobject.html#galsim.ChromaticDeconvolution.evaluateAtWavelength">[docs]</a>    <span class="k">def</span> <span class="nf">evaluateAtWavelength</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">wave</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Evaluate this chromatic object at a particular wavelength ``wave``.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            wave:   Wavelength in nanometers.</span>

<span class="sd">        Returns:</span>
<span class="sd">            the monochromatic object at the given wavelength.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.convolve</span> <span class="kn">import</span> <span class="n">Deconvolve</span>
        <span class="k">return</span> <span class="n">Deconvolve</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_obj</span><span class="o">.</span><span class="n">evaluateAtWavelength</span><span class="p">(</span><span class="n">wave</span><span class="p">),</span> <span class="n">gsparams</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">gsparams</span><span class="p">,</span>
                          <span class="n">propagate_gsparams</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_propagate_gsparams</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_shoot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">photons</span><span class="p">,</span> <span class="n">rng</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">GalSimNotImplementedError</span><span class="p">(</span><span class="s2">&quot;ChromaticDeconvolution cannot use method=&#39;phot&#39;&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="ChromaticAutoConvolution"><a class="viewcode-back" href="../../chromaticobject.html#galsim.ChromaticAutoConvolution">[docs]</a><span class="k">class</span> <span class="nc">ChromaticAutoConvolution</span><span class="p">(</span><span class="n">ChromaticObject</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A special class for convolving a `ChromaticObject` with itself.</span>

<span class="sd">    It is equivalent in functionality to ``galsim.Convolve([obj,obj])``, but takes advantage of</span>
<span class="sd">    the fact that the two profiles are the same for some efficiency gains.</span>

<span class="sd">    This is the type returned from `galsim.AutoConvolve` if the argument is a `ChromaticObject`.</span>
<span class="sd">    This is the normal way to construct this class.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        obj:                The object to be convolved with itself.</span>
<span class="sd">        real_space:         Whether to use real space convolution.  [default: None, which means</span>
<span class="sd">                            to automatically decide this according to whether the objects have hard</span>
<span class="sd">                            edges.]</span>
<span class="sd">        gsparams:           An optional `GSParams` argument.  See the docstring for `GSParams` for</span>
<span class="sd">                            details. [default: None]</span>
<span class="sd">        propagate_gsparams: Whether to propagate gsparams to each of the components.  This</span>
<span class="sd">                            is normally a good idea, but there may be use cases where one</span>
<span class="sd">                            would not want to do this. [default: True]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">real_space</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">gsparams</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">propagate_gsparams</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">obj</span><span class="o">.</span><span class="n">SED</span><span class="o">.</span><span class="n">dimensionless</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">GalSimSEDError</span><span class="p">(</span><span class="s2">&quot;Cannot autoconvolve spectral ChromaticObject.&quot;</span><span class="p">,</span> <span class="n">obj</span><span class="o">.</span><span class="n">SED</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_gsparams</span> <span class="o">=</span> <span class="n">GSParams</span><span class="o">.</span><span class="n">check</span><span class="p">(</span><span class="n">gsparams</span><span class="p">,</span> <span class="n">obj</span><span class="o">.</span><span class="n">gsparams</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_propagate_gsparams</span> <span class="o">=</span> <span class="n">propagate_gsparams</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_propagate_gsparams</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_obj</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">withGSParams</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_gsparams</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_obj</span> <span class="o">=</span> <span class="n">obj</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_real_space</span> <span class="o">=</span> <span class="n">real_space</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">separable</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">separable</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">interpolated</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">interpolated</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">interpolated</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">deinterpolated</span> <span class="o">=</span> <span class="n">ChromaticAutoConvolution</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_obj</span><span class="o">.</span><span class="n">deinterpolated</span><span class="p">,</span> <span class="n">real_space</span><span class="p">,</span>
                                                           <span class="bp">self</span><span class="o">.</span><span class="n">_gsparams</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_propagate_gsparams</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">deinterpolated</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">SED</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">SED</span> <span class="o">*</span> <span class="n">obj</span><span class="o">.</span><span class="n">SED</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">wave_list</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">wave_list</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">gsparams</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The `GSParams` for this object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gsparams</span>

<div class="viewcode-block" id="ChromaticAutoConvolution.withGSParams"><a class="viewcode-back" href="../../chromaticobject.html#galsim.ChromaticAutoConvolution.withGSParams">[docs]</a>    <span class="nd">@doc_inherit</span>
    <span class="k">def</span> <span class="nf">withGSParams</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gsparams</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">gsparams</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">gsparams</span><span class="p">:</span> <span class="k">return</span> <span class="bp">self</span>
        <span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">copy</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">_gsparams</span> <span class="o">=</span> <span class="n">GSParams</span><span class="o">.</span><span class="n">check</span><span class="p">(</span><span class="n">gsparams</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gsparams</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_propagate_gsparams</span><span class="p">:</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">_obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_obj</span><span class="o">.</span><span class="n">withGSParams</span><span class="p">(</span><span class="n">ret</span><span class="o">.</span><span class="n">_gsparams</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ret</span></div>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span> <span class="ow">is</span> <span class="n">other</span> <span class="ow">or</span>
                <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">ChromaticAutoConvolution</span><span class="p">)</span> <span class="ow">and</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">_obj</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_obj</span> <span class="ow">and</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">_real_space</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_real_space</span> <span class="ow">and</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">gsparams</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">gsparams</span> <span class="ow">and</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">_propagate_gsparams</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_propagate_gsparams</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">((</span><span class="s2">&quot;galsim.ChromaticAutoConvolution&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_obj</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_real_space</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gsparams</span><span class="p">,</span>
                     <span class="bp">self</span><span class="o">.</span><span class="n">_propagate_gsparams</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="s1">&#39;galsim.ChromaticAutoConvolution(</span><span class="si">%r</span><span class="s1">, real_space=</span><span class="si">%r</span><span class="s1">, gsparams=</span><span class="si">%r</span><span class="s1">, &#39;</span>
                <span class="s1">&#39;propagate_gsparams=</span><span class="si">%r</span><span class="s1">)&#39;</span><span class="p">)</span><span class="o">%</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_obj</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_real_space</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gsparams</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_propagate_gsparams</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;galsim.ChromaticAutoConvolution(</span><span class="si">%s</span><span class="s1">)&#39;</span><span class="o">%</span><span class="bp">self</span><span class="o">.</span><span class="n">_obj</span>

<div class="viewcode-block" id="ChromaticAutoConvolution.evaluateAtWavelength"><a class="viewcode-back" href="../../chromaticobject.html#galsim.ChromaticAutoConvolution.evaluateAtWavelength">[docs]</a>    <span class="k">def</span> <span class="nf">evaluateAtWavelength</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">wave</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Evaluate this chromatic object at a particular wavelength ``wave``.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            wave:   Wavelength in nanometers.</span>

<span class="sd">        Returns:</span>
<span class="sd">            the monochromatic object at the given wavelength.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.convolve</span> <span class="kn">import</span> <span class="n">AutoConvolve</span>
        <span class="k">return</span> <span class="n">AutoConvolve</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_obj</span><span class="o">.</span><span class="n">evaluateAtWavelength</span><span class="p">(</span><span class="n">wave</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_real_space</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gsparams</span><span class="p">,</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">_propagate_gsparams</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_shoot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">photons</span><span class="p">,</span> <span class="n">rng</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">GalSimNotImplementedError</span><span class="p">(</span><span class="s2">&quot;ChromaticAutoConvolution cannot be used as a PhotonOp&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="ChromaticAutoCorrelation"><a class="viewcode-back" href="../../chromaticobject.html#galsim.ChromaticAutoCorrelation">[docs]</a><span class="k">class</span> <span class="nc">ChromaticAutoCorrelation</span><span class="p">(</span><span class="n">ChromaticObject</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A special class for correlating a `ChromaticObject` with itself.</span>

<span class="sd">    It is equivalent in functionality to::</span>

<span class="sd">        galsim.Convolve([obj,obj.rotate(180.*galsim.degrees)])</span>

<span class="sd">    but takes advantage of the fact that the two profiles are the same for some efficiency gains.</span>

<span class="sd">    This is the type returned from `galsim.AutoCorrelate` if the argument is a `ChromaticObject`.</span>
<span class="sd">    This is the normal way to construct this class.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        obj:                The object to be convolved with itself.</span>
<span class="sd">        real_space:         Whether to use real space convolution.  [default: None, which means</span>
<span class="sd">                            to automatically decide this according to whether the objects have hard</span>
<span class="sd">                            edges.]</span>
<span class="sd">        gsparams:           An optional `GSParams` argument.  See the docstring for `GSParams` for</span>
<span class="sd">                            details. [default: None]</span>
<span class="sd">        propagate_gsparams: Whether to propagate gsparams to each of the components.  This</span>
<span class="sd">                            is normally a good idea, but there may be use cases where one</span>
<span class="sd">                            would not want to do this. [default: True]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">real_space</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">gsparams</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">propagate_gsparams</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">obj</span><span class="o">.</span><span class="n">SED</span><span class="o">.</span><span class="n">dimensionless</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">GalSimSEDError</span><span class="p">(</span><span class="s2">&quot;Cannot autocorrelate spectral ChromaticObject.&quot;</span><span class="p">,</span> <span class="n">obj</span><span class="o">.</span><span class="n">SED</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_gsparams</span> <span class="o">=</span> <span class="n">GSParams</span><span class="o">.</span><span class="n">check</span><span class="p">(</span><span class="n">gsparams</span><span class="p">,</span> <span class="n">obj</span><span class="o">.</span><span class="n">gsparams</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_propagate_gsparams</span> <span class="o">=</span> <span class="n">propagate_gsparams</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_propagate_gsparams</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_obj</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">withGSParams</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_gsparams</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_obj</span> <span class="o">=</span> <span class="n">obj</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_real_space</span> <span class="o">=</span> <span class="n">real_space</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">separable</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">separable</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">interpolated</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">interpolated</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">interpolated</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">deinterpolated</span> <span class="o">=</span> <span class="n">ChromaticAutoCorrelation</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_obj</span><span class="o">.</span><span class="n">deinterpolated</span><span class="p">,</span>
                                                           <span class="bp">self</span><span class="o">.</span><span class="n">_real_space</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gsparams</span><span class="p">,</span>
                                                           <span class="bp">self</span><span class="o">.</span><span class="n">_propagate_gsparams</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">deinterpolated</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">SED</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">SED</span> <span class="o">*</span> <span class="n">obj</span><span class="o">.</span><span class="n">SED</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">wave_list</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">wave_list</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">gsparams</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The `GSParams` for this object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gsparams</span>

<div class="viewcode-block" id="ChromaticAutoCorrelation.withGSParams"><a class="viewcode-back" href="../../chromaticobject.html#galsim.ChromaticAutoCorrelation.withGSParams">[docs]</a>    <span class="nd">@doc_inherit</span>
    <span class="k">def</span> <span class="nf">withGSParams</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gsparams</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">gsparams</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">gsparams</span><span class="p">:</span> <span class="k">return</span> <span class="bp">self</span>
        <span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">copy</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">_gsparams</span> <span class="o">=</span> <span class="n">GSParams</span><span class="o">.</span><span class="n">check</span><span class="p">(</span><span class="n">gsparams</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gsparams</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_propagate_gsparams</span><span class="p">:</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">_obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_obj</span><span class="o">.</span><span class="n">withGSParams</span><span class="p">(</span><span class="n">ret</span><span class="o">.</span><span class="n">_gsparams</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ret</span></div>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span> <span class="ow">is</span> <span class="n">other</span> <span class="ow">or</span>
                <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">ChromaticAutoCorrelation</span><span class="p">)</span> <span class="ow">and</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">_obj</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_obj</span> <span class="ow">and</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">_real_space</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_real_space</span> <span class="ow">and</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">gsparams</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">gsparams</span> <span class="ow">and</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">_propagate_gsparams</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_propagate_gsparams</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">((</span><span class="s2">&quot;galsim.ChromaticAutoCorrelation&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_obj</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_real_space</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gsparams</span><span class="p">,</span>
                     <span class="bp">self</span><span class="o">.</span><span class="n">_propagate_gsparams</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="s1">&#39;galsim.ChromaticAutoCorrelation(</span><span class="si">%r</span><span class="s1">, real_space=</span><span class="si">%r</span><span class="s1">, gsparams=</span><span class="si">%r</span><span class="s1">, &#39;</span>
                <span class="s1">&#39;propagate_gsparams=</span><span class="si">%r</span><span class="s1">)&#39;</span><span class="p">)</span><span class="o">%</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_obj</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_real_space</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gsparams</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_propagate_gsparams</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;galsim.ChromaticAutoCorrelation(</span><span class="si">%s</span><span class="s1">)&#39;</span><span class="o">%</span><span class="bp">self</span><span class="o">.</span><span class="n">_obj</span>

<div class="viewcode-block" id="ChromaticAutoCorrelation.evaluateAtWavelength"><a class="viewcode-back" href="../../chromaticobject.html#galsim.ChromaticAutoCorrelation.evaluateAtWavelength">[docs]</a>    <span class="k">def</span> <span class="nf">evaluateAtWavelength</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">wave</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Evaluate this chromatic object at a particular wavelength ``wave``.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            wave:   Wavelength in nanometers.</span>

<span class="sd">        Returns:</span>
<span class="sd">            the monochromatic object at the given wavelength.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.convolve</span> <span class="kn">import</span> <span class="n">AutoCorrelate</span>
        <span class="k">return</span> <span class="n">AutoCorrelate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_obj</span><span class="o">.</span><span class="n">evaluateAtWavelength</span><span class="p">(</span><span class="n">wave</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_real_space</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gsparams</span><span class="p">,</span>
                             <span class="bp">self</span><span class="o">.</span><span class="n">_propagate_gsparams</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_shoot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">photons</span><span class="p">,</span> <span class="n">rng</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">GalSimNotImplementedError</span><span class="p">(</span><span class="s2">&quot;ChromaticAutoCorrelation cannot be used as a PhotonOp&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="ChromaticFourierSqrtProfile"><a class="viewcode-back" href="../../chromaticobject.html#galsim.ChromaticFourierSqrtProfile">[docs]</a><span class="k">class</span> <span class="nc">ChromaticFourierSqrtProfile</span><span class="p">(</span><span class="n">ChromaticObject</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A class for computing the Fourier-space square root of a `ChromaticObject`.</span>

<span class="sd">    The ChromaticFourierSqrtProfile class represents a wavelength-dependent Fourier-space square</span>
<span class="sd">    root of a profile.</span>

<span class="sd">    You may also specify a gsparams argument.  See the docstring for `GSParams` for more</span>
<span class="sd">    information about this option.  Note: if ``gsparams`` is unspecified (or None), then the</span>
<span class="sd">    ChromaticFourierSqrtProfile inherits the same `GSParams` as the object being operated on.</span>

<span class="sd">    The normal way to use this class is to use the `FourierSqrt` factory function::</span>

<span class="sd">        &gt;&gt;&gt; fourier_sqrt = galsim.FourierSqrt(chromatic_obj)</span>

<span class="sd">    If ``chromatic_obj`` is indeed a `ChromaticObject`, then that function will create a</span>
<span class="sd">    ChromaticFourierSqrtProfile object.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        obj:                The object to compute the Fourier-space square root of.</span>
<span class="sd">        gsparams:           An optional `GSParams` argument.  See the docstring for `GSParams` for</span>
<span class="sd">                            details. [default: None]</span>
<span class="sd">        propagate_gsparams: Whether to propagate gsparams to each of the components.  This</span>
<span class="sd">                            is normally a good idea, but there may be use cases where one</span>
<span class="sd">                            would not want to do this. [default: True]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">gsparams</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">propagate_gsparams</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="kn">import</span> <span class="nn">math</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">obj</span><span class="o">.</span><span class="n">SED</span><span class="o">.</span><span class="n">dimensionless</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">GalSimSEDError</span><span class="p">(</span><span class="s2">&quot;Cannot take Fourier sqrt of spectral ChromaticObject.&quot;</span><span class="p">,</span> <span class="n">obj</span><span class="o">.</span><span class="n">SED</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_gsparams</span> <span class="o">=</span> <span class="n">GSParams</span><span class="o">.</span><span class="n">check</span><span class="p">(</span><span class="n">gsparams</span><span class="p">,</span> <span class="n">obj</span><span class="o">.</span><span class="n">gsparams</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_propagate_gsparams</span> <span class="o">=</span> <span class="n">propagate_gsparams</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_propagate_gsparams</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_obj</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">withGSParams</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_gsparams</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_obj</span> <span class="o">=</span> <span class="n">obj</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">separable</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">separable</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">interpolated</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">interpolated</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">interpolated</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">deinterpolated</span> <span class="o">=</span> <span class="n">ChromaticFourierSqrtProfile</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_obj</span><span class="o">.</span><span class="n">deinterpolated</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gsparams</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_propagate_gsparams</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">deinterpolated</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">SED</span> <span class="o">=</span> <span class="n">SED</span><span class="p">(</span><span class="k">lambda</span> <span class="n">w</span><span class="p">:</span><span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">SED</span><span class="p">(</span><span class="n">w</span><span class="p">)),</span> <span class="s1">&#39;nm&#39;</span><span class="p">,</span> <span class="s1">&#39;1&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">wave_list</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">wave_list</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">gsparams</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The `GSParams` for this object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gsparams</span>

<div class="viewcode-block" id="ChromaticFourierSqrtProfile.withGSParams"><a class="viewcode-back" href="../../chromaticobject.html#galsim.ChromaticFourierSqrtProfile.withGSParams">[docs]</a>    <span class="nd">@doc_inherit</span>
    <span class="k">def</span> <span class="nf">withGSParams</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gsparams</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">gsparams</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">gsparams</span><span class="p">:</span> <span class="k">return</span> <span class="bp">self</span>
        <span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">copy</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">_gsparams</span> <span class="o">=</span> <span class="n">GSParams</span><span class="o">.</span><span class="n">check</span><span class="p">(</span><span class="n">gsparams</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gsparams</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_propagate_gsparams</span><span class="p">:</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">_obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_obj</span><span class="o">.</span><span class="n">withGSParams</span><span class="p">(</span><span class="n">ret</span><span class="o">.</span><span class="n">_gsparams</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ret</span></div>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span> <span class="ow">is</span> <span class="n">other</span> <span class="ow">or</span>
                <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">ChromaticFourierSqrtProfile</span><span class="p">)</span> <span class="ow">and</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">_obj</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_obj</span> <span class="ow">and</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">gsparams</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">gsparams</span> <span class="ow">and</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">_propagate_gsparams</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_propagate_gsparams</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">((</span><span class="s2">&quot;galsim.ChromaticFourierSqrtProfile&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_obj</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gsparams</span><span class="p">,</span>
                     <span class="bp">self</span><span class="o">.</span><span class="n">_propagate_gsparams</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;galsim.ChromaticFourierSqrtProfile(</span><span class="si">%r</span><span class="s1">, gsparams=</span><span class="si">%r</span><span class="s1">, propagate_gsparams=</span><span class="si">%r</span><span class="s1">)&#39;</span><span class="o">%</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_obj</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gsparams</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_propagate_gsparams</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;galsim.ChromaticFourierSqrtProfile(</span><span class="si">%s</span><span class="s1">)&#39;</span><span class="o">%</span><span class="bp">self</span><span class="o">.</span><span class="n">_obj</span>

<div class="viewcode-block" id="ChromaticFourierSqrtProfile.evaluateAtWavelength"><a class="viewcode-back" href="../../chromaticobject.html#galsim.ChromaticFourierSqrtProfile.evaluateAtWavelength">[docs]</a>    <span class="k">def</span> <span class="nf">evaluateAtWavelength</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">wave</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Evaluate this chromatic object at a particular wavelength ``wave``.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            wave:   Wavelength in nanometers.</span>

<span class="sd">        Returns:</span>
<span class="sd">            the monochromatic object at the given wavelength.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.fouriersqrt</span> <span class="kn">import</span> <span class="n">FourierSqrt</span>
        <span class="k">return</span> <span class="n">FourierSqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_obj</span><span class="o">.</span><span class="n">evaluateAtWavelength</span><span class="p">(</span><span class="n">wave</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">gsparams</span><span class="p">,</span>
                           <span class="bp">self</span><span class="o">.</span><span class="n">_propagate_gsparams</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_shoot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">photons</span><span class="p">,</span> <span class="n">rng</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">GalSimNotImplementedError</span><span class="p">(</span><span class="s2">&quot;ChromaticFourierSqrtProfile cannot use method=&#39;phot&#39;&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="ChromaticOpticalPSF"><a class="viewcode-back" href="../../chromaticobject.html#galsim.ChromaticOpticalPSF">[docs]</a><span class="k">class</span> <span class="nc">ChromaticOpticalPSF</span><span class="p">(</span><span class="n">ChromaticObject</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A subclass of ChromaticObject meant to represent chromatic optical PSFs.</span>

<span class="sd">    Chromaticity plays two roles in optical PSFs. First, it determines the diffraction limit, via</span>
<span class="sd">    the wavelength/diameter factor.  Second, aberrations such as defocus, coma, etc. are typically</span>
<span class="sd">    defined in physical distances, but their impact on the PSF depends on their size in units of</span>
<span class="sd">    wavelength.  Other aspects of the optical PSF do not require explicit specification of their</span>
<span class="sd">    chromaticity, e.g., once the obscuration and struts are specified in units of the aperture</span>
<span class="sd">    diameter, their chromatic dependence gets taken care of automatically.  Note that the</span>
<span class="sd">    ChromaticOpticalPSF implicitly defines diffraction limits in units of ``scale_units``, which by</span>
<span class="sd">    default are arcsec, but can in principle be set to any of our GalSim angle units.</span>

<span class="sd">    When using interpolation to speed up image rendering (see the `ChromaticObject.interpolate`</span>
<span class="sd">    method for details), the ideal number of wavelengths to use across a given bandpass depends on</span>
<span class="sd">    the application and accuracy requirements.  In general it will be necessary to do a test in</span>
<span class="sd">    comparison with a more exact calculation to ensure convergence.  However, a typical calculation</span>
<span class="sd">    might use ~10-15 samples across a typical optical bandpass, with ``oversample_fac`` in the range</span>
<span class="sd">    1.5-2; for moderate accuracy, ~5 samples across the bandpass and ``oversample_fac=1`` may</span>
<span class="sd">    suffice. All of these statements assume that aberrations are not very large (typically &lt;~0.25</span>
<span class="sd">    waves, which is commonly satisfied by space telescopes); if they are larger than that, then more</span>
<span class="sd">    stringent settings are required.</span>

<span class="sd">    Note that a ChromaticOpticalPSF by itself is NOT the correct thing to use to draw an image of a</span>
<span class="sd">    star. Stars (and galaxies too, of course) have an `SED` that is not flat. To draw a real star,</span>
<span class="sd">    you should either multiply the ChromaticOpticalPSF object by an `SED`, or convolve it with a</span>
<span class="sd">    point source multiplied by an `SED`::</span>

<span class="sd">        &gt;&gt;&gt; psf = galsim.ChromaticOpticalPSF(...)</span>
<span class="sd">        &gt;&gt;&gt; star = galsim.DeltaFunction() * psf_sed</span>
<span class="sd">        &gt;&gt;&gt; final_star = galsim.Convolve( [psf, star] )</span>
<span class="sd">        &gt;&gt;&gt; final_star.drawImage(bandpass = bp, ...)</span>

<span class="sd">    .. note::</span>

<span class="sd">        When geometric_shooting is False (the default), the photon shooting implementation is</span>
<span class="sd">        only approximately correct with respect to the wavelength dependence.  It is also</span>
<span class="sd">        not particularly fast, since it generates three optical screens to span the wavelength</span>
<span class="sd">        range and shoots from these (with a subsequent adjustment to improve the accuracy</span>
<span class="sd">        of this approximation).  We expect that most users who want to use photon shooting in</span>
<span class="sd">        conjunction with this class will prefer to make an InterpolatedChromaticObject</span>
<span class="sd">        (by calling ``psf.interpolate(...)``), especially if it is a good approximation to</span>
<span class="sd">        use the same optical PSF for a whole exposure or CCD image, so the setup time for</span>
<span class="sd">        the interpolation is able to be amortized for many objects.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        lam:            Fiducial wavelength for which diffraction limit and aberrations are</span>
<span class="sd">                        initially defined, in nanometers.</span>
<span class="sd">        diam:           Telescope diameter in meters.  Either ``diam`` or ``lam_over_diam`` must be</span>
<span class="sd">                        specified.</span>
<span class="sd">        lam_over_diam:  Ratio of (fiducial wavelength) / telescope diameter in units of</span>
<span class="sd">                        ``scale_unit``.  Either ``diam`` or ``lam_over_diam`` must be specified.</span>
<span class="sd">        aberrations:    An array of aberrations, in units of fiducial wavelength ``lam``.  The</span>
<span class="sd">                        size and format of this array is described in the OpticalPSF docstring.</span>
<span class="sd">        scale_unit:     Units used to define the diffraction limit and draw images.</span>
<span class="sd">                        [default: galsim.arcsec]</span>
<span class="sd">        gsparams:       An optional `GSParams` argument.  See the docstring for `GSParams` for</span>
<span class="sd">                        details. [default: None]</span>
<span class="sd">        geometric_shooting: If True, then when drawing using photon shooting, use geometric</span>
<span class="sd">                        optics approximation where the photon angles are derived from the</span>
<span class="sd">                        phase screen gradient.  If False, then first draw using Fourier</span>
<span class="sd">                        optics and then shoot from the derived InterpolatedImage. [default: False]</span>
<span class="sd">        **kwargs:       Any other keyword arguments to be passed to OpticalPSF, for example,</span>
<span class="sd">                        related to struts, obscuration, oversampling, etc.  See OpticalPSF</span>
<span class="sd">                        docstring for a complete list of options.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_req_params</span> <span class="o">=</span> <span class="p">{</span> <span class="s1">&#39;lam&#39;</span> <span class="p">:</span> <span class="nb">float</span> <span class="p">}</span>
    <span class="n">_opt_params</span> <span class="o">=</span> <span class="p">{</span> <span class="n">k</span><span class="p">:</span><span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">OpticalPSF</span><span class="o">.</span><span class="n">_opt_params</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="o">!=</span> <span class="s1">&#39;diam&#39;</span> <span class="p">}</span>
    <span class="n">_single_params</span> <span class="o">=</span> <span class="p">[</span> <span class="p">{</span><span class="s1">&#39;diam&#39;</span> <span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="s1">&#39;lam_over_diam&#39;</span> <span class="p">:</span> <span class="nb">float</span><span class="p">}</span> <span class="p">]</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lam</span><span class="p">,</span> <span class="n">diam</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">lam_over_diam</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">aberrations</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">scale_unit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">gsparams</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">.angle</span> <span class="kn">import</span> <span class="n">AngleUnit</span><span class="p">,</span> <span class="n">arcsec</span><span class="p">,</span> <span class="n">radians</span>
        <span class="c1"># First, take the basic info.</span>
        <span class="k">if</span> <span class="n">scale_unit</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">scale_unit</span> <span class="o">=</span> <span class="n">arcsec</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">scale_unit</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">scale_unit</span> <span class="o">=</span> <span class="n">AngleUnit</span><span class="o">.</span><span class="n">from_name</span><span class="p">(</span><span class="n">scale_unit</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scale_unit</span> <span class="o">=</span> <span class="n">scale_unit</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_gsparams</span> <span class="o">=</span> <span class="n">GSParams</span><span class="o">.</span><span class="n">check</span><span class="p">(</span><span class="n">gsparams</span><span class="p">)</span>

        <span class="c1"># We have to require either diam OR lam_over_diam:</span>
        <span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="n">diam</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">lam_over_diam</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span>
             <span class="p">(</span><span class="n">diam</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">lam_over_diam</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="p">):</span>
            <span class="k">raise</span> <span class="n">GalSimIncompatibleValuesError</span><span class="p">(</span>
                <span class="s2">&quot;Need to specify telescope diameter OR wavelength/diam ratio&quot;</span><span class="p">,</span>
                <span class="n">diam</span><span class="o">=</span><span class="n">diam</span><span class="p">,</span> <span class="n">lam_over_diam</span><span class="o">=</span><span class="n">lam_over_diam</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">diam</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lam_over_diam</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.e-9</span><span class="o">*</span><span class="n">lam</span><span class="o">/</span><span class="n">diam</span><span class="p">)</span><span class="o">*</span><span class="n">radians</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">scale_unit</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">diam</span> <span class="o">=</span> <span class="n">diam</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lam_over_diam</span> <span class="o">=</span> <span class="n">lam_over_diam</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">diam</span> <span class="o">=</span> <span class="p">(</span><span class="n">lam</span><span class="o">*</span><span class="mf">1e-9</span><span class="o">/</span><span class="n">lam_over_diam</span><span class="p">)</span><span class="o">*</span><span class="n">radians</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">scale_unit</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lam</span> <span class="o">=</span> <span class="n">lam</span>

        <span class="k">if</span> <span class="n">aberrations</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">aberrations</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">aberrations</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">aberrations</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">12</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">aberrations</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">aberrations</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="mi">12</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">aberrations</span><span class="p">)))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">aberrations</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span>

        <span class="c1"># Pop named aberrations from kwargs so aberrations=[0,0,0,0,1] means the same as</span>
        <span class="c1"># defocus=1 (w/ all other named aberrations 0).</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ab</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">([</span><span class="s1">&#39;defocus&#39;</span><span class="p">,</span> <span class="s1">&#39;astig1&#39;</span><span class="p">,</span> <span class="s1">&#39;astig2&#39;</span><span class="p">,</span> <span class="s1">&#39;coma1&#39;</span><span class="p">,</span> <span class="s1">&#39;coma2&#39;</span><span class="p">,</span> <span class="s1">&#39;trefoil1&#39;</span><span class="p">,</span>
                                <span class="s1">&#39;trefoil2&#39;</span><span class="p">,</span> <span class="s1">&#39;spher&#39;</span><span class="p">]):</span>
            <span class="k">if</span> <span class="n">ab</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">aberrations</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">ab</span><span class="p">)</span>
        <span class="k">if</span> <span class="s1">&#39;fft_sign&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">fft_sign</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;fft_sign&#39;</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">fft_sign</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;+&#39;</span><span class="p">,</span> <span class="s1">&#39;-&#39;</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="n">GalSimValueError</span><span class="p">(</span><span class="s2">&quot;Invalid fft_sign&quot;</span><span class="p">,</span> <span class="n">fft_sign</span><span class="p">,</span> <span class="n">allowed_values</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;+&#39;</span><span class="p">,</span><span class="s1">&#39;-&#39;</span><span class="p">])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">kwargs</span> <span class="o">=</span> <span class="n">kwargs</span>

        <span class="c1"># Define the necessary attributes for this ChromaticObject.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">separable</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">interpolated</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">deinterpolated</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">SED</span> <span class="o">=</span> <span class="n">SED</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;nm&#39;</span><span class="p">,</span> <span class="s1">&#39;1&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">wave_list</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">gsparams</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The `GSParams` for this object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gsparams</span>

<div class="viewcode-block" id="ChromaticOpticalPSF.withGSParams"><a class="viewcode-back" href="../../chromaticobject.html#galsim.ChromaticOpticalPSF.withGSParams">[docs]</a>    <span class="nd">@doc_inherit</span>
    <span class="k">def</span> <span class="nf">withGSParams</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gsparams</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">gsparams</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">gsparams</span><span class="p">:</span> <span class="k">return</span> <span class="bp">self</span>
        <span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">copy</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">_gsparams</span> <span class="o">=</span> <span class="n">GSParams</span><span class="o">.</span><span class="n">check</span><span class="p">(</span><span class="n">gsparams</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gsparams</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ret</span></div>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span> <span class="ow">is</span> <span class="n">other</span> <span class="ow">or</span>
                <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">ChromaticOpticalPSF</span><span class="p">)</span> <span class="ow">and</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">lam</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">lam</span> <span class="ow">and</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">lam_over_diam</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">lam_over_diam</span> <span class="ow">and</span>
                 <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">aberrations</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">aberrations</span><span class="p">)</span> <span class="ow">and</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">scale_unit</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">scale_unit</span> <span class="ow">and</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">gsparams</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">gsparams</span> <span class="ow">and</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">kwargs</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">kwargs</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">((</span><span class="s2">&quot;galsim.ChromaticOpticalPSF&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lam</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lam_over_diam</span><span class="p">,</span>
                     <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">aberrations</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale_unit</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gsparams</span><span class="p">,</span>
                     <span class="nb">frozenset</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">())))</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">.angle</span> <span class="kn">import</span> <span class="n">arcsec</span>
        <span class="n">s</span> <span class="o">=</span> <span class="s1">&#39;galsim.ChromaticOpticalPSF(lam=</span><span class="si">%r</span><span class="s1">, lam_over_diam=</span><span class="si">%r</span><span class="s1">, aberrations=</span><span class="si">%r</span><span class="s1">&#39;</span><span class="o">%</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">lam</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lam_over_diam</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">aberrations</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale_unit</span> <span class="o">!=</span> <span class="n">arcsec</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="s1">&#39;, scale_unit=</span><span class="si">%r</span><span class="s1">&#39;</span><span class="o">%</span><span class="bp">self</span><span class="o">.</span><span class="n">scale_unit</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="s1">&#39;, </span><span class="si">%s</span><span class="s1">=</span><span class="si">%r</span><span class="s1">&#39;</span><span class="o">%</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">)</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="s1">&#39;, gsparams=</span><span class="si">%r</span><span class="s1">&#39;</span><span class="o">%</span><span class="bp">self</span><span class="o">.</span><span class="n">gsparams</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="s1">&#39;)&#39;</span>
        <span class="k">return</span> <span class="n">s</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;galsim.ChromaticOpticalPSF(lam=</span><span class="si">%s</span><span class="s1">, lam_over_diam=</span><span class="si">%s</span><span class="s1">, aberrations=</span><span class="si">%s</span><span class="s1">)&#39;</span><span class="o">%</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">lam</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lam_over_diam</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">aberrations</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>

<div class="viewcode-block" id="ChromaticOpticalPSF.evaluateAtWavelength"><a class="viewcode-back" href="../../chromaticobject.html#galsim.ChromaticOpticalPSF.evaluateAtWavelength">[docs]</a>    <span class="k">def</span> <span class="nf">evaluateAtWavelength</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">wave</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method to directly instantiate a monochromatic instance of this object.</span>

<span class="sd">        Parameters:</span>
<span class="sd">             wave:  Wavelength in nanometers.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># The aberrations were in units of wavelength for the fiducial wavelength, so we have to</span>
        <span class="c1"># convert to units of waves for *this* wavelength.</span>
        <span class="n">wave_factor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lam</span> <span class="o">/</span> <span class="n">wave</span>

        <span class="c1"># stepk and maxk also scale basically with this ratio, and they are fairly slow to</span>
        <span class="c1"># calculate, so once we&#39;ve done this once, store the results and just rescale all future</span>
        <span class="c1"># versions with this factor.</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_stepk&#39;</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">OpticalPSF</span><span class="p">(</span>
                    <span class="n">lam</span><span class="o">=</span><span class="n">wave</span><span class="p">,</span> <span class="n">diam</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">diam</span><span class="p">,</span>
                    <span class="n">aberrations</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">aberrations</span><span class="o">*</span><span class="n">wave_factor</span><span class="p">,</span> <span class="n">scale_unit</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">scale_unit</span><span class="p">,</span>
                    <span class="n">_force_stepk</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_stepk</span><span class="o">*</span><span class="n">wave_factor</span><span class="p">,</span> <span class="n">_force_maxk</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_maxk</span><span class="o">*</span><span class="n">wave_factor</span><span class="p">,</span>
                    <span class="n">gsparams</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">gsparams</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">OpticalPSF</span><span class="p">(</span>
                    <span class="n">lam</span><span class="o">=</span><span class="n">wave</span><span class="p">,</span> <span class="n">diam</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">diam</span><span class="p">,</span>
                    <span class="n">aberrations</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">aberrations</span><span class="o">*</span><span class="n">wave_factor</span><span class="p">,</span> <span class="n">scale_unit</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">scale_unit</span><span class="p">,</span>
                    <span class="n">gsparams</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">gsparams</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_stepk</span> <span class="o">=</span> <span class="n">ret</span><span class="o">.</span><span class="n">stepk</span> <span class="o">/</span> <span class="n">wave_factor</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_maxk</span> <span class="o">=</span> <span class="n">ret</span><span class="o">.</span><span class="n">maxk</span> <span class="o">/</span> <span class="n">wave_factor</span>
            <span class="k">return</span> <span class="n">ret</span></div>

    <span class="k">def</span> <span class="nf">_shoot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">photons</span><span class="p">,</span> <span class="n">rng</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">.photon_array</span> <span class="kn">import</span> <span class="n">PhotonArray</span>
        <span class="kn">from</span> <span class="nn">.random</span> <span class="kn">import</span> <span class="n">UniformDeviate</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;geometric_shooting&#39;</span><span class="p">,</span><span class="kc">False</span><span class="p">):</span>
            <span class="c1"># In the geometric shooting approximation, the lambda factors out, and this</span>
            <span class="c1"># becomes the same kind of calculation we did for ChromaticAiry.</span>
            <span class="c1"># Use the mean wavelength for the base profile.</span>
            <span class="n">mean_wave</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">photons</span><span class="o">.</span><span class="n">wavelength</span><span class="p">)</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluateAtWavelength</span><span class="p">(</span><span class="n">mean_wave</span><span class="p">)</span>
            <span class="n">obj</span><span class="o">.</span><span class="n">_shoot</span><span class="p">(</span><span class="n">photons</span><span class="p">,</span> <span class="n">rng</span><span class="p">)</span>
            <span class="n">factor</span> <span class="o">=</span> <span class="n">photons</span><span class="o">.</span><span class="n">wavelength</span> <span class="o">/</span> <span class="n">mean_wave</span>
            <span class="n">photons</span><span class="o">.</span><span class="n">scaleXY</span><span class="p">(</span><span class="n">factor</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># When not using geometric shooting, the following isn&#39;t exact.</span>
            <span class="c1"># The exact method would involve doing the fourier transform for each wavelength</span>
            <span class="c1"># in the photon list.  Obviously, that&#39;s not tenable.</span>
            <span class="c1"># So instead, we shoot with the same random seed for 3 different profiles:</span>
            <span class="c1"># The minimum wavelength, the mean, and the maximum.</span>
            <span class="c1"># Then interpolate between the results for each photon.</span>
            <span class="c1"># This should (hopefully!) be good enough for most use cases if the bandpass</span>
            <span class="c1"># isn&#39;t extremely wide and the wavelength dependence is modest over the range.</span>

            <span class="n">wave1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">photons</span><span class="o">.</span><span class="n">wavelength</span><span class="p">)</span>
            <span class="n">wave2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">photons</span><span class="o">.</span><span class="n">wavelength</span><span class="p">)</span>
            <span class="n">wave3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">photons</span><span class="o">.</span><span class="n">wavelength</span><span class="p">)</span>

            <span class="n">prof1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluateAtWavelength</span><span class="p">(</span><span class="n">wave1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">wave1</span> <span class="o">==</span> <span class="n">wave3</span><span class="p">:</span>
                <span class="c1"># Interjection at this point -- if min=mean=max, then this is easy.</span>
                <span class="k">return</span> <span class="n">prof1</span><span class="o">.</span><span class="n">_shoot</span><span class="p">(</span><span class="n">photons</span><span class="p">,</span> <span class="n">rng</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Otherwise we&#39;re ok dividing by wave2-wave1 and wave3-wave2 below.</span>
                <span class="k">assert</span> <span class="n">wave2</span> <span class="o">!=</span> <span class="n">wave1</span>
                <span class="k">assert</span> <span class="n">wave3</span> <span class="o">!=</span> <span class="n">wave2</span>
            <span class="n">prof2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluateAtWavelength</span><span class="p">(</span><span class="n">wave2</span><span class="p">)</span>
            <span class="n">prof3</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluateAtWavelength</span><span class="p">(</span><span class="n">wave3</span><span class="p">)</span>
            <span class="c1"># For each photon, shoot using one of these profiles according to the given</span>
            <span class="c1"># wavelength.</span>
            <span class="c1"># For wavelenghts with w1 &lt; w &lt; w2, select from prof1 or prof2 with probabilities</span>
            <span class="c1">#     P(use prof1) = (w2-w)/(w2-w1)</span>
            <span class="c1">#     P(use prof2) = (w-w1)/(w2-w1)</span>
            <span class="c1"># Likewise when w2 &lt; w &lt; w3:</span>
            <span class="c1">#     P(use prof2) = (w3-w)/(w3-w2)</span>
            <span class="c1">#     P(use prof3) = (w-w2)/(w3-w2)</span>
            <span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">photons</span><span class="p">))</span>
            <span class="n">UniformDeviate</span><span class="p">(</span><span class="n">rng</span><span class="p">)</span><span class="o">.</span><span class="n">generate</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">photons</span><span class="o">.</span><span class="n">wavelength</span>
            <span class="n">use_p1</span> <span class="o">=</span> <span class="p">(</span><span class="n">wave1</span> <span class="o">&lt;=</span> <span class="n">w</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">w</span> <span class="o">&lt;</span> <span class="n">wave2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">u</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">wave2</span><span class="o">-</span><span class="n">w</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">wave2</span><span class="o">-</span><span class="n">wave1</span><span class="p">))</span>
            <span class="n">use_p2</span> <span class="o">=</span> <span class="p">(</span><span class="n">wave1</span> <span class="o">&lt;=</span> <span class="n">w</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">w</span> <span class="o">&lt;</span> <span class="n">wave2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">u</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">wave2</span><span class="o">-</span><span class="n">w</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">wave2</span><span class="o">-</span><span class="n">wave1</span><span class="p">))</span>
            <span class="n">use_p2</span> <span class="o">|=</span> <span class="p">(</span><span class="n">wave2</span> <span class="o">&lt;=</span> <span class="n">w</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">w</span> <span class="o">&lt;=</span> <span class="n">wave3</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">u</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">wave3</span><span class="o">-</span><span class="n">w</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">wave3</span><span class="o">-</span><span class="n">wave2</span><span class="p">))</span>
            <span class="n">use_p3</span> <span class="o">=</span> <span class="p">(</span><span class="n">wave2</span> <span class="o">&lt;=</span> <span class="n">w</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">w</span> <span class="o">&lt;=</span> <span class="n">wave3</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">u</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">wave3</span><span class="o">-</span><span class="n">w</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">wave3</span><span class="o">-</span><span class="n">wave2</span><span class="p">))</span>
            <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">use_p1</span> <span class="o">|</span> <span class="n">use_p2</span> <span class="o">|</span> <span class="n">use_p3</span><span class="p">)</span>
            <span class="k">assert</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">use_p1</span> <span class="o">&amp;</span> <span class="n">use_p2</span><span class="p">)</span>
            <span class="k">assert</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">use_p2</span> <span class="o">&amp;</span> <span class="n">use_p3</span><span class="p">)</span>
            <span class="k">assert</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">use_p1</span> <span class="o">&amp;</span> <span class="n">use_p3</span><span class="p">)</span>

            <span class="n">temp1</span> <span class="o">=</span> <span class="n">PhotonArray</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">use_p1</span><span class="p">))</span>
            <span class="n">temp2</span> <span class="o">=</span> <span class="n">PhotonArray</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">use_p2</span><span class="p">))</span>
            <span class="n">temp3</span> <span class="o">=</span> <span class="n">PhotonArray</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">use_p3</span><span class="p">))</span>
            <span class="n">prof1</span><span class="o">.</span><span class="n">_shoot</span><span class="p">(</span><span class="n">temp1</span><span class="p">,</span> <span class="n">rng</span><span class="p">)</span>
            <span class="n">prof2</span><span class="o">.</span><span class="n">_shoot</span><span class="p">(</span><span class="n">temp2</span><span class="p">,</span> <span class="n">rng</span><span class="p">)</span>
            <span class="n">prof3</span><span class="o">.</span><span class="n">_shoot</span><span class="p">(</span><span class="n">temp3</span><span class="p">,</span> <span class="n">rng</span><span class="p">)</span>
            <span class="n">photons</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="n">use_p1</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp1</span><span class="o">.</span><span class="n">x</span> <span class="o">*</span> <span class="p">(</span><span class="n">w</span><span class="p">[</span><span class="n">use_p1</span><span class="p">]</span> <span class="o">/</span> <span class="n">wave1</span><span class="p">)</span>
            <span class="n">photons</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="n">use_p1</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp1</span><span class="o">.</span><span class="n">y</span> <span class="o">*</span> <span class="p">(</span><span class="n">w</span><span class="p">[</span><span class="n">use_p1</span><span class="p">]</span> <span class="o">/</span> <span class="n">wave1</span><span class="p">)</span>
            <span class="n">photons</span><span class="o">.</span><span class="n">flux</span><span class="p">[</span><span class="n">use_p1</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp1</span><span class="o">.</span><span class="n">flux</span> <span class="o">*</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">temp1</span><span class="p">)</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">photons</span><span class="p">))</span>
            <span class="n">photons</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="n">use_p2</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp2</span><span class="o">.</span><span class="n">x</span> <span class="o">*</span> <span class="p">(</span><span class="n">w</span><span class="p">[</span><span class="n">use_p2</span><span class="p">]</span> <span class="o">/</span> <span class="n">wave2</span><span class="p">)</span>
            <span class="n">photons</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="n">use_p2</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp2</span><span class="o">.</span><span class="n">y</span> <span class="o">*</span> <span class="p">(</span><span class="n">w</span><span class="p">[</span><span class="n">use_p2</span><span class="p">]</span> <span class="o">/</span> <span class="n">wave2</span><span class="p">)</span>
            <span class="n">photons</span><span class="o">.</span><span class="n">flux</span><span class="p">[</span><span class="n">use_p2</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp2</span><span class="o">.</span><span class="n">flux</span> <span class="o">*</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">temp2</span><span class="p">)</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">photons</span><span class="p">))</span>
            <span class="n">photons</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="n">use_p3</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp3</span><span class="o">.</span><span class="n">x</span> <span class="o">*</span> <span class="p">(</span><span class="n">w</span><span class="p">[</span><span class="n">use_p3</span><span class="p">]</span> <span class="o">/</span> <span class="n">wave3</span><span class="p">)</span>
            <span class="n">photons</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="n">use_p3</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp3</span><span class="o">.</span><span class="n">y</span> <span class="o">*</span> <span class="p">(</span><span class="n">w</span><span class="p">[</span><span class="n">use_p3</span><span class="p">]</span> <span class="o">/</span> <span class="n">wave3</span><span class="p">)</span>
            <span class="n">photons</span><span class="o">.</span><span class="n">flux</span><span class="p">[</span><span class="n">use_p3</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp3</span><span class="o">.</span><span class="n">flux</span> <span class="o">*</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">temp3</span><span class="p">)</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">photons</span><span class="p">))</span></div>


<div class="viewcode-block" id="ChromaticAiry"><a class="viewcode-back" href="../../chromaticobject.html#galsim.ChromaticAiry">[docs]</a><span class="k">class</span> <span class="nc">ChromaticAiry</span><span class="p">(</span><span class="n">ChromaticObject</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A subclass of `ChromaticObject` meant to represent chromatic Airy profiles.</span>

<span class="sd">    For more information about the basics of Airy profiles, please see `galsim.Airy`.</span>

<span class="sd">    This class is a chromatic representation of Airy profiles, including the wavelength-dependent</span>
<span class="sd">    diffraction limit.  One can also get this functionality using the `ChromaticOpticalPSF` class,</span>
<span class="sd">    but that class includes additional complications beyond a simple Airy profile, and thus has a</span>
<span class="sd">    more complicated internal representation.  For users who only want a (possibly obscured) Airy</span>
<span class="sd">    profile, the ChromaticAiry class is likely to be a less computationally expensive and more</span>
<span class="sd">    accurate option.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        lam:            Fiducial wavelength for which diffraction limit is initially defined, in</span>
<span class="sd">                        nanometers.</span>
<span class="sd">        diam:           Telescope diameter in meters.  Either ``diam`` or ``lam_over_diam`` must be</span>
<span class="sd">                        specified.</span>
<span class="sd">        lam_over_diam:  Ratio of (fiducial wavelength) / telescope diameter in units of</span>
<span class="sd">                        ``scale_unit``.  Either ``diam`` or ``lam_over_diam`` must be specified.</span>
<span class="sd">        scale_unit:     Units used to define the diffraction limit and draw images.</span>
<span class="sd">                        [default: galsim.arcsec]</span>
<span class="sd">        gsparams:       An optional `GSParams` argument.  See the docstring for `GSParams` for</span>
<span class="sd">                        details. [default: None]</span>
<span class="sd">        **kwargs:       Any other keyword arguments to be passed to `Airy`: either flux, or</span>
<span class="sd">                        gsparams.  See `galsim.Airy` docstring for a complete description of these</span>
<span class="sd">                        options.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_req_params</span> <span class="o">=</span> <span class="p">{</span> <span class="s1">&#39;lam&#39;</span> <span class="p">:</span> <span class="nb">float</span> <span class="p">}</span>
    <span class="n">_opt_params</span> <span class="o">=</span> <span class="p">{</span> <span class="s1">&#39;scale_unit&#39;</span> <span class="p">:</span> <span class="nb">str</span> <span class="p">}</span>
    <span class="n">_single_params</span> <span class="o">=</span> <span class="p">[</span> <span class="p">{</span><span class="s1">&#39;diam&#39;</span> <span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="s1">&#39;lam_over_diam&#39;</span> <span class="p">:</span> <span class="nb">float</span><span class="p">}</span> <span class="p">]</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lam</span><span class="p">,</span> <span class="n">diam</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">lam_over_diam</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">scale_unit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">gsparams</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">.angle</span> <span class="kn">import</span> <span class="n">AngleUnit</span><span class="p">,</span> <span class="n">arcsec</span><span class="p">,</span> <span class="n">radians</span>
        <span class="c1"># First, take the basic info.</span>
        <span class="c1"># We have to require either diam OR lam_over_diam:</span>
        <span class="k">if</span> <span class="n">scale_unit</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">scale_unit</span> <span class="o">=</span> <span class="n">arcsec</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">scale_unit</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">scale_unit</span> <span class="o">=</span> <span class="n">AngleUnit</span><span class="o">.</span><span class="n">from_name</span><span class="p">(</span><span class="n">scale_unit</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scale_unit</span> <span class="o">=</span> <span class="n">scale_unit</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_gsparams</span> <span class="o">=</span> <span class="n">GSParams</span><span class="o">.</span><span class="n">check</span><span class="p">(</span><span class="n">gsparams</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="n">diam</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">lam_over_diam</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span>
             <span class="p">(</span><span class="n">diam</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">lam_over_diam</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="p">):</span>
            <span class="k">raise</span> <span class="n">GalSimIncompatibleValuesError</span><span class="p">(</span>
                <span class="s2">&quot;Need to specify telescope diameter OR wavelength/diam ratio&quot;</span><span class="p">,</span>
                <span class="n">diam</span><span class="o">=</span><span class="n">diam</span><span class="p">,</span> <span class="n">lam_over_diam</span><span class="o">=</span><span class="n">lam_over_diam</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">diam</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lam_over_diam</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.e-9</span><span class="o">*</span><span class="n">lam</span><span class="o">/</span><span class="n">diam</span><span class="p">)</span><span class="o">*</span><span class="n">radians</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">scale_unit</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lam_over_diam</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">lam_over_diam</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lam</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">lam</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">kwargs</span> <span class="o">=</span> <span class="n">kwargs</span>

        <span class="c1"># Define the necessary attributes for this ChromaticObject.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">separable</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">interpolated</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">deinterpolated</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">SED</span> <span class="o">=</span> <span class="n">SED</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;nm&#39;</span><span class="p">,</span> <span class="s1">&#39;1&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">wave_list</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">gsparams</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The `GSParams` for this object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gsparams</span>

<div class="viewcode-block" id="ChromaticAiry.withGSParams"><a class="viewcode-back" href="../../chromaticobject.html#galsim.ChromaticAiry.withGSParams">[docs]</a>    <span class="nd">@doc_inherit</span>
    <span class="k">def</span> <span class="nf">withGSParams</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gsparams</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">gsparams</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">gsparams</span><span class="p">:</span> <span class="k">return</span> <span class="bp">self</span>
        <span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">copy</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">_gsparams</span> <span class="o">=</span> <span class="n">GSParams</span><span class="o">.</span><span class="n">check</span><span class="p">(</span><span class="n">gsparams</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gsparams</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ret</span></div>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span> <span class="ow">is</span> <span class="n">other</span> <span class="ow">or</span>
                <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">ChromaticAiry</span><span class="p">)</span> <span class="ow">and</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">lam</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">lam</span> <span class="ow">and</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">lam_over_diam</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">lam_over_diam</span> <span class="ow">and</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">scale_unit</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">scale_unit</span> <span class="ow">and</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">gsparams</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">gsparams</span> <span class="ow">and</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">kwargs</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">kwargs</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">((</span><span class="s2">&quot;galsim.ChromaticAiry&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lam</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lam_over_diam</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale_unit</span><span class="p">,</span>
                     <span class="bp">self</span><span class="o">.</span><span class="n">gsparams</span><span class="p">,</span> <span class="nb">frozenset</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">())))</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">.angle</span> <span class="kn">import</span> <span class="n">arcsec</span>
        <span class="n">s</span> <span class="o">=</span> <span class="s1">&#39;galsim.ChromaticAiry(lam=</span><span class="si">%r</span><span class="s1">, lam_over_diam=</span><span class="si">%r</span><span class="s1">&#39;</span><span class="o">%</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lam</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lam_over_diam</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale_unit</span> <span class="o">!=</span> <span class="n">arcsec</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="s1">&#39;, scale_unit=</span><span class="si">%r</span><span class="s1">&#39;</span><span class="o">%</span><span class="bp">self</span><span class="o">.</span><span class="n">scale_unit</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="s1">&#39;, </span><span class="si">%s</span><span class="s1">=</span><span class="si">%r</span><span class="s1">&#39;</span><span class="o">%</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">)</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="s1">&#39;, gsparams=</span><span class="si">%r</span><span class="s1">&#39;</span><span class="o">%</span><span class="bp">self</span><span class="o">.</span><span class="n">gsparams</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="s1">&#39;)&#39;</span>
        <span class="k">return</span> <span class="n">s</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;galsim.ChromaticAiry(lam=</span><span class="si">%s</span><span class="s1">, lam_over_diam=</span><span class="si">%s</span><span class="s1">)&#39;</span><span class="o">%</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lam</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lam_over_diam</span><span class="p">)</span>

<div class="viewcode-block" id="ChromaticAiry.evaluateAtWavelength"><a class="viewcode-back" href="../../chromaticobject.html#galsim.ChromaticAiry.evaluateAtWavelength">[docs]</a>    <span class="k">def</span> <span class="nf">evaluateAtWavelength</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">wave</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method to directly instantiate a monochromatic instance of this object.</span>

<span class="sd">        Parameters:</span>
<span class="sd">             wave:  Wavelength in nanometers.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.airy</span> <span class="kn">import</span> <span class="n">Airy</span>
        <span class="c1"># We need to rescale the stored lam/diam by the ratio of input wavelength to stored fiducial</span>
        <span class="c1"># wavelength.</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">Airy</span><span class="p">(</span>
            <span class="n">lam_over_diam</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">lam_over_diam</span><span class="o">*</span><span class="p">(</span><span class="n">wave</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">lam</span><span class="p">),</span> <span class="n">scale_unit</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">scale_unit</span><span class="p">,</span>
            <span class="n">gsparams</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">gsparams</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ret</span></div>

    <span class="k">def</span> <span class="nf">_shoot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">photons</span><span class="p">,</span> <span class="n">rng</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">.airy</span> <span class="kn">import</span> <span class="n">Airy</span>
        <span class="c1"># Start with the convolution at the reference wavelength</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="n">Airy</span><span class="p">(</span><span class="n">lam_over_diam</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">lam_over_diam</span><span class="p">,</span> <span class="n">scale_unit</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">scale_unit</span><span class="p">,</span>
                   <span class="n">gsparams</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">gsparams</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">_shoot</span><span class="p">(</span><span class="n">photons</span><span class="p">,</span> <span class="n">rng</span><span class="p">)</span>

        <span class="c1"># Now adjust the positions according to the wavelengths</span>
        <span class="n">factor</span> <span class="o">=</span> <span class="n">photons</span><span class="o">.</span><span class="n">wavelength</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">lam</span>
        <span class="n">photons</span><span class="o">.</span><span class="n">scaleXY</span><span class="p">(</span><span class="n">factor</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">_findWave</span><span class="p">(</span><span class="n">wave_list</span><span class="p">,</span> <span class="n">wave</span><span class="p">):</span>
    <span class="c1"># Helper routine to search a sorted NumPy array of wavelengths (not necessarily evenly spaced)</span>
    <span class="c1"># to find where a particular wavelength ``wave`` would fit in, and return the index below along</span>
    <span class="c1"># with the fraction of the way to the next entry in the array.</span>
    <span class="n">lower_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">wave_list</span><span class="p">,</span> <span class="n">wave</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>
    <span class="c1"># There can be edge issues, so watch out for that:</span>
    <span class="k">if</span> <span class="n">lower_idx</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span> <span class="n">lower_idx</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="n">lower_idx</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">wave_list</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span> <span class="n">lower_idx</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">wave_list</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>

    <span class="n">frac</span> <span class="o">=</span> <span class="p">(</span><span class="n">wave</span><span class="o">-</span><span class="n">wave_list</span><span class="p">[</span><span class="n">lower_idx</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="n">wave_list</span><span class="p">[</span><span class="n">lower_idx</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">wave_list</span><span class="p">[</span><span class="n">lower_idx</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">lower_idx</span><span class="p">,</span> <span class="n">frac</span>

<span class="k">def</span> <span class="nf">_linearInterp</span><span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="n">frac</span><span class="p">,</span> <span class="n">lower_idx</span><span class="p">):</span>
    <span class="c1"># Helper routine for linear interpolation between values in lists (which could be lists of</span>
    <span class="c1"># images, just not numbers, hence the need to avoid a LookupTable).  Not really worth</span>
    <span class="c1"># splitting out on its own now, but could be useful to have separate routines for the</span>
    <span class="c1"># interpolation later on if we want to enable something other than linear interpolation.</span>
    <span class="k">return</span> <span class="n">frac</span><span class="o">*</span><span class="nb">list</span><span class="p">[</span><span class="n">lower_idx</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="mf">1.</span><span class="o">-</span><span class="n">frac</span><span class="p">)</span><span class="o">*</span><span class="nb">list</span><span class="p">[</span><span class="n">lower_idx</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">_remove_setup_kwargs</span><span class="p">(</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="c1"># Helper function to remove from kwargs anything that is only used for setting up image and that</span>
    <span class="c1"># might otherwise interfere with drawImage.</span>
    <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;dtype&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;scale&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;wcs&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;nx&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;ny&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;bounds&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
</pre></div>

           </div>
           
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2019, GalSim-developers.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>