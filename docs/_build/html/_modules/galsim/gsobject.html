<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>galsim.gsobject &mdash; GalSim 2.7.0 documentation</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/sphinx_highlight.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            GalSim
          </a>
              <div class="version">
                2.7
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../overview.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../install.html">Installation Instructions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tutorials.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../image.html">Images and Related Concepts</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../sb.html">Surface Brightness Profiles</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../chromatic.html">Wavelength-dependent Profiles</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../units.html">Units</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../wcs.html">World Coordinate Systems</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../random.html">Noise and Random Values</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../wl.html">Weak Lensing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../photon.html">Photon Shooting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../utilities.html">Helper Functions and Classes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../errors.html">Errors and Warnings</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../config.html">The Config Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../hsm.html">The HSM Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../des.html">The DES Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../roman.html">The Roman Space Telescope Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../cpp.html">C++ Layer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../shared.html">Shared Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../history.html">Revision History</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">GalSim</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">galsim.gsobject</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for galsim.gsobject</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright (c) 2012-2023 by the GalSim developers team on GitHub</span>
<span class="c1"># https://github.com/GalSim-developers</span>
<span class="c1">#</span>
<span class="c1"># This file is part of GalSim: The modular galaxy image simulation toolkit.</span>
<span class="c1"># https://github.com/GalSim-developers/GalSim</span>
<span class="c1">#</span>
<span class="c1"># GalSim is free software: redistribution and use in source and binary forms,</span>
<span class="c1"># with or without modification, are permitted provided that the following</span>
<span class="c1"># conditions are met:</span>
<span class="c1">#</span>
<span class="c1"># 1. Redistributions of source code must retain the above copyright notice, this</span>
<span class="c1">#    list of conditions, and the disclaimer given in the accompanying LICENSE</span>
<span class="c1">#    file.</span>
<span class="c1"># 2. Redistributions in binary form must reproduce the above copyright notice,</span>
<span class="c1">#    this list of conditions, and the disclaimer given in the documentation</span>
<span class="c1">#    and/or other materials provided with the distribution.</span>
<span class="c1">#</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span> <span class="s1">&#39;GSObject&#39;</span> <span class="p">]</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">copy</span>

<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">_galsim</span>
<span class="kn">from</span> <span class="nn">.gsparams</span> <span class="kn">import</span> <span class="n">GSParams</span>
<span class="kn">from</span> <span class="nn">.position</span> <span class="kn">import</span> <span class="n">_PositionD</span><span class="p">,</span> <span class="n">_PositionI</span><span class="p">,</span> <span class="n">Position</span><span class="p">,</span> <span class="n">parse_pos_args</span>
<span class="kn">from</span> <span class="nn">._utilities</span> <span class="kn">import</span> <span class="n">lazy_property</span>
<span class="kn">from</span> <span class="nn">.errors</span> <span class="kn">import</span> <span class="n">GalSimError</span><span class="p">,</span> <span class="n">GalSimRangeError</span><span class="p">,</span> <span class="n">GalSimValueError</span><span class="p">,</span> <span class="n">GalSimIncompatibleValuesError</span>
<span class="kn">from</span> <span class="nn">.errors</span> <span class="kn">import</span> <span class="n">GalSimFFTSizeError</span><span class="p">,</span> <span class="n">GalSimNotImplementedError</span><span class="p">,</span> <span class="n">convert_cpp_errors</span><span class="p">,</span> <span class="n">galsim_warn</span>
<span class="kn">from</span> <span class="nn">.image</span> <span class="kn">import</span> <span class="n">Image</span><span class="p">,</span> <span class="n">ImageD</span><span class="p">,</span> <span class="n">ImageF</span><span class="p">,</span> <span class="n">ImageCD</span><span class="p">,</span> <span class="n">ImageCF</span>
<span class="kn">from</span> <span class="nn">.shear</span> <span class="kn">import</span> <span class="n">Shear</span><span class="p">,</span> <span class="n">_Shear</span>
<span class="kn">from</span> <span class="nn">.angle</span> <span class="kn">import</span> <span class="n">Angle</span>
<span class="kn">from</span> <span class="nn">.bounds</span> <span class="kn">import</span> <span class="n">BoundsI</span><span class="p">,</span> <span class="n">_BoundsI</span>
<span class="kn">from</span> <span class="nn">.random</span> <span class="kn">import</span> <span class="n">BaseDeviate</span>
<span class="kn">from</span> <span class="nn">.sensor</span> <span class="kn">import</span> <span class="n">Sensor</span>
<span class="kn">from</span> <span class="nn">.random</span> <span class="kn">import</span> <span class="n">PoissonDeviate</span>
<span class="kn">from</span> <span class="nn">.wcs</span> <span class="kn">import</span> <span class="n">BaseWCS</span><span class="p">,</span> <span class="n">PixelScale</span>


<div class="viewcode-block" id="GSObject"><a class="viewcode-back" href="../../gsobject.html#galsim.GSObject">[docs]</a><span class="k">class</span> <span class="nc">GSObject</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Base class for all GalSim classes that represent some kind of surface brightness profile.</span>

<span class="sd">    A GSObject is not intended to be constructed directly.  Normally, you would use whatever</span>
<span class="sd">    derived class is appropriate for the surface brightness profile you want::</span>

<span class="sd">        &gt;&gt;&gt; gal = galsim.Sersic(n=4, half_light_radius=4.3)</span>
<span class="sd">        &gt;&gt;&gt; psf = galsim.Moffat(beta=3, fwhm=2.85)</span>
<span class="sd">        &gt;&gt;&gt; conv = galsim.Convolve([gal,psf])</span>

<span class="sd">    All of these classes are subclasses of GSObject, so you should see those docstrings for</span>
<span class="sd">    more details about how to construct the various profiles.  Here we discuss attributes and</span>
<span class="sd">    methods that are common to all GSObjects.</span>

<span class="sd">    GSObjects are always defined in sky coordinates.  So all sizes and other linear dimensions</span>
<span class="sd">    should be in terms of some kind of units on the sky, arcsec for instance.  Only later (when</span>
<span class="sd">    they are drawn) is the connection to pixel coordinates established via a pixel scale or WCS.</span>
<span class="sd">    (See the documentation for galsim.BaseWCS for more details about how to specify various kinds</span>
<span class="sd">    of world coordinate systems more complicated than a simple pixel scale.)</span>

<span class="sd">    For instance, if you eventually draw onto an image that has a pixel scale of 0.2 arcsec/pixel,</span>
<span class="sd">    then the normal thing to do would be to define your surface brightness profiles in terms of</span>
<span class="sd">    arcsec and then draw with ``pixel_scale=0.2``.  However, while arcsec are the usual choice of</span>
<span class="sd">    units for the sky coordinates, if you wanted, you could instead define the sizes of all your</span>
<span class="sd">    galaxies and PSFs in terms of radians and then use ``pixel_scale=0.2/206265`` when you draw</span>
<span class="sd">    them.</span>

<span class="sd">    **Transforming methods**:</span>

<span class="sd">    The GSObject class uses an &quot;immutable&quot; design[1], so all methods that would potentially modify</span>
<span class="sd">    the object actually return a new object instead.  This uses pointers and such behind the</span>
<span class="sd">    scenes, so it all happens efficiently, but it makes using the objects a bit simpler, since</span>
<span class="sd">    you don&#39;t need to worry about some function changing your object behind your back.</span>

<span class="sd">    In all cases below, we just give an example usage.  See the docstrings for the methods for</span>
<span class="sd">    more details about how to use them.::</span>

<span class="sd">        &gt;&gt;&gt; obj = obj.shear(shear)      # Apply a shear to the object.</span>
<span class="sd">        &gt;&gt;&gt; obj = obj.dilate(scale)     # Apply a flux-preserving dilation.</span>
<span class="sd">        &gt;&gt;&gt; obj = obj.magnify(mu)       # Apply a surface-brightness-preserving magnification.</span>
<span class="sd">        &gt;&gt;&gt; obj = obj.rotate(theta)     # Apply a rotation.</span>
<span class="sd">        &gt;&gt;&gt; obj = obj.shift(dx,dy)      # Shft the object in real space.</span>
<span class="sd">        &gt;&gt;&gt; obj = obj.transform(dudx,dudy,dvdx,dvdy)    # Apply a general jacobian transformation.</span>
<span class="sd">        &gt;&gt;&gt; obj = obj.lens(g1,g2,mu)    # Apply both a lensing shear and magnification.</span>
<span class="sd">        &gt;&gt;&gt; obj = obj.withFlux(flux)    # Set a new flux value.</span>
<span class="sd">        &gt;&gt;&gt; obj = obj * ratio           # Scale the surface brightness profile by some factor.</span>

<span class="sd">    **Access Methods**:</span>

<span class="sd">    There are some access methods and properties that are available for all GSObjects.</span>
<span class="sd">    Again, see the docstrings for each method for more details.::</span>

<span class="sd">        &gt;&gt;&gt; obj.flux</span>
<span class="sd">        &gt;&gt;&gt; obj.centroid</span>
<span class="sd">        &gt;&gt;&gt; obj.nyquist_scale</span>
<span class="sd">        &gt;&gt;&gt; obj.stepk</span>
<span class="sd">        &gt;&gt;&gt; obj.maxk</span>
<span class="sd">        &gt;&gt;&gt; obj.has_hard_edges</span>
<span class="sd">        &gt;&gt;&gt; obj.is_axisymmetric</span>
<span class="sd">        &gt;&gt;&gt; obj.is_analytic_x</span>
<span class="sd">        &gt;&gt;&gt; obj.is_analytic_k</span>
<span class="sd">        &gt;&gt;&gt; obj.xValue(x,y) or obj.xValue(pos)</span>
<span class="sd">        &gt;&gt;&gt; obj.kValue(kx,ky) os obj.kValue(kpos)</span>

<span class="sd">    Most subclasses have additional methods that are available for values that are particular to</span>
<span class="sd">    that specific surface brightness profile.  e.g. ``sigma = gauss.sigma``.  However, note</span>
<span class="sd">    that class-specific methods are not available after performing one of the above transforming</span>
<span class="sd">    operations.::</span>

<span class="sd">        &gt;&gt;&gt; gal = galsim.Gaussian(sigma=5)</span>
<span class="sd">        &gt;&gt;&gt; gal = gal.shear(g1=0.2, g2=0.05)</span>
<span class="sd">        &gt;&gt;&gt; sigma = gal.sigma               # This will raise an exception.</span>

<span class="sd">    It is however possible to access the original object that was transformed via the</span>
<span class="sd">    ``original`` attribute.::</span>

<span class="sd">        &gt;&gt;&gt; sigma = gal.original.sigma      # This works.</span>

<span class="sd">    No matter how many transformations are performed, the ``original`` attribute will contain the</span>
<span class="sd">    _original_ object (not necessarily the most recent ancestor).</span>

<span class="sd">    **Drawing Methods**:</span>

<span class="sd">    The main thing to do with a GSObject once you have built it is to draw it onto an image.</span>
<span class="sd">    There are two methods that do this.  In both cases, there are lots of optional parameters.</span>
<span class="sd">    See the docstrings for these methods for more details.::</span>

<span class="sd">        &gt;&gt;&gt; image = obj.drawImage(...)</span>
<span class="sd">        &gt;&gt;&gt; kimage = obj.drawKImage(...)</span>

<span class="sd">    There two attributes that may be available for a GSObject.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        original:   This was mentioned above as a way to access the original object that has</span>
<span class="sd">                    been transformed by one of the transforming methods.</span>
<span class="sd">        noise:      Some types, like `RealGalaxy`, set this attribute to be the intrinsic noise that</span>
<span class="sd">                    is already inherent in the profile and will thus be present when you draw the</span>
<span class="sd">                    object.  The noise is propagated correctly through the various transforming</span>
<span class="sd">                    methods, as well as convolutions and flux rescalings.  Note that the ``noise``</span>
<span class="sd">                    attribute can be set directly by users even for GSObjects that do not naturally</span>
<span class="sd">                    have one. The typical use for this attribute is to use it to whiten the noise in</span>
<span class="sd">                    the image after drawing.  See `BaseCorrelatedNoise` for more details.</span>

<span class="sd">    **GSParams**:</span>

<span class="sd">    All GSObject classes take an optional ``gsparams`` argument, so we document that feature here.</span>
<span class="sd">    For all documentation about the specific derived classes, please see the docstring for each</span>
<span class="sd">    one individually.</span>

<span class="sd">    The ``gsparams`` argument can be used to specify various numbers that govern the tradeoff</span>
<span class="sd">    between accuracy and speed for the calculations made in drawing a GSObject.  The numbers are</span>
<span class="sd">    encapsulated in a class called `GSParams`, and the user should make careful choices whenever</span>
<span class="sd">    they opt to deviate from the defaults.  For more details about the parameters and their default</span>
<span class="sd">    values, please see the docstring of the `GSParams` class.</span>

<span class="sd">    For example, let&#39;s say you want to do something that requires an FFT larger than 4096 x 4096</span>
<span class="sd">    (and you have enough memory to handle it!).  Then you can create a new `GSParams` object with a</span>
<span class="sd">    larger ``maximum_fft_size`` and pass that to your GSObject on construction::</span>

<span class="sd">        &gt;&gt;&gt; gal = galsim.Sersic(n=4, half_light_radius=4.3)</span>
<span class="sd">        &gt;&gt;&gt; psf = galsim.Moffat(beta=3, fwhm=2.85)</span>
<span class="sd">        &gt;&gt;&gt; conv = galsim.Convolve([gal,psf])</span>
<span class="sd">        &gt;&gt;&gt; im = galsim.Image(1000,1000, scale=0.02)        # Note the very small pixel scale!</span>
<span class="sd">        &gt;&gt;&gt; im = conv.drawImage(image=im)                   # This uses the default GSParams.</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">          File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span>
<span class="sd">          File &quot;galsim/gsobject.py&quot;, line 1666, in drawImage</span>
<span class="sd">            added_photons = prof.drawFFT(draw_image, add)</span>
<span class="sd">          File &quot;galsim/gsobject.py&quot;, line 1877, in drawFFT</span>
<span class="sd">            kimage, wrap_size = self.drawFFT_makeKImage(image)</span>
<span class="sd">          File &quot;galsim/gsobject.py&quot;, line 1802, in drawFFT_makeKImage</span>
<span class="sd">            raise GalSimFFTSizeError(&quot;drawFFT requires an FFT that is too large.&quot;, Nk)</span>
<span class="sd">        galsim.errors.GalSimFFTSizeError: drawFFT requires an FFT that is too large.</span>
<span class="sd">        The required FFT size would be 12288 x 12288, which requires 3.38 GB of memory.</span>
<span class="sd">        If you can handle the large FFT, you may update gsparams.maximum_fft_size.</span>
<span class="sd">        &gt;&gt;&gt; big_fft_params = galsim.GSParams(maximum_fft_size=12300)</span>
<span class="sd">        &gt;&gt;&gt; conv = galsim.Convolve([gal,psf],gsparams=big_fft_params)</span>
<span class="sd">        &gt;&gt;&gt; im = conv.drawImage(image=im)                   # Now it works (but is slow!)</span>
<span class="sd">        &gt;&gt;&gt; im.write(&#39;high_res_sersic.fits&#39;)</span>

<span class="sd">    Note that for compound objects such as `Convolution` or `Sum`, not all `GSParams` can be</span>
<span class="sd">    changed when the compound object is created.  In the example given here, it is possible to</span>
<span class="sd">    change parameters related to the drawing, but not the Fourier space parameters for the</span>
<span class="sd">    components that go into the `Convolution`.  To get better sampling in Fourier space,</span>
<span class="sd">    for example, the ``gal`` and/or ``psf`` should be created with ``gsparams`` that have a</span>
<span class="sd">    non-default value of ``folding_threshold``.  This statement applies to the threshold and</span>
<span class="sd">    accuracy parameters.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_gsparams_opt</span> <span class="o">=</span> <span class="p">{</span> <span class="s1">&#39;minimum_fft_size&#39;</span> <span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                      <span class="s1">&#39;maximum_fft_size&#39;</span> <span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                      <span class="s1">&#39;folding_threshold&#39;</span> <span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
                      <span class="s1">&#39;stepk_minimum_hlr&#39;</span> <span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
                      <span class="s1">&#39;maxk_threshold&#39;</span> <span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
                      <span class="s1">&#39;kvalue_accuracy&#39;</span> <span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
                      <span class="s1">&#39;xvalue_accuracy&#39;</span> <span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
                      <span class="s1">&#39;realspace_relerr&#39;</span> <span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
                      <span class="s1">&#39;realspace_abserr&#39;</span> <span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
                      <span class="s1">&#39;integration_relerr&#39;</span> <span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
                      <span class="s1">&#39;integration_abserr&#39;</span> <span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
                      <span class="s1">&#39;shoot_accuracy&#39;</span> <span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
                      <span class="s1">&#39;allowed_flux_variation&#39;</span> <span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
                      <span class="s1">&#39;range_division_for_extrema&#39;</span> <span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                      <span class="s1">&#39;small_fraction_of_flux&#39;</span> <span class="p">:</span> <span class="nb">float</span>
                    <span class="p">}</span>
    <span class="n">redshift</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># For backwards compatibility with old atRedshift usage.  Can be overwritten.</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;The GSObject base class should not be instantiated directly.&quot;</span><span class="p">)</span>

    <span class="c1"># Note: subclasses are expected to define the following attributes or properties:</span>
    <span class="c1">#</span>
    <span class="c1"># Required for all profiles:</span>
    <span class="c1">#</span>
    <span class="c1">#     _flux (the object&#39;s flux, natch)</span>
    <span class="c1">#     _gsparams (use GSParams.check(None) if you just want the default)</span>
    <span class="c1">#     _stepk (the sampling in k space necessary to avoid folding of image in x space)</span>
    <span class="c1">#     _maxk (the value of k beyond which aliasing can be neglected)</span>
    <span class="c1">#     _has_hard_edges (true if should use real-space convolution with another hard edge profile)</span>
    <span class="c1">#     _is_axisymmetric (true if f(x,y) = f(r))</span>
    <span class="c1">#     _is_analytic_x (true if _xValue and _drawReal are implemented)</span>
    <span class="c1">#     _is_analytic_k (true if _kValue and _drawKImage are implemented)</span>
    <span class="c1">#</span>
    <span class="c1"># Required and typically class attributes, but there are defaults in each case:</span>
    <span class="c1">#</span>
    <span class="c1">#     _req_params (dict of required config parameters: name : type, default: {})</span>
    <span class="c1">#     _opt_params (dict of optional config parameters: name : type, default: {})</span>
    <span class="c1">#     _single_params (list of dicts for parameters where exactly one of several is required,</span>
    <span class="c1">#                    default: [])</span>
    <span class="c1">#     _takes_rng (bool specifying whether rng is an input parameter, default: False)</span>
    <span class="c1">#</span>
    <span class="c1"># Optional</span>
    <span class="c1">#</span>
    <span class="c1">#     _centroid (default = PositionD(0,0), which is often the right value)</span>
    <span class="c1">#     _positive_flux (default = _flux + _negative_flux)</span>
    <span class="c1">#     _negative_flux (default = 0; note: this should be absolute value of the negative flux)</span>
    <span class="c1">#     _max_sb (default 1.e500, which in this context is equivalent to &quot;unknown&quot;)</span>
    <span class="c1">#     _noise (default None)</span>
    <span class="c1">#</span>
    <span class="c1"># In addition, subclasses should typically define most of the following methods.</span>
    <span class="c1"># The default in each case is to raise a NotImplementedError, so if you cannot implement one,</span>
    <span class="c1"># you may simply not define it.</span>
    <span class="c1">#</span>
    <span class="c1">#     _xValue(self, pos)</span>
    <span class="c1">#     _kValue(self, kpos)</span>
    <span class="c1">#     _drawReal(self, image)</span>
    <span class="c1">#     _shoot(self, photons, rng):</span>
    <span class="c1">#     _drawKImage(self, image)</span>
    <span class="c1">#</span>
    <span class="c1"># Required for real-space convolution</span>
    <span class="c1">#</span>
    <span class="c1">#     _sbp which must be an attribute or property providing a C++-layer SBProfile instance.</span>
    <span class="c1">#</span>
    <span class="c1"># Note that most objects don&#39;t need to implement real-space convolution, so use of a C++-layer</span>
    <span class="c1"># SBProfile sub-class is usually only an implementation detail to improve efficiency.</span>
    <span class="c1">#</span>
    <span class="c1"># TODO: For now, _sbp is also required for transformations, but this is expected to be</span>
    <span class="c1">#       addressed in a future PR.</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">flux</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The flux of the profile.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flux</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">gsparams</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;A `GSParams` object that sets various parameters relevant for speed/accuracy trade-offs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gsparams</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">maxk</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The value of k beyond which aliasing can be neglected.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_maxk</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">stepk</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The sampling in k space necessary to avoid folding of image in x space.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stepk</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">nyquist_scale</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The pixel spacing that does not alias maxk.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxk</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">has_hard_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Whether there are any hard edges in the profile, which would require very small k</span>
<span class="sd">        spacing when working in the Fourier domain.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_hard_edges</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_axisymmetric</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Whether the profile is axially symmetric; affects efficiency of evaluation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_axisymmetric</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_analytic_x</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Whether the real-space values can be determined immediately at any position without</span>
<span class="sd">        requiring a Discrete Fourier Transform.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_analytic_x</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_analytic_k</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Whether the k-space values can be determined immediately at any position without</span>
<span class="sd">        requiring a Discrete Fourier Transform.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_analytic_k</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">centroid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The (x, y) centroid of an object as a `PositionD`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_centroid</span>

    <span class="nd">@lazy_property</span>
    <span class="k">def</span> <span class="nf">_centroid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Most profiles are centered at 0,0, so make this the default.</span>
        <span class="k">return</span> <span class="n">_PositionD</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">positive_flux</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The expectation value of flux in positive photons.</span>

<span class="sd">        Some profiles, when rendered with photon shooting, need to shoot both positive- and</span>
<span class="sd">        negative-flux photons.  For such profiles, this method returns the total flux</span>
<span class="sd">        of the positive-valued photons.</span>

<span class="sd">        For profiles that don&#39;t have this complication, this is equivalent to getFlux().</span>

<span class="sd">        It should be generally true that ``obj.positive_flux - obj.negative_flux`` returns the same</span>
<span class="sd">        thing as ``obj.flux``.  Small difference may accrue from finite numerical accuracy in</span>
<span class="sd">        cases involving lookup tables, etc.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_positive_flux</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">negative_flux</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the expectation value of flux in negative photons.</span>

<span class="sd">        Some profiles, when rendered with photon shooting, need to shoot both positive- and</span>
<span class="sd">        negative-flux photons.  For such profiles, this method returns the total absolute flux</span>
<span class="sd">        of the negative-valued photons (i.e. as a positive value).</span>

<span class="sd">        For profiles that don&#39;t have this complication, this returns 0.</span>

<span class="sd">        It should be generally true that ``obj.positive_flux - obj.negative_flux`` returns the same</span>
<span class="sd">        thing as ``obj.flux``.  Small difference may accrue from finite numerical accuracy in</span>
<span class="sd">        cases involving lookup tables, etc.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_negative_flux</span>

    <span class="nd">@lazy_property</span>
    <span class="k">def</span> <span class="nf">_positive_flux</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># The usual case.</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">flux</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_negative_flux</span>

    <span class="nd">@lazy_property</span>
    <span class="k">def</span> <span class="nf">_negative_flux</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># The usual case.</span>
        <span class="k">return</span> <span class="mf">0.</span>

    <span class="nd">@lazy_property</span>
    <span class="k">def</span> <span class="nf">_flux_per_photon</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># The usual case.</span>
        <span class="k">return</span> <span class="mf">1.</span>

    <span class="k">def</span> <span class="nf">_calculate_flux_per_photon</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># If negative_flux is overriden, then _flux_per_photon should be overridden as well</span>
        <span class="c1"># to return this calculation.</span>
        <span class="n">posflux</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">positive_flux</span>
        <span class="n">negflux</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">negative_flux</span>
        <span class="n">eta</span> <span class="o">=</span> <span class="n">negflux</span> <span class="o">/</span> <span class="p">(</span><span class="n">posflux</span> <span class="o">+</span> <span class="n">negflux</span><span class="p">)</span>
        <span class="k">return</span> <span class="mf">1.</span><span class="o">-</span><span class="mf">2.</span><span class="o">*</span><span class="n">eta</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">max_sb</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;An estimate of the maximum surface brightness of the object.</span>

<span class="sd">        Some profiles will return the exact peak SB, typically equal to the value of</span>
<span class="sd">        obj.xValue(obj.centroid).  However, not all profiles (e.g. Convolution) know how to</span>
<span class="sd">        calculate this value without just drawing the image and checking what the maximum value is.</span>
<span class="sd">        Clearly, this would be inefficient, so in these cases, some kind of estimate is returned,</span>
<span class="sd">        which will generally be conservative on the high side.</span>

<span class="sd">        This routine is mainly used by the photon shooting process, where an overestimate of</span>
<span class="sd">        the maximum surface brightness is acceptable.</span>

<span class="sd">        Note, for negative-flux profiles, this will return the absolute value of the most negative</span>
<span class="sd">        surface brightness.  Technically, it is an estimate of the maximum deviation from zero,</span>
<span class="sd">        rather than the maximum value.  For most profiles, these are the same thing.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_max_sb</span>

    <span class="nd">@lazy_property</span>
    <span class="k">def</span> <span class="nf">_max_sb</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># The way this is used, overestimates are conservative.</span>
        <span class="c1"># So the default value of 1.e500 will skip the optimization involving the maximum sb.</span>
        <span class="k">return</span> <span class="mf">1.e500</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">noise</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;An estimate of the noise already in the profile.</span>

<span class="sd">        Some profiles have some noise already in their definition.  E.g. those that come from</span>
<span class="sd">        observations of galaxies in real data.  In GalSim, `RealGalaxy` objects are an example of</span>
<span class="sd">        this.  In these cases, the noise attribute gives an estimate of the Noise object that</span>
<span class="sd">        would generate noise consistent with that already in the profile.</span>

<span class="sd">        It is permissible to attach a noise estimate to an existing object with::</span>

<span class="sd">            &gt;&gt;&gt; obj.noise = noise    # Some BaseNoise instance</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_noise</span>

    <span class="nd">@noise</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">noise</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="c1"># We allow the user to set the noise with obj.noise = n</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_noise</span> <span class="o">=</span> <span class="n">n</span>

    <span class="nd">@lazy_property</span>
    <span class="k">def</span> <span class="nf">_noise</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Most profiles don&#39;t have any noise.</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="c1"># a few definitions for using GSObjects as duck-typed ChromaticObjects</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">separable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="kc">True</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">interpolated</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="kc">False</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">deinterpolated</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">sed</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">sed</span><span class="o">.</span><span class="n">SED</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">flux</span><span class="p">,</span> <span class="s1">&#39;nm&#39;</span><span class="p">,</span> <span class="s1">&#39;1&#39;</span><span class="p">)</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">SED</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">.deprecated</span> <span class="kn">import</span> <span class="n">depr</span>
        <span class="n">depr</span><span class="p">(</span><span class="s1">&#39;obj.SED&#39;</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">,</span> <span class="s1">&#39;obj.sed&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sed</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">spectral</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="kc">False</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dimensionless</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="kc">True</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">wave_list</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">_fiducial_profile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bandpass</span><span class="p">):</span> <span class="k">return</span> <span class="n">bandpass</span><span class="o">.</span><span class="n">effective_wavelength</span><span class="p">,</span> <span class="bp">self</span>

    <span class="c1"># Also need these methods to duck-type as a ChromaticObject</span>
    <span class="k">def</span> <span class="nf">evaluateAtWavelength</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">wave</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>
    <span class="k">def</span> <span class="nf">_approxWavelength</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">wave</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">wave</span><span class="p">,</span> <span class="bp">self</span>

    <span class="c1"># Make op+ of two GSObjects work to return an Add object</span>
    <span class="c1"># Note: we don&#39;t define __iadd__ and similar.  Let python handle this automatically</span>
    <span class="c1"># to make obj += obj2 be equivalent to obj = obj + obj2.</span>
<div class="viewcode-block" id="GSObject.__add__"><a class="viewcode-back" href="../../gsobject.html#galsim.GSObject.__add__">[docs]</a>    <span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Add two GSObjects.</span>

<span class="sd">        Equivalent to Add(self, other)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_sum</span><span class="o">.</span><span class="n">Add</span><span class="p">([</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">])</span></div>

    <span class="c1"># op- is unusual, but allowed.  It subtracts off one profile from another.</span>
<div class="viewcode-block" id="GSObject.__sub__"><a class="viewcode-back" href="../../gsobject.html#galsim.GSObject.__sub__">[docs]</a>    <span class="k">def</span> <span class="fm">__sub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Subtract two GSObjects.</span>

<span class="sd">        Equivalent to Add(self, -1 * other)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_sum</span><span class="o">.</span><span class="n">Add</span><span class="p">([</span><span class="bp">self</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mf">1.</span> <span class="o">*</span> <span class="n">other</span><span class="p">)])</span></div>

    <span class="c1"># Make op* work to adjust the flux of an object</span>
<div class="viewcode-block" id="GSObject.__mul__"><a class="viewcode-back" href="../../gsobject.html#galsim.GSObject.__mul__">[docs]</a>    <span class="k">def</span> <span class="fm">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Scale the flux of the object by the given factor.</span>

<span class="sd">        obj * flux_ratio is equivalent to obj.withScaledFlux(flux_ratio)</span>

<span class="sd">        It creates a new object that has the same profile as the original, but with the</span>
<span class="sd">        surface brightness at every location scaled by the given amount.</span>

<span class="sd">        You can also multiply by an `SED`, which will create a `ChromaticObject` where the `SED`</span>
<span class="sd">        acts like a wavelength-dependent ``flux_ratio``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">withScaledFlux</span><span class="p">(</span><span class="n">other</span><span class="p">)</span></div>

<div class="viewcode-block" id="GSObject.__rmul__"><a class="viewcode-back" href="../../gsobject.html#galsim.GSObject.__rmul__">[docs]</a>    <span class="k">def</span> <span class="fm">__rmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Equivalent to obj * other.  See `__mul__` for details.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__mul__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span></div>

    <span class="c1"># Likewise for op/</span>
<div class="viewcode-block" id="GSObject.__div__"><a class="viewcode-back" href="../../gsobject.html#galsim.GSObject.__div__">[docs]</a>    <span class="k">def</span> <span class="nf">__div__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Equivalent to obj * (1/other).  See `__mul__` for details.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.</span> <span class="o">/</span> <span class="n">other</span><span class="p">)</span></div>

    <span class="fm">__truediv__</span> <span class="o">=</span> <span class="n">__div__</span>

    <span class="k">def</span> <span class="fm">__neg__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="o">-</span><span class="mf">1.</span> <span class="o">*</span> <span class="bp">self</span>

    <span class="c1"># Some calculations that can be done for all GSObjects.</span>
<div class="viewcode-block" id="GSObject.calculateHLR"><a class="viewcode-back" href="../../gsobject.html#galsim.GSObject.calculateHLR">[docs]</a>    <span class="k">def</span> <span class="nf">calculateHLR</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">centroid</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">flux_frac</span><span class="o">=</span><span class="mf">0.5</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the half-light radius of the object.</span>

<span class="sd">        If the profile has a half_light_radius attribute, it will just return that, but in the</span>
<span class="sd">        general case, we draw the profile and estimate the half-light radius directly.</span>

<span class="sd">        This function (by default at least) is only accurate to a few percent, typically.</span>
<span class="sd">        Possibly worse depending on the profile being measured.  If you care about a high</span>
<span class="sd">        precision estimate of the half-light radius, the accuracy can be improved using the</span>
<span class="sd">        optional parameter scale to change the pixel scale used to draw the profile.</span>

<span class="sd">        The default scale is half the Nyquist scale, which were found to produce results accurate</span>
<span class="sd">        to a few percent on our internal tests.  Using a smaller scale will be more accurate at</span>
<span class="sd">        the expense of speed.</span>

<span class="sd">        In addition, you can optionally specify the size of the image to draw. The default size is</span>
<span class="sd">        None, which means `drawImage` will choose a size designed to contain around 99.5% of the</span>
<span class="sd">        flux.  This is overkill for this calculation, so choosing a smaller size than this may</span>
<span class="sd">        speed up this calculation somewhat.</span>

<span class="sd">        Also, while the name of this function refers to the half-light radius, in fact it can also</span>
<span class="sd">        calculate radii that enclose other fractions of the light, according to the parameter</span>
<span class="sd">        ``flux_frac``.  E.g. for r90, you would set flux_frac=0.90.</span>

<span class="sd">        The default scale should usually be acceptable for things like testing that a galaxy</span>
<span class="sd">        has a reasonable resolution, but they should not be trusted for very fine grain</span>
<span class="sd">        discriminations.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            size:           If given, the stamp size to use for the drawn image. [default: None,</span>
<span class="sd">                            which will let `drawImage` choose the size automatically]</span>
<span class="sd">            scale:          If given, the pixel scale to use for the drawn image. [default:</span>
<span class="sd">                            0.5 * self.nyquist_scale]</span>
<span class="sd">            centroid:       The position to use for the centroid. [default: self.centroid]</span>
<span class="sd">            flux_frac:      The fraction of light to be enclosed by the returned radius.</span>
<span class="sd">                            [default: 0.5]</span>

<span class="sd">        Returns:</span>
<span class="sd">            an estimate of the half-light radius in physical units</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># It there is a half_light_radius attribute, use that.</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">half_light_radius</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">AttributeError</span><span class="p">,</span> <span class="n">GalSimError</span><span class="p">):</span>
            <span class="c1"># Otherwise, or (e.g. with Airy where it is only implemented for obscuration=0)</span>
            <span class="c1"># if there is an error trying to use it, then keep going with this calculation.</span>
            <span class="k">pass</span>

        <span class="k">if</span> <span class="n">scale</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">scale</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nyquist_scale</span> <span class="o">*</span> <span class="mf">0.5</span>

        <span class="k">if</span> <span class="n">centroid</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">centroid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">centroid</span>

        <span class="c1"># Draw the image.  Note: need a method that integrates over pixels to get flux right.</span>
        <span class="c1"># The offset is to make all the rsq values different to help the precision a bit.</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="n">_PositionD</span><span class="p">(</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.33</span><span class="p">)</span>
        <span class="n">im</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">drawImage</span><span class="p">(</span><span class="n">nx</span><span class="o">=</span><span class="n">size</span><span class="p">,</span> <span class="n">ny</span><span class="o">=</span><span class="n">size</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="n">offset</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

        <span class="n">center</span> <span class="o">=</span> <span class="n">im</span><span class="o">.</span><span class="n">true_center</span> <span class="o">+</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">centroid</span><span class="o">/</span><span class="n">scale</span>
        <span class="k">return</span> <span class="n">im</span><span class="o">.</span><span class="n">calculateHLR</span><span class="p">(</span><span class="n">center</span><span class="o">=</span><span class="n">center</span><span class="p">,</span> <span class="n">flux</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">flux</span><span class="p">,</span> <span class="n">flux_frac</span><span class="o">=</span><span class="n">flux_frac</span><span class="p">)</span></div>

<div class="viewcode-block" id="GSObject.calculateMomentRadius"><a class="viewcode-back" href="../../gsobject.html#galsim.GSObject.calculateMomentRadius">[docs]</a>    <span class="k">def</span> <span class="nf">calculateMomentRadius</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">centroid</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rtype</span><span class="o">=</span><span class="s1">&#39;det&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns an estimate of the radius based on unweighted second moments.</span>

<span class="sd">        The second moments are defined as:</span>

<span class="sd">        Q_ij = int( I(x,y) i j dx dy ) / int( I(x,y) dx dy )</span>
<span class="sd">        where i,j may be either x or y.</span>

<span class="sd">        If I(x,y) is a Gaussian, then T = Tr(Q) = Qxx + Qyy = 2 sigma^2.  Thus, one reasonable</span>
<span class="sd">        choice for a &quot;radius&quot; for an arbitrary profile is sqrt(T/2).</span>

<span class="sd">        In addition, det(Q) = sigma^4.  So another choice for an arbitrary profile is det(Q)^1/4.</span>

<span class="sd">        This routine can return either of these measures according to the value of the ``rtype``</span>
<span class="sd">        parameter.  ``rtype=&#39;trace&#39;`` will cause it to return sqrt(T/2).  ``rtype=&#39;det&#39;`` will cause</span>
<span class="sd">        it to return det(Q)^1/4.  And ``rtype=&#39;both&#39;`` will return a tuple with both values.</span>

<span class="sd">        Note that for the special case of a Gaussian profile, no calculation is necessary, and</span>
<span class="sd">        the ``sigma`` attribute will be used in both cases.  In the limit as scale-&gt;0, this</span>
<span class="sd">        function will return the same value, but because finite pixels are drawn, the results</span>
<span class="sd">        will not be precisely equal for real use cases.  The approximation being made is that</span>
<span class="sd">        the integral of I(x,y) i j dx dy over each pixel can be approximated as</span>
<span class="sd">        int(I(x,y) dx dy) * i_center * j_center.</span>

<span class="sd">        This function (by default at least) is only accurate to a few percent, typically.</span>
<span class="sd">        Possibly worse depending on the profile being measured.  If you care about a high</span>
<span class="sd">        precision estimate of the radius, the accuracy can be improved using the optional</span>
<span class="sd">        parameters size and scale to change the size and pixel scale used to draw the profile.</span>

<span class="sd">        The default is to use the the Nyquist scale for the pixel scale and let `drawImage`</span>
<span class="sd">        choose a size for the stamp that will enclose at least 99.5% of the flux.  These</span>
<span class="sd">        were found to produce results accurate to a few percent on our internal tests.</span>
<span class="sd">        Using a smaller scale and larger size will be more accurate at the expense of speed.</span>

<span class="sd">        The default parameters should usually be acceptable for things like testing that a galaxy</span>
<span class="sd">        has a reasonable resolution, but they should not be trusted for very fine grain</span>
<span class="sd">        discriminations.  For a more accurate estimate, see galsim.hsm.FindAdaptiveMom.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            size:           If given, the stamp size to use for the drawn image. [default: None,</span>
<span class="sd">                            which will let `drawImage` choose the size automatically]</span>
<span class="sd">            scale:          If given, the pixel scale to use for the drawn image. [default:</span>
<span class="sd">                            self.nyquist_scale]</span>
<span class="sd">            centroid:       The position to use for the centroid. [default: self.centroid]</span>
<span class="sd">            rtype:          There are three options for this parameter:</span>
<span class="sd">                            - &#39;trace&#39; means return sqrt(T/2)</span>
<span class="sd">                            - &#39;det&#39; means return det(Q)^1/4</span>
<span class="sd">                            - &#39;both&#39; means return both: (sqrt(T/2), det(Q)^1/4)</span>
<span class="sd">                            [default: &#39;det&#39;]</span>

<span class="sd">        Returns:</span>
<span class="sd">            an estimate of the radius in physical units (or both estimates if rtype == &#39;both&#39;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">rtype</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;trace&#39;</span><span class="p">,</span> <span class="s1">&#39;det&#39;</span><span class="p">,</span> <span class="s1">&#39;both&#39;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">GalSimValueError</span><span class="p">(</span><span class="s2">&quot;Invalid rtype.&quot;</span><span class="p">,</span> <span class="n">rtype</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;trace&#39;</span><span class="p">,</span> <span class="s1">&#39;det&#39;</span><span class="p">,</span> <span class="s1">&#39;both&#39;</span><span class="p">))</span>

        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;sigma&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">rtype</span> <span class="o">==</span> <span class="s1">&#39;both&#39;</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigma</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigma</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigma</span>

        <span class="k">if</span> <span class="n">scale</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">scale</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nyquist_scale</span>

        <span class="k">if</span> <span class="n">centroid</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">centroid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">centroid</span>

        <span class="c1"># Draw the image.  Note: need a method that integrates over pixels to get flux right.</span>
        <span class="n">im</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">drawImage</span><span class="p">(</span><span class="n">nx</span><span class="o">=</span><span class="n">size</span><span class="p">,</span> <span class="n">ny</span><span class="o">=</span><span class="n">size</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

        <span class="n">center</span> <span class="o">=</span> <span class="n">im</span><span class="o">.</span><span class="n">true_center</span> <span class="o">+</span> <span class="n">centroid</span><span class="o">/</span><span class="n">scale</span>
        <span class="k">return</span> <span class="n">im</span><span class="o">.</span><span class="n">calculateMomentRadius</span><span class="p">(</span><span class="n">center</span><span class="o">=</span><span class="n">center</span><span class="p">,</span> <span class="n">flux</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">flux</span><span class="p">,</span> <span class="n">rtype</span><span class="o">=</span><span class="n">rtype</span><span class="p">)</span></div>

<div class="viewcode-block" id="GSObject.calculateFWHM"><a class="viewcode-back" href="../../gsobject.html#galsim.GSObject.calculateFWHM">[docs]</a>    <span class="k">def</span> <span class="nf">calculateFWHM</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">centroid</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the full-width half-maximum (FWHM) of the object.</span>

<span class="sd">        If the profile has a fwhm attribute, it will just return that, but in the general case,</span>
<span class="sd">        we draw the profile and estimate the FWHM directly.</span>

<span class="sd">        As with `calculateHLR` and `calculateMomentRadius`, this function optionally takes size and</span>
<span class="sd">        scale values to use for the image drawing.  The default is to use the the Nyquist scale</span>
<span class="sd">        for the pixel scale and let `drawImage` choose a size for the stamp that will enclose at</span>
<span class="sd">        least 99.5% of the flux.  These were found to produce results accurate to well below</span>
<span class="sd">        one percent on our internal tests, so it is unlikely that you will want to adjust</span>
<span class="sd">        them for accuracy.  However, using a smaller size than default could help speed up</span>
<span class="sd">        the calculation, since the default is usually much larger than is needed.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            size:           If given, the stamp size to use for the drawn image. [default: None,</span>
<span class="sd">                            which will let `drawImage` choose the size automatically]</span>
<span class="sd">            scale:          If given, the pixel scale to use for the drawn image. [default:</span>
<span class="sd">                            self.nyquist_scale]</span>
<span class="sd">            centroid:       The position to use for the centroid. [default: self.centroid]</span>

<span class="sd">        Returns:</span>
<span class="sd">            an estimate of the full-width half-maximum in physical units</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;fwhm&#39;</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">fwhm</span>

        <span class="k">if</span> <span class="n">scale</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">scale</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nyquist_scale</span>

        <span class="k">if</span> <span class="n">centroid</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">centroid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">centroid</span>

        <span class="c1"># Draw the image.  Note: draw with method=&#39;sb&#39; here, since the fwhm is a property of the</span>
        <span class="c1"># raw surface brightness profile, not integrated over pixels.</span>
        <span class="c1"># The offset is to make all the rsq values different to help the precision a bit.</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="n">_PositionD</span><span class="p">(</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.33</span><span class="p">)</span>

        <span class="n">im</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">drawImage</span><span class="p">(</span><span class="n">nx</span><span class="o">=</span><span class="n">size</span><span class="p">,</span> <span class="n">ny</span><span class="o">=</span><span class="n">size</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="n">offset</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;sb&#39;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

        <span class="c1"># Get the maximum value, assuming the maximum is at the centroid.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_analytic_x</span><span class="p">:</span>
            <span class="n">Imax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xValue</span><span class="p">(</span><span class="n">centroid</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">im1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">drawImage</span><span class="p">(</span><span class="n">nx</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">ny</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;sb&#39;</span><span class="p">,</span> <span class="n">offset</span><span class="o">=-</span><span class="n">centroid</span><span class="o">/</span><span class="n">scale</span><span class="p">)</span>
            <span class="n">Imax</span> <span class="o">=</span> <span class="n">im1</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">center</span> <span class="o">=</span> <span class="n">im</span><span class="o">.</span><span class="n">true_center</span> <span class="o">+</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">centroid</span><span class="o">/</span><span class="n">scale</span>
        <span class="k">return</span> <span class="n">im</span><span class="o">.</span><span class="n">calculateFWHM</span><span class="p">(</span><span class="n">center</span><span class="o">=</span><span class="n">center</span><span class="p">,</span> <span class="n">Imax</span><span class="o">=</span><span class="n">Imax</span><span class="p">)</span></div>

<div class="viewcode-block" id="GSObject.xValue"><a class="viewcode-back" href="../../gsobject.html#galsim.GSObject.xValue">[docs]</a>    <span class="k">def</span> <span class="nf">xValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the value of the object at a chosen 2D position in real space.</span>

<span class="sd">        This function returns the surface brightness of the object at a particular position</span>
<span class="sd">        in real space.  The position argument may be provided as a `PositionD` or `PositionI`</span>
<span class="sd">        argument, or it may be given as x,y (either as a tuple or as two arguments).</span>

<span class="sd">        The object surface brightness profiles are typically defined in world coordinates, so</span>
<span class="sd">        the position here should be in world coordinates as well.</span>

<span class="sd">        Not all `GSObject` classes can use this method.  Classes like Convolution that require a</span>
<span class="sd">        Discrete Fourier Transform to determine the real space values will not do so for a single</span>
<span class="sd">        position.  Instead a GalSimError will be raised.  The xValue() method is available if and</span>
<span class="sd">        only if ``obj.is_analytic_x == True``.</span>

<span class="sd">        Users who wish to use the xValue() method for an object that is the convolution of other</span>
<span class="sd">        profiles can do so by drawing the convolved profile into an image, using the image to</span>
<span class="sd">        initialize a new `InterpolatedImage`, and then using the xValue() method for that new</span>
<span class="sd">        object.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            position:    The position at which you want the surface brightness of the object.</span>

<span class="sd">        Returns:</span>
<span class="sd">            the surface brightness at that position.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="n">parse_pos_args</span><span class="p">(</span><span class="n">args</span><span class="p">,</span><span class="n">kwargs</span><span class="p">,</span><span class="s1">&#39;x&#39;</span><span class="p">,</span><span class="s1">&#39;y&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xValue</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span></div>

<div class="viewcode-block" id="GSObject._xValue"><a class="viewcode-back" href="../../gsobject.html#galsim.GSObject._xValue">[docs]</a>    <span class="k">def</span> <span class="nf">_xValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pos</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Equivalent to `xValue`, but ``pos`` must be a `galsim.PositionD` instance</span>

<span class="sd">        Parameters:</span>
<span class="sd">            pos:        The position at which you want the surface brightness of the object.</span>

<span class="sd">        Returns:</span>
<span class="sd">            the surface brightness at that position.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> does not implement xValue&quot;</span><span class="o">%</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span></div>

<div class="viewcode-block" id="GSObject.kValue"><a class="viewcode-back" href="../../gsobject.html#galsim.GSObject.kValue">[docs]</a>    <span class="k">def</span> <span class="nf">kValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the value of the object at a chosen 2D position in k space.</span>

<span class="sd">        This function returns the amplitude of the fourier transform of the surface brightness</span>
<span class="sd">        profile at a given position in k space.  The position argument may be provided as a</span>
<span class="sd">        `Position` argument, or it may be given as kx,ky (either as a tuple or as two arguments).</span>

<span class="sd">        Technically, kValue() is available if and only if the given obj has ``obj.is_analytic_k</span>
<span class="sd">        == True``, but this is the case for all `GSObject` classes currently, so that should never</span>
<span class="sd">        be an issue (unlike for `xValue`).</span>

<span class="sd">        Parameters:</span>
<span class="sd">            position:    The position in k space at which you want the fourier amplitude.</span>

<span class="sd">        Returns:</span>
<span class="sd">            the amplitude of the fourier transform at that position.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">kpos</span> <span class="o">=</span> <span class="n">parse_pos_args</span><span class="p">(</span><span class="n">args</span><span class="p">,</span><span class="n">kwargs</span><span class="p">,</span><span class="s1">&#39;kx&#39;</span><span class="p">,</span><span class="s1">&#39;ky&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kValue</span><span class="p">(</span><span class="n">kpos</span><span class="p">)</span></div>

<div class="viewcode-block" id="GSObject._kValue"><a class="viewcode-back" href="../../gsobject.html#galsim.GSObject._kValue">[docs]</a>    <span class="k">def</span> <span class="nf">_kValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kpos</span><span class="p">):</span>  <span class="c1"># pragma: no cover  (all our classes override this)</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Equivalent to `kValue`, but ``kpos`` must be a `galsim.PositionD` instance.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> does not implement kValue&quot;</span><span class="o">%</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span></div>

<div class="viewcode-block" id="GSObject.withGSParams"><a class="viewcode-back" href="../../gsobject.html#galsim.GSObject.withGSParams">[docs]</a>    <span class="k">def</span> <span class="nf">withGSParams</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gsparams</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a version of the current object with the given `GSParams`.</span>

<span class="sd">        You may either provide a `GSParams` instance::</span>

<span class="sd">            &gt;&gt;&gt; gsparams = galsim.GSParams(folding_threshold=1.e-4, maxk_threshold=1.e-4)</span>
<span class="sd">            &gt;&gt;&gt; obj = obj.withGSParams(gsparams)</span>

<span class="sd">        or one or more named parameters as keyword arguments::</span>

<span class="sd">            &gt;&gt;&gt; obj = obj.withGSParams(folding_threshold=1.e-4, maxk_threshold=1.e-4)</span>

<span class="sd">        .. note::</span>

<span class="sd">            The latter style will leave all non-named parameters at their current</span>
<span class="sd">            values. It only updates the named parameters to the given values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Note to developers: objects that wrap other objects should override this in order</span>
        <span class="c1"># to apply the new gsparams to the components.</span>
        <span class="c1"># This implementation relies on getstate/setstate clearing out any _sbp or similar</span>
        <span class="c1"># attribute that depends on the details of gsparams.  If there are stored calculations</span>
        <span class="c1"># aside from these, you should also clear them as well, or update them.</span>
        <span class="k">if</span> <span class="n">gsparams</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">gsparams</span><span class="p">:</span> <span class="k">return</span> <span class="bp">self</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">_gsparams</span> <span class="o">=</span> <span class="n">GSParams</span><span class="o">.</span><span class="n">check</span><span class="p">(</span><span class="n">gsparams</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gsparams</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ret</span></div>

<div class="viewcode-block" id="GSObject.withFlux"><a class="viewcode-back" href="../../gsobject.html#galsim.GSObject.withFlux">[docs]</a>    <span class="k">def</span> <span class="nf">withFlux</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">flux</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a version of the current object with a different flux.</span>

<span class="sd">        This function is equivalent to ``obj.withScaledFlux(flux / obj.flux)``.</span>

<span class="sd">        It creates a new object that has the same profile as the original, but with the</span>
<span class="sd">        surface brightness at every location rescaled such that the total flux will be</span>
<span class="sd">        the given value.  Note that if ``flux`` is an `SED`, the return value will be a</span>
<span class="sd">        `ChromaticObject` with specified `SED`.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            flux:       The new flux for the object.</span>

<span class="sd">        Returns:</span>
<span class="sd">            the object with the new flux</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">withScaledFlux</span><span class="p">(</span><span class="n">flux</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">flux</span><span class="p">)</span></div>

<div class="viewcode-block" id="GSObject.withScaledFlux"><a class="viewcode-back" href="../../gsobject.html#galsim.GSObject.withScaledFlux">[docs]</a>    <span class="k">def</span> <span class="nf">withScaledFlux</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">flux_ratio</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a version of the current object with the flux scaled by the given ``flux_ratio``.</span>

<span class="sd">        This function is equivalent to ``obj.withFlux(flux_ratio * obj.flux)``.  Indeed, withFlux()</span>
<span class="sd">        is implemented in terms of this one.</span>

<span class="sd">        It creates a new object that has the same profile as the original, but with the</span>
<span class="sd">        surface brightness at every location scaled by the given amount.  If ``flux_ratio`` is an</span>
<span class="sd">        `SED`, then the returned object is a `ChromaticObject` with the `SED` multiplied by</span>
<span class="sd">        its current ``flux``.</span>

<span class="sd">        Note that in this case the ``flux`` attribute of the `GSObject` being scaled gets</span>
<span class="sd">        interpreted as being dimensionless, instead of having its normal units of [photons/s/cm^2].</span>
<span class="sd">        The photons/s/cm^2 units are (optionally) carried by the `SED` instead, or even left out</span>
<span class="sd">        entirely if the `SED` is dimensionless itself (see discussion in the `ChromaticObject`</span>
<span class="sd">        docstring).  The `GSObject` ``flux`` attribute *does* still contribute to the</span>
<span class="sd">        `ChromaticObject` normalization, though.  For example, the following are equivalent::</span>

<span class="sd">            &gt;&gt;&gt; chrom_obj = gsobj.withScaledFlux(sed * 3.0)</span>
<span class="sd">            &gt;&gt;&gt; chrom_obj2 = (gsobj * 3.0).withScaledFlux(sed)</span>

<span class="sd">        An equivalent, and usually simpler, way to effect this scaling is::</span>

<span class="sd">            &gt;&gt;&gt; obj = obj * flux_ratio</span>

<span class="sd">        Parameters:</span>
<span class="sd">            flux_ratio:     The ratio by which to rescale the flux of the object when creating a new</span>
<span class="sd">                            one.</span>

<span class="sd">        Returns:</span>
<span class="sd">            the object with the new flux.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Prohibit non-SED callable flux_ratio here as most likely an error.</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">flux_ratio</span><span class="p">,</span> <span class="s1">&#39;__call__&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">flux_ratio</span><span class="p">,</span> <span class="n">sed</span><span class="o">.</span><span class="n">SED</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;callable flux_ratio must be an SED.&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">flux_ratio</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">transform</span><span class="o">.</span><span class="n">Transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">flux_ratio</span><span class="o">=</span><span class="n">flux_ratio</span><span class="p">)</span></div>

<div class="viewcode-block" id="GSObject.expand"><a class="viewcode-back" href="../../gsobject.html#galsim.GSObject.expand">[docs]</a>    <span class="k">def</span> <span class="nf">expand</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scale</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Expand the linear size of the profile by the given ``scale`` factor, while preserving</span>
<span class="sd">        surface brightness.</span>

<span class="sd">        e.g. ``half_light_radius`` &lt;-- ``half_light_radius * scale``</span>

<span class="sd">        This doesn&#39;t correspond to either of the normal operations one would typically want to do to</span>
<span class="sd">        a galaxy.  The functions dilate() and magnify() are the more typical usage.  But this</span>
<span class="sd">        function is conceptually simple.  It rescales the linear dimension of the profile, while</span>
<span class="sd">        preserving surface brightness.  As a result, the flux will necessarily change as well.</span>

<span class="sd">        See dilate() for a version that applies a linear scale factor while preserving flux.</span>

<span class="sd">        See magnify() for a version that applies a scale factor to the area while preserving surface</span>
<span class="sd">        brightness.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            scale:      The factor by which to scale the linear dimension of the object.</span>

<span class="sd">        Returns:</span>
<span class="sd">            the expanded object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">transform</span><span class="o">.</span><span class="n">Transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">jac</span><span class="o">=</span><span class="p">[</span><span class="n">scale</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="n">scale</span><span class="p">])</span></div>

<div class="viewcode-block" id="GSObject.dilate"><a class="viewcode-back" href="../../gsobject.html#galsim.GSObject.dilate">[docs]</a>    <span class="k">def</span> <span class="nf">dilate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scale</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Dilate the linear size of the profile by the given ``scale`` factor, while preserving</span>
<span class="sd">        flux.</span>

<span class="sd">        e.g. ``half_light_radius`` &lt;-- ``half_light_radius * scale``</span>

<span class="sd">        See expand() and magnify() for versions that preserve surface brightness, and thus</span>
<span class="sd">        changes the flux.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            scale:      The linear rescaling factor to apply.</span>

<span class="sd">        Returns:</span>
<span class="sd">            the dilated object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># equivalent to self.expand(scale) * (1./scale**2)</span>
        <span class="k">return</span> <span class="n">transform</span><span class="o">.</span><span class="n">Transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">jac</span><span class="o">=</span><span class="p">[</span><span class="n">scale</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="n">scale</span><span class="p">],</span> <span class="n">flux_ratio</span><span class="o">=</span><span class="n">scale</span><span class="o">**-</span><span class="mi">2</span><span class="p">)</span></div>

<div class="viewcode-block" id="GSObject.magnify"><a class="viewcode-back" href="../../gsobject.html#galsim.GSObject.magnify">[docs]</a>    <span class="k">def</span> <span class="nf">magnify</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mu</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a version of the current object with a lensing magnification applied to it,</span>
<span class="sd">        scaling the area and flux by ``mu`` at fixed surface brightness.</span>

<span class="sd">        This process applies a lensing magnification mu, which scales the linear dimensions of the</span>
<span class="sd">        image by the factor sqrt(mu), i.e., ``half_light_radius`` &lt;--</span>
<span class="sd">        ``half_light_radius * sqrt(mu)`` while increasing the flux by a factor of mu.  Thus,</span>
<span class="sd">        magnify() preserves surface brightness.</span>

<span class="sd">        See dilate() for a version that applies a linear scale factor while preserving flux.</span>

<span class="sd">        See expand() for a version that applies a linear scale factor while preserving surface</span>
<span class="sd">        brightness.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            mu:     The lensing magnification to apply.</span>

<span class="sd">        Returns:</span>
<span class="sd">            the magnified object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span></div>

<div class="viewcode-block" id="GSObject.shear"><a class="viewcode-back" href="../../gsobject.html#galsim.GSObject.shear">[docs]</a>    <span class="k">def</span> <span class="nf">shear</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a version of the current object with an area-preserving shear applied to it.</span>

<span class="sd">        The arguments may be either a `Shear` instance or arguments to be used to initialize one.</span>

<span class="sd">        For more details about the allowed keyword arguments, see the `Shear` docstring.</span>

<span class="sd">        The shear() method precisely preserves the area.  To include a lensing distortion with</span>
<span class="sd">        the appropriate change in area, either use shear() with magnify(), or use lens(), which</span>
<span class="sd">        combines both operations.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            shear:      The `Shear` to be applied. Or, as described above, you may instead supply</span>
<span class="sd">                        parameters do construct a shear directly.  eg. ``obj.shear(g1=g1,g2=g2)``.</span>

<span class="sd">        Returns:</span>
<span class="sd">            the sheared object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Error, gave both unnamed and named arguments to GSObject.shear!&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Shear</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Error, unnamed argument to GSObject.shear is not a Shear!&quot;</span><span class="p">)</span>
            <span class="n">shear</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Error, too many unnamed arguments to GSObject.shear!&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Error, shear argument is required&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">shear</span> <span class="o">=</span> <span class="n">Shear</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">transform</span><span class="o">.</span><span class="n">Transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shear</span><span class="o">.</span><span class="n">getMatrix</span><span class="p">())</span></div>

<div class="viewcode-block" id="GSObject._shear"><a class="viewcode-back" href="../../gsobject.html#galsim.GSObject._shear">[docs]</a>    <span class="k">def</span> <span class="nf">_shear</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shear</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Equivalent to `GSObject.shear`, but without the overhead of sanity checks or other</span>
<span class="sd">        ways to input the ``shear`` value.</span>

<span class="sd">        Also, it won&#39;t propagate any noise attribute.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            shear:      The `Shear` to be applied.</span>

<span class="sd">        Returns:</span>
<span class="sd">            the sheared object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">transform</span><span class="o">.</span><span class="n">_Transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shear</span><span class="o">.</span><span class="n">getMatrix</span><span class="p">())</span></div>

<div class="viewcode-block" id="GSObject.lens"><a class="viewcode-back" href="../../gsobject.html#galsim.GSObject.lens">[docs]</a>    <span class="k">def</span> <span class="nf">lens</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">g1</span><span class="p">,</span> <span class="n">g2</span><span class="p">,</span> <span class="n">mu</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a version of the current object with both a lensing shear and magnification</span>
<span class="sd">        applied to it.</span>

<span class="sd">        This `GSObject` method applies a lensing (reduced) shear and magnification.  The shear must</span>
<span class="sd">        be specified using the g1, g2 definition of shear (see `Shear` for more details).</span>
<span class="sd">        This is the same definition as the outputs of the PowerSpectrum and NFWHalo classes, which</span>
<span class="sd">        compute shears according to some lensing power spectrum or lensing by an NFW dark matter</span>
<span class="sd">        halo.  The magnification determines the rescaling factor for the object area and flux,</span>
<span class="sd">        preserving surface brightness.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            g1:         First component of lensing (reduced) shear to apply to the object.</span>
<span class="sd">            g2:         Second component of lensing (reduced) shear to apply to the object.</span>
<span class="sd">            mu:         Lensing magnification to apply to the object.  This is the factor by which</span>
<span class="sd">                        the solid angle subtended by the object is magnified, preserving surface</span>
<span class="sd">                        brightness.</span>

<span class="sd">        Returns:</span>
<span class="sd">            the lensed object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">shear</span> <span class="o">=</span> <span class="n">Shear</span><span class="p">(</span><span class="n">g1</span><span class="o">=</span><span class="n">g1</span><span class="p">,</span> <span class="n">g2</span><span class="o">=</span><span class="n">g2</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">transform</span><span class="o">.</span><span class="n">Transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shear</span><span class="o">.</span><span class="n">getMatrix</span><span class="p">()</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span></div>

    <span class="k">def</span> <span class="nf">_lens</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">g1</span><span class="p">,</span> <span class="n">g2</span><span class="p">,</span> <span class="n">mu</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Equivalent to `GSObject.lens`, but without the overhead of some of the sanity checks.</span>

<span class="sd">        Also, it won&#39;t propagate any noise attribute.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            g1:         First component of lensing (reduced) shear to apply to the object.</span>
<span class="sd">            g2:         Second component of lensing (reduced) shear to apply to the object.</span>
<span class="sd">            mu:         Lensing magnification to apply to the object.  This is the factor by which</span>
<span class="sd">                        the solid angle subtended by the object is magnified, preserving surface</span>
<span class="sd">                        brightness.</span>

<span class="sd">        Returns:</span>
<span class="sd">            the lensed object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">shear</span> <span class="o">=</span> <span class="n">_Shear</span><span class="p">(</span><span class="n">g1</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">g2</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">transform</span><span class="o">.</span><span class="n">_Transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shear</span><span class="o">.</span><span class="n">getMatrix</span><span class="p">()</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span>

<div class="viewcode-block" id="GSObject.rotate"><a class="viewcode-back" href="../../gsobject.html#galsim.GSObject.rotate">[docs]</a>    <span class="k">def</span> <span class="nf">rotate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theta</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Rotate this object by an `Angle` ``theta``.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            theta:      Rotation angle (`Angle` object, positive means anticlockwise).</span>

<span class="sd">        Returns:</span>
<span class="sd">            the rotated object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">Angle</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Input theta should be an Angle&quot;</span><span class="p">)</span>
        <span class="n">s</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">theta</span><span class="o">.</span><span class="n">sincos</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">transform</span><span class="o">.</span><span class="n">Transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">jac</span><span class="o">=</span><span class="p">[</span><span class="n">c</span><span class="p">,</span> <span class="o">-</span><span class="n">s</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">c</span><span class="p">])</span></div>

<div class="viewcode-block" id="GSObject.transform"><a class="viewcode-back" href="../../gsobject.html#galsim.GSObject.transform">[docs]</a>    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dudx</span><span class="p">,</span> <span class="n">dudy</span><span class="p">,</span> <span class="n">dvdx</span><span class="p">,</span> <span class="n">dvdy</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a version of the current object with an arbitrary Jacobian matrix transformation</span>
<span class="sd">        applied to it.</span>

<span class="sd">        This applies a Jacobian matrix to the coordinate system in which this object</span>
<span class="sd">        is defined.  It changes a profile defined in terms of (x,y) to one defined in</span>
<span class="sd">        terms of (u,v) where:</span>

<span class="sd">            u = dudx x + dudy y</span>
<span class="sd">            v = dvdx x + dvdy y</span>

<span class="sd">        That is, an arbitrary affine transform, but without the translation (which is</span>
<span class="sd">        easily effected via the `shift` method).</span>

<span class="sd">        Note that this function is similar to expand in that it preserves surface brightness,</span>
<span class="sd">        not flux.  If you want to preserve flux, you should also do::</span>

<span class="sd">            &gt;&gt;&gt; prof *= 1./abs(dudx*dvdy - dudy*dvdx)</span>

<span class="sd">        Parameters:</span>
<span class="sd">            dudx:       du/dx, where (x,y) are the current coords, and (u,v) are the new coords.</span>
<span class="sd">            dudy:       du/dy, where (x,y) are the current coords, and (u,v) are the new coords.</span>
<span class="sd">            dvdx:       dv/dx, where (x,y) are the current coords, and (u,v) are the new coords.</span>
<span class="sd">            dvdy:       dv/dy, where (x,y) are the current coords, and (u,v) are the new coords.</span>

<span class="sd">        Returns:</span>
<span class="sd">            the transformed object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">transform</span><span class="o">.</span><span class="n">Transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">jac</span><span class="o">=</span><span class="p">[</span><span class="n">dudx</span><span class="p">,</span> <span class="n">dudy</span><span class="p">,</span> <span class="n">dvdx</span><span class="p">,</span> <span class="n">dvdy</span><span class="p">])</span></div>

<div class="viewcode-block" id="GSObject.shift"><a class="viewcode-back" href="../../gsobject.html#galsim.GSObject.shift">[docs]</a>    <span class="k">def</span> <span class="nf">shift</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a version of the current object shifted by some amount in real space.</span>

<span class="sd">        After this call, the caller&#39;s type will be a `GSObject`.</span>
<span class="sd">        This means that if the caller was a derived type that had extra methods or properties</span>
<span class="sd">        beyond those defined in `GSObject` (e.g. `Gaussian.sigma`), then these methods are no</span>
<span class="sd">        longer available.</span>

<span class="sd">        Note: in addition to the dx,dy parameter names, you may also supply dx,dy as a tuple,</span>
<span class="sd">        or as a `Position` object.</span>

<span class="sd">        The shift coordinates here are sky coordinates.  `GSObject` profiles are always defined in</span>
<span class="sd">        sky coordinates and only later (when they are drawn) is the connection to pixel coordinates</span>
<span class="sd">        established (via a pixel_scale or WCS).  So a shift of dx moves the object horizontally</span>
<span class="sd">        in the sky (e.g. west in the local tangent plane of the observation), and dy moves the</span>
<span class="sd">        object vertically (north in the local tangent plane).</span>

<span class="sd">        The units are typically arcsec, but we don&#39;t enforce that anywhere.  The units here just</span>
<span class="sd">        need to be consistent with the units used for any size values used by the `GSObject`.</span>
<span class="sd">        The connection of these units to the eventual image pixels is defined by either the</span>
<span class="sd">        ``pixel_scale`` or the ``wcs`` parameter of `GSObject.drawImage`.</span>

<span class="sd">        Note: if you want to shift the object by a set number (or fraction) of pixels in the</span>
<span class="sd">        drawn image, you probably want to use the ``offset`` parameter of `GSObject.drawImage`</span>
<span class="sd">        rather than this method.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            dx:         Horizontal shift to apply.</span>
<span class="sd">            dy:         Vertical shift to apply.</span>

<span class="sd">        Alternatively, you may supply a single parameter as a `Position` instance, rather than</span>
<span class="sd">        the two components separately if that is more convenient.</span>

<span class="sd">        Parameter:</span>
<span class="sd">            offset:     The shift to apply, given as PositionD(dx,dy) or PositionI(dx,dy)</span>

<span class="sd">        Returns:</span>
<span class="sd">            the shifted object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="n">parse_pos_args</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">,</span> <span class="s1">&#39;dx&#39;</span><span class="p">,</span> <span class="s1">&#39;dy&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">transform</span><span class="o">.</span><span class="n">Transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="n">offset</span><span class="p">)</span></div>

<div class="viewcode-block" id="GSObject._shift"><a class="viewcode-back" href="../../gsobject.html#galsim.GSObject._shift">[docs]</a>    <span class="k">def</span> <span class="nf">_shift</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dx</span><span class="p">,</span> <span class="n">dy</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Equivalent to `shift`, but without the overhead of sanity checks or option</span>
<span class="sd">        to give the shift as a PositionD.</span>

<span class="sd">        Also, it won&#39;t propagate any noise attribute.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            dx:         The x-component of the shift to apply</span>
<span class="sd">            dy:         The y-component of the shift to apply</span>

<span class="sd">        Returns:</span>
<span class="sd">            the shifted object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new_obj</span> <span class="o">=</span> <span class="n">transform</span><span class="o">.</span><span class="n">_Transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="p">(</span><span class="n">dx</span><span class="p">,</span><span class="n">dy</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">new_obj</span></div>

<div class="viewcode-block" id="GSObject.atRedshift"><a class="viewcode-back" href="../../gsobject.html#galsim.GSObject.atRedshift">[docs]</a>    <span class="k">def</span> <span class="nf">atRedshift</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">redshift</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a version of the current object with a different redshift.</span>

<span class="sd">        For regular GSObjects, this method doesn&#39;t do anything aside from setting a ``redshift``</span>
<span class="sd">        attribute with the given value.  But this allows duck typing with ChromaticObjects</span>
<span class="sd">        where this function will adjust the SED appropriately.</span>

<span class="sd">        .. warning::</span>

<span class="sd">            This method has been deprecated as of version 2.5.3.</span>

<span class="sd">        Returns:</span>
<span class="sd">            the object with the new redshift</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.deprecated</span> <span class="kn">import</span> <span class="n">depr</span>
        <span class="n">depr</span><span class="p">(</span><span class="s1">&#39;atRedshift&#39;</span><span class="p">,</span> <span class="s1">&#39;2.5.3&#39;</span><span class="p">,</span> <span class="s1">&#39;obj = copy.copy(obj); obj.redshift = redshift&#39;</span><span class="p">)</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">redshift</span> <span class="o">=</span> <span class="n">redshift</span>
        <span class="k">return</span> <span class="n">ret</span></div>

    <span class="c1"># Make sure the image is defined with the right size and wcs for drawImage()</span>
    <span class="k">def</span> <span class="nf">_setup_image</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span> <span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">bounds</span><span class="p">,</span> <span class="n">add_to_image</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">center</span><span class="p">,</span> <span class="n">odd</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="c1"># If image is given, check validity of nx,ny,bounds:</span>
        <span class="k">if</span> <span class="n">image</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">bounds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">GalSimIncompatibleValuesError</span><span class="p">(</span>
                    <span class="s2">&quot;Cannot provide bounds if image is provided&quot;</span><span class="p">,</span> <span class="n">bounds</span><span class="o">=</span><span class="n">bounds</span><span class="p">,</span> <span class="n">image</span><span class="o">=</span><span class="n">image</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">nx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">ny</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">GalSimIncompatibleValuesError</span><span class="p">(</span>
                    <span class="s2">&quot;Cannot provide nx,ny if image is provided&quot;</span><span class="p">,</span> <span class="n">nx</span><span class="o">=</span><span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="o">=</span><span class="n">ny</span><span class="p">,</span> <span class="n">image</span><span class="o">=</span><span class="n">image</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">image</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="n">dtype</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">GalSimIncompatibleValuesError</span><span class="p">(</span>
                    <span class="s2">&quot;Cannot specify dtype != image.array.dtype if image is provided&quot;</span><span class="p">,</span>
                    <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">image</span><span class="o">=</span><span class="n">image</span><span class="p">)</span>

            <span class="c1"># Resize the given image if necessary</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">image</span><span class="o">.</span><span class="n">bounds</span><span class="o">.</span><span class="n">isDefined</span><span class="p">():</span>
                <span class="c1"># Can&#39;t add to image if need to resize</span>
                <span class="k">if</span> <span class="n">add_to_image</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">GalSimIncompatibleValuesError</span><span class="p">(</span>
                        <span class="s2">&quot;Cannot add_to_image if image bounds are not defined&quot;</span><span class="p">,</span>
                        <span class="n">add_to_image</span><span class="o">=</span><span class="n">add_to_image</span><span class="p">,</span> <span class="n">image</span><span class="o">=</span><span class="n">image</span><span class="p">)</span>
                <span class="n">N</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getGoodImageSize</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">odd</span><span class="p">:</span> <span class="n">N</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">bounds</span> <span class="o">=</span> <span class="n">_BoundsI</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">N</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">N</span><span class="p">)</span>
                <span class="n">image</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">bounds</span><span class="p">)</span>
            <span class="c1"># Else use the given image as is</span>

        <span class="c1"># Otherwise, make a new image</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Can&#39;t add to image if none is provided.</span>
            <span class="k">if</span> <span class="n">add_to_image</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">GalSimIncompatibleValuesError</span><span class="p">(</span>
                    <span class="s2">&quot;Cannot add_to_image if image is None&quot;</span><span class="p">,</span> <span class="n">add_to_image</span><span class="o">=</span><span class="n">add_to_image</span><span class="p">,</span> <span class="n">image</span><span class="o">=</span><span class="n">image</span><span class="p">)</span>
            <span class="c1"># Use bounds or nx,ny if provided</span>
            <span class="k">if</span> <span class="n">bounds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">nx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">ny</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">GalSimIncompatibleValuesError</span><span class="p">(</span>
                        <span class="s2">&quot;Cannot set both bounds and (nx, ny)&quot;</span><span class="p">,</span> <span class="n">nx</span><span class="o">=</span><span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="o">=</span><span class="n">ny</span><span class="p">,</span> <span class="n">bounds</span><span class="o">=</span><span class="n">bounds</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">bounds</span><span class="o">.</span><span class="n">isDefined</span><span class="p">():</span>
                    <span class="k">raise</span> <span class="n">GalSimValueError</span><span class="p">(</span><span class="s2">&quot;Cannot use undefined bounds&quot;</span><span class="p">,</span> <span class="n">bounds</span><span class="p">)</span>
                <span class="n">image</span> <span class="o">=</span> <span class="n">Image</span><span class="p">(</span><span class="n">bounds</span><span class="o">=</span><span class="n">bounds</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">nx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">ny</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">nx</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">ny</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">GalSimIncompatibleValuesError</span><span class="p">(</span>
                        <span class="s2">&quot;Must set either both or neither of nx, ny&quot;</span><span class="p">,</span> <span class="n">nx</span><span class="o">=</span><span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="o">=</span><span class="n">ny</span><span class="p">)</span>
                <span class="n">image</span> <span class="o">=</span> <span class="n">Image</span><span class="p">(</span><span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">center</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1"># Note: this needs to match the corresponding calculation in _get_new_bounds</span>
                    <span class="n">image</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span><span class="n">_PositionI</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">center</span><span class="o">.</span><span class="n">x</span><span class="o">+</span><span class="mf">0.5</span><span class="o">-</span><span class="n">image</span><span class="o">.</span><span class="n">true_center</span><span class="o">.</span><span class="n">x</span><span class="p">),</span>
                                           <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">center</span><span class="o">.</span><span class="n">y</span><span class="o">+</span><span class="mf">0.5</span><span class="o">-</span><span class="n">image</span><span class="o">.</span><span class="n">true_center</span><span class="o">.</span><span class="n">y</span><span class="p">)))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">N</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getGoodImageSize</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">odd</span><span class="p">:</span> <span class="n">N</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">image</span> <span class="o">=</span> <span class="n">Image</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">center</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">image</span><span class="o">.</span><span class="n">setCenter</span><span class="p">(</span><span class="n">_PositionI</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">center</span><span class="o">.</span><span class="n">x</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">center</span><span class="o">.</span><span class="n">y</span><span class="p">)))</span>

        <span class="k">return</span> <span class="n">image</span>

    <span class="k">def</span> <span class="nf">_local_wcs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">wcs</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">center</span><span class="p">,</span> <span class="n">use_true_center</span><span class="p">,</span> <span class="n">new_bounds</span><span class="p">):</span>
        <span class="c1"># Get the local WCS at the location of the object.</span>

        <span class="k">if</span> <span class="n">wcs</span><span class="o">.</span><span class="n">_isUniform</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">wcs</span><span class="o">.</span><span class="n">local</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">image</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">bounds</span> <span class="o">=</span> <span class="n">new_bounds</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">bounds</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">bounds</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">bounds</span><span class="o">.</span><span class="n">isDefined</span><span class="p">():</span>
            <span class="k">raise</span> <span class="n">GalSimIncompatibleValuesError</span><span class="p">(</span>
                <span class="s2">&quot;Cannot provide non-local wcs with automatically sized image&quot;</span><span class="p">,</span>
                <span class="n">wcs</span><span class="o">=</span><span class="n">wcs</span><span class="p">,</span> <span class="n">image</span><span class="o">=</span><span class="n">image</span><span class="p">,</span> <span class="n">bounds</span><span class="o">=</span><span class="n">new_bounds</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">center</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">obj_cen</span> <span class="o">=</span> <span class="n">center</span>
        <span class="k">elif</span> <span class="n">use_true_center</span><span class="p">:</span>
            <span class="n">obj_cen</span> <span class="o">=</span> <span class="n">bounds</span><span class="o">.</span><span class="n">true_center</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">obj_cen</span> <span class="o">=</span> <span class="n">bounds</span><span class="o">.</span><span class="n">center</span>
            <span class="c1"># Convert from PositionI to PositionD</span>
            <span class="n">obj_cen</span> <span class="o">=</span> <span class="n">_PositionD</span><span class="p">(</span><span class="n">obj_cen</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">obj_cen</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
        <span class="c1"># _parse_offset has already turned offset=None into PositionD(0,0), so it is safe to add.</span>
        <span class="n">obj_cen</span> <span class="o">+=</span> <span class="n">offset</span>
        <span class="k">return</span> <span class="n">wcs</span><span class="o">.</span><span class="n">local</span><span class="p">(</span><span class="n">image_pos</span><span class="o">=</span><span class="n">obj_cen</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_parse_offset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">offset</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">offset</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_PositionD</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="n">Position</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">_PositionD</span><span class="p">(</span><span class="n">offset</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">offset</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Let python raise the appropriate exception if this isn&#39;t valid.</span>
            <span class="k">return</span> <span class="n">_PositionD</span><span class="p">(</span><span class="n">offset</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">offset</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">_parse_center</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">center</span><span class="p">):</span>
        <span class="c1"># Almost the same as _parse_offset, except we leave it as None in that case.</span>
        <span class="k">if</span> <span class="n">center</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">center</span><span class="p">,</span> <span class="n">Position</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">_PositionD</span><span class="p">(</span><span class="n">center</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">center</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Let python raise the appropriate exception if this isn&#39;t valid.</span>
            <span class="k">return</span> <span class="n">_PositionD</span><span class="p">(</span><span class="n">center</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">center</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">_get_new_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span> <span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">bounds</span><span class="p">,</span> <span class="n">center</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">image</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">image</span><span class="o">.</span><span class="n">bounds</span><span class="o">.</span><span class="n">isDefined</span><span class="p">():</span>
            <span class="k">return</span> <span class="n">image</span><span class="o">.</span><span class="n">bounds</span>
        <span class="k">elif</span> <span class="n">nx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">ny</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">b</span> <span class="o">=</span> <span class="n">BoundsI</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">nx</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">ny</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">center</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># Note: this needs to match the corresponding calculation in _setup_image</span>
                <span class="c1"># where we shift the image center after making a new image with nx,ny.</span>
                <span class="n">b</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span><span class="n">_PositionI</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">center</span><span class="o">.</span><span class="n">x</span><span class="o">+</span><span class="mf">0.5</span><span class="o">-</span><span class="n">b</span><span class="o">.</span><span class="n">true_center</span><span class="o">.</span><span class="n">x</span><span class="p">),</span>
                                       <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">center</span><span class="o">.</span><span class="n">y</span><span class="o">+</span><span class="mf">0.5</span><span class="o">-</span><span class="n">b</span><span class="o">.</span><span class="n">true_center</span><span class="o">.</span><span class="n">y</span><span class="p">)))</span>
            <span class="k">return</span> <span class="n">b</span>
        <span class="k">elif</span> <span class="n">bounds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">bounds</span><span class="o">.</span><span class="n">isDefined</span><span class="p">():</span>
            <span class="k">return</span> <span class="n">bounds</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">BoundsI</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_adjust_offset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_bounds</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">center</span><span class="p">,</span> <span class="n">use_true_center</span><span class="p">):</span>
        <span class="c1"># Note: this assumes self is in terms of image coordinates.</span>
        <span class="k">if</span> <span class="n">center</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">new_bounds</span><span class="o">.</span><span class="n">isDefined</span><span class="p">():</span>
                <span class="n">offset</span> <span class="o">+=</span> <span class="n">center</span> <span class="o">-</span> <span class="n">new_bounds</span><span class="o">.</span><span class="n">center</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Then will be created as even sized image.</span>
                <span class="n">offset</span> <span class="o">+=</span> <span class="n">_PositionD</span><span class="p">(</span><span class="n">center</span><span class="o">.</span><span class="n">x</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">center</span><span class="o">.</span><span class="n">x</span><span class="p">),</span> <span class="n">center</span><span class="o">.</span><span class="n">y</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">center</span><span class="o">.</span><span class="n">y</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">use_true_center</span><span class="p">:</span>
            <span class="c1"># For even-sized images, the SBProfile draw function centers the result in the</span>
            <span class="c1"># pixel just up and right of the real center.  So shift it back to make sure it really</span>
            <span class="c1"># draws in the center.</span>
            <span class="c1"># Also, remember that numpy&#39;s shape is ordered as [y,x]</span>
            <span class="n">dx</span> <span class="o">=</span> <span class="n">offset</span><span class="o">.</span><span class="n">x</span>
            <span class="n">dy</span> <span class="o">=</span> <span class="n">offset</span><span class="o">.</span><span class="n">y</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="n">new_bounds</span><span class="o">.</span><span class="n">numpyShape</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="n">dx</span> <span class="o">-=</span> <span class="mf">0.5</span>
            <span class="k">if</span> <span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="n">dy</span> <span class="o">-=</span> <span class="mf">0.5</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="n">_PositionD</span><span class="p">(</span><span class="n">dx</span><span class="p">,</span><span class="n">dy</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">offset</span>

    <span class="k">def</span> <span class="nf">_determine_wcs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scale</span><span class="p">,</span> <span class="n">wcs</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span> <span class="n">default_wcs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1"># Determine the correct wcs given the input scale, wcs and image.</span>
        <span class="k">if</span> <span class="n">wcs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">scale</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">GalSimIncompatibleValuesError</span><span class="p">(</span>
                    <span class="s2">&quot;Cannot provide both wcs and scale&quot;</span><span class="p">,</span> <span class="n">wcs</span><span class="o">=</span><span class="n">wcs</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">wcs</span><span class="p">,</span> <span class="n">BaseWCS</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;wcs must be a BaseWCS instance&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">image</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="n">image</span><span class="o">.</span><span class="n">wcs</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">elif</span> <span class="n">scale</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">wcs</span> <span class="o">=</span> <span class="n">PixelScale</span><span class="p">(</span><span class="n">scale</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">image</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="n">image</span><span class="o">.</span><span class="n">wcs</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">elif</span> <span class="n">image</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">image</span><span class="o">.</span><span class="n">wcs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">wcs</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">wcs</span>

        <span class="c1"># If the input scale &lt;= 0, or wcs is still None at this point, then use the Nyquist scale:</span>
        <span class="k">if</span> <span class="n">wcs</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="p">(</span><span class="n">wcs</span><span class="o">.</span><span class="n">_isPixelScale</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">wcs</span><span class="o">.</span><span class="n">scale</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">default_wcs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">wcs</span> <span class="o">=</span> <span class="n">PixelScale</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nyquist_scale</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">wcs</span> <span class="o">=</span> <span class="n">default_wcs</span>

        <span class="k">return</span> <span class="n">wcs</span>

    <span class="k">def</span> <span class="nf">_prepareDraw</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Do any work that was postponed until drawImage.</span>
        <span class="k">pass</span>

<div class="viewcode-block" id="GSObject.drawImage"><a class="viewcode-back" href="../../gsobject.html#galsim.GSObject.drawImage">[docs]</a>    <span class="k">def</span> <span class="nf">drawImage</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">image</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ny</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">bounds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">wcs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                  <span class="n">method</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">,</span> <span class="n">area</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span> <span class="n">exptime</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span> <span class="n">gain</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span> <span class="n">add_to_image</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                  <span class="n">center</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">use_true_center</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                  <span class="n">n_photons</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span> <span class="n">rng</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">max_extra_noise</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span>
                  <span class="n">poisson_flux</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sensor</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">photon_ops</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">n_subsample</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">maxN</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                  <span class="n">save_photons</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">bandpass</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">setup_only</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                  <span class="n">surface_ops</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Draws an `Image` of the object.</span>

<span class="sd">        The drawImage() method is used to draw an `Image` of the current object using one of several</span>
<span class="sd">        possible rendering methods (see below).  It can create a new `Image` or can draw onto an</span>
<span class="sd">        existing one if provided by the ``image`` parameter.  If the ``image`` is given, you can</span>
<span class="sd">        also optionally add to the given `Image` if ``add_to_image = True``, but the default is to</span>
<span class="sd">        replace the current contents with new values.</span>

<span class="sd">        **Providing an input image**:</span>

<span class="sd">        Note that if you provide an ``image`` parameter, it is the image onto which the profile</span>
<span class="sd">        will be drawn.  The provided image *will be modified*.  A reference to the same image</span>
<span class="sd">        is also returned to provide a parallel return behavior to when ``image`` is ``None``</span>
<span class="sd">        (described above).</span>

<span class="sd">        This option is useful in practice because you may want to construct the image first and</span>
<span class="sd">        then draw onto it, perhaps multiple times. For example, you might be drawing onto a</span>
<span class="sd">        subimage of a larger image. Or you may want to draw different components of a complex</span>
<span class="sd">        profile separately.  In this case, the returned value is typically ignored.  For example::</span>

<span class="sd">            &gt;&gt;&gt; im1 = bulge.drawImage()</span>
<span class="sd">            &gt;&gt;&gt; im2 = disk.drawImage(image=im1, add_to_image=True)</span>
<span class="sd">            &gt;&gt;&gt; assert im1 is im2</span>

<span class="sd">            &gt;&gt;&gt; full_image = galsim.Image(2048, 2048, scale=pixel_scale)</span>
<span class="sd">            &gt;&gt;&gt; b = galsim.BoundsI(x-32, x+32, y-32, y+32)</span>
<span class="sd">            &gt;&gt;&gt; stamp = obj.drawImage(image = full_image[b])</span>
<span class="sd">            &gt;&gt;&gt; assert (stamp.array == full_image[b].array).all()</span>

<span class="sd">        **Letting drawImage create the image for you**:</span>

<span class="sd">        If drawImage() will be creating the image from scratch for you, then there are several ways</span>
<span class="sd">        to control the size of the new image.  If the ``nx`` and ``ny`` keywords are present, then</span>
<span class="sd">        an image with these numbers of pixels on a side will be created.  Similarly, if the ``bounds``</span>
<span class="sd">        keyword is present, then an image with the specified bounds will be created.  Note that it</span>
<span class="sd">        is an error to provide an existing `Image` when also specifying ``nx``, ``ny``, or</span>
<span class="sd">        ``bounds``.  In the absence of ``nx``, ``ny``, and ``bounds``, drawImage will decide a good</span>
<span class="sd">        size to use based on the size of the object being drawn.  Basically, it will try to use an</span>
<span class="sd">        area large enough to include at least 99.5% of the flux.</span>

<span class="sd">        .. note::</span>

<span class="sd">            This value 0.995 is really ``1 - folding_threshold``.  You can change the value of</span>
<span class="sd">            ``folding_threshold`` for any object via `GSParams`.</span>

<span class="sd">        You can set the pixel scale of the constructed image with the ``scale`` parameter, or set</span>
<span class="sd">        a WCS function with ``wcs``.  If you do not provide either ``scale`` or ``wcs``, then</span>
<span class="sd">        drawImage() will default to using the Nyquist scale for the current object.</span>

<span class="sd">        You can also set the data type used in the new `Image` with the ``dtype`` parameter that has</span>
<span class="sd">        the same options as for the `Image` constructor.</span>

<span class="sd">        **The drawing &quot;method&quot;**:</span>

<span class="sd">        There are several different possible methods drawImage() can use for rendering the image.</span>
<span class="sd">        This is set by the ``method`` parameter.  The options are:</span>

<span class="sd">        auto</span>
<span class="sd">                This is the default, which will normally be equivalent to &#39;fft&#39;.  However,</span>
<span class="sd">                if the object being rendered is simple (no convolution) and has hard edges</span>
<span class="sd">                (e.g. a Box or a truncated Moffat or Sersic), then it will switch to</span>
<span class="sd">                &#39;real_space&#39;, since that is often both faster and more accurate in these</span>
<span class="sd">                cases (due to ringing in Fourier space).</span>
<span class="sd">        fft</span>
<span class="sd">                The integration of the light within each pixel is mathematically equivalent</span>
<span class="sd">                to convolving by the pixel profile (a `Pixel` object) and sampling the result</span>
<span class="sd">                at the centers of the pixels.  This method will do that convolution using</span>
<span class="sd">                a discrete Fourier transform.  Furthermore, if the object (or any component</span>
<span class="sd">                of it) has been transformed via shear(), dilate(), etc., then these</span>
<span class="sd">                transformations are done in Fourier space as well.</span>
<span class="sd">        real_space</span>
<span class="sd">                This uses direct integrals (using the Gauss-Kronrod-Patterson algorithm)</span>
<span class="sd">                in real space for the integration over the pixel response.  It is usually</span>
<span class="sd">                slower than the &#39;fft&#39; method, but if the profile has hard edges that cause</span>
<span class="sd">                ringing in Fourier space, it can be faster and/or more accurate.  If you</span>
<span class="sd">                use &#39;real_space&#39; with something that is already a Convolution, then this</span>
<span class="sd">                will revert to &#39;fft&#39;, since the double convolution that is required to also</span>
<span class="sd">                handle the pixel response is far too slow to be practical using real-space</span>
<span class="sd">                integrals.</span>
<span class="sd">        phot</span>
<span class="sd">                This uses a technique called photon shooting to render the image.</span>
<span class="sd">                Essentially, the object profile is taken as a probability distribution</span>
<span class="sd">                from which a finite number of photons are &quot;shot&quot; onto the image.  Each</span>
<span class="sd">                photon&#39;s flux gets added to whichever pixel the photon hits.  This process</span>
<span class="sd">                automatically accounts for the integration of the light over the pixel</span>
<span class="sd">                area, since all photons that hit any part of the pixel are counted.</span>
<span class="sd">                Convolutions and transformations are simple geometric processes in this</span>
<span class="sd">                framework.  However, there are two caveats with this method: (1) the</span>
<span class="sd">                resulting image will have Poisson noise from the finite number of photons,</span>
<span class="sd">                and (2) it is not available for all object types (notably anything that</span>
<span class="sd">                includes a Deconvolution).</span>
<span class="sd">        no_pixel</span>
<span class="sd">                Instead of integrating over the pixels, this method will sample the profile</span>
<span class="sd">                at the centers of the pixels and multiply by the pixel area.  If there is</span>
<span class="sd">                a convolution involved, the choice of whether this will use an FFT or</span>
<span class="sd">                real-space calculation is governed by the ``real_space`` parameter of the</span>
<span class="sd">                Convolution class.  This method is the appropriate choice if you are using</span>
<span class="sd">                a PSF that already includes a convolution by the pixel response.  For</span>
<span class="sd">                example, if you are using a PSF from an observed image of a star, then it</span>
<span class="sd">                has already been convolved by the pixel, so you would not want to do so</span>
<span class="sd">                again.  Note: The multiplication by the pixel area gets the flux</span>
<span class="sd">                normalization right for the above use case.  cf. ``method = &#39;sb&#39;``.</span>
<span class="sd">        sb</span>
<span class="sd">                This is a lot like &#39;no_pixel&#39;, except that the image values will simply be</span>
<span class="sd">                the sampled object profile&#39;s surface brightness, not multiplied by the</span>
<span class="sd">                pixel area.  This does not correspond to any real observing scenario, but</span>
<span class="sd">                it could be useful if you want to view the surface brightness profile of an</span>
<span class="sd">                object directly, without including the pixel integration.</span>

<span class="sd">        The &#39;phot&#39; method has a few extra parameters that adjust how it functions.  The total</span>
<span class="sd">        number of photons to shoot is normally calculated from the object&#39;s flux.  This flux is</span>
<span class="sd">        taken to be given in photons/cm^2/s, so for most simple profiles, this times area * exptime</span>
<span class="sd">        will equal the number of photons shot.  (See the discussion in Rowe et al, 2015, for why</span>
<span class="sd">        this might be modified for `InterpolatedImage` and related profiles.)  However, you can</span>
<span class="sd">        manually set a different number of photons with ``n_photons``.  You can also set</span>
<span class="sd">        ``max_extra_noise`` to tell drawImage() to use fewer photons than normal (and so is faster)</span>
<span class="sd">        such that no more than that much extra noise is added to any pixel.  This is particularly</span>
<span class="sd">        useful if you will be subsequently adding sky noise, and you can thus tolerate more noise</span>
<span class="sd">        than the normal number of photons would give you, since using fewer photons is of course</span>
<span class="sd">        faster.  Finally, the default behavior is to have the total flux vary as a Poisson random</span>
<span class="sd">        variate, which is normally appropriate with photon shooting.  But you can turn this off with</span>
<span class="sd">        ``poisson_flux=False``.  It also defaults to False if you set an explicit value for</span>
<span class="sd">        ``n_photons``.</span>

<span class="sd">        Given the periodicity implicit in the use of FFTs, there can occasionally be artifacts due</span>
<span class="sd">        to wrapping at the edges, particularly for objects that are quite extended (e.g., due to</span>
<span class="sd">        the nature of the radial profile). See `GSParams` for parameters that you can use to reduce</span>
<span class="sd">        the level of these artifacts, in particular ``folding_threshold`` may be helpful if you see</span>
<span class="sd">        such artifacts in your images.</span>

<span class="sd">        Setting the offset:</span>

<span class="sd">        The object will by default be drawn with its nominal center at the center location of the</span>
<span class="sd">        image.  There is thus a qualitative difference in the appearance of the rendered profile</span>
<span class="sd">        when drawn on even- and odd-sized images.  For a profile with a maximum at (0,0), this</span>
<span class="sd">        maximum will fall in the central pixel of an odd-sized image, but in the corner of the four</span>
<span class="sd">        central pixels of an even-sized image.  There are three parameters that can affect this</span>
<span class="sd">        behavior.  First, you can specify any arbitrary pixel position to center the object using</span>
<span class="sd">        the ``center`` parameter.  If this is None, then it will pick one of the two potential</span>
<span class="sd">        &quot;centers&quot; of the image, either ``image.true_center`` or ``image.center``.  The latter is</span>
<span class="sd">        an integer position, which always corresponds to the center of some pixel, which for even</span>
<span class="sd">        sized images won&#39;t (cannot) be the actual &quot;true&quot; center of the image.  You can choose which</span>
<span class="sd">        of these two centers you want to use with the ``use_true_center`` parameters, which</span>
<span class="sd">        defaults to False.  You can also arbitrarily offset the profile from the image center with</span>
<span class="sd">        the ``offset`` parameter to handle any aribtrary offset you want from the chosen center.</span>
<span class="sd">        (Typically, one would use only one of ``center`` or ``offset`` but it is permissible to use</span>
<span class="sd">        both.)</span>

<span class="sd">        Setting the overall normalization:</span>

<span class="sd">        Normally, the flux of the object should be equal to the sum of all the pixel values in the</span>
<span class="sd">        image, less some small amount of flux that may fall off the edge of the image (assuming you</span>
<span class="sd">        don&#39;t use ``method=&#39;sb&#39;``).  However, you may optionally set a ``gain`` value, which</span>
<span class="sd">        converts between photons and ADU (so-called analog-to-digital units), the units of the</span>
<span class="sd">        pixel values in real images.  Normally, the gain of a CCD is in electrons/ADU, but in</span>
<span class="sd">        GalSim, we fold the quantum efficiency into the gain as well, so the units are photons/ADU.</span>

<span class="sd">        Another caveat is that, technically, flux is really in units of photons/cm^2/s, not photons.</span>
<span class="sd">        So if you want, you can keep track of this properly and provide an ``area`` and ``exptime``</span>
<span class="sd">        here. This detail is more important with chromatic objects where the `SED` is typically</span>
<span class="sd">        given in erg/cm^2/s/nm, so the exposure time and area are important details. With achromatic</span>
<span class="sd">        objects however, it is often more convenient to ignore these details and just consider the</span>
<span class="sd">        flux to be the total number of photons for this exposure, in which case, you would leave the</span>
<span class="sd">        area and exptime parameters at their default value of 1.</span>

<span class="sd">        On return, the image will have an attribute ``added_flux``, which will be set to the total</span>
<span class="sd">        flux added to the image.  This may be useful as a sanity check that you have provided a</span>
<span class="sd">        large enough image to catch most of the flux.  For example::</span>

<span class="sd">            &gt;&gt;&gt; obj.drawImage(image)</span>
<span class="sd">            &gt;&gt;&gt; assert image.added_flux &gt; 0.99 * obj.flux</span>

<span class="sd">        The appropriate threshold will depend on your particular application, including what kind</span>
<span class="sd">        of profile the object has, how big your image is relative to the size of your object,</span>
<span class="sd">        whether you are keeping ``poisson_flux=True``, etc.</span>

<span class="sd">        The following code snippet illustrates how ``gain``, ``exptime``, ``area``, and ``method``</span>
<span class="sd">        can all influence the relationship between the ``flux`` attribute of a `GSObject` and</span>
<span class="sd">        both the pixel values and ``.added_flux`` attribute of an `Image` drawn with</span>
<span class="sd">        ``drawImage()``::</span>

<span class="sd">            &gt;&gt;&gt; obj = galsim.Gaussian(fwhm=1)</span>
<span class="sd">            &gt;&gt;&gt; obj.flux</span>
<span class="sd">            1.0</span>
<span class="sd">            &gt;&gt;&gt; im = obj.drawImage()</span>
<span class="sd">            &gt;&gt;&gt; im.added_flux</span>
<span class="sd">            0.9999630988657515</span>
<span class="sd">            &gt;&gt;&gt; im.array.sum()</span>
<span class="sd">            0.99996305</span>
<span class="sd">            &gt;&gt;&gt; im = obj.drawImage(exptime=10, area=10)</span>
<span class="sd">            &gt;&gt;&gt; im.added_flux</span>
<span class="sd">            0.9999630988657525</span>
<span class="sd">            &gt;&gt;&gt; im.array.sum()</span>
<span class="sd">            99.996315</span>
<span class="sd">            &gt;&gt;&gt; im = obj.drawImage(exptime=10, area=10, method=&#39;sb&#39;, scale=0.5, nx=10, ny=10)</span>
<span class="sd">            &gt;&gt;&gt; im.added_flux</span>
<span class="sd">            0.9999973790505298</span>
<span class="sd">            &gt;&gt;&gt; im.array.sum()</span>
<span class="sd">            399.9989</span>
<span class="sd">            &gt;&gt;&gt; im = obj.drawImage(exptime=10, area=10, gain=2)</span>
<span class="sd">            &gt;&gt;&gt; im.added_flux</span>
<span class="sd">            0.9999630988657525</span>
<span class="sd">            &gt;&gt;&gt; im.array.sum()</span>
<span class="sd">            49.998158</span>

<span class="sd">        Using a non-trivial sensor:</span>

<span class="sd">        Normally the sensor is modeled as an array of pixels where any photon that hits a given</span>
<span class="sd">        pixel is accumulated into that pixel.  The final pixel value then just reflects the total</span>
<span class="sd">        number of pixels that hit each sensor.  However, real sensors do not (quite) work this way.</span>

<span class="sd">        In real CCDs, the photons travel some distance into the silicon before converting to</span>
<span class="sd">        electrons.  Then the electrons diffuse laterally some amount as they are pulled by the</span>
<span class="sd">        electric field toward the substrate.  Finally, previous electrons that have already been</span>
<span class="sd">        deposited will repel subsequent electrons, both slowing down their descent, leading to</span>
<span class="sd">        more diffusion, and pushing them laterally toward neighboring pixels, which is called</span>
<span class="sd">        the brighter-fatter effect.</span>

<span class="sd">        Users interested in modeling this kind of effect can supply a ``sensor`` object to use</span>
<span class="sd">        for the accumulation step.  See `SiliconSensor` for a class that models silicon-based CCD</span>
<span class="sd">        sensors.</span>

<span class="sd">        Some related effects may need to be done to the photons at the surface layer before being</span>
<span class="sd">        passed into the sensor object.  For instance, the photons may need to be given appropriate</span>
<span class="sd">        incidence angles according to the optics of the telescope (since this matters for where the</span>
<span class="sd">        photons are converted to electrons).  You may also need to give the photons wavelengths</span>
<span class="sd">        according to the `SED` of the object.  Such steps are specified in a ``photon_ops``</span>
<span class="sd">        parameter, which should be a list of any such operations you wish to perform on the photon</span>
<span class="sd">        array before passing them to the sensor.  See `FRatioAngles` and `WavelengthSampler` for</span>
<span class="sd">        two examples of such photon operators.</span>

<span class="sd">        Since the sensor deals with photons, it is most natural to use this feature in conjunction</span>
<span class="sd">        with photon shooting (``method=&#39;phot&#39;``).  However, it is allowed with FFT methods too.</span>
<span class="sd">        But there is a caveat one should be aware of in this case.  The FFT drawing is used to</span>
<span class="sd">        produce an intermediate image, which is then converted to a `PhotonArray` using the</span>
<span class="sd">        factory function `PhotonArray.makeFromImage`.  This assigns photon positions randomly</span>
<span class="sd">        within each pixel where they were drawn, which isn&#39;t always a particularly good</span>
<span class="sd">        approximation.</span>

<span class="sd">        To improve this behavior, the intermediate image is drawn with smaller pixels than the</span>
<span class="sd">        target image, so the photons are given positions closer to their true locations.  The</span>
<span class="sd">        amount of subsampling is controlled by the ``n_subsample`` parameter, which defaults to 3.</span>
<span class="sd">        Larger values will be more accurate at the expense of larger FFTs (i.e. slower and using</span>
<span class="sd">        more memory).</span>

<span class="sd">        Parameters:</span>
<span class="sd">            image:          If provided, this will be the image on which to draw the profile.</span>
<span class="sd">                            If ``image`` is None, then an automatically-sized `Image` will be</span>
<span class="sd">                            created.  If ``image`` is given, but its bounds are undefined (e.g. if</span>
<span class="sd">                            it was constructed with ``image = galsim.Image()``), then it will be</span>
<span class="sd">                            resized appropriately based on the profile&#39;s size [default: None].</span>
<span class="sd">            nx:             If provided and ``image`` is None, use to set the x-direction size of</span>
<span class="sd">                            the image.  Must be accompanied by ``ny``.</span>
<span class="sd">            ny:             If provided and ``image`` is None, use to set the y-direction size of</span>
<span class="sd">                            the image.  Must be accompanied by ``nx``.</span>
<span class="sd">            bounds:         If provided and ``image`` is None, use to set the bounds of the image.</span>
<span class="sd">            scale:          If provided, use this as the pixel scale for the image.</span>
<span class="sd">                            If ``scale`` is None and ``image`` is given, then take the provided</span>
<span class="sd">                            image&#39;s pixel scale.</span>
<span class="sd">                            If ``scale`` is None and ``image`` is None, then use the Nyquist scale.</span>
<span class="sd">                            If ``scale &lt;= 0`` (regardless of ``image``), then use the Nyquist scale.</span>
<span class="sd">                            If ``scale &gt; 0`` and ``image`` is given, then override ``image.scale``</span>
<span class="sd">                            with the value given as a keyword.  [default: None]</span>
<span class="sd">            wcs:            If provided, use this as the wcs for the image (possibly overriding any</span>
<span class="sd">                            existing ``image.wcs``).  At most one of ``scale`` or ``wcs`` may be</span>
<span class="sd">                            provided.  [default: None]</span>
<span class="sd">            dtype:          The data type to use for an automatically constructed image.  Only</span>
<span class="sd">                            valid if ``image`` is None. [default: None, which means to use</span>
<span class="sd">                            numpy.float32]</span>
<span class="sd">            method:         Which method to use for rendering the image.  See discussion above</span>
<span class="sd">                            for the various options and what they do. [default: &#39;auto&#39;]</span>
<span class="sd">            area:           Collecting area of telescope in cm^2.  [default: 1.]</span>
<span class="sd">            exptime:        Exposure time in s.  [default: 1.]</span>
<span class="sd">            gain:           The number of photons per ADU (&quot;analog to digital units&quot;, the units of</span>
<span class="sd">                            the numbers output from a CCD).  [default: 1]</span>
<span class="sd">            add_to_image:   Whether to add flux to the existing image rather than clear out</span>
<span class="sd">                            anything in the image before drawing.</span>
<span class="sd">                            Note: This requires that ``image`` be provided and that it have defined</span>
<span class="sd">                            bounds. [default: False]</span>
<span class="sd">            center:         The position on the image at which to place the nominal center of the</span>
<span class="sd">                            object (usually the centroid, but not necessarily).  [default: None]</span>
<span class="sd">            use_true_center: If ``center`` is None, then the object is normally centered at the</span>
<span class="sd">                            true center of the image (using the property image.true_center).</span>
<span class="sd">                            If you would rather use the integer center (given by image.center),</span>
<span class="sd">                            set this to ``False``.  [default: True]</span>
<span class="sd">            offset:         The offset in pixel coordinates at which to center the profile being</span>
<span class="sd">                            drawn relative to either ``center`` (if given) or the center of the</span>
<span class="sd">                            image (either the true center or integer center according to the</span>
<span class="sd">                            ``use_true_center`` parameter). [default: None]</span>
<span class="sd">            n_photons:      If provided, the number of photons to use for photon shooting.</span>
<span class="sd">                            If not provided (i.e. ``n_photons = 0``), use as many photons as</span>
<span class="sd">                            necessary to result in an image with the correct Poisson shot</span>
<span class="sd">                            noise for the object&#39;s flux.  For positive definite profiles, this</span>
<span class="sd">                            is equivalent to ``n_photons = flux``.  However, some profiles need</span>
<span class="sd">                            more than this because some of the shot photons are negative</span>
<span class="sd">                            (usually due to interpolants).</span>
<span class="sd">                            [default: 0]</span>
<span class="sd">            rng:            If provided, a random number generator to use for photon shooting,</span>
<span class="sd">                            which may be any kind of `BaseDeviate` object.  If ``rng`` is None, one</span>
<span class="sd">                            will be automatically created.  [default: None]</span>
<span class="sd">            max_extra_noise: If provided, the allowed extra noise in each pixel when photon</span>
<span class="sd">                            shooting.  This is only relevant if ``n_photons=0``, so the number of</span>
<span class="sd">                            photons is being automatically calculated.  In that case, if the image</span>
<span class="sd">                            noise is dominated by the sky background, then you can get away with</span>
<span class="sd">                            using fewer shot photons than the full ``n_photons = flux``.</span>
<span class="sd">                            Essentially each shot photon can have a ``flux &gt; 1``, which increases</span>
<span class="sd">                            the noise in each pixel.  The ``max_extra_noise`` parameter specifies</span>
<span class="sd">                            how much extra noise per pixel is allowed because of this approximation.</span>
<span class="sd">                            A typical value for this might be ``max_extra_noise = sky_level / 100``</span>
<span class="sd">                            where ``sky_level`` is the flux per pixel due to the sky.  Note that</span>
<span class="sd">                            this uses a &quot;variance&quot; definition of noise, not a &quot;sigma&quot; definition.</span>
<span class="sd">                            [default: 0.]</span>
<span class="sd">            poisson_flux:   Whether to allow total object flux scaling to vary according to</span>
<span class="sd">                            Poisson statistics for ``n_photons`` samples when photon shooting.</span>
<span class="sd">                            [default: True, unless ``n_photons`` is given, in which case the default</span>
<span class="sd">                            is False]</span>
<span class="sd">            sensor:         An optional `Sensor` instance, which will be used to accumulate the</span>
<span class="sd">                            photons onto the image. [default: None]</span>
<span class="sd">            photon_ops:     A list of operators that can modify the photon array that will be</span>
<span class="sd">                            applied in order before accumulating the photons on the sensor.</span>
<span class="sd">                            [default: None]</span>
<span class="sd">            n_subsample:    The number of sub-pixels per final pixel to use for fft drawing when</span>
<span class="sd">                            using a sensor.  The sensor step needs to know the sub-pixel positions</span>
<span class="sd">                            of the photons, which is lost in the fft method.  So using smaller</span>
<span class="sd">                            pixels for the fft step keeps some of that information, making the</span>
<span class="sd">                            assumption of uniform flux per pixel less bad of an approximation.</span>
<span class="sd">                            [default: 3]</span>
<span class="sd">            maxN:           Sets the maximum number of photons that will be added to the image</span>
<span class="sd">                            at a time.  (Memory requirements are proportional to this number.)</span>

<span class="sd">                            .. note::</span>

<span class="sd">                                Using this parameter will not necessarily produce identical</span>
<span class="sd">                                results as when not using it due to potentially different order</span>
<span class="sd">                                of various random number generations in either the photon_ops,</span>
<span class="sd">                                or the sensor, or (for method=&#39;fft&#39;) the conversion of the FFT</span>
<span class="sd">                                image to photons.</span>

<span class="sd">                            [default: None, which means no limit]</span>
<span class="sd">            save_photons:   If True, save the `PhotonArray` as ``image.photons``. Only valid if</span>
<span class="sd">                            method is &#39;phot&#39; or sensor is not None.  [default: False]</span>
<span class="sd">            bandpass:       This parameter is ignored, but is allowed to enable duck typing</span>
<span class="sd">                            eqivalence between this method and the ChromaticObject.drawImage</span>
<span class="sd">                            method. [default: None]</span>
<span class="sd">            setup_only:     Don&#39;t actually draw anything on the image.  Just make sure the image</span>
<span class="sd">                            is set up correctly.  This is used internally by GalSim, but there</span>
<span class="sd">                            may be cases where the user will want the same functionality.</span>
<span class="sd">                            [default: False]</span>

<span class="sd">        Returns:</span>
<span class="sd">            the drawn `Image`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">surface_ops</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">.deprecated</span> <span class="kn">import</span> <span class="n">depr</span>
            <span class="n">depr</span><span class="p">(</span><span class="s1">&#39;surface_ops&#39;</span><span class="p">,</span> <span class="mf">2.3</span><span class="p">,</span> <span class="s1">&#39;photon_ops&#39;</span><span class="p">)</span>
            <span class="n">photon_ops</span> <span class="o">=</span> <span class="n">surface_ops</span>

        <span class="c1"># Check that image is sane</span>
        <span class="k">if</span> <span class="n">image</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">Image</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;image is not an Image instance&quot;</span><span class="p">,</span> <span class="n">image</span><span class="p">)</span>

        <span class="c1"># Make sure (gain, area, exptime) have valid values:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">gain</span> <span class="o">&gt;</span> <span class="mf">0.</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">GalSimRangeError</span><span class="p">(</span><span class="s2">&quot;Invalid gain &lt;= 0.&quot;</span><span class="p">,</span> <span class="n">gain</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">area</span> <span class="o">&gt;</span> <span class="mf">0.</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">GalSimRangeError</span><span class="p">(</span><span class="s2">&quot;Invalid area &lt;= 0.&quot;</span><span class="p">,</span> <span class="n">area</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">exptime</span> <span class="o">&gt;</span> <span class="mf">0.</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">GalSimRangeError</span><span class="p">(</span><span class="s2">&quot;Invalid exptime &lt;= 0.&quot;</span><span class="p">,</span> <span class="n">exptime</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">method</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;auto&#39;</span><span class="p">,</span> <span class="s1">&#39;fft&#39;</span><span class="p">,</span> <span class="s1">&#39;real_space&#39;</span><span class="p">,</span> <span class="s1">&#39;phot&#39;</span><span class="p">,</span> <span class="s1">&#39;no_pixel&#39;</span><span class="p">,</span> <span class="s1">&#39;sb&#39;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">GalSimValueError</span><span class="p">(</span><span class="s2">&quot;Invalid method name&quot;</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span>
                                   <span class="p">(</span><span class="s1">&#39;auto&#39;</span><span class="p">,</span> <span class="s1">&#39;fft&#39;</span><span class="p">,</span> <span class="s1">&#39;real_space&#39;</span><span class="p">,</span> <span class="s1">&#39;phot&#39;</span><span class="p">,</span> <span class="s1">&#39;no_pixel&#39;</span><span class="p">,</span> <span class="s1">&#39;sb&#39;</span><span class="p">))</span>

        <span class="c1"># Check that the user isn&#39;t convolving by a Pixel already.  This is almost always an error.</span>
        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;auto&#39;</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">convolve</span><span class="o">.</span><span class="n">Convolution</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">([</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">box</span><span class="o">.</span><span class="n">Pixel</span><span class="p">)</span> <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">obj_list</span> <span class="p">]):</span>
                <span class="n">galsim_warn</span><span class="p">(</span>
                    <span class="s2">&quot;You called drawImage with ``method=&#39;auto&#39;`` &quot;</span>
                    <span class="s2">&quot;for an object that includes convolution by a Pixel.  &quot;</span>
                    <span class="s2">&quot;This is probably an error.  Normally, you should let GalSim &quot;</span>
                    <span class="s2">&quot;handle the Pixel convolution for you.  If you want to handle the Pixel &quot;</span>
                    <span class="s2">&quot;convolution yourself, you can use method=no_pixel.  Or if you really meant &quot;</span>
                    <span class="s2">&quot;for your profile to include the Pixel and also have GalSim convolve by &quot;</span>
                    <span class="s2">&quot;an _additional_ Pixel, you can suppress this warning by using method=fft.&quot;</span><span class="p">)</span>

        <span class="c1"># Some parameters are only relevant for method == &#39;phot&#39;</span>
        <span class="k">if</span> <span class="n">method</span> <span class="o">!=</span> <span class="s1">&#39;phot&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">n_photons</span> <span class="o">!=</span> <span class="mf">0.</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">GalSimIncompatibleValuesError</span><span class="p">(</span>
                    <span class="s2">&quot;n_photons is only relevant for method=&#39;phot&#39;&quot;</span><span class="p">,</span>
                    <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">sensor</span><span class="o">=</span><span class="n">sensor</span><span class="p">,</span> <span class="n">n_photons</span><span class="o">=</span><span class="n">n_photons</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">max_extra_noise</span> <span class="o">!=</span> <span class="mf">0.</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">GalSimIncompatibleValuesError</span><span class="p">(</span>
                    <span class="s2">&quot;max_extra_noise is only relevant for method=&#39;phot&#39;&quot;</span><span class="p">,</span>
                    <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">sensor</span><span class="o">=</span><span class="n">sensor</span><span class="p">,</span> <span class="n">max_extra_noise</span><span class="o">=</span><span class="n">max_extra_noise</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">poisson_flux</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">GalSimIncompatibleValuesError</span><span class="p">(</span>
                    <span class="s2">&quot;poisson_flux is only relevant for method=&#39;phot&#39;&quot;</span><span class="p">,</span>
                    <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">sensor</span><span class="o">=</span><span class="n">sensor</span><span class="p">,</span> <span class="n">poisson_flux</span><span class="o">=</span><span class="n">poisson_flux</span><span class="p">)</span>

        <span class="c1"># If using photon ops with fft, then need a sensor.</span>
        <span class="c1"># Note: &quot;if photon_ops&quot; so photon_ops being [] or () is the same as None.</span>
        <span class="k">if</span> <span class="n">photon_ops</span> <span class="ow">and</span> <span class="n">method</span> <span class="o">!=</span> <span class="s1">&#39;phot&#39;</span> <span class="ow">and</span> <span class="n">sensor</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">sensor</span> <span class="o">=</span> <span class="n">Sensor</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">photon_ops</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Easier to just make it an empty tuple, rather than deal with None below.</span>
            <span class="n">photon_ops</span> <span class="o">=</span> <span class="p">()</span>

        <span class="c1"># Some parameters are only relevant for either phot or when using a sensor.</span>
        <span class="k">if</span> <span class="n">method</span> <span class="o">!=</span> <span class="s1">&#39;phot&#39;</span> <span class="ow">and</span> <span class="n">sensor</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">rng</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">GalSimIncompatibleValuesError</span><span class="p">(</span>
                    <span class="s2">&quot;rng is only relevant for method=&#39;phot&#39; or when using a sensor&quot;</span><span class="p">,</span>
                    <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">sensor</span><span class="o">=</span><span class="n">sensor</span><span class="p">,</span> <span class="n">rng</span><span class="o">=</span><span class="n">rng</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">maxN</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">GalSimIncompatibleValuesError</span><span class="p">(</span>
                    <span class="s2">&quot;maxN is only relevant for method=&#39;phot&#39; or when using a sensor&quot;</span><span class="p">,</span>
                    <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">sensor</span><span class="o">=</span><span class="n">sensor</span><span class="p">,</span> <span class="n">maxN</span><span class="o">=</span><span class="n">maxN</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">save_photons</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">GalSimIncompatibleValuesError</span><span class="p">(</span>
                    <span class="s2">&quot;save_photons is only valid for method=&#39;phot&#39; or when using a sensor&quot;</span><span class="p">,</span>
                    <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">sensor</span><span class="o">=</span><span class="n">sensor</span><span class="p">,</span> <span class="n">save_photons</span><span class="o">=</span><span class="n">save_photons</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># If we want to save photons, it doesn&#39;t make sense to limit the number per shoot call.</span>
            <span class="k">if</span> <span class="n">save_photons</span> <span class="ow">and</span> <span class="n">maxN</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">GalSimIncompatibleValuesError</span><span class="p">(</span>
                    <span class="s2">&quot;Setting maxN is incompatible with save_photons=True&quot;</span><span class="p">)</span>

        <span class="c1"># Do any delayed computation needed by fft or real_space drawing.</span>
        <span class="k">if</span> <span class="n">method</span> <span class="o">!=</span> <span class="s1">&#39;phot&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_prepareDraw</span><span class="p">()</span>

        <span class="c1"># Figure out what wcs we are going to use.</span>
        <span class="n">wcs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_determine_wcs</span><span class="p">(</span><span class="n">scale</span><span class="p">,</span> <span class="n">wcs</span><span class="p">,</span> <span class="n">image</span><span class="p">)</span>

        <span class="c1"># Make sure offset and center are PositionD, converting from other formats (tuple, array,..)</span>
        <span class="c1"># Note: If None, offset is converted to PositionD(0,0), but center will remain None.</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_offset</span><span class="p">(</span><span class="n">offset</span><span class="p">)</span>
        <span class="n">center</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_center</span><span class="p">(</span><span class="n">center</span><span class="p">)</span>

        <span class="c1"># Determine the bounds of the new image for use below (if it can be known yet)</span>
        <span class="n">new_bounds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_new_bounds</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">bounds</span><span class="p">,</span> <span class="n">center</span><span class="p">)</span>

        <span class="c1"># Get the local WCS, accounting for the offset correctly.</span>
        <span class="n">local_wcs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_local_wcs</span><span class="p">(</span><span class="n">wcs</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">center</span><span class="p">,</span> <span class="n">use_true_center</span><span class="p">,</span> <span class="n">new_bounds</span><span class="p">)</span>

        <span class="c1"># Account for area and exptime.</span>
        <span class="n">flux_scale</span> <span class="o">=</span> <span class="n">area</span> <span class="o">*</span> <span class="n">exptime</span>
        <span class="c1"># For surface brightness normalization, also scale by the pixel area.</span>
        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;sb&#39;</span><span class="p">:</span>
            <span class="n">flux_scale</span> <span class="o">/=</span> <span class="n">local_wcs</span><span class="o">.</span><span class="n">pixelArea</span><span class="p">()</span>
        <span class="c1"># Only do the gain here if not photon shooting, since need the number of photons to</span>
        <span class="c1"># reflect that actual photons, not ADU.</span>
        <span class="k">if</span> <span class="n">gain</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">method</span> <span class="o">!=</span> <span class="s1">&#39;phot&#39;</span> <span class="ow">and</span> <span class="n">sensor</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">flux_scale</span> <span class="o">/=</span> <span class="n">gain</span>

        <span class="c1"># Determine the offset, and possibly fix the centering for even-sized images</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_adjust_offset</span><span class="p">(</span><span class="n">new_bounds</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">center</span><span class="p">,</span> <span class="n">use_true_center</span><span class="p">)</span>

        <span class="c1"># Convert the profile in world coordinates to the profile in image coordinates:</span>
        <span class="n">prof</span> <span class="o">=</span> <span class="n">local_wcs</span><span class="o">.</span><span class="n">profileToImage</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">flux_ratio</span><span class="o">=</span><span class="n">flux_scale</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="n">offset</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">offset</span> <span class="o">!=</span> <span class="n">_PositionD</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">):</span>
            <span class="n">local_wcs</span> <span class="o">=</span> <span class="n">local_wcs</span><span class="o">.</span><span class="n">shiftOrigin</span><span class="p">(</span><span class="n">offset</span><span class="p">)</span>

        <span class="c1"># If necessary, convolve by the pixel</span>
        <span class="k">if</span> <span class="n">method</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;auto&#39;</span><span class="p">,</span> <span class="s1">&#39;fft&#39;</span><span class="p">,</span> <span class="s1">&#39;real_space&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;auto&#39;</span><span class="p">:</span>
                <span class="n">real_space</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;fft&#39;</span><span class="p">:</span>
                <span class="n">real_space</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">real_space</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">prof_no_pixel</span> <span class="o">=</span> <span class="n">prof</span>
            <span class="n">prof</span> <span class="o">=</span> <span class="n">convolve</span><span class="o">.</span><span class="n">Convolve</span><span class="p">(</span><span class="n">prof</span><span class="p">,</span> <span class="n">box</span><span class="o">.</span><span class="n">Pixel</span><span class="p">(</span><span class="n">scale</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">gsparams</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">gsparams</span><span class="p">),</span>
                                     <span class="n">real_space</span><span class="o">=</span><span class="n">real_space</span><span class="p">,</span> <span class="n">gsparams</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">gsparams</span><span class="p">)</span>

        <span class="c1"># Make sure image is setup correctly</span>
        <span class="n">image</span> <span class="o">=</span> <span class="n">prof</span><span class="o">.</span><span class="n">_setup_image</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">bounds</span><span class="p">,</span> <span class="n">add_to_image</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">center</span><span class="p">)</span>
        <span class="n">image</span><span class="o">.</span><span class="n">wcs</span> <span class="o">=</span> <span class="n">wcs</span>

        <span class="k">if</span> <span class="n">setup_only</span><span class="p">:</span>
            <span class="n">image</span><span class="o">.</span><span class="n">added_flux</span> <span class="o">=</span> <span class="mf">0.</span>
            <span class="k">return</span> <span class="n">image</span>

        <span class="c1"># Making a view of the image lets us change the center without messing up the original.</span>
        <span class="n">imview</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">_view</span><span class="p">()</span>
        <span class="n">imview</span><span class="o">.</span><span class="n">_shift</span><span class="p">(</span><span class="o">-</span><span class="n">image</span><span class="o">.</span><span class="n">center</span><span class="p">)</span>  <span class="c1"># equiv. to setCenter(0,0), but faster</span>
        <span class="n">imview</span><span class="o">.</span><span class="n">wcs</span> <span class="o">=</span> <span class="n">PixelScale</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span>
        <span class="n">orig_center</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">center</span>  <span class="c1"># Save the original center to pass to sensor.accumulate</span>
        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;phot&#39;</span><span class="p">:</span>
            <span class="n">added_photons</span><span class="p">,</span> <span class="n">photons</span> <span class="o">=</span> <span class="n">prof</span><span class="o">.</span><span class="n">drawPhot</span><span class="p">(</span><span class="n">imview</span><span class="p">,</span> <span class="n">gain</span><span class="p">,</span> <span class="n">add_to_image</span><span class="p">,</span>
                                                   <span class="n">n_photons</span><span class="p">,</span> <span class="n">rng</span><span class="p">,</span> <span class="n">max_extra_noise</span><span class="p">,</span> <span class="n">poisson_flux</span><span class="p">,</span>
                                                   <span class="n">sensor</span><span class="p">,</span> <span class="n">photon_ops</span><span class="p">,</span> <span class="n">maxN</span><span class="p">,</span>
                                                   <span class="n">orig_center</span><span class="p">,</span> <span class="n">local_wcs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># If not using phot, but doing sensor, then make a copy.</span>
            <span class="k">if</span> <span class="n">sensor</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">imview</span><span class="o">.</span><span class="n">dtype</span> <span class="ow">in</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">):</span>
                    <span class="n">dtype</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span>
                <span class="n">draw_image</span> <span class="o">=</span> <span class="n">imview</span><span class="o">.</span><span class="n">real</span><span class="o">.</span><span class="n">subsample</span><span class="p">(</span><span class="n">n_subsample</span><span class="p">,</span> <span class="n">n_subsample</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
                <span class="n">draw_image</span><span class="o">.</span><span class="n">_shift</span><span class="p">(</span><span class="o">-</span><span class="n">draw_image</span><span class="o">.</span><span class="n">center</span><span class="p">)</span>  <span class="c1"># eqiv. to setCenter(0,0)</span>
                <span class="k">if</span> <span class="n">method</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;auto&#39;</span><span class="p">,</span> <span class="s1">&#39;fft&#39;</span><span class="p">,</span> <span class="s1">&#39;real_space&#39;</span><span class="p">):</span>
                    <span class="c1"># Need to reconvolve by the new smaller pixel instead</span>
                    <span class="n">pix</span> <span class="o">=</span> <span class="n">box</span><span class="o">.</span><span class="n">Pixel</span><span class="p">(</span><span class="n">scale</span><span class="o">=</span><span class="mf">1.0</span><span class="o">/</span><span class="n">n_subsample</span><span class="p">,</span> <span class="n">gsparams</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">gsparams</span><span class="p">)</span>
                    <span class="n">prof</span> <span class="o">=</span> <span class="n">convolve</span><span class="o">.</span><span class="n">Convolve</span><span class="p">(</span><span class="n">prof_no_pixel</span><span class="p">,</span> <span class="n">pix</span><span class="p">,</span> <span class="n">real_space</span><span class="o">=</span><span class="n">real_space</span><span class="p">,</span>
                                             <span class="n">gsparams</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">gsparams</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">n_subsample</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="c1"># We can&#39;t just pull off the pixel-free version, so we need to deconvolve</span>
                    <span class="c1"># by the original pixel and reconvolve by the smaller one.</span>
                    <span class="n">dec</span> <span class="o">=</span> <span class="n">convolve</span><span class="o">.</span><span class="n">Deconvolve</span><span class="p">(</span><span class="n">box</span><span class="o">.</span><span class="n">Pixel</span><span class="p">(</span><span class="n">scale</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">gsparams</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">gsparams</span><span class="p">))</span>
                    <span class="n">pix</span> <span class="o">=</span> <span class="n">box</span><span class="o">.</span><span class="n">Pixel</span><span class="p">(</span><span class="n">scale</span><span class="o">=</span><span class="mf">1.0</span><span class="o">/</span><span class="n">n_subsample</span><span class="p">,</span> <span class="n">gsparams</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">gsparams</span><span class="p">)</span>
                    <span class="n">prof</span> <span class="o">=</span> <span class="n">convolve</span><span class="o">.</span><span class="n">Convolve</span><span class="p">(</span><span class="n">prof</span><span class="p">,</span> <span class="n">dec</span><span class="p">,</span> <span class="n">pix</span><span class="p">,</span> <span class="n">gsparams</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">gsparams</span><span class="p">)</span>
                <span class="n">add</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">add_to_image</span><span class="p">:</span> <span class="n">imview</span><span class="o">.</span><span class="n">setZero</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">draw_image</span> <span class="o">=</span> <span class="n">imview</span>
                <span class="n">add</span> <span class="o">=</span> <span class="n">add_to_image</span>

            <span class="k">if</span> <span class="n">prof</span><span class="o">.</span><span class="n">is_analytic_x</span><span class="p">:</span>
                <span class="n">added_photons</span> <span class="o">=</span> <span class="n">prof</span><span class="o">.</span><span class="n">drawReal</span><span class="p">(</span><span class="n">draw_image</span><span class="p">,</span> <span class="n">add</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">added_photons</span> <span class="o">=</span> <span class="n">prof</span><span class="o">.</span><span class="n">drawFFT</span><span class="p">(</span><span class="n">draw_image</span><span class="p">,</span> <span class="n">add</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">sensor</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">maxN</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">maxN</span> <span class="o">&lt;</span> <span class="n">added_photons</span><span class="p">:</span>
                    <span class="n">niter</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">added_photons</span> <span class="o">/</span> <span class="n">maxN</span><span class="p">))</span>
                    <span class="n">draw_image</span> <span class="o">/=</span> <span class="n">niter</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">niter</span> <span class="o">=</span> <span class="mi">1</span>

                <span class="n">added_photons</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">resume</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">for</span> <span class="n">it</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">niter</span><span class="p">):</span>
                    <span class="n">photons</span> <span class="o">=</span> <span class="n">pa</span><span class="o">.</span><span class="n">PhotonArray</span><span class="o">.</span><span class="n">makeFromImage</span><span class="p">(</span><span class="n">draw_image</span><span class="p">,</span> <span class="n">rng</span><span class="o">=</span><span class="n">rng</span><span class="p">)</span>

                    <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">photon_ops</span><span class="p">:</span>
                        <span class="n">op</span><span class="o">.</span><span class="n">applyTo</span><span class="p">(</span><span class="n">photons</span><span class="p">,</span> <span class="n">local_wcs</span><span class="p">,</span> <span class="n">rng</span><span class="p">)</span>

                    <span class="k">if</span> <span class="n">imview</span><span class="o">.</span><span class="n">dtype</span> <span class="ow">in</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">):</span>
                        <span class="n">added_photons</span> <span class="o">+=</span> <span class="n">sensor</span><span class="o">.</span><span class="n">accumulate</span><span class="p">(</span><span class="n">photons</span><span class="p">,</span> <span class="n">imview</span><span class="p">,</span> <span class="n">orig_center</span><span class="p">,</span>
                                                           <span class="n">resume</span><span class="o">=</span><span class="n">resume</span><span class="p">)</span>
                        <span class="n">resume</span> <span class="o">=</span> <span class="kc">True</span>  <span class="c1"># Resume from this point if there are any further iterations.</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># Need a temporary</span>
                        <span class="n">im1</span> <span class="o">=</span> <span class="n">ImageD</span><span class="p">(</span><span class="n">bounds</span><span class="o">=</span><span class="n">imview</span><span class="o">.</span><span class="n">bounds</span><span class="p">)</span>
                        <span class="n">added_photons</span> <span class="o">+=</span> <span class="n">sensor</span><span class="o">.</span><span class="n">accumulate</span><span class="p">(</span><span class="n">photons</span><span class="p">,</span> <span class="n">im1</span><span class="p">,</span> <span class="n">orig_center</span><span class="p">)</span>
                        <span class="n">imview</span> <span class="o">+=</span> <span class="n">im1</span>

        <span class="n">image</span><span class="o">.</span><span class="n">added_flux</span> <span class="o">=</span> <span class="n">added_photons</span> <span class="o">/</span> <span class="n">flux_scale</span>
        <span class="k">if</span> <span class="n">save_photons</span><span class="p">:</span>
            <span class="n">image</span><span class="o">.</span><span class="n">photons</span> <span class="o">=</span> <span class="n">photons</span>

        <span class="k">return</span> <span class="n">image</span></div>

<div class="viewcode-block" id="GSObject.drawReal"><a class="viewcode-back" href="../../gsobject.html#galsim.GSObject.drawReal">[docs]</a>    <span class="k">def</span> <span class="nf">drawReal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span> <span class="n">add_to_image</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Draw this profile into an `Image` by direct evaluation at the location of each pixel.</span>

<span class="sd">        This is usually called from the `drawImage` function, rather than called directly by the</span>
<span class="sd">        user.  In particular, the input image must be already set up with defined bounds.  The</span>
<span class="sd">        profile will be drawn centered on whatever pixel corresponds to (0,0) with the given</span>
<span class="sd">        bounds, not the image center (unlike `drawImage`).  The image also must have a `PixelScale`</span>
<span class="sd">        wcs.  The profile being drawn should have already been converted to image coordinates via::</span>

<span class="sd">            &gt;&gt;&gt; image_profile = original_wcs.toImage(original_profile)</span>

<span class="sd">        Note that the image produced by ``drawReal`` represents the profile sampled at the center</span>
<span class="sd">        of each pixel and then multiplied by the pixel area.  That is, the profile is NOT</span>
<span class="sd">        integrated over the area of the pixel.  This is equivalent to method=&#39;no_pixel&#39; in</span>
<span class="sd">        `drawImage`.  If you want to render a profile integrated over the pixel, you can convolve</span>
<span class="sd">        with a `Pixel` first and draw that.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            image:          The `Image` onto which to place the flux. [required]</span>
<span class="sd">            add_to_image:   Whether to add flux to the existing image rather than clear out</span>
<span class="sd">                            anything in the image before drawing. [default: False]</span>

<span class="sd">        Returns:</span>
<span class="sd">            The total flux drawn inside the image bounds.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">image</span><span class="o">.</span><span class="n">wcs</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">image</span><span class="o">.</span><span class="n">wcs</span><span class="o">.</span><span class="n">_isPixelScale</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">GalSimValueError</span><span class="p">(</span><span class="s2">&quot;drawReal requires an image with a PixelScale wcs&quot;</span><span class="p">,</span> <span class="n">image</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">image</span><span class="o">.</span><span class="n">dtype</span> <span class="ow">in</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">add_to_image</span> <span class="ow">and</span> <span class="n">image</span><span class="o">.</span><span class="n">iscontiguous</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_drawReal</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">image</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Need a temporary</span>
            <span class="k">if</span> <span class="n">image</span><span class="o">.</span><span class="n">dtype</span> <span class="ow">in</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">uint32</span><span class="p">):</span>
                <span class="n">im1</span> <span class="o">=</span> <span class="n">ImageD</span><span class="p">(</span><span class="n">bounds</span><span class="o">=</span><span class="n">image</span><span class="o">.</span><span class="n">bounds</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">image</span><span class="o">.</span><span class="n">scale</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">im1</span> <span class="o">=</span> <span class="n">ImageF</span><span class="p">(</span><span class="n">bounds</span><span class="o">=</span><span class="n">image</span><span class="o">.</span><span class="n">bounds</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">image</span><span class="o">.</span><span class="n">scale</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_drawReal</span><span class="p">(</span><span class="n">im1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">add_to_image</span><span class="p">:</span>
                <span class="n">image</span> <span class="o">+=</span> <span class="n">im1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">image</span><span class="o">.</span><span class="n">_copyFrom</span><span class="p">(</span><span class="n">im1</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">im1</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span></div>

<div class="viewcode-block" id="GSObject._drawReal"><a class="viewcode-back" href="../../gsobject.html#galsim.GSObject._drawReal">[docs]</a>    <span class="k">def</span> <span class="nf">_drawReal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span> <span class="n">jac</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="p">(</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">),</span> <span class="n">flux_scaling</span><span class="o">=</span><span class="mf">1.</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;A version of `drawReal` without the sanity checks or some options.</span>

<span class="sd">        This is nearly equivalent to the regular ``drawReal(image, add_to_image=False)``, but</span>
<span class="sd">        the image&#39;s dtype must be either float32 or float64, and it must have a c_contiguous array</span>
<span class="sd">        (``image.iscontiguous`` must be True).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> does not implement drawReal&quot;</span><span class="o">%</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span></div>

<div class="viewcode-block" id="GSObject.getGoodImageSize"><a class="viewcode-back" href="../../gsobject.html#galsim.GSObject.getGoodImageSize">[docs]</a>    <span class="k">def</span> <span class="nf">getGoodImageSize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pixel_scale</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a good size to use for drawing this profile.</span>

<span class="sd">        The size will be large enough to cover most of the flux of the object.  Specifically,</span>
<span class="sd">        at least (1-gsparams.folding_threshold) (i.e. 99.5% by default) of the flux should fall</span>
<span class="sd">        in the image.</span>

<span class="sd">        Also, the returned size is always an even number, which is usually desired in practice.</span>
<span class="sd">        Of course, if you prefer an odd-sized image, you can add 1 to the result.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            pixel_scale:    The desired pixel scale of the image to be built.</span>

<span class="sd">        Returns:</span>
<span class="sd">            N, a good (linear) size of an image on which to draw this object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Start with a good size from stepk and the pixel scale</span>
        <span class="n">Nd</span> <span class="o">=</span> <span class="mf">2.</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="p">(</span><span class="n">pixel_scale</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">stepk</span><span class="p">)</span>

        <span class="c1"># Make it an integer</span>
        <span class="c1"># (Some slop to keep from getting extra pixels due to roundoff errors in calculations.)</span>
        <span class="n">N</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">Nd</span><span class="o">*</span><span class="p">(</span><span class="mf">1.</span><span class="o">-</span><span class="mf">1.e-12</span><span class="p">)))</span>

        <span class="c1"># Round up to an even value</span>
        <span class="n">N</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">((</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">N</span></div>

<div class="viewcode-block" id="GSObject.drawFFT_makeKImage"><a class="viewcode-back" href="../../gsobject.html#galsim.GSObject.drawFFT_makeKImage">[docs]</a>    <span class="k">def</span> <span class="nf">drawFFT_makeKImage</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">image</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This is a helper routine for drawFFT that just makes the (blank) k-space image</span>
<span class="sd">        onto which the profile will be drawn.  This can be useful if you want to break</span>
<span class="sd">        up the calculation into parts for extra efficiency.  E.g. save the k-space image of</span>
<span class="sd">        the PSF so drawing many models of the galaxy with the given PSF profile can avoid</span>
<span class="sd">        drawing the PSF each time.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            image:      The `Image` onto which to place the flux.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (kimage, wrap_size), where wrap_size is either the size of kimage or smaller if</span>
<span class="sd">            the result should be wrapped before doing the inverse fft.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Start with what this profile thinks a good size would be given the image&#39;s pixel scale.</span>
        <span class="n">N</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getGoodImageSize</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">scale</span><span class="p">)</span>

        <span class="c1"># We must make something big enough to cover the target image size:</span>
        <span class="n">image_N</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">((</span><span class="n">image</span><span class="o">.</span><span class="n">bounds</span><span class="o">.</span><span class="n">_getinitargs</span><span class="p">())))</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span>
                      <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">bounds</span><span class="o">.</span><span class="n">numpyShape</span><span class="p">()))</span>
        <span class="n">N</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">image_N</span><span class="p">)</span>

        <span class="c1"># Round up to a good size for making FFTs:</span>
        <span class="n">N</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">good_fft_size</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>

        <span class="c1"># Make sure we hit the minimum size specified in the gsparams.</span>
        <span class="n">N</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gsparams</span><span class="o">.</span><span class="n">minimum_fft_size</span><span class="p">)</span>

        <span class="n">dk</span> <span class="o">=</span> <span class="mf">2.</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="p">(</span><span class="n">N</span> <span class="o">*</span> <span class="n">image</span><span class="o">.</span><span class="n">scale</span><span class="p">)</span>

        <span class="n">maxk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxk</span>
        <span class="k">if</span> <span class="n">N</span><span class="o">*</span><span class="n">dk</span><span class="o">/</span><span class="mi">2</span> <span class="o">&gt;</span> <span class="n">maxk</span><span class="p">:</span>
            <span class="n">Nk</span> <span class="o">=</span> <span class="n">N</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># There will be aliasing.  Make a larger image and then wrap it.</span>
            <span class="n">Nk</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">maxk</span><span class="o">/</span><span class="n">dk</span><span class="p">))</span> <span class="o">*</span> <span class="mi">2</span>

        <span class="k">if</span> <span class="n">Nk</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">gsparams</span><span class="o">.</span><span class="n">maximum_fft_size</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">GalSimFFTSizeError</span><span class="p">(</span><span class="s2">&quot;drawFFT requires an FFT that is too large.&quot;</span><span class="p">,</span> <span class="n">Nk</span><span class="p">)</span>

        <span class="n">bounds</span> <span class="o">=</span> <span class="n">_BoundsI</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">Nk</span><span class="o">//</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="n">Nk</span><span class="o">//</span><span class="mi">2</span><span class="p">,</span><span class="n">Nk</span><span class="o">//</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">image</span><span class="o">.</span><span class="n">dtype</span> <span class="ow">in</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">uint32</span><span class="p">):</span>
            <span class="n">kimage</span> <span class="o">=</span> <span class="n">ImageCD</span><span class="p">(</span><span class="n">bounds</span><span class="o">=</span><span class="n">bounds</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">dk</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">kimage</span> <span class="o">=</span> <span class="n">ImageCF</span><span class="p">(</span><span class="n">bounds</span><span class="o">=</span><span class="n">bounds</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">dk</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">kimage</span><span class="p">,</span> <span class="n">N</span></div>

<div class="viewcode-block" id="GSObject.drawFFT_finish"><a class="viewcode-back" href="../../gsobject.html#galsim.GSObject.drawFFT_finish">[docs]</a>    <span class="k">def</span> <span class="nf">drawFFT_finish</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span> <span class="n">kimage</span><span class="p">,</span> <span class="n">wrap_size</span><span class="p">,</span> <span class="n">add_to_image</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This is a helper routine for drawFFT that finishes the calculation, based on the</span>
<span class="sd">        drawn k-space image.</span>

<span class="sd">        It applies the Fourier transform to ``kimage`` and adds the result to ``image``.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            image:          The `Image` onto which to place the flux.</span>
<span class="sd">            kimage:         The k-space `Image` where the object was drawn.</span>
<span class="sd">            wrap_size:      The size of the region to wrap kimage, which must be either the same</span>
<span class="sd">                            size as kimage or smaller.</span>
<span class="sd">            add_to_image:   Whether to add flux to the existing image rather than clear out</span>
<span class="sd">                            anything in the image before drawing.</span>

<span class="sd">        Returns:</span>
<span class="sd">            The total flux drawn inside the image bounds.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Wrap the full image to the size we want for the FT.</span>
        <span class="c1"># Even if N == Nk, this is useful to make this portion properly Hermitian in the</span>
        <span class="c1"># N/2 column and N/2 row.</span>
        <span class="n">bwrap</span> <span class="o">=</span> <span class="n">_BoundsI</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">wrap_size</span><span class="o">//</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="n">wrap_size</span><span class="o">//</span><span class="mi">2</span><span class="p">,</span> <span class="n">wrap_size</span><span class="o">//</span><span class="mi">2</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">kimage_wrap</span> <span class="o">=</span> <span class="n">kimage</span><span class="o">.</span><span class="n">_wrap</span><span class="p">(</span><span class="n">bwrap</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

        <span class="c1"># Perform the fourier transform.</span>
        <span class="n">breal</span> <span class="o">=</span> <span class="n">_BoundsI</span><span class="p">(</span><span class="o">-</span><span class="n">wrap_size</span><span class="o">//</span><span class="mi">2</span><span class="p">,</span> <span class="n">wrap_size</span><span class="o">//</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="n">wrap_size</span><span class="o">//</span><span class="mi">2</span><span class="p">,</span> <span class="n">wrap_size</span><span class="o">//</span><span class="mi">2</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">real_image</span> <span class="o">=</span> <span class="n">Image</span><span class="p">(</span><span class="n">breal</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">with</span> <span class="n">convert_cpp_errors</span><span class="p">():</span>
            <span class="n">_galsim</span><span class="o">.</span><span class="n">irfft</span><span class="p">(</span><span class="n">kimage_wrap</span><span class="o">.</span><span class="n">_image</span><span class="p">,</span> <span class="n">real_image</span><span class="o">.</span><span class="n">_image</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Add (a portion of) this to the original image.</span>
        <span class="n">temp</span> <span class="o">=</span> <span class="n">real_image</span><span class="o">.</span><span class="n">subImage</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">bounds</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">add_to_image</span><span class="p">:</span>
            <span class="n">image</span> <span class="o">+=</span> <span class="n">temp</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">image</span><span class="o">.</span><span class="n">_copyFrom</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span>
        <span class="n">added_photons</span> <span class="o">=</span> <span class="n">temp</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">added_photons</span></div>

<div class="viewcode-block" id="GSObject.drawFFT"><a class="viewcode-back" href="../../gsobject.html#galsim.GSObject.drawFFT">[docs]</a>    <span class="k">def</span> <span class="nf">drawFFT</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span> <span class="n">add_to_image</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Draw this profile into an `Image` by computing the k-space image and performing an FFT.</span>

<span class="sd">        This is usually called from the `drawImage` function, rather than called directly by the</span>
<span class="sd">        user.  In particular, the input image must be already set up with defined bounds.  The</span>
<span class="sd">        profile will be drawn centered on whatever pixel corresponds to (0,0) with the given</span>
<span class="sd">        bounds, not the image center (unlike `drawImage`).  The image also must have a `PixelScale`</span>
<span class="sd">        wcs.  The profile being drawn should have already been converted to image coordinates via::</span>

<span class="sd">            &gt;&gt;&gt; image_profile = original_wcs.toImage(original_profile)</span>

<span class="sd">        Note that the `Image` produced by drawFFT represents the profile sampled at the center</span>
<span class="sd">        of each pixel and then multiplied by the pixel area.  That is, the profile is NOT</span>
<span class="sd">        integrated over the area of the pixel.  This is equivalent to method=&#39;no_pixel&#39; in</span>
<span class="sd">        `drawImage`.  If you want to render a profile integrated over the pixel, you can convolve</span>
<span class="sd">        with a `Pixel` first and draw that.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            image:          The `Image` onto which to place the flux. [required]</span>
<span class="sd">            add_to_image:   Whether to add flux to the existing image rather than clear out</span>
<span class="sd">                            anything in the image before drawing. [default: False]</span>

<span class="sd">        Returns:</span>
<span class="sd">            The total flux drawn inside the image bounds.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">image</span><span class="o">.</span><span class="n">wcs</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">image</span><span class="o">.</span><span class="n">wcs</span><span class="o">.</span><span class="n">_isPixelScale</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">GalSimValueError</span><span class="p">(</span><span class="s2">&quot;drawPhot requires an image with a PixelScale wcs&quot;</span><span class="p">,</span> <span class="n">image</span><span class="p">)</span>

        <span class="n">kimage</span><span class="p">,</span> <span class="n">wrap_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">drawFFT_makeKImage</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_drawKImage</span><span class="p">(</span><span class="n">kimage</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">drawFFT_finish</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">kimage</span><span class="p">,</span> <span class="n">wrap_size</span><span class="p">,</span> <span class="n">add_to_image</span><span class="p">)</span></div>

<div class="viewcode-block" id="GSObject._calculate_nphotons"><a class="viewcode-back" href="../../gsobject.html#galsim.GSObject._calculate_nphotons">[docs]</a>    <span class="k">def</span> <span class="nf">_calculate_nphotons</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_photons</span><span class="p">,</span> <span class="n">poisson_flux</span><span class="p">,</span> <span class="n">max_extra_noise</span><span class="p">,</span> <span class="n">rng</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculate how many photons to shoot and what flux_ratio (called g) each one should</span>
<span class="sd">        have in order to produce an image with the right S/N and total flux.</span>

<span class="sd">        This routine is normally called by `drawPhot`.</span>

<span class="sd">        Returns:</span>
<span class="sd">            n_photons, g</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># For profiles that are positive definite, then N = flux. Easy.</span>
        <span class="c1">#</span>
        <span class="c1"># However, some profiles shoot some of their photons with negative flux. This means that</span>
        <span class="c1"># we need a few more photons to get the right S/N = sqrt(flux). Take eta to be the</span>
        <span class="c1"># fraction of shot photons that have negative flux.</span>
        <span class="c1">#</span>
        <span class="c1"># S^2 = (N+ - N-)^2 = (N+ + N- - 2N-)^2 = (Ntot - 2N-)^2 = Ntot^2(1 - 2 eta)^2</span>
        <span class="c1"># N^2 = Var(S) = (N+ + N-) = Ntot</span>
        <span class="c1">#</span>
        <span class="c1"># So flux = (S/N)^2 = Ntot (1-2eta)^2</span>
        <span class="c1"># Ntot = flux / (1-2eta)^2</span>
        <span class="c1">#</span>
        <span class="c1"># However, if each photon has a flux of 1, then S = (1-2eta) Ntot = flux / (1-2eta).</span>
        <span class="c1"># So in fact, each photon needs to carry a flux of g = 1-2eta to get the right</span>
        <span class="c1"># total flux.</span>
        <span class="c1">#</span>
        <span class="c1"># That&#39;s all the easy case. The trickier case is when we are sky-background dominated.</span>
        <span class="c1"># Then we can usually get away with fewer shot photons than the above.  In particular,</span>
        <span class="c1"># if the noise from the photon shooting is much less than the sky noise, then we can</span>
        <span class="c1"># use fewer shot photons and essentially have each photon have a flux &gt; 1. This is ok</span>
        <span class="c1"># as long as the additional noise due to this approximation is &quot;much less than&quot; the</span>
        <span class="c1"># noise we&#39;ll be adding to the image for the sky noise.</span>
        <span class="c1">#</span>
        <span class="c1"># Let&#39;s still have Ntot photons, but now each with a flux of g. And let&#39;s look at the</span>
        <span class="c1"># noise we get in the brightest pixel that has a nominal total flux of Imax.</span>
        <span class="c1">#</span>
        <span class="c1"># The number of photons hitting this pixel will be Imax/flux * Ntot.</span>
        <span class="c1"># The variance of this number is the same thing (Poisson counting).</span>
        <span class="c1"># So the noise in that pixel is:</span>
        <span class="c1">#</span>
        <span class="c1"># N^2 = Imax/flux * Ntot * g^2</span>
        <span class="c1">#</span>
        <span class="c1"># And the signal in that pixel will be:</span>
        <span class="c1">#</span>
        <span class="c1"># S = Imax/flux * (N+ - N-) * g which has to equal Imax, so</span>
        <span class="c1"># g = flux / Ntot(1-2eta)</span>
        <span class="c1"># N^2 = Imax/Ntot * flux / (1-2eta)^2</span>
        <span class="c1">#</span>
        <span class="c1"># As expected, we see that lowering Ntot will increase the noise in that (and every</span>
        <span class="c1"># other) pixel.</span>
        <span class="c1"># The input max_extra_noise parameter is the maximum value of spurious noise we want</span>
        <span class="c1"># to allow.</span>
        <span class="c1">#</span>
        <span class="c1"># So setting N^2 = Imax + nu, we get</span>
        <span class="c1">#</span>
        <span class="c1"># Ntot = flux / (1-2eta)^2 / (1 + nu/Imax)</span>
        <span class="c1"># g = (1 - 2eta) * (1 + nu/Imax)</span>
        <span class="c1">#</span>
        <span class="c1"># Returns the total flux placed inside the image bounds by photon shooting.</span>
        <span class="c1">#</span>

        <span class="n">flux</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">flux</span>
        <span class="k">if</span> <span class="n">flux</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">1.0</span>

        <span class="c1"># The _flux_per_photon property is (1-2eta)</span>
        <span class="c1"># This factor will already be accounted for by the shoot function, so don&#39;t include</span>
        <span class="c1"># that as part of our scaling here.  There may be other adjustments though, so g=1 here.</span>
        <span class="n">eta_factor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flux_per_photon</span>
        <span class="n">mod_flux</span> <span class="o">=</span> <span class="n">flux</span> <span class="o">/</span> <span class="p">(</span><span class="n">eta_factor</span> <span class="o">*</span> <span class="n">eta_factor</span><span class="p">)</span>
        <span class="n">g</span> <span class="o">=</span> <span class="mf">1.</span>

        <span class="c1"># If requested, let the target flux value vary as a Poisson deviate</span>
        <span class="k">if</span> <span class="n">poisson_flux</span><span class="p">:</span>
            <span class="c1"># If we have both positive and negative photons, then the mix of these</span>
            <span class="c1"># already gives us some variation in the flux value from the variance</span>
            <span class="c1"># of how many are positive and how many are negative.</span>
            <span class="c1"># The number of negative photons varies as a binomial distribution.</span>
            <span class="c1"># &lt;F-&gt; = eta * Ntot * g</span>
            <span class="c1"># &lt;F+&gt; = (1-eta) * Ntot * g</span>
            <span class="c1"># &lt;F+ - F-&gt; = (1-2eta) * Ntot * g = flux</span>
            <span class="c1"># Var(F-) = eta * (1-eta) * Ntot * g^2</span>
            <span class="c1"># F+ = Ntot * g - F- is not an independent variable, so</span>
            <span class="c1"># Var(F+ - F-) = Var(Ntot*g - 2*F-)</span>
            <span class="c1">#              = 4 * Var(F-)</span>
            <span class="c1">#              = 4 * eta * (1-eta) * Ntot * g^2</span>
            <span class="c1">#              = 4 * eta * (1-eta) * flux</span>
            <span class="c1"># We want the variance to be equal to flux, so we need an extra:</span>
            <span class="c1"># delta Var = (1 - 4*eta + 4*eta^2) * flux</span>
            <span class="c1">#           = (1-2eta)^2 * flux</span>
            <span class="n">absflux</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">flux</span><span class="p">)</span>
            <span class="n">mean</span> <span class="o">=</span> <span class="n">eta_factor</span><span class="o">*</span><span class="n">eta_factor</span> <span class="o">*</span> <span class="n">absflux</span>
            <span class="n">pd</span> <span class="o">=</span> <span class="n">PoissonDeviate</span><span class="p">(</span><span class="n">rng</span><span class="p">,</span> <span class="n">mean</span><span class="p">)</span>
            <span class="n">pd_val</span> <span class="o">=</span> <span class="n">pd</span><span class="p">()</span> <span class="o">-</span> <span class="n">mean</span> <span class="o">+</span> <span class="n">absflux</span>
            <span class="n">ratio</span> <span class="o">=</span> <span class="n">pd_val</span> <span class="o">/</span> <span class="n">absflux</span>
            <span class="n">g</span> <span class="o">*=</span> <span class="n">ratio</span>
            <span class="n">mod_flux</span> <span class="o">*=</span> <span class="n">ratio</span>

        <span class="k">if</span> <span class="n">n_photons</span> <span class="o">==</span> <span class="mf">0.</span><span class="p">:</span>
            <span class="n">n_photons</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">mod_flux</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">max_extra_noise</span> <span class="o">&gt;</span> <span class="mf">0.</span><span class="p">:</span>
                <span class="n">gfactor</span> <span class="o">=</span> <span class="mf">1.</span> <span class="o">+</span> <span class="n">max_extra_noise</span> <span class="o">/</span> <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">max_sb</span><span class="p">)</span>
                <span class="n">n_photons</span> <span class="o">/=</span> <span class="n">gfactor</span>
                <span class="n">g</span> <span class="o">*=</span> <span class="n">gfactor</span>

        <span class="c1"># Make n_photons an integer.</span>
        <span class="n">iN</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">n_photons</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">)</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">g</span> <span class="k">if</span> <span class="n">iN</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="mf">1.</span>  <span class="c1"># g=0 can cause trouble in places, so avoid it.</span>

        <span class="k">return</span> <span class="n">iN</span><span class="p">,</span> <span class="n">g</span></div>


<div class="viewcode-block" id="GSObject.makePhot"><a class="viewcode-back" href="../../gsobject.html#galsim.GSObject.makePhot">[docs]</a>    <span class="k">def</span> <span class="nf">makePhot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_photons</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">rng</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">max_extra_noise</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span> <span class="n">poisson_flux</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">photon_ops</span><span class="o">=</span><span class="p">(),</span> <span class="n">local_wcs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">surface_ops</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Make photons for a profile.</span>

<span class="sd">        This is equivalent to drawPhot, except that the photons are not placed onto</span>
<span class="sd">        an image.  Instead, it just returns the PhotonArray.</span>

<span class="sd">        .. note::</span>

<span class="sd">            The (x,y) positions returned are in the same units as the distance units</span>
<span class="sd">            of the GSObject being rendered.  If you want (x,y) in pixel coordinates, you</span>
<span class="sd">            should call this function for the profile in image coordinates::</span>

<span class="sd">                &gt;&gt;&gt; photons = image.wcs.toImage(obj).makePhot()</span>

<span class="sd">            Or if you just want a simple pixel scale conversion from sky coordinates to image</span>
<span class="sd">            coordinates, you can instead do</span>

<span class="sd">                &gt;&gt;&gt; photons = obj.makePhot()</span>
<span class="sd">                &gt;&gt;&gt; photons.scaleXY(1./pixel_scale)</span>

<span class="sd">        Parameters:</span>
<span class="sd">            n_photons:      If provided, the number of photons to use for photon shooting.</span>
<span class="sd">                            If not provided (i.e. ``n_photons = 0``), use as many photons as</span>
<span class="sd">                            necessary to result in an image with the correct Poisson shot</span>
<span class="sd">                            noise for the object&#39;s flux.  For positive definite profiles, this</span>
<span class="sd">                            is equivalent to ``n_photons = flux``.  However, some profiles need</span>
<span class="sd">                            more than this because some of the shot photons are negative</span>
<span class="sd">                            (usually due to interpolants).  [default: 0]</span>
<span class="sd">            rng:            If provided, a random number generator to use for photon shooting,</span>
<span class="sd">                            which may be any kind of `BaseDeviate` object.  If ``rng`` is None, one</span>
<span class="sd">                            will be automatically created, using the time as a seed.</span>
<span class="sd">                            [default: None]</span>
<span class="sd">            max_extra_noise: If provided, the allowed extra noise in each pixel when photon</span>
<span class="sd">                            shooting.  This is only relevant if ``n_photons=0``, so the number of</span>
<span class="sd">                            photons is being automatically calculated.  In that case, if the image</span>
<span class="sd">                            noise is dominated by the sky background, then you can get away with</span>
<span class="sd">                            using fewer shot photons than the full ``n_photons = flux``.</span>
<span class="sd">                            Essentially each shot photon can have a ``flux &gt; 1``, which increases</span>
<span class="sd">                            the noise in each pixel.  The ``max_extra_noise`` parameter specifies</span>
<span class="sd">                            how much extra noise per pixel is allowed because of this approximation.</span>
<span class="sd">                            A typical value for this might be ``max_extra_noise = sky_level / 100``</span>
<span class="sd">                            where ``sky_level`` is the flux per pixel due to the sky.  Note that</span>
<span class="sd">                            this uses a &quot;variance&quot; definition of noise, not a &quot;sigma&quot; definition.</span>
<span class="sd">                            [default: 0.]</span>
<span class="sd">            poisson_flux:   Whether to allow total object flux scaling to vary according to</span>
<span class="sd">                            Poisson statistics for ``n_photons`` samples when photon shooting.</span>
<span class="sd">                            [default: True, unless ``n_photons`` is given, in which case the default</span>
<span class="sd">                            is False]</span>
<span class="sd">            photon_ops:     A list of operators that can modify the photon array that will be</span>
<span class="sd">                            applied in order before accumulating the photons on the sensor.</span>
<span class="sd">                            [default: ()]</span>
<span class="sd">            local_wcs:      The local wcs in the original image. [default: None]</span>

<span class="sd">        Returns:</span>
<span class="sd">            - a `PhotonArray` with the data about the photons.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">surface_ops</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">.deprecated</span> <span class="kn">import</span> <span class="n">depr</span>
            <span class="n">depr</span><span class="p">(</span><span class="s1">&#39;surface_ops&#39;</span><span class="p">,</span> <span class="mf">2.3</span><span class="p">,</span> <span class="s1">&#39;photon_ops&#39;</span><span class="p">)</span>
            <span class="n">photon_ops</span> <span class="o">=</span> <span class="n">surface_ops</span>

        <span class="c1"># Make sure the type of n_photons is correct and has a valid value:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">n_photons</span> <span class="o">&gt;=</span> <span class="mf">0.</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">GalSimRangeError</span><span class="p">(</span><span class="s2">&quot;Invalid n_photons &lt; 0.&quot;</span><span class="p">,</span> <span class="n">n_photons</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">poisson_flux</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># If n_photons is given, poisson_flux = False</span>
            <span class="n">poisson_flux</span> <span class="o">=</span> <span class="p">(</span><span class="n">n_photons</span> <span class="o">==</span> <span class="mf">0.</span><span class="p">)</span>

        <span class="c1"># Check that either n_photons is set to something or flux is set to something</span>
        <span class="k">if</span> <span class="n">n_photons</span> <span class="o">==</span> <span class="mf">0.</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">flux</span> <span class="o">==</span> <span class="mf">1.</span><span class="p">:</span>
            <span class="n">galsim_warn</span><span class="p">(</span>
                    <span class="s2">&quot;Warning: drawImage for object with flux == 1, area == 1, and &quot;</span>
                    <span class="s2">&quot;exptime == 1, but n_photons == 0.  This will only shoot a single photon.&quot;</span><span class="p">)</span>

        <span class="n">Ntot</span><span class="p">,</span> <span class="n">g</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calculate_nphotons</span><span class="p">(</span><span class="n">n_photons</span><span class="p">,</span> <span class="n">poisson_flux</span><span class="p">,</span> <span class="n">max_extra_noise</span><span class="p">,</span> <span class="n">rng</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">photons</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shoot</span><span class="p">(</span><span class="n">Ntot</span><span class="p">,</span> <span class="n">rng</span><span class="p">)</span>
        <span class="k">except</span> <span class="p">(</span><span class="n">GalSimError</span><span class="p">,</span> <span class="ne">NotImplementedError</span><span class="p">)</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">GalSimNotImplementedError</span><span class="p">(</span>
                    <span class="s2">&quot;Unable to draw this GSObject with photon shooting.  Perhaps it &quot;</span>
                    <span class="s2">&quot;is a Deconvolve or is a compound including one or more &quot;</span>
                    <span class="s2">&quot;Deconvolve objects.</span><span class="se">\n</span><span class="s2">Original error: </span><span class="si">%r</span><span class="s2">&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">e</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">g</span> <span class="o">!=</span> <span class="mf">1.</span><span class="p">:</span>
            <span class="n">photons</span><span class="o">.</span><span class="n">scaleFlux</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">photon_ops</span><span class="p">:</span>
            <span class="n">op</span><span class="o">.</span><span class="n">applyTo</span><span class="p">(</span><span class="n">photons</span><span class="p">,</span> <span class="n">local_wcs</span><span class="p">,</span> <span class="n">rng</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">photons</span></div>


<div class="viewcode-block" id="GSObject.drawPhot"><a class="viewcode-back" href="../../gsobject.html#galsim.GSObject.drawPhot">[docs]</a>    <span class="k">def</span> <span class="nf">drawPhot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span> <span class="n">gain</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span> <span class="n">add_to_image</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">n_photons</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">rng</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">max_extra_noise</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span> <span class="n">poisson_flux</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">sensor</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">photon_ops</span><span class="o">=</span><span class="p">(),</span> <span class="n">maxN</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">orig_center</span><span class="o">=</span><span class="n">_PositionI</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span>
                 <span class="n">local_wcs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">surface_ops</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Draw this profile into an `Image` by shooting photons.</span>

<span class="sd">        This is usually called from the `drawImage` function, rather than called directly by the</span>
<span class="sd">        user.  In particular, the input image must be already set up with defined bounds.  The</span>
<span class="sd">        profile will be drawn centered on whatever pixel corresponds to (0,0) with the given</span>
<span class="sd">        bounds, not the image center (unlike `drawImage`).  The image also must have a `PixelScale`</span>
<span class="sd">        wcs.  The profile being drawn should have already been converted to image coordinates via::</span>

<span class="sd">            &gt;&gt;&gt; image_profile = original_wcs.toImage(original_profile)</span>

<span class="sd">        Note that the image produced by `drawPhot` represents the profile integrated over the</span>
<span class="sd">        area of each pixel.  This is equivalent to convolving the profile by a square `Pixel`</span>
<span class="sd">        profile and sampling the value at the center of each pixel, although this happens</span>
<span class="sd">        automatically by the shooting algorithm, so you do not need to manually convolve by</span>
<span class="sd">        a `Pixel` as you would for `drawReal` or `drawFFT`.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            image:          The `Image` onto which to place the flux. [required]</span>
<span class="sd">            gain:           The number of photons per ADU (&quot;analog to digital units&quot;, the units of</span>
<span class="sd">                            the numbers output from a CCD). [default: 1.]</span>
<span class="sd">            add_to_image:   Whether to add to the existing images rather than clear out</span>
<span class="sd">                            anything in the image before drawing.  [default: False]</span>
<span class="sd">            n_photons:      If provided, the number of photons to use for photon shooting.</span>
<span class="sd">                            If not provided (i.e. ``n_photons = 0``), use as many photons as</span>
<span class="sd">                            necessary to result in an image with the correct Poisson shot</span>
<span class="sd">                            noise for the object&#39;s flux.  For positive definite profiles, this</span>
<span class="sd">                            is equivalent to ``n_photons = flux``.  However, some profiles need</span>
<span class="sd">                            more than this because some of the shot photons are negative</span>
<span class="sd">                            (usually due to interpolants).  [default: 0]</span>
<span class="sd">            rng:            If provided, a random number generator to use for photon shooting,</span>
<span class="sd">                            which may be any kind of `BaseDeviate` object.  If ``rng`` is None, one</span>
<span class="sd">                            will be automatically created, using the time as a seed.</span>
<span class="sd">                            [default: None]</span>
<span class="sd">            max_extra_noise: If provided, the allowed extra noise in each pixel when photon</span>
<span class="sd">                            shooting.  This is only relevant if ``n_photons=0``, so the number of</span>
<span class="sd">                            photons is being automatically calculated.  In that case, if the image</span>
<span class="sd">                            noise is dominated by the sky background, then you can get away with</span>
<span class="sd">                            using fewer shot photons than the full ``n_photons = flux``.</span>
<span class="sd">                            Essentially each shot photon can have a ``flux &gt; 1``, which increases</span>
<span class="sd">                            the noise in each pixel.  The ``max_extra_noise`` parameter specifies</span>
<span class="sd">                            how much extra noise per pixel is allowed because of this approximation.</span>
<span class="sd">                            A typical value for this might be ``max_extra_noise = sky_level / 100``</span>
<span class="sd">                            where ``sky_level`` is the flux per pixel due to the sky.  Note that</span>
<span class="sd">                            this uses a &quot;variance&quot; definition of noise, not a &quot;sigma&quot; definition.</span>
<span class="sd">                            [default: 0.]</span>
<span class="sd">            poisson_flux:   Whether to allow total object flux scaling to vary according to</span>
<span class="sd">                            Poisson statistics for ``n_photons`` samples when photon shooting.</span>
<span class="sd">                            [default: True, unless ``n_photons`` is given, in which case the default</span>
<span class="sd">                            is False]</span>
<span class="sd">            sensor:         An optional `Sensor` instance, which will be used to accumulate the</span>
<span class="sd">                            photons onto the image. [default: None]</span>
<span class="sd">            photon_ops:     A list of operators that can modify the photon array that will be</span>
<span class="sd">                            applied in order before accumulating the photons on the sensor.</span>
<span class="sd">                            [default: ()]</span>
<span class="sd">            maxN:           Sets the maximum number of photons that will be added to the image</span>
<span class="sd">                            at a time.  (Memory requirements are proportional to this number.)</span>
<span class="sd">                            [default: None, which means no limit]</span>
<span class="sd">            orig_center:    The position of the image center in the original image coordinates.</span>
<span class="sd">                            [default: (0,0)]</span>
<span class="sd">            local_wcs:      The local wcs in the original image. [default: None]</span>

<span class="sd">        Returns:</span>
<span class="sd">            (added_flux, photons) where:</span>
<span class="sd">            - added_flux is the total flux of photons that landed inside the image bounds, and</span>
<span class="sd">            - photons is the `PhotonArray` that was applied to the image.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">surface_ops</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">.deprecated</span> <span class="kn">import</span> <span class="n">depr</span>
            <span class="n">depr</span><span class="p">(</span><span class="s1">&#39;surface_ops&#39;</span><span class="p">,</span> <span class="mf">2.3</span><span class="p">,</span> <span class="s1">&#39;photon_ops&#39;</span><span class="p">)</span>
            <span class="n">photon_ops</span> <span class="o">=</span> <span class="n">surface_ops</span>

        <span class="c1"># Make sure the type of n_photons is correct and has a valid value:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">n_photons</span> <span class="o">&gt;=</span> <span class="mf">0.</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">GalSimRangeError</span><span class="p">(</span><span class="s2">&quot;Invalid n_photons &lt; 0.&quot;</span><span class="p">,</span> <span class="n">n_photons</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">poisson_flux</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># If n_photons is given, poisson_flux = False</span>
            <span class="n">poisson_flux</span> <span class="o">=</span> <span class="p">(</span><span class="n">n_photons</span> <span class="o">==</span> <span class="mf">0.</span><span class="p">)</span>

        <span class="c1"># Check that either n_photons is set to something or flux is set to something</span>
        <span class="k">if</span> <span class="n">n_photons</span> <span class="o">==</span> <span class="mf">0.</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">flux</span> <span class="o">==</span> <span class="mf">1.</span><span class="p">:</span>
            <span class="n">galsim_warn</span><span class="p">(</span>
                    <span class="s2">&quot;Warning: drawImage for object with flux == 1, area == 1, and &quot;</span>
                    <span class="s2">&quot;exptime == 1, but n_photons == 0.  This will only shoot a single photon.&quot;</span><span class="p">)</span>

        <span class="c1"># Make sure the image is set up to have unit pixel scale and centered at 0,0.</span>
        <span class="k">if</span> <span class="n">image</span><span class="o">.</span><span class="n">wcs</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">image</span><span class="o">.</span><span class="n">wcs</span><span class="o">.</span><span class="n">_isPixelScale</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">GalSimValueError</span><span class="p">(</span><span class="s2">&quot;drawPhot requires an image with a PixelScale wcs&quot;</span><span class="p">,</span> <span class="n">image</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">sensor</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">sensor</span> <span class="o">=</span> <span class="n">Sensor</span><span class="p">()</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sensor</span><span class="p">,</span> <span class="n">Sensor</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;The sensor provided is not a Sensor instance&quot;</span><span class="p">)</span>

        <span class="n">Ntot</span><span class="p">,</span> <span class="n">g</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calculate_nphotons</span><span class="p">(</span><span class="n">n_photons</span><span class="p">,</span> <span class="n">poisson_flux</span><span class="p">,</span> <span class="n">max_extra_noise</span><span class="p">,</span> <span class="n">rng</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">gain</span> <span class="o">!=</span> <span class="mf">1.</span><span class="p">:</span>
            <span class="n">g</span> <span class="o">/=</span> <span class="n">gain</span>

        <span class="c1"># total flux falling inside image bounds, this will be returned on exit.</span>
        <span class="n">added_flux</span> <span class="o">=</span> <span class="mf">0.</span>

        <span class="k">if</span> <span class="n">maxN</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">maxN</span> <span class="o">=</span> <span class="n">Ntot</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">add_to_image</span><span class="p">:</span> <span class="n">image</span><span class="o">.</span><span class="n">setZero</span><span class="p">()</span>

        <span class="c1"># Nleft is the number of photons remaining to shoot.</span>
        <span class="n">Nleft</span> <span class="o">=</span> <span class="n">Ntot</span>
        <span class="n">photons</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># Just in case Nleft is already 0.</span>
        <span class="n">resume</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">while</span> <span class="n">Nleft</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Shoot at most maxN at a time</span>
            <span class="n">thisN</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">maxN</span><span class="p">,</span> <span class="n">Nleft</span><span class="p">)</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="n">photons</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shoot</span><span class="p">(</span><span class="n">thisN</span><span class="p">,</span> <span class="n">rng</span><span class="p">)</span>
            <span class="k">except</span> <span class="p">(</span><span class="n">GalSimError</span><span class="p">,</span> <span class="ne">NotImplementedError</span><span class="p">)</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">GalSimNotImplementedError</span><span class="p">(</span>
                        <span class="s2">&quot;Unable to draw this GSObject with photon shooting.  Perhaps it &quot;</span>
                        <span class="s2">&quot;is a Deconvolve or is a compound including one or more &quot;</span>
                        <span class="s2">&quot;Deconvolve objects.</span><span class="se">\n</span><span class="s2">Original error: </span><span class="si">%r</span><span class="s2">&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">e</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">g</span> <span class="o">!=</span> <span class="mf">1.</span> <span class="ow">or</span> <span class="n">thisN</span> <span class="o">!=</span> <span class="n">Ntot</span><span class="p">:</span>
                <span class="n">photons</span><span class="o">.</span><span class="n">scaleFlux</span><span class="p">(</span><span class="n">g</span> <span class="o">*</span> <span class="n">thisN</span> <span class="o">/</span> <span class="n">Ntot</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">image</span><span class="o">.</span><span class="n">scale</span> <span class="o">!=</span> <span class="mf">1.</span><span class="p">:</span>
                <span class="n">photons</span><span class="o">.</span><span class="n">scaleXY</span><span class="p">(</span><span class="mf">1.</span><span class="o">/</span><span class="n">image</span><span class="o">.</span><span class="n">scale</span><span class="p">)</span>  <span class="c1"># Convert x,y to image coords if necessary</span>

            <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">photon_ops</span><span class="p">:</span>
                <span class="n">op</span><span class="o">.</span><span class="n">applyTo</span><span class="p">(</span><span class="n">photons</span><span class="p">,</span> <span class="n">local_wcs</span><span class="p">,</span> <span class="n">rng</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">image</span><span class="o">.</span><span class="n">dtype</span> <span class="ow">in</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">):</span>
                <span class="n">added_flux</span> <span class="o">+=</span> <span class="n">sensor</span><span class="o">.</span><span class="n">accumulate</span><span class="p">(</span><span class="n">photons</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span> <span class="n">orig_center</span><span class="p">,</span> <span class="n">resume</span><span class="o">=</span><span class="n">resume</span><span class="p">)</span>
                <span class="n">resume</span> <span class="o">=</span> <span class="kc">True</span>  <span class="c1"># Resume from this point if there are any further iterations.</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Need a temporary</span>
                <span class="n">im1</span> <span class="o">=</span> <span class="n">ImageD</span><span class="p">(</span><span class="n">bounds</span><span class="o">=</span><span class="n">image</span><span class="o">.</span><span class="n">bounds</span><span class="p">)</span>
                <span class="n">added_flux</span> <span class="o">+=</span> <span class="n">sensor</span><span class="o">.</span><span class="n">accumulate</span><span class="p">(</span><span class="n">photons</span><span class="p">,</span> <span class="n">im1</span><span class="p">,</span> <span class="n">orig_center</span><span class="p">)</span>
                <span class="n">image</span> <span class="o">+=</span> <span class="n">im1</span>

            <span class="n">Nleft</span> <span class="o">-=</span> <span class="n">thisN</span>

        <span class="k">return</span> <span class="n">added_flux</span><span class="p">,</span> <span class="n">photons</span></div>


<div class="viewcode-block" id="GSObject.shoot"><a class="viewcode-back" href="../../gsobject.html#galsim.GSObject.shoot">[docs]</a>    <span class="k">def</span> <span class="nf">shoot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_photons</span><span class="p">,</span> <span class="n">rng</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Shoot photons into a `PhotonArray`.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            n_photons:  The number of photons to use for photon shooting.</span>
<span class="sd">            rng:        If provided, a random number generator to use for photon shooting,</span>
<span class="sd">                        which may be any kind of `BaseDeviate` object.  If ``rng`` is None, one</span>
<span class="sd">                        will be automatically created, using the time as a seed.</span>
<span class="sd">                        [default: None]</span>

<span class="sd">        Returns:</span>
<span class="sd">            A `PhotonArray`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">photons</span> <span class="o">=</span> <span class="n">pa</span><span class="o">.</span><span class="n">PhotonArray</span><span class="p">(</span><span class="n">n_photons</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">n_photons</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># It&#39;s ok to shoot 0, but downstream can have problems with it, so just stop now.</span>
            <span class="k">return</span> <span class="n">photons</span>
        <span class="k">if</span> <span class="n">rng</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">rng</span> <span class="o">=</span> <span class="n">BaseDeviate</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_shoot</span><span class="p">(</span><span class="n">photons</span><span class="p">,</span> <span class="n">rng</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">photons</span></div>

<div class="viewcode-block" id="GSObject._shoot"><a class="viewcode-back" href="../../gsobject.html#galsim.GSObject._shoot">[docs]</a>    <span class="k">def</span> <span class="nf">_shoot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">photons</span><span class="p">,</span> <span class="n">rng</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Shoot photons into the given `PhotonArray`.</span>

<span class="sd">        This is the backend implementation of `shoot` once the `PhotonArray` has been constructed.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            photons:    A `PhotonArray` instance into which the photons should be placed.</span>
<span class="sd">            rng:        A `BaseDeviate` instance to use for the photon shooting,</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> does not implement shoot&quot;</span><span class="o">%</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span></div>

<div class="viewcode-block" id="GSObject.applyTo"><a class="viewcode-back" href="../../gsobject.html#galsim.GSObject.applyTo">[docs]</a>    <span class="k">def</span> <span class="nf">applyTo</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">photon_array</span><span class="p">,</span> <span class="n">local_wcs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rng</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Apply this surface brightness profile as a convolution to an existing photon array.</span>

<span class="sd">        This method allows a GSObject to duck type as a PhotonOp, so one can apply a PSF</span>
<span class="sd">        in a photon_ops list.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            photon_array:   A `PhotonArray` to apply the operator to.</span>
<span class="sd">            local_wcs:      A `LocalWCS` instance defining the local WCS for the current photon</span>
<span class="sd">                            bundle in case the operator needs this information.  [default: None]</span>
<span class="sd">            rng:            A random number generator to use to effect the convolution.</span>
<span class="sd">                            [default: None]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">p1</span> <span class="o">=</span> <span class="n">pa</span><span class="o">.</span><span class="n">PhotonArray</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">photon_array</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">photon_array</span><span class="o">.</span><span class="n">hasAllocatedWavelengths</span><span class="p">():</span>
            <span class="n">p1</span><span class="o">.</span><span class="n">_wave</span> <span class="o">=</span> <span class="n">photon_array</span><span class="o">.</span><span class="n">_wave</span>
        <span class="k">if</span> <span class="n">photon_array</span><span class="o">.</span><span class="n">hasAllocatedPupil</span><span class="p">():</span>
            <span class="n">p1</span><span class="o">.</span><span class="n">_pupil_u</span> <span class="o">=</span> <span class="n">photon_array</span><span class="o">.</span><span class="n">_pupil_u</span>
            <span class="n">p1</span><span class="o">.</span><span class="n">_pupil_v</span> <span class="o">=</span> <span class="n">photon_array</span><span class="o">.</span><span class="n">_pupil_v</span>
        <span class="k">if</span> <span class="n">photon_array</span><span class="o">.</span><span class="n">hasAllocatedTimes</span><span class="p">():</span>
            <span class="n">p1</span><span class="o">.</span><span class="n">_time</span> <span class="o">=</span> <span class="n">photon_array</span><span class="o">.</span><span class="n">_time</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="n">local_wcs</span><span class="o">.</span><span class="n">toImage</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="k">if</span> <span class="n">local_wcs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">_shoot</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">rng</span><span class="p">)</span>
        <span class="n">photon_array</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">rng</span><span class="p">)</span></div>

<div class="viewcode-block" id="GSObject.drawKImage"><a class="viewcode-back" href="../../gsobject.html#galsim.GSObject.drawKImage">[docs]</a>    <span class="k">def</span> <span class="nf">drawKImage</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">image</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ny</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">bounds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                   <span class="n">add_to_image</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">recenter</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">bandpass</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">setup_only</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Draws the k-space (complex) `Image` of the object, with bounds optionally set by input</span>
<span class="sd">        `Image` instance.</span>

<span class="sd">        Normalization is always such that image(0,0) = flux.  Unlike the real-space `drawImage`</span>
<span class="sd">        function, the (0,0) point will always be one of the actual pixel values.  For even-sized</span>
<span class="sd">        images, it will be 1/2 pixel above and to the right of the true center of the image.</span>

<span class="sd">        Another difference from  `drawImage` is that a wcs other than a simple pixel scale is not</span>
<span class="sd">        allowed.  There is no ``wcs`` parameter here, and if the images have a non-trivial wcs (and</span>
<span class="sd">        you don&#39;t override it with the ``scale`` parameter), a TypeError will be raised.</span>

<span class="sd">        Also, there is no convolution by a pixel.  This is just a direct image of the Fourier</span>
<span class="sd">        transform of the surface brightness profile.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            image:          If provided, this will be the `Image` onto which to draw the k-space</span>
<span class="sd">                            image.  If ``image`` is None, then an automatically-sized image will be</span>
<span class="sd">                            created.  If ``image`` is given, but its bounds are undefined, then it</span>
<span class="sd">                            will be resized appropriately based on the profile&#39;s size.</span>
<span class="sd">                            [default: None]</span>
<span class="sd">            nx:             If provided and ``image`` is None, use to set the x-direction size of</span>
<span class="sd">                            the image.  Must be accompanied by ``ny``.</span>
<span class="sd">            ny:             If provided and ``image`` is None, use to set the y-direction size of</span>
<span class="sd">                            the image.  Must be accompanied by ``nx``.</span>
<span class="sd">            bounds:         If provided and ``image`` is None, use to set the bounds of the image.</span>
<span class="sd">            scale:          If provided, use this as the pixel scale, dk, for the images.</span>
<span class="sd">                            If ``scale`` is None and ``image`` is given, then take the provided</span>
<span class="sd">                            images&#39; pixel scale (which must be equal).</span>
<span class="sd">                            If ``scale`` is None and ``image`` is None, then use the Nyquist scale.</span>
<span class="sd">                            If ``scale &lt;= 0`` (regardless of ``image``), then use the Nyquist scale.</span>
<span class="sd">                            [default: None]</span>
<span class="sd">            add_to_image:   Whether to add to the existing images rather than clear out</span>
<span class="sd">                            anything in the image before drawing.</span>
<span class="sd">                            Note: This requires that ``image`` be provided and that it has defined</span>
<span class="sd">                            bounds. [default: False]</span>
<span class="sd">            recenter:       Whether to recenter the image to put k = 0 at the center (True) or to</span>
<span class="sd">                            trust the provided bounds (False).  [default: True]</span>
<span class="sd">            bandpass:       This parameter is ignored, but is allowed to enable duck typing</span>
<span class="sd">                            eqivalence between this method and the ChromaticObject.drawImage</span>
<span class="sd">                            method. [default: None]</span>
<span class="sd">            setup_only:     Don&#39;t actually draw anything on the image.  Just make sure the image</span>
<span class="sd">                            is set up correctly.  This is used internally by GalSim, but there</span>
<span class="sd">                            may be cases where the user will want the same functionality.</span>
<span class="sd">                            [default: False]</span>

<span class="sd">        Returns:</span>
<span class="sd">            an `Image` instance (created if necessary)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Make sure provided image is complex</span>
        <span class="k">if</span> <span class="n">image</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">Image</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Provided image must be galsim.Image&quot;</span><span class="p">,</span> <span class="n">image</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">image</span><span class="o">.</span><span class="n">iscomplex</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">GalSimValueError</span><span class="p">(</span><span class="s2">&quot;Provided image must be complex&quot;</span><span class="p">,</span> <span class="n">image</span><span class="p">)</span>

        <span class="c1"># Possibly get the scale from image.</span>
        <span class="k">if</span> <span class="n">image</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">scale</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Grab the scale to use from the image.</span>
            <span class="c1"># This will raise a TypeError if image.wcs is not a PixelScale</span>
            <span class="n">scale</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">scale</span>

        <span class="c1"># The input scale (via scale or image.scale) is really a dk value, so call it that for</span>
        <span class="c1"># clarity here, since we also need the real-space pixel scale, which we will call dx.</span>
        <span class="k">if</span> <span class="n">scale</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">scale</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">dk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stepk</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dk</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">scale</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">image</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">image</span><span class="o">.</span><span class="n">bounds</span><span class="o">.</span><span class="n">isDefined</span><span class="p">():</span>
            <span class="n">dx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="p">(</span> <span class="nb">max</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">dk</span> <span class="p">)</span>
        <span class="k">elif</span> <span class="n">scale</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">scale</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">dx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nyquist_scale</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Then dk = scale, which implies that we need to have dx smaller than nyquist_scale</span>
            <span class="c1"># by a factor of (dk/stepk)</span>
            <span class="n">dx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nyquist_scale</span> <span class="o">*</span> <span class="n">dk</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">stepk</span>

        <span class="c1"># If the profile needs to be constructed from scratch, the _setup_image function will</span>
        <span class="c1"># do that, but only if the profile is in image coordinates for the real space image.</span>
        <span class="c1"># So make that profile.</span>
        <span class="k">if</span> <span class="n">image</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">image</span><span class="o">.</span><span class="n">bounds</span><span class="o">.</span><span class="n">isDefined</span><span class="p">():</span>
            <span class="n">real_prof</span> <span class="o">=</span> <span class="n">PixelScale</span><span class="p">(</span><span class="n">dx</span><span class="p">)</span><span class="o">.</span><span class="n">profileToImage</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">complex128</span> <span class="k">if</span> <span class="n">image</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">image</span><span class="o">.</span><span class="n">dtype</span>
            <span class="n">image</span> <span class="o">=</span> <span class="n">real_prof</span><span class="o">.</span><span class="n">_setup_image</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">bounds</span><span class="p">,</span> <span class="n">add_to_image</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span>
                                           <span class="n">center</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">odd</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Do some checks that setup_image would have done for us</span>
            <span class="k">if</span> <span class="n">bounds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">GalSimIncompatibleValuesError</span><span class="p">(</span>
                    <span class="s2">&quot;Cannot provide bounds if image is provided&quot;</span><span class="p">,</span> <span class="n">bounds</span><span class="o">=</span><span class="n">bounds</span><span class="p">,</span> <span class="n">image</span><span class="o">=</span><span class="n">image</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">nx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">ny</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">GalSimIncompatibleValuesError</span><span class="p">(</span>
                    <span class="s2">&quot;Cannot provide nx,ny if image is provided&quot;</span><span class="p">,</span> <span class="n">nx</span><span class="o">=</span><span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="o">=</span><span class="n">ny</span><span class="p">,</span> <span class="n">image</span><span class="o">=</span><span class="n">image</span><span class="p">)</span>

        <span class="c1"># Can&#39;t both recenter a provided image and add to it.</span>
        <span class="k">if</span> <span class="n">recenter</span> <span class="ow">and</span> <span class="n">image</span><span class="o">.</span><span class="n">center</span> <span class="o">!=</span> <span class="n">_PositionI</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="n">add_to_image</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">GalSimIncompatibleValuesError</span><span class="p">(</span>
                <span class="s2">&quot;Cannot use add_to_image=True unless image is centered at (0,0) or recenter=False&quot;</span><span class="p">,</span>
                <span class="n">recenter</span><span class="o">=</span><span class="n">recenter</span><span class="p">,</span> <span class="n">image</span><span class="o">=</span><span class="n">image</span><span class="p">,</span> <span class="n">add_to_image</span><span class="o">=</span><span class="n">add_to_image</span><span class="p">)</span>

        <span class="c1"># Set the center to 0,0 if appropriate</span>
        <span class="k">if</span> <span class="n">recenter</span> <span class="ow">and</span> <span class="n">image</span><span class="o">.</span><span class="n">center</span> <span class="o">!=</span> <span class="n">_PositionI</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">):</span>
            <span class="n">image</span><span class="o">.</span><span class="n">_shift</span><span class="p">(</span><span class="o">-</span><span class="n">image</span><span class="o">.</span><span class="n">center</span><span class="p">)</span>

        <span class="c1"># Set the wcs of the images to use the dk scale size</span>
        <span class="n">image</span><span class="o">.</span><span class="n">scale</span> <span class="o">=</span> <span class="n">dk</span>

        <span class="k">if</span> <span class="n">setup_only</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">image</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">add_to_image</span> <span class="ow">and</span> <span class="n">image</span><span class="o">.</span><span class="n">iscontiguous</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_drawKImage</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">im2</span> <span class="o">=</span> <span class="n">Image</span><span class="p">(</span><span class="n">bounds</span><span class="o">=</span><span class="n">image</span><span class="o">.</span><span class="n">bounds</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">image</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">image</span><span class="o">.</span><span class="n">scale</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_drawKImage</span><span class="p">(</span><span class="n">im2</span><span class="p">)</span>
            <span class="n">image</span> <span class="o">+=</span> <span class="n">im2</span>
        <span class="k">return</span> <span class="n">image</span></div>

<div class="viewcode-block" id="GSObject._drawKImage"><a class="viewcode-back" href="../../gsobject.html#galsim.GSObject._drawKImage">[docs]</a>    <span class="k">def</span> <span class="nf">_drawKImage</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span> <span class="n">jac</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>  <span class="c1"># pragma: no cover  (all our classes override this)</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;A version of `drawKImage` without the sanity checks or some options.</span>

<span class="sd">        Equivalent to ``drawKImage(image, add_to_image=False, recenter=False, add_to_image=False)``,</span>
<span class="sd">        but without the option to create the image automatically.</span>

<span class="sd">        The input image must be provided as a complex `Image` instance (dtype=complex64 or</span>
<span class="sd">        complex128), and the bounds should be set up appropriately (e.g. with 0,0 in the center if</span>
<span class="sd">        so desired).  This corresponds to recenter=False for the normal `drawKImage`.  And, it must</span>
<span class="sd">        have a c_contiguous array (image.iscontiguous must be True).</span>

<span class="sd">        Parameters:</span>
<span class="sd">            image:      The `Image` onto which to draw the k-space image. [required]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> does not implement drawKImage&quot;</span><span class="o">%</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span></div>

    <span class="c1"># Derived classes should define the __eq__ function</span>
    <span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span> <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__eq__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span></div>

<span class="c1"># Put these at the bottom to avoid circular import errors.</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">convolve</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="nb">sum</span> <span class="k">as</span> <span class="n">_sum</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">transform</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">box</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">photon_array</span> <span class="k">as</span> <span class="n">pa</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">sed</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, GalSim-developers.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>