

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>galsim.wfirst.wfirst_psfs &mdash; GalSim 2.2.5 documentation</title>
  

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html" class="icon icon-home"> GalSim
          

          
          </a>

          
            
            
              <div class="version">
                2.2
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../overview.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../install.html">Installation Instructions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../image.html">Images and Related Concepts</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../sb.html">Surface Brightness Profiles</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../chromatic.html">Wavelength-dependent Profiles</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../units.html">Units</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../wcs.html">World Coordinate Systems</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../random.html">Noise and Random Values</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../wl.html">Weak Lensing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../photon.html">Photon Shooting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../utilities.html">Helper Functions and Classes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../errors.html">Errors and Warnings</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../config.html">The Config Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../hsm.html">The HSM Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../des.html">The DES Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../wfirst.html">The WFIRST Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../shared.html">Shared Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../history.html">Revision History</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">GalSim</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>galsim.wfirst.wfirst_psfs</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for galsim.wfirst.wfirst_psfs</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright (c) 2012-2019 by the GalSim developers team on GitHub</span>
<span class="c1"># https://github.com/GalSim-developers</span>
<span class="c1">#</span>
<span class="c1"># This file is part of GalSim: The modular galaxy image simulation toolkit.</span>
<span class="c1"># https://github.com/GalSim-developers/GalSim</span>
<span class="c1">#</span>
<span class="c1"># GalSim is free software: redistribution and use in source and binary forms,</span>
<span class="c1"># with or without modification, are permitted provided that the following</span>
<span class="c1"># conditions are met:</span>
<span class="c1">#</span>
<span class="c1"># 1. Redistributions of source code must retain the above copyright notice, this</span>
<span class="c1">#    list of conditions, and the disclaimer given in the accompanying LICENSE</span>
<span class="c1">#    file.</span>
<span class="c1"># 2. Redistributions in binary form must reproduce the above copyright notice,</span>
<span class="c1">#    this list of conditions, and the disclaimer given in the documentation</span>
<span class="c1">#    and/or other materials provided with the distribution.</span>
<span class="c1">#</span>

<span class="kn">from</span> <span class="nn">past.builtins</span> <span class="kn">import</span> <span class="n">basestring</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">os</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">@file wfirst_psfs.py</span>

<span class="sd">Part of the WFIRST module.  This file includes routines needed to define a realistic PSF for WFIRST.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="c1"># Define a default set of bandpasses for which this routine works.</span>
<span class="n">default_bandpass_list</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;J129&#39;</span><span class="p">,</span> <span class="s1">&#39;F184&#39;</span><span class="p">,</span> <span class="s1">&#39;W149&#39;</span><span class="p">,</span> <span class="s1">&#39;Y106&#39;</span><span class="p">,</span> <span class="s1">&#39;Z087&#39;</span><span class="p">,</span> <span class="s1">&#39;H158&#39;</span><span class="p">]</span>
<span class="c1"># Prefix for files containing information about Zernikes for each SCA for cycle 7.</span>
<span class="n">zemax_filepref</span> <span class="o">=</span> <span class="s2">&quot;WFIRST_Phase-A_SRR_WFC_Zernike_and_Field_Data_170727&quot;</span>
<span class="n">zemax_filesuff</span> <span class="o">=</span> <span class="s1">&#39;.txt&#39;</span>
<span class="n">zemax_wavelength</span> <span class="o">=</span> <span class="mf">1293.</span> <span class="c1">#nm</span>

<div class="viewcode-block" id="getPSF"><a class="viewcode-back" href="../../../wfirst.html#galsim.wfirst.getPSF">[docs]</a><span class="k">def</span> <span class="nf">getPSF</span><span class="p">(</span><span class="n">SCA</span><span class="p">,</span> <span class="n">bandpass</span><span class="p">,</span>
           <span class="n">SCA_pos</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">approximate_struts</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">n_waves</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">extra_aberrations</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
           <span class="n">logger</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">wavelength</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">high_accuracy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">gsparams</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Get a single PSF for WFIRST observations.</span>

<span class="sd">    The user must provide the SCA and bandpass; the latter is used when setting up the pupil</span>
<span class="sd">    plane configuration and when interpolating chromatic information, if requested.</span>

<span class="sd">    This routine carries out linear interpolation of the aberrations within a given SCA, based on</span>
<span class="sd">    the WFIRST Cycle 7 specification of the aberrations as a function of focal plane position.</span>

<span class="sd">    The default is to do the calculations using the full specification of the WFIRST pupil plane,</span>
<span class="sd">    which is a costly calculation in terms of memory.  For this, we use the provided pupil plane for</span>
<span class="sd">    long- and short-wavelength bands for Cycle 7 (the list of bands associated with each pupil plane</span>
<span class="sd">    is stored in ``galsim.wfirst.longwave_bands`` and ``galsim.wfirst.shortwave_bands``).</span>

<span class="sd">    To avoid using the full pupil plane configuration, use the optional keyword</span>
<span class="sd">    ``approximate_struts``.  In this case, the pupil plane will have the correct obscuration and</span>
<span class="sd">    number of struts, but the struts will be purely radial and evenly spaced instead of the true</span>
<span class="sd">    configuration.  The simplicity of this arrangement leads to a much faster calculation, and</span>
<span class="sd">    somewhat simplifies the configuration of the diffraction spikes.  Also note that currently the</span>
<span class="sd">    orientation of the struts is fixed, rather than rotating depending on the orientation of the</span>
<span class="sd">    focal plane.  Rotation of the PSF can easily be affected by the user via::</span>

<span class="sd">       psf = galsim.wfirst.getPSF(...).rotate(angle)</span>

<span class="sd">    which will rotate the entire PSF (including the diffraction spikes and any other features).</span>

<span class="sd">    The calculation takes advantage of the fact that the diffraction limit and aberrations have a</span>
<span class="sd">    simple, understood wavelength-dependence.  (The WFIRST project webpage for Cycle 7 does in fact</span>
<span class="sd">    provide aberrations as a function of wavelength, but the deviation from the expected chromatic</span>
<span class="sd">    dependence is sub-percent so we neglect it here.)  For reference, the script used to parse the</span>
<span class="sd">    Zernikes given on the webpage and create the files in the GalSim repository can be found in</span>
<span class="sd">    ``devel/external/parse_wfirst_zernikes_1217.py``.  The resulting chromatic object can be used to</span>
<span class="sd">    draw into any of the WFIRST bandpasses, though the pupil plane configuration will only be</span>
<span class="sd">    correct for those bands in the same range (i.e., long- or short-wavelength bands).</span>

<span class="sd">    For applications that require very high accuracy in the modeling of the PSF, with very limited</span>
<span class="sd">    aliasing, the ``high_accuracy`` option can be set to True.  When using this option, the MTF has</span>
<span class="sd">    a value below 1e-4 for all wavenumbers above the band limit when using</span>
<span class="sd">    ``approximate_struts=True``, or below 3e-4 when using ``approximate_struts=False``.  In</span>
<span class="sd">    contrast, when ``high_accuracy=False`` (the default), there are some bumps in the MTF above the</span>
<span class="sd">    band limit that reach an amplitude of ~1e-2.</span>

<span class="sd">    By default, no additional aberrations are included above the basic design.  However, users can</span>
<span class="sd">    provide an optional keyword ``extra_aberrations`` that will be included on top of those that are</span>
<span class="sd">    part of the design.  This should be in the same format as for the ChromaticOpticalPSF class,</span>
<span class="sd">    with units of waves at the fiducial wavelength, 1293 nm. Currently, only aberrations up to order</span>
<span class="sd">    22 (Noll convention) are simulated.  For WFIRST, the current tolerance for additional</span>
<span class="sd">    aberrations is a total of 90 nanometers RMS:</span>

<span class="sd">    http://wfirst.gsfc.nasa.gov/science/sdt_public/wps/references/instrument/README_AFTA_C5_WFC_Zernike_and_Field_Data.pdf</span>

<span class="sd">    distributed largely among coma, astigmatism, trefoil, and spherical aberrations (NOT defocus).</span>
<span class="sd">    This information might serve as a guide for reasonable ``extra_aberrations`` inputs.</span>

<span class="sd">    Jitter and charge diffusion are, by default, not included.  Users who wish to include these can</span>
<span class="sd">    find some guidelines for typical length scales of the Gaussians that can represent these</span>
<span class="sd">    effects, and convolve the ChromaticOpticalPSF with appropriate achromatic Gaussians.</span>

<span class="sd">    The PSFs are always defined assuming the user will specify length scales in arcsec.</span>

<span class="sd">    Users may find they do not have to call `getPSF` for all objects in their simulations; for a</span>
<span class="sd">    given SCA and position within the SCA, and a given pupil plane configuration and wavelength</span>
<span class="sd">    information, it should be possible to reuse the PSFs.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        SCA:                Single value specifying the SCA for which the PSF should be</span>
<span class="sd">                            loaded.</span>
<span class="sd">        bandpass:           Single string specifying the bandpass to use when defining the</span>
<span class="sd">                            pupil plane configuration and/or interpolation of chromatic PSFs.</span>
<span class="sd">                            If ``approximate_struts`` is True (which means we do not use a</span>
<span class="sd">                            realistic pupil plane configuration) and ``n_waves`` is None (no</span>
<span class="sd">                            interpolation of chromatic PSFs) then &#39;bandpass&#39; can be None.  It</span>
<span class="sd">                            is also possible to pass a string &#39;long&#39; or &#39;short&#39; for this</span>
<span class="sd">                            argument; in that case, the correct pupil plane configuration</span>
<span class="sd">                            will be used for long- or short-wavelength bands as defined using</span>
<span class="sd">                            ``galsm.wfirst.longwave_bands`` and</span>
<span class="sd">                            ``galsim.wfirst.shortwave_bands``, respectively (but no</span>
<span class="sd">                            interpolation can be used, since it is defined using the extent</span>
<span class="sd">                            of the chosen bandpass).</span>
<span class="sd">        SCA_pos:            Single galsim.PositionD indicating the position within the SCA</span>
<span class="sd">                            for which the PSF should be created. If None, the exact center of</span>
<span class="sd">                            the SCA is chosen. [default: None]</span>
<span class="sd">        approximate_struts: Should the routine use an approximate representation of the pupil</span>
<span class="sd">                            plane, with 6 equally-spaced radial struts, instead of the exact</span>
<span class="sd">                            representation of the pupil plane?  Setting this parameter to</span>
<span class="sd">                            True will lead to faster calculations, with a slightly less</span>
<span class="sd">                            realistic PSFs.  [default: False]</span>
<span class="sd">        n_waves:            Number of wavelengths to use for setting up interpolation of the</span>
<span class="sd">                            chromatic PSF objects, which can lead to much faster image</span>
<span class="sd">                            rendering.  If None, then no interpolation is used. Note that</span>
<span class="sd">                            users who want to interpolate can always set up the interpolation</span>
<span class="sd">                            later on even if they do not do so when calling `getPSF`.</span>
<span class="sd">                            [default: None]</span>
<span class="sd">        extra_aberrations:  Array of extra aberrations to include in the PSF model, on top of</span>
<span class="sd">                            those that are part of the WFIRST design.  These should be</span>
<span class="sd">                            provided in units of waves at the fiducial wavelength of 1293 nm,</span>
<span class="sd">                            as an array of length 23 with entries 4 through 22 corresponding</span>
<span class="sd">                            to defocus through the 22nd Zernike in the Noll convention.</span>
<span class="sd">                            [default: None]</span>
<span class="sd">        logger:             A logger object for output of progress statements if the user</span>
<span class="sd">                            wants them.  [default: None]</span>
<span class="sd">        wavelength:         An option to get an achromatic PSF for a single wavelength, for</span>
<span class="sd">                            users who do not care about chromaticity of the PSF.  If None,</span>
<span class="sd">                            then the fully chromatic PSF is returned.  Alternatively the user</span>
<span class="sd">                            should supply either (a) a wavelength in nanometers, and they</span>
<span class="sd">                            will get achromatic OpticalPSF objects for that wavelength, or</span>
<span class="sd">                            (b) a bandpass object, in which case they will get achromatic</span>
<span class="sd">                            OpticalPSF objects defined at the effective wavelength of that</span>
<span class="sd">                            bandpass.  [default: False]</span>
<span class="sd">        high_accuracy:      If True, make higher-fidelity representations of the PSF in</span>
<span class="sd">                            Fourier space, to minimize aliasing (see plots on</span>
<span class="sd">                            https://github.com/GalSim-developers/GalSim/issues/661 for more</span>
<span class="sd">                            details).  This setting is more expensive in terms of time and</span>
<span class="sd">                            RAM, and may not be necessary for many applications.</span>
<span class="sd">                            [default: False]</span>
<span class="sd">        gsparams:           An optional GSParams argument.  See the docstring for GSParams</span>
<span class="sd">                            for details. [default: None]</span>

<span class="sd">    Returns:</span>
<span class="sd">        A single PSF object (either a ChromaticOpticalPSF or an OpticalPSF depending on the</span>
<span class="sd">        inputs).</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">PositionD</span>
    <span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">GalSimValueError</span>
    <span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">n_pix</span><span class="p">,</span> <span class="n">longwave_bands</span><span class="p">,</span> <span class="n">shortwave_bands</span>

    <span class="c1"># Deal with inputs:</span>

    <span class="c1"># SCA_pos: if None, then all should just be center of the SCA.</span>
    <span class="k">if</span> <span class="n">SCA_pos</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">SCA_pos</span> <span class="o">=</span> <span class="n">PositionD</span><span class="p">(</span><span class="n">n_pix</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">n_pix</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>

    <span class="c1"># Parse the bandpasses to see which pupil plane image is needed, if approximate_struts is False</span>
    <span class="c1"># (otherwise just say None).</span>
    <span class="n">pupil_plane_type</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">approximate_struts</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">bandpass</span> <span class="ow">in</span> <span class="n">longwave_bands</span> <span class="ow">or</span> <span class="n">bandpass</span><span class="o">==</span><span class="s1">&#39;long&#39;</span><span class="p">:</span>
            <span class="n">pupil_plane_type</span> <span class="o">=</span> <span class="s1">&#39;long&#39;</span>
        <span class="k">elif</span> <span class="n">bandpass</span> <span class="ow">in</span> <span class="n">shortwave_bands</span> <span class="ow">or</span> <span class="n">bandpass</span><span class="o">==</span><span class="s1">&#39;short&#39;</span><span class="p">:</span>
            <span class="n">pupil_plane_type</span> <span class="o">=</span> <span class="s1">&#39;short&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">GalSimValueError</span><span class="p">(</span><span class="s2">&quot;Bandpass not a valid WFIRST bandpass or &#39;short&#39;/&#39;long&#39;.&quot;</span><span class="p">,</span>
                                   <span class="n">bandpass</span><span class="p">,</span> <span class="n">default_bandpass_list</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Sanity checking:</span>
        <span class="c1"># If we need to use bandpass info, require that it be one of the defaults.</span>
        <span class="c1"># If we do not need to use bandpass info, allow it to be None.</span>
        <span class="k">if</span> <span class="n">n_waves</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">bandpass</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">default_bandpass_list</span><span class="o">+</span><span class="p">[</span><span class="s1">&#39;short&#39;</span><span class="p">,</span><span class="s1">&#39;long&#39;</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="n">GalSimValueError</span><span class="p">(</span><span class="s2">&quot;Bandpass not a valid WFIRST bandpass or &#39;short&#39;/&#39;long&#39;.&quot;</span><span class="p">,</span>
                                       <span class="n">bandpass</span><span class="p">,</span> <span class="n">default_bandpass_list</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">bandpass</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">default_bandpass_list</span><span class="o">+</span><span class="p">[</span><span class="s1">&#39;short&#39;</span><span class="p">,</span><span class="s1">&#39;long&#39;</span><span class="p">]</span> <span class="ow">and</span> <span class="n">bandpass</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">GalSimValueError</span><span class="p">(</span><span class="s2">&quot;Bandpass not a valid WFIRST bandpass or &#39;short&#39;/&#39;long&#39;.&quot;</span><span class="p">,</span>
                                       <span class="n">bandpass</span><span class="p">,</span> <span class="n">default_bandpass_list</span><span class="p">)</span>

    <span class="c1"># If bandpass is &#39;short&#39;/&#39;long&#39;, then make sure that interpolation is not called for, since that</span>
    <span class="c1"># requires an actual bandpass.</span>
    <span class="k">if</span> <span class="n">bandpass</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;short&#39;</span><span class="p">,</span><span class="s1">&#39;long&#39;</span><span class="p">]</span> <span class="ow">and</span> <span class="n">n_waves</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">GalSimValueError</span><span class="p">(</span><span class="s2">&quot;Cannot use bandpass=&#39;short&#39;/&#39;long&#39; with interpolation.&quot;</span><span class="p">,</span> <span class="n">bandpass</span><span class="p">)</span>

    <span class="c1"># Now call _get_single_PSF().</span>
    <span class="n">psf</span> <span class="o">=</span> <span class="n">_get_single_PSF</span><span class="p">(</span><span class="n">SCA</span><span class="p">,</span> <span class="n">bandpass</span><span class="p">,</span> <span class="n">SCA_pos</span><span class="p">,</span> <span class="n">approximate_struts</span><span class="p">,</span>
                          <span class="n">n_waves</span><span class="p">,</span> <span class="n">extra_aberrations</span><span class="p">,</span> <span class="n">logger</span><span class="p">,</span> <span class="n">wavelength</span><span class="p">,</span>
                          <span class="n">high_accuracy</span><span class="p">,</span> <span class="n">pupil_plane_type</span><span class="p">,</span> <span class="n">gsparams</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">psf</span></div>

<span class="k">def</span> <span class="nf">_get_single_PSF</span><span class="p">(</span><span class="n">SCA</span><span class="p">,</span> <span class="n">bandpass</span><span class="p">,</span> <span class="n">SCA_pos</span><span class="p">,</span> <span class="n">approximate_struts</span><span class="p">,</span>
                    <span class="n">n_waves</span><span class="p">,</span> <span class="n">extra_aberrations</span><span class="p">,</span> <span class="n">logger</span><span class="p">,</span> <span class="n">wavelength</span><span class="p">,</span>
                    <span class="n">high_accuracy</span><span class="p">,</span> <span class="n">pupil_plane_type</span><span class="p">,</span> <span class="n">gsparams</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Routine for making a single PSF.  This gets called by `getPSF` after it parses all the</span>
<span class="sd">       options that were passed in.  Users will not directly interact with this routine.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">fits</span>
    <span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">Image</span><span class="p">,</span> <span class="n">OpticalPSF</span><span class="p">,</span> <span class="n">ChromaticOpticalPSF</span>
    <span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">pupil_plane_file_longwave</span><span class="p">,</span> <span class="n">pupil_plane_file_shortwave</span><span class="p">,</span> <span class="n">pupil_plane_scale</span>
    <span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">diameter</span><span class="p">,</span> <span class="n">obscuration</span>
    <span class="kn">from</span> <span class="nn">.wfirst_bandpass</span> <span class="kn">import</span> <span class="n">getBandpasses</span>

    <span class="c1"># Deal with some accuracy settings.</span>
    <span class="k">if</span> <span class="n">high_accuracy</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">approximate_struts</span><span class="p">:</span>
            <span class="n">oversampling</span> <span class="o">=</span> <span class="mf">3.5</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">oversampling</span> <span class="o">=</span> <span class="mf">2.0</span>

            <span class="c1"># In this case, we need to pad the edges of the pupil plane image, so we cannot just use</span>
            <span class="c1"># the stored file.</span>
            <span class="k">if</span> <span class="n">pupil_plane_type</span> <span class="o">==</span> <span class="s1">&#39;long&#39;</span><span class="p">:</span>
                <span class="n">tmp_pupil_plane_im</span> <span class="o">=</span> <span class="n">fits</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">pupil_plane_file_longwave</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">tmp_pupil_plane_im</span> <span class="o">=</span> <span class="n">fits</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">pupil_plane_file_shortwave</span><span class="p">)</span>
            <span class="n">old_bounds</span> <span class="o">=</span> <span class="n">tmp_pupil_plane_im</span><span class="o">.</span><span class="n">bounds</span>
            <span class="n">new_bounds</span> <span class="o">=</span> <span class="n">old_bounds</span><span class="o">.</span><span class="n">withBorder</span><span class="p">((</span><span class="n">old_bounds</span><span class="o">.</span><span class="n">xmax</span><span class="o">+</span><span class="mi">1</span><span class="o">-</span><span class="n">old_bounds</span><span class="o">.</span><span class="n">xmin</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">pupil_plane_im</span> <span class="o">=</span> <span class="n">Image</span><span class="p">(</span><span class="n">bounds</span><span class="o">=</span><span class="n">new_bounds</span><span class="p">)</span>
            <span class="n">pupil_plane_im</span><span class="p">[</span><span class="n">old_bounds</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp_pupil_plane_im</span>
            <span class="n">pupil_plane_scale</span> <span class="o">=</span> <span class="n">pupil_plane_scale</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">approximate_struts</span><span class="p">:</span>
            <span class="n">oversampling</span> <span class="o">=</span> <span class="mf">1.5</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">oversampling</span> <span class="o">=</span> <span class="mf">1.2</span>
            <span class="k">if</span> <span class="n">pupil_plane_type</span> <span class="o">==</span> <span class="s1">&#39;long&#39;</span><span class="p">:</span>
                <span class="n">pupil_plane_im</span> <span class="o">=</span> <span class="n">pupil_plane_file_longwave</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">pupil_plane_im</span> <span class="o">=</span> <span class="n">pupil_plane_file_shortwave</span>
            <span class="n">pupil_plane_scale</span> <span class="o">=</span> <span class="n">pupil_plane_scale</span>

    <span class="c1"># Start reading in the aberrations for that SCA</span>
    <span class="k">if</span> <span class="n">logger</span><span class="p">:</span> <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Beginning to get the PSF aberrations for SCA </span><span class="si">%d</span><span class="s1">.&#39;</span><span class="o">%</span><span class="n">SCA</span><span class="p">)</span>
    <span class="n">aberrations</span><span class="p">,</span> <span class="n">x_pos</span><span class="p">,</span> <span class="n">y_pos</span> <span class="o">=</span> <span class="n">_read_aberrations</span><span class="p">(</span><span class="n">SCA</span><span class="p">)</span>
    <span class="c1"># Do bilinear interpolation, unless we&#39;re exactly at the center (default).</span>
    <span class="n">use_aberrations</span> <span class="o">=</span> <span class="n">_interp_aberrations_bilinear</span><span class="p">(</span><span class="n">aberrations</span><span class="p">,</span> <span class="n">x_pos</span><span class="p">,</span> <span class="n">y_pos</span><span class="p">,</span> <span class="n">SCA_pos</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">extra_aberrations</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">use_aberrations</span> <span class="o">+=</span> <span class="n">extra_aberrations</span>
    <span class="c1"># We don&#39;t want to use piston, tip, or tilt aberrations.  The former doesn&#39;t affect the</span>
    <span class="c1"># appearance of the PSF, and the latter cause centroid shifts.  So, we set the first 4</span>
    <span class="c1"># numbers (corresponding to a place-holder, piston, tip, and tilt) to zero.</span>
    <span class="n">use_aberrations</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.</span>

    <span class="c1"># Now set up the PSF, including the option to simplify the pupil plane.</span>
    <span class="k">if</span> <span class="n">wavelength</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">approximate_struts</span><span class="p">:</span>
            <span class="n">PSF</span> <span class="o">=</span> <span class="n">ChromaticOpticalPSF</span><span class="p">(</span><span class="n">lam</span><span class="o">=</span><span class="n">zemax_wavelength</span><span class="p">,</span>
                                      <span class="n">diam</span><span class="o">=</span><span class="n">diameter</span><span class="p">,</span> <span class="n">aberrations</span><span class="o">=</span><span class="n">use_aberrations</span><span class="p">,</span>
                                      <span class="n">obscuration</span><span class="o">=</span><span class="n">obscuration</span><span class="p">,</span> <span class="n">nstruts</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span>
                                      <span class="n">oversampling</span><span class="o">=</span><span class="n">oversampling</span><span class="p">,</span> <span class="n">gsparams</span><span class="o">=</span><span class="n">gsparams</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">PSF</span> <span class="o">=</span> <span class="n">ChromaticOpticalPSF</span><span class="p">(</span><span class="n">lam</span><span class="o">=</span><span class="n">zemax_wavelength</span><span class="p">,</span>
                                      <span class="n">diam</span><span class="o">=</span><span class="n">diameter</span><span class="p">,</span> <span class="n">aberrations</span><span class="o">=</span><span class="n">use_aberrations</span><span class="p">,</span>
                                      <span class="n">obscuration</span><span class="o">=</span><span class="n">obscuration</span><span class="p">,</span>
                                      <span class="n">pupil_plane_im</span><span class="o">=</span><span class="n">pupil_plane_im</span><span class="p">,</span>
                                      <span class="n">pupil_plane_scale</span><span class="o">=</span><span class="n">pupil_plane_scale</span><span class="p">,</span>
                                      <span class="n">oversampling</span><span class="o">=</span><span class="n">oversampling</span><span class="p">,</span> <span class="n">pad_factor</span><span class="o">=</span><span class="mf">2.</span><span class="p">,</span> <span class="n">gsparams</span><span class="o">=</span><span class="n">gsparams</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">n_waves</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># To decide the range of wavelengths to use, check the bandpass.</span>
            <span class="n">bp_dict</span> <span class="o">=</span> <span class="n">getBandpasses</span><span class="p">()</span>
            <span class="n">bp</span> <span class="o">=</span> <span class="n">bp_dict</span><span class="p">[</span><span class="n">bandpass</span><span class="p">]</span>
            <span class="n">PSF</span> <span class="o">=</span> <span class="n">PSF</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">waves</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">bp</span><span class="o">.</span><span class="n">blue_limit</span><span class="p">,</span> <span class="n">bp</span><span class="o">.</span><span class="n">red_limit</span><span class="p">,</span> <span class="n">n_waves</span><span class="p">),</span>
                                  <span class="n">oversample_fac</span><span class="o">=</span><span class="mf">1.5</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">wavelength</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;wavelength should either be a Bandpass, float, or None.&quot;</span><span class="p">)</span>
        <span class="n">tmp_aberrations</span> <span class="o">=</span> <span class="n">use_aberrations</span> <span class="o">*</span> <span class="n">zemax_wavelength</span> <span class="o">/</span> <span class="n">wavelength</span>
        <span class="k">if</span> <span class="n">approximate_struts</span><span class="p">:</span>
            <span class="n">PSF</span> <span class="o">=</span> <span class="n">OpticalPSF</span><span class="p">(</span><span class="n">lam</span><span class="o">=</span><span class="n">wavelength</span><span class="p">,</span> <span class="n">diam</span><span class="o">=</span><span class="n">diameter</span><span class="p">,</span>
                             <span class="n">aberrations</span><span class="o">=</span><span class="n">tmp_aberrations</span><span class="p">,</span>
                             <span class="n">obscuration</span><span class="o">=</span><span class="n">obscuration</span><span class="p">,</span> <span class="n">nstruts</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span>
                             <span class="n">oversampling</span><span class="o">=</span><span class="n">oversampling</span><span class="p">,</span> <span class="n">gsparams</span><span class="o">=</span><span class="n">gsparams</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">PSF</span> <span class="o">=</span> <span class="n">OpticalPSF</span><span class="p">(</span><span class="n">lam</span><span class="o">=</span><span class="n">wavelength</span><span class="p">,</span> <span class="n">diam</span><span class="o">=</span><span class="n">diameter</span><span class="p">,</span>
                             <span class="n">aberrations</span><span class="o">=</span><span class="n">tmp_aberrations</span><span class="p">,</span>
                             <span class="n">obscuration</span><span class="o">=</span><span class="n">obscuration</span><span class="p">,</span>
                             <span class="n">pupil_plane_im</span><span class="o">=</span><span class="n">pupil_plane_im</span><span class="p">,</span>
                             <span class="n">pupil_plane_scale</span><span class="o">=</span><span class="n">pupil_plane_scale</span><span class="p">,</span>
                             <span class="n">oversampling</span><span class="o">=</span><span class="n">oversampling</span><span class="p">,</span> <span class="n">pad_factor</span><span class="o">=</span><span class="mf">2.</span><span class="p">,</span> <span class="n">gsparams</span><span class="o">=</span><span class="n">gsparams</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">PSF</span>

<span class="k">def</span> <span class="nf">_read_aberrations</span><span class="p">(</span><span class="n">SCA</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This is a helper routine that reads in aberrations for a particular SCA and wavelength (given as</span>
<span class="sd">    galsim.wfirst.wfirst_psfs.zemax_wavelength) from stored files, and returns them along with the</span>
<span class="sd">    field positions.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        SCA:        The identifier for the SCA, from 1-18.</span>

<span class="sd">    Returns:</span>
<span class="sd">        NumPy arrays containing the aberrations, and x and y field positions.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">meta_data</span>
    <span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">pixel_scale</span><span class="p">,</span> <span class="n">n_pix</span>

    <span class="c1"># Construct filename.</span>
    <span class="n">sca_str</span> <span class="o">=</span> <span class="s1">&#39;_</span><span class="si">%02d</span><span class="s1">&#39;</span><span class="o">%</span><span class="n">SCA</span>
    <span class="n">infile</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">meta_data</span><span class="o">.</span><span class="n">share_dir</span><span class="p">,</span>
                          <span class="n">zemax_filepref</span> <span class="o">+</span> <span class="n">sca_str</span> <span class="o">+</span> <span class="n">zemax_filesuff</span><span class="p">)</span>

    <span class="c1"># Read in data.</span>
    <span class="n">dat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="n">infile</span><span class="p">)</span>
    <span class="c1"># It actually has 5 field positions, not just 1, to allow us to make position-dependent PSFs</span>
    <span class="c1"># within an SCA eventually.  Put it in the required format: an array of length (5 field</span>
    <span class="c1"># positions, 23 Zernikes), with the first entry empty (Zernike polynomials are 1-indexed so we</span>
    <span class="c1"># use entries 1-22).  The units are waves.</span>
    <span class="n">aberrations</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span><span class="mi">23</span><span class="p">))</span>
    <span class="n">aberrations</span><span class="p">[:,</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">dat</span><span class="p">[:,</span><span class="mi">5</span><span class="p">:]</span>
    <span class="c1"># Also get the field position.  The file gives it in arcsec with respect to the center, but we</span>
    <span class="c1"># want it in pixels with respect to the corner.</span>
    <span class="n">x_sca_pos</span> <span class="o">=</span> <span class="n">dat</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">pixel_scale</span> <span class="o">+</span> <span class="n">n_pix</span><span class="o">/</span><span class="mi">2</span>
    <span class="n">y_sca_pos</span> <span class="o">=</span> <span class="n">dat</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span><span class="o">/</span><span class="n">pixel_scale</span> <span class="o">+</span> <span class="n">n_pix</span><span class="o">/</span><span class="mi">2</span>
    <span class="k">return</span> <span class="n">aberrations</span><span class="p">,</span> <span class="n">x_sca_pos</span><span class="p">,</span> <span class="n">y_sca_pos</span>

<span class="k">def</span> <span class="nf">_interp_aberrations_bilinear</span><span class="p">(</span><span class="n">aberrations</span><span class="p">,</span> <span class="n">x_pos</span><span class="p">,</span> <span class="n">y_pos</span><span class="p">,</span> <span class="n">SCA_pos</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This is a helper routine to do bilinear interpolation of aberrations defined at 4 field</span>
<span class="sd">    positions: the four corners.  Note that we also have aberrations at the center position,</span>
<span class="sd">    but these are generally quite close (within a few percent) of what would come from this bilinear</span>
<span class="sd">    interpolation.  So for simplicity, we just do the bilinear interpolation.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">min_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">x_pos</span><span class="p">)</span>
    <span class="n">min_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">y_pos</span><span class="p">)</span>
    <span class="n">max_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">x_pos</span><span class="p">)</span>
    <span class="n">max_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">y_pos</span><span class="p">)</span>
    <span class="n">x_frac</span> <span class="o">=</span> <span class="p">(</span><span class="n">SCA_pos</span><span class="o">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">min_x</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">max_x</span> <span class="o">-</span> <span class="n">min_x</span><span class="p">)</span>
    <span class="n">y_frac</span> <span class="o">=</span> <span class="p">(</span><span class="n">SCA_pos</span><span class="o">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">min_y</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">max_y</span> <span class="o">-</span> <span class="n">min_y</span><span class="p">)</span>
    <span class="n">lower_x_lower_y_ab</span> <span class="o">=</span> <span class="n">aberrations</span><span class="p">[(</span><span class="n">x_pos</span><span class="o">==</span><span class="n">min_x</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">y_pos</span><span class="o">==</span><span class="n">min_y</span><span class="p">),</span> <span class="p">:]</span>
    <span class="n">lower_x_upper_y_ab</span> <span class="o">=</span> <span class="n">aberrations</span><span class="p">[(</span><span class="n">x_pos</span><span class="o">==</span><span class="n">min_x</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">y_pos</span><span class="o">==</span><span class="n">max_y</span><span class="p">),</span> <span class="p">:]</span>
    <span class="n">upper_x_lower_y_ab</span> <span class="o">=</span> <span class="n">aberrations</span><span class="p">[(</span><span class="n">x_pos</span><span class="o">==</span><span class="n">max_x</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">y_pos</span><span class="o">==</span><span class="n">min_y</span><span class="p">),</span> <span class="p">:]</span>
    <span class="n">upper_x_upper_y_ab</span> <span class="o">=</span> <span class="n">aberrations</span><span class="p">[(</span><span class="n">x_pos</span><span class="o">==</span><span class="n">max_x</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">y_pos</span><span class="o">==</span><span class="n">max_y</span><span class="p">),</span> <span class="p">:]</span>
    <span class="n">interp_ab</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.0</span><span class="o">-</span><span class="n">x_frac</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mf">1.0</span><span class="o">-</span><span class="n">y_frac</span><span class="p">)</span><span class="o">*</span><span class="n">lower_x_lower_y_ab</span> <span class="o">+</span> \
        <span class="p">(</span><span class="mf">1.0</span><span class="o">-</span><span class="n">x_frac</span><span class="p">)</span><span class="o">*</span><span class="n">y_frac</span><span class="o">*</span><span class="n">lower_x_upper_y_ab</span> <span class="o">+</span> \
        <span class="n">x_frac</span><span class="o">*</span><span class="p">(</span><span class="mf">1.0</span><span class="o">-</span><span class="n">y_frac</span><span class="p">)</span><span class="o">*</span><span class="n">upper_x_lower_y_ab</span> <span class="o">+</span> \
        <span class="n">x_frac</span><span class="o">*</span><span class="n">y_frac</span><span class="o">*</span><span class="n">upper_x_upper_y_ab</span>

    <span class="k">return</span> <span class="n">interp_ab</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
</pre></div>

           </div>
           
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2019, GalSim-developers.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>