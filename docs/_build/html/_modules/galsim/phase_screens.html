<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>galsim.phase_screens &mdash; GalSim 2.5.0 documentation</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/sphinx_highlight.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            GalSim
          </a>
              <div class="version">
                2.5
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../overview.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../install.html">Installation Instructions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tutorials.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../image.html">Images and Related Concepts</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../sb.html">Surface Brightness Profiles</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../chromatic.html">Wavelength-dependent Profiles</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../units.html">Units</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../wcs.html">World Coordinate Systems</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../random.html">Noise and Random Values</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../wl.html">Weak Lensing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../photon.html">Photon Shooting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../utilities.html">Helper Functions and Classes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../errors.html">Errors and Warnings</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../config.html">The Config Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../hsm.html">The HSM Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../des.html">The DES Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../roman.html">The Roman Space Telescope Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../cpp.html">C++ Layer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../shared.html">Shared Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../history.html">Revision History</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">GalSim</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">galsim.phase_screens</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for galsim.phase_screens</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright (c) 2012-2023 by the GalSim developers team on GitHub</span>
<span class="c1"># https://github.com/GalSim-developers</span>
<span class="c1">#</span>
<span class="c1"># This file is part of GalSim: The modular galaxy image simulation toolkit.</span>
<span class="c1"># https://github.com/GalSim-developers/GalSim</span>
<span class="c1">#</span>
<span class="c1"># GalSim is free software: redistribution and use in source and binary forms,</span>
<span class="c1"># with or without modification, are permitted provided that the following</span>
<span class="c1"># conditions are met:</span>
<span class="c1">#</span>
<span class="c1"># 1. Redistributions of source code must retain the above copyright notice, this</span>
<span class="c1">#    list of conditions, and the disclaimer given in the accompanying LICENSE</span>
<span class="c1">#    file.</span>
<span class="c1"># 2. Redistributions in binary form must reproduce the above copyright notice,</span>
<span class="c1">#    this list of conditions, and the disclaimer given in the documentation</span>
<span class="c1">#    and/or other materials provided with the distribution.</span>
<span class="c1">#</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span> <span class="s1">&#39;AtmosphericScreen&#39;</span><span class="p">,</span> <span class="s1">&#39;Atmosphere&#39;</span><span class="p">,</span> <span class="s1">&#39;OpticalScreen&#39;</span><span class="p">,</span> <span class="s1">&#39;UserScreen&#39;</span><span class="p">,</span> <span class="p">]</span>

<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">multiprocessing</span>
<span class="kn">from</span> <span class="nn">contextlib</span> <span class="kn">import</span> <span class="n">contextmanager</span>
<span class="kn">from</span> <span class="nn">numbers</span> <span class="kn">import</span> <span class="n">Real</span>

<span class="kn">from</span> <span class="nn">.random</span> <span class="kn">import</span> <span class="n">BaseDeviate</span><span class="p">,</span> <span class="n">GaussianDeviate</span>
<span class="kn">from</span> <span class="nn">.image</span> <span class="kn">import</span> <span class="n">Image</span>
<span class="kn">from</span> <span class="nn">.angle</span> <span class="kn">import</span> <span class="n">radians</span>
<span class="kn">from</span> <span class="nn">.table</span> <span class="kn">import</span> <span class="n">LookupTable2D</span><span class="p">,</span> <span class="n">_LookupTable2D</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">utilities</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">fft</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">zernike</span>
<span class="kn">from</span> <span class="nn">.utilities</span> <span class="kn">import</span> <span class="n">LRU_Cache</span><span class="p">,</span> <span class="n">lazy_property</span>
<span class="kn">from</span> <span class="nn">.errors</span> <span class="kn">import</span> <span class="n">GalSimRangeError</span><span class="p">,</span> <span class="n">GalSimValueError</span><span class="p">,</span> <span class="n">GalSimIncompatibleValuesError</span>
<span class="kn">from</span> <span class="nn">.errors</span> <span class="kn">import</span> <span class="n">galsim_warn</span><span class="p">,</span> <span class="n">GalSimNotImplementedError</span><span class="p">,</span> <span class="n">GalSimError</span>
<span class="kn">from</span> <span class="nn">.kolmogorov</span> <span class="kn">import</span> <span class="n">Kolmogorov</span>
<span class="kn">from</span> <span class="nn">.airy</span> <span class="kn">import</span> <span class="n">Airy</span>


<span class="c1"># Two helper functions to cache the calculation required for _getStepK</span>
<span class="k">def</span> <span class="nf">__calcAtmStepK</span><span class="p">(</span><span class="n">lam</span><span class="p">,</span> <span class="n">r0_500</span><span class="p">,</span> <span class="n">gsparams</span><span class="p">):</span>
    <span class="c1"># Use a Kolmogorov to get appropriate stepk.</span>
    <span class="n">obj</span> <span class="o">=</span> <span class="n">Kolmogorov</span><span class="p">(</span><span class="n">lam</span><span class="o">=</span><span class="n">lam</span><span class="p">,</span> <span class="n">r0_500</span><span class="o">=</span><span class="n">r0_500</span><span class="p">,</span> <span class="n">gsparams</span><span class="o">=</span><span class="n">gsparams</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">obj</span><span class="o">.</span><span class="n">stepk</span>
<span class="n">_calcAtmStepK</span> <span class="o">=</span> <span class="n">LRU_Cache</span><span class="p">(</span><span class="n">__calcAtmStepK</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">__calcOptStepK</span><span class="p">(</span><span class="n">lam</span><span class="p">,</span> <span class="n">diam</span><span class="p">,</span> <span class="n">obscuration</span><span class="p">,</span> <span class="n">gsparams</span><span class="p">):</span>
    <span class="c1"># Use an Airy to get appropriate stepk.</span>
    <span class="n">obj</span> <span class="o">=</span> <span class="n">Airy</span><span class="p">(</span><span class="n">lam</span><span class="o">=</span><span class="n">lam</span><span class="p">,</span> <span class="n">diam</span><span class="o">=</span><span class="n">diam</span><span class="p">,</span> <span class="n">obscuration</span><span class="o">=</span><span class="n">obscuration</span><span class="p">,</span> <span class="n">gsparams</span><span class="o">=</span><span class="n">gsparams</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">obj</span><span class="o">.</span><span class="n">stepk</span>
<span class="n">_calcOptStepK</span> <span class="o">=</span> <span class="n">LRU_Cache</span><span class="p">(</span><span class="n">__calcOptStepK</span><span class="p">)</span>


<span class="c1"># Global dict of &quot;pointers&quot; (roughly) to shared memory.</span>
<span class="n">_GSScreenShare</span> <span class="o">=</span> <span class="p">{}</span>


<div class="viewcode-block" id="initWorkerArgs"><a class="viewcode-back" href="../../phase_psf.html#galsim.initWorkerArgs">[docs]</a><span class="k">def</span> <span class="nf">initWorkerArgs</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Function used to generate worker arguments to pass to multiprocessing.Pool initializer.</span>

<span class="sd">    See `AtmosphericScreen` docstring for more information.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">_GSScreenShare</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">v</span><span class="p">[</span><span class="s1">&#39;alpha&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">value</span> <span class="o">!=</span> <span class="mf">1.0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">GalSimNotImplementedError</span><span class="p">(</span>
                <span class="s2">&quot;Shared memory use is only supported for frozen-flow screens&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">_GSScreenShare</span><span class="p">,)</span></div>


<div class="viewcode-block" id="initWorker"><a class="viewcode-back" href="../../phase_psf.html#galsim.initWorker">[docs]</a><span class="k">def</span> <span class="nf">initWorker</span><span class="p">(</span><span class="n">share</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Worker initialization function to pass to multiprocessing.Pool initializer.</span>

<span class="sd">    See `AtmosphericScreen` docstring for more information.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_GSScreenShare</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">share</span><span class="p">)</span>  <span class="c1"># pragma: no cover  (covered, but in a fork)</span></div>

<div class="viewcode-block" id="reset_shared_screens"><a class="viewcode-back" href="../../phase_psf.html#galsim.reset_shared_screens">[docs]</a><span class="k">def</span> <span class="nf">reset_shared_screens</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Reset the global dict that contains screens being shared across multiprocessing processes.</span>

<span class="sd">    This is almost never necessary.  However, if you first use one multiprocessing context with</span>
<span class="sd">    `initWorker` and `initWorkerArgs`, and then switch to a different context for another</span>
<span class="sd">    multiprocessing action, the dict we use for storing the shared memory will not be usable</span>
<span class="sd">    in the new context.  In this case, you should reset the global dict before starting</span>
<span class="sd">    the second multiprocessing action by running::</span>

<span class="sd">        galsim.phase_screens.reset_shared_screens()</span>

<span class="sd">    If you only ever use one multiprocessing context in your program, you should never need</span>
<span class="sd">    to call this.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">global</span> <span class="n">_GSScreenShare</span>
    <span class="n">_GSScreenShare</span> <span class="o">=</span> <span class="p">{}</span></div>

<span class="c1"># Helper to let the with Lock() context in the __del__ below timeout if things get borked.</span>
<span class="c1"># From https://stackoverflow.com/questions/71282555/acquire-a-multiprocessing-lock-in-a-with-statement-if-non-blocking-or-with-timeo</span>
<span class="nd">@contextmanager</span>
<span class="k">def</span> <span class="nf">acquire_lock</span><span class="p">(</span><span class="n">lock</span><span class="p">,</span> <span class="n">block</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="n">held</span> <span class="o">=</span> <span class="n">lock</span><span class="o">.</span><span class="n">acquire</span><span class="p">(</span><span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="n">timeout</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">held</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">held</span><span class="p">:</span>
            <span class="n">lock</span><span class="o">.</span><span class="n">release</span><span class="p">()</span>


<div class="viewcode-block" id="AtmosphericScreen"><a class="viewcode-back" href="../../phase_psf.html#galsim.AtmosphericScreen">[docs]</a><span class="k">class</span> <span class="nc">AtmosphericScreen</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; An atmospheric phase screen that can drift in the wind and evolves (&quot;boils&quot;) over time.  The</span>
<span class="sd">    initial phases and fractional phase updates are drawn from a von Karman power spectrum, which is</span>
<span class="sd">    defined by a Fried parameter that effectively sets the amplitude of the turbulence, and an outer</span>
<span class="sd">    scale beyond which the turbulence power flattens.</span>

<span class="sd">    AtmosphericScreen delays the actual instantiation of the phase screen array in memory until it</span>
<span class="sd">    is used for either drawing a PSF or querying the wavefront or wavefront gradient.  This is to</span>
<span class="sd">    facilitate automatic truncation of the screen power spectrum depending on the use case.  For</span>
<span class="sd">    example, when drawing a `PhaseScreenPSF` using Fourier methods, the entire power spectrum should</span>
<span class="sd">    generally be used.  On the other hand, when drawing using photon-shooting and the geometric</span>
<span class="sd">    approximation, it&#39;s better to truncate the high-k modes of the power spectrum here so</span>
<span class="sd">    that they can be handled instead by a SecondKick object (which also happens automatically; see</span>
<span class="sd">    the `PhaseScreenPSF` docstring).  (See Peterson et al. 2015 for more details about the second</span>
<span class="sd">    kick).  Querying the wavefront or wavefront gradient will instantiate the screen using the full</span>
<span class="sd">    power spectrum.</span>

<span class="sd">    This class will normally attempt to sanity check that the screen has been appropriately</span>
<span class="sd">    instantiated depending on the use case, i.e., depending on whether it&#39;s being used to draw with</span>
<span class="sd">    Fourier optics or geometric optics.  If you want to turn this warning off, however, you can</span>
<span class="sd">    use the ``suppress_warning`` keyword argument.</span>

<span class="sd">    If you wish to override the automatic truncation determination, then you can directly</span>
<span class="sd">    instantiate the phase screen array using the `AtmosphericScreen.instantiate` method.</span>

<span class="sd">    Note that once a screen has been instantiated with a particular set of truncation parameters, it</span>
<span class="sd">    cannot be re-instantiated with another set of parameters.</span>

<span class="sd">    **Shared memory**:</span>

<span class="sd">    Instantiated AtmosphericScreen objects can consume a significant amount of memory.  For example,</span>
<span class="sd">    an atmosphere with 6 screens, each extending 819.2 m and with resolution of 10 cm will consume</span>
<span class="sd">    3 GB of memory.  In contexts where both a realistic atmospheric PSF and high throughput via</span>
<span class="sd">    multiprocessing are required, allocating this 3 GB of memory once in a shared memory space</span>
<span class="sd">    accessible to each subprocess (as opposed to once per subprocess) is highly desireable.  We</span>
<span class="sd">    provide a few functions here to enable such usage:</span>

<span class="sd">        - The mp_context keyword argument to AtmosphericScreen.</span>
<span class="sd">          This is used to indicate which multiprocessing process launching context will be used.</span>
<span class="sd">          This is important for setting up the shared memory correctly.</span>
<span class="sd">        - The `initWorker` and `initWorkerArgs` functions.</span>
<span class="sd">          These should be used in a call to multiprocessing.Pool to correctly inform the worker</span>
<span class="sd">          process where to find AtmosphericScreen shared memory.</span>

<span class="sd">    A template example might look something like::</span>

<span class="sd">        import galsim</span>
<span class="sd">        import multiprocessing as mp</span>

<span class="sd">        def work(i, atm):</span>
<span class="sd">            args, moreArgs = fn(i)</span>
<span class="sd">            psf = atm.makePSF(*args)</span>
<span class="sd">            return psf.drawImage(*moreArgs)</span>

<span class="sd">        ctx = mp.get_context(&quot;spawn&quot;)  # &quot;spawn&quot; is generally the safest context available</span>

<span class="sd">        atm = galsim.Atmosphere(..., mp_context=ctx)  # internally calls AtmosphericScreen ctor</span>
<span class="sd">        nProc = 4  # Note, can set this to None to get a good default</span>

<span class="sd">        # Note: Especially if you are using &quot;fork&quot; context, then you want to make sure to run</span>
<span class="sd">        #       your Pool in a single_threaded context.  Even if not, it&#39;s probably a good idea</span>
<span class="sd">        #       so each process isn&#39;t spawning lots of OpenMP (or other) threads.</span>
<span class="sd">        with galsim.utilities.single_threaded():</span>
<span class="sd">            with ctx.Pool(</span>
<span class="sd">                nProc,</span>
<span class="sd">                initializer=galsim.phase_screens.initWorker,</span>
<span class="sd">                initargs=galsim.phase_screens.initWorkerArgs()</span>
<span class="sd">            ) as pool:</span>
<span class="sd">                results = []</span>
<span class="sd">                # First submit</span>
<span class="sd">                for i in range(10):</span>
<span class="sd">                    results.append(pool.apply_async(work, (i, atm)))</span>
<span class="sd">                # Then wait to finish</span>
<span class="sd">                for r in results:</span>
<span class="sd">                    r.wait()</span>
<span class="sd">        # Turn future objects into actual returned images.</span>
<span class="sd">        results = [r.get() for r in results]</span>

<span class="sd">    It is also possible to manually instantiate each of the AtmosphericScreen objects in a</span>
<span class="sd">    `PhaseScreenList` in parallel using a process pool.  This requires knowing what k-scale to</span>
<span class="sd">    truncate the screen at::</span>

<span class="sd">        atm = galsim.Atmosphere(..., mp_context=ctx)</span>
<span class="sd">        with galsim.utilities.single_threaded():</span>
<span class="sd">            with ctx.Pool(</span>
<span class="sd">                nProc,</span>
<span class="sd">                initializer=galsim.phase_screens.initWorker,</span>
<span class="sd">                initargs=galsim.phase_screens.initWorkerArgs()</span>
<span class="sd">            ) as pool:</span>
<span class="sd">                dummyPSF = atm.makePSF(...)</span>
<span class="sd">                kmax = dummyPSF.screen_kmax</span>
<span class="sd">                atm.instantiate(pool=pool, kmax=kmax)</span>

<span class="sd">    Finally, the above multiprocessing shared memory tricks are only currently supported for</span>
<span class="sd">    non-time-evolving screens (alpha=1).</span>

<span class="sd">    **Pickling**:</span>

<span class="sd">    The shared memory portion of an atmospheric screen is not included by default in the pickle of</span>
<span class="sd">    an `AtmosphericScreen` instance.  This means that while it is possible to pickle/unpickle an</span>
<span class="sd">    `AtmosphericScreen` as normal within a single launch of a potentially-multiprocess program, (as</span>
<span class="sd">    long as the shared memory is persistent), a different path is needed to say, create an</span>
<span class="sd">    `AtmosphericScreen` pickle, quit python, restart python, and unpickle the screen.  The same</span>
<span class="sd">    holds for any object that wraps an `AtmosphericScreen` as an attribute as well, which could</span>
<span class="sd">    include, e.g., `PhaseScreenList` or `PhaseScreenPSF`.</span>

<span class="sd">    To get around this limitation, the context manager `galsim.utilities.pickle_shared` can be</span>
<span class="sd">    used.  For example::</span>

<span class="sd">        screen = galsim.AtmosphericScreen(...)</span>
<span class="sd">        with galsim.utilities.pickle_shared():</span>
<span class="sd">            pickle.dump(screen, open(&#39;myScreen.pkl&#39;, &#39;wb&#39;))</span>

<span class="sd">    will pickle both the screen object and any required shared memory used in its definition.</span>
<span class="sd">    Unpickling then proceeds exactly as normal::</span>

<span class="sd">        screen = pickle.load(open(&#39;myScreen.pkl&#39;, &#39;rb&#39;))</span>

<span class="sd">    Parameters:</span>
<span class="sd">        screen_size:        Physical extent of square phase screen in meters.  This should be large</span>
<span class="sd">                            enough to accommodate the desired field-of-view of the telescope as</span>
<span class="sd">                            well as the meta-pupil defined by the wind speed and exposure time.</span>
<span class="sd">                            Note that the screen will have periodic boundary conditions, so while</span>
<span class="sd">                            the code will still run with a small screen, this may introduce</span>
<span class="sd">                            artifacts into PSFs or PSF correlation functions.  Also note that</span>
<span class="sd">                            screen_size may be tweaked by the initializer to ensure ``screen_size``</span>
<span class="sd">                            is a multiple of ``screen_scale``.</span>
<span class="sd">        screen_scale:       Physical pixel scale of phase screen in meters.  An order unity multiple</span>
<span class="sd">                            of the Fried parameter is usually sufficiently small, but users should</span>
<span class="sd">                            test the effects of varying this parameter to ensure robust results.</span>
<span class="sd">                            [default: r0_500]</span>
<span class="sd">        altitude:           Altitude of phase screen in km.  This is with respect to the telescope,</span>
<span class="sd">                            not sea-level.  [default: 0.0]</span>
<span class="sd">        r0_500:             Fried parameter setting the amplitude of turbulence; contributes to</span>
<span class="sd">                            &quot;size&quot; of the resulting atmospheric PSF.  Specified at wavelength 500</span>
<span class="sd">                            nm, in units of meters.  [default: 0.2]</span>
<span class="sd">        L0:                 Outer scale in meters.  The turbulence power spectrum will smoothly</span>
<span class="sd">                            approach a constant at scales larger than L0.  Set to ``None`` or</span>
<span class="sd">                            ``np.inf`` for a power spectrum without an outer scale.  [default: 25.0]</span>
<span class="sd">        vx:                 x-component wind velocity in meters/second.  [default: 0.]</span>
<span class="sd">        vy:                 y-component wind velocity in meters/second.  [default: 0.]</span>
<span class="sd">        alpha:              Square root of fraction of phase that is &quot;remembered&quot; between time_steps</span>
<span class="sd">                            (i.e., alpha**2 is the fraction remembered). The fraction</span>
<span class="sd">                            sqrt(1-alpha**2) is then the amount of turbulence freshly generated in</span>
<span class="sd">                            each step.  Setting alpha=1.0 results in a frozen-flow atmosphere.</span>
<span class="sd">                            Note that computing PSFs from frozen-flow atmospheres may be</span>
<span class="sd">                            significantly faster than computing PSFs with non-frozen-flow</span>
<span class="sd">                            atmospheres.  If ``alpha`` != 1.0, then it is required that a</span>
<span class="sd">                            ``time_step`` is also specified.  [default: 1.0]</span>
<span class="sd">        time_step:          Time interval between phase boiling updates.  Note that this is distinct</span>
<span class="sd">                            from the time interval used to integrate the PSF over time, which is set</span>
<span class="sd">                            by the ``time_step`` keyword argument to `PhaseScreenPSF` or</span>
<span class="sd">                            `PhaseScreenList.makePSF`.  If ``time_step`` is not None, then</span>
<span class="sd">                            it is required that ``alpha`` is set to something other than 1.0.</span>
<span class="sd">                            [default: None]</span>
<span class="sd">        rng:                Random number generator as a `BaseDeviate`.  If None, then use</span>
<span class="sd">                            the clock time or system entropy to seed a new generator.</span>
<span class="sd">                            [default: None]</span>
<span class="sd">        suppress_warning:   Turn off instantiation sanity checking.  (See above)  [default: False]</span>
<span class="sd">        mp_context          GalSim uses shared memory for phase screen allocation to better enable</span>
<span class="sd">                            multiprocessing.  Use this keyword to set the launch context for</span>
<span class="sd">                            multiprocessing.  Usually it will be sufficient to leave this at its</span>
<span class="sd">                            default.  [default: None]</span>

<span class="sd">    Relevant SPIE paper:</span>
<span class="sd">    &quot;Remembrance of phases past: An autoregressive method for generating realistic atmospheres in</span>
<span class="sd">    simulations&quot;</span>
<span class="sd">    Srikar Srinath, Univ. of California, Santa Cruz;</span>
<span class="sd">    Lisa A. Poyneer, Lawrence Livermore National Lab.;</span>
<span class="sd">    Alexander R. Rudy, UCSC; S. Mark Ammons, LLNL</span>
<span class="sd">    Published in Proceedings Volume 9148: Adaptive Optics Systems IV</span>
<span class="sd">    September 2014</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">screen_size</span><span class="p">,</span> <span class="n">screen_scale</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">altitude</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">r0_500</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">L0</span><span class="o">=</span><span class="mf">25.0</span><span class="p">,</span>
                 <span class="n">vx</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">vy</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">time_step</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rng</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">suppress_warning</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">mp_context</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">alpha</span> <span class="o">!=</span> <span class="mf">1.0</span> <span class="ow">and</span> <span class="n">time_step</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">GalSimIncompatibleValuesError</span><span class="p">(</span>
                <span class="s2">&quot;No time_step provided when alpha != 1.0&quot;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">time_step</span><span class="o">=</span><span class="n">time_step</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">alpha</span> <span class="o">==</span> <span class="mf">1.0</span> <span class="ow">and</span> <span class="n">time_step</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">GalSimIncompatibleValuesError</span><span class="p">(</span>
                <span class="s2">&quot;Setting AtmosphericScreen time_step prohibited when alpha == 1.0.  &quot;</span>
                <span class="s2">&quot;Did you mean to set time_step in makePSF or PhaseScreenPSF?&quot;</span><span class="p">,</span>
                <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">time_step</span><span class="o">=</span><span class="n">time_step</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">alpha</span> <span class="o">!=</span> <span class="mf">1.0</span> <span class="ow">and</span> <span class="n">mp_context</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">GalSimNotImplementedError</span><span class="p">(</span>
                <span class="s2">&quot;Shared memory use is only supported for frozen-flow screens&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">screen_scale</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># We copy Jee+Tyson(2011) and (arbitrarily) set the screen scale equal to r0 by default.</span>
            <span class="n">screen_scale</span> <span class="o">=</span> <span class="n">r0_500</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">npix</span> <span class="o">=</span> <span class="n">Image</span><span class="o">.</span><span class="n">good_fft_size</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">screen_size</span><span class="o">/</span><span class="n">screen_scale</span><span class="p">)))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">screen_scale</span> <span class="o">=</span> <span class="n">screen_scale</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">screen_size</span> <span class="o">=</span> <span class="n">screen_scale</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">npix</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_altitude</span> <span class="o">=</span> <span class="n">altitude</span> <span class="o">*</span> <span class="mf">1000.</span>  <span class="c1"># meters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">time_step</span> <span class="o">=</span> <span class="n">time_step</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">r0_500</span> <span class="o">=</span> <span class="n">r0_500</span>
        <span class="k">if</span> <span class="n">L0</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">:</span>  <span class="c1"># Allow np.inf as synonym for None.</span>
            <span class="n">L0</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">L0</span> <span class="o">=</span> <span class="n">L0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vx</span> <span class="o">=</span> <span class="n">vx</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vy</span> <span class="o">=</span> <span class="n">vy</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span> <span class="o">=</span> <span class="n">alpha</span>

        <span class="k">if</span> <span class="n">rng</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">rng</span> <span class="o">=</span> <span class="n">BaseDeviate</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_suppress_warning</span> <span class="o">=</span> <span class="n">suppress_warning</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_orig_rng</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">duplicate</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dynamic</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reversible</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span> <span class="o">==</span> <span class="mf">1.0</span>

        <span class="c1"># Use shared memory for screens.  Allocate it here; fill it in on demand.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mp_context</span><span class="p">,</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">context</span><span class="o">.</span><span class="n">BaseContext</span><span class="p">):</span>
            <span class="n">mp_context</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">get_context</span><span class="p">(</span><span class="n">mp_context</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mp_context</span> <span class="o">=</span> <span class="n">mp_context</span>

        <span class="c1"># A unique id for this screen, created in the parent process, that can be used to find the</span>
        <span class="c1"># correct shared memory object in child processes.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_shareKey</span> <span class="o">=</span> <span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_objDict</span> <span class="o">=</span> <span class="n">AtmosphericScreen</span><span class="o">.</span><span class="n">_initObjDict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mp_context</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">npix</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">)</span>
        <span class="n">_GSScreenShare</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_shareKey</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_objDict</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_initObjDict</span><span class="p">(</span>
        <span class="n">ctx</span><span class="p">,</span> <span class="n">npix</span><span class="p">,</span>
        <span class="n">alpha</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">time</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">kmin</span><span class="o">=-</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">kmax</span><span class="o">=-</span><span class="mf">1.0</span><span class="p">,</span>
        <span class="n">x0</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">y0</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">xperiod</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">yperiod</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
        <span class="n">instantiated</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">refcount</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">f</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>
        <span class="n">RawArray</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="n">RawArray</span>
        <span class="n">RawValue</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="n">RawValue</span>
        <span class="n">Lock</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="n">Lock</span>

        <span class="n">_objDict</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;f&#39;</span><span class="p">:</span><span class="n">RawArray</span><span class="p">(</span><span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="p">(</span><span class="n">npix</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">npix</span><span class="o">+</span><span class="mi">1</span><span class="p">)),</span>
            <span class="s1">&#39;x&#39;</span><span class="p">:</span><span class="n">RawArray</span><span class="p">(</span><span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="n">npix</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span>
            <span class="s1">&#39;y&#39;</span><span class="p">:</span><span class="n">RawArray</span><span class="p">(</span><span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="n">npix</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span>
            <span class="s1">&#39;alpha&#39;</span><span class="p">:</span><span class="n">RawValue</span><span class="p">(</span><span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="p">),</span>
            <span class="s1">&#39;time&#39;</span><span class="p">:</span><span class="n">RawValue</span><span class="p">(</span><span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="n">time</span><span class="p">),</span>
            <span class="s1">&#39;kmin&#39;</span><span class="p">:</span><span class="n">RawValue</span><span class="p">(</span><span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="n">kmin</span><span class="p">),</span>
            <span class="s1">&#39;kmax&#39;</span><span class="p">:</span><span class="n">RawValue</span><span class="p">(</span><span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="n">kmax</span><span class="p">),</span>
            <span class="s1">&#39;x0&#39;</span><span class="p">:</span><span class="n">RawValue</span><span class="p">(</span><span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="n">x0</span><span class="p">),</span>
            <span class="s1">&#39;y0&#39;</span><span class="p">:</span><span class="n">RawValue</span><span class="p">(</span><span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="n">y0</span><span class="p">),</span>
            <span class="s1">&#39;xperiod&#39;</span><span class="p">:</span><span class="n">RawValue</span><span class="p">(</span><span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="n">xperiod</span><span class="p">),</span>
            <span class="s1">&#39;yperiod&#39;</span><span class="p">:</span><span class="n">RawValue</span><span class="p">(</span><span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="n">yperiod</span><span class="p">),</span>
            <span class="s1">&#39;instantiated&#39;</span><span class="p">:</span><span class="n">RawValue</span><span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="n">instantiated</span><span class="p">),</span>
            <span class="s1">&#39;refcount&#39;</span><span class="p">:</span><span class="n">RawValue</span><span class="p">(</span><span class="s1">&#39;i&#39;</span><span class="p">,</span> <span class="n">refcount</span><span class="p">),</span>
            <span class="s1">&#39;lock&#39;</span><span class="p">:</span><span class="n">Lock</span><span class="p">(),</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="n">f</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">np</span><span class="o">.</span><span class="n">frombuffer</span><span class="p">(</span><span class="n">_objDict</span><span class="p">[</span><span class="s1">&#39;f&#39;</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)[:]</span> <span class="o">=</span> <span class="n">f</span>
            <span class="n">np</span><span class="o">.</span><span class="n">frombuffer</span><span class="p">(</span><span class="n">_objDict</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)[:]</span> <span class="o">=</span> <span class="n">x</span>
            <span class="n">np</span><span class="o">.</span><span class="n">frombuffer</span><span class="p">(</span><span class="n">_objDict</span><span class="p">[</span><span class="s1">&#39;y&#39;</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)[:]</span> <span class="o">=</span> <span class="n">y</span>
        <span class="k">return</span> <span class="n">_objDict</span>

    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="n">screenShare</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;screenShare&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
        <span class="n">shareKey</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shareKey</span>
        <span class="k">if</span> <span class="n">screenShare</span> <span class="ow">and</span> <span class="n">shareKey</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">_GSScreenShare</span><span class="p">:</span>
            <span class="n">_GSScreenShare</span><span class="p">[</span><span class="n">shareKey</span><span class="p">]</span> <span class="o">=</span> <span class="n">AtmosphericScreen</span><span class="o">.</span><span class="n">_initObjDict</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mp_context</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">npix</span><span class="p">,</span>
                <span class="n">refcount</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="o">**</span><span class="n">screenShare</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_objDict</span> <span class="o">=</span> <span class="n">_GSScreenShare</span><span class="p">[</span><span class="n">shareKey</span><span class="p">]</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">_objDict</span><span class="p">[</span><span class="s1">&#39;lock&#39;</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_objDict</span><span class="p">[</span><span class="s1">&#39;refcount&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">value</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">state</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;_objDict&#39;</span><span class="p">)</span>
        <span class="n">state</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;_tab2d&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">utilities</span><span class="o">.</span><span class="n">_pickle_shared</span><span class="p">:</span>
            <span class="n">state</span><span class="p">[</span><span class="s1">&#39;screenShare&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getScreenShare</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">state</span>

    <span class="k">def</span> <span class="fm">__del__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_objDict&#39;</span><span class="p">):</span>  <span class="c1"># for if __init__ raised exception</span>
            <span class="k">return</span>
        <span class="k">with</span> <span class="n">acquire_lock</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_objDict</span><span class="p">[</span><span class="s1">&#39;lock&#39;</span><span class="p">],</span> <span class="n">timeout</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span> <span class="k">as</span> <span class="n">acquired</span><span class="p">:</span>
            <span class="c1"># If this can&#39;t acquire the lock, just timeout and return -- don&#39;t hang.</span>
            <span class="c1"># (This seems to happen occasionally, but apparently only here in __del__.)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">acquired</span><span class="p">:</span> <span class="k">return</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_objDict</span><span class="p">[</span><span class="s1">&#39;refcount&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">value</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="c1"># Normally, shareKey is present, but on final cleanup, we have no control over</span>
            <span class="c1"># the order than things are deleted, so it might already be gone, in which</span>
            <span class="c1"># case there can be a KeyError here.</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_objDict</span><span class="p">[</span><span class="s1">&#39;refcount&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shareKey</span> <span class="ow">in</span> <span class="n">_GSScreenShare</span><span class="p">:</span>
                <span class="k">del</span> <span class="n">_GSScreenShare</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_shareKey</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_getScreenShare</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">screenShare</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">_objDict</span><span class="p">[</span><span class="s1">&#39;lock&#39;</span><span class="p">]:</span>
            <span class="n">screenShare</span><span class="p">[</span><span class="s1">&#39;f&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">frombuffer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_objDict</span><span class="p">[</span><span class="s1">&#39;f&#39;</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
            <span class="n">screenShare</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">frombuffer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_objDict</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
            <span class="n">screenShare</span><span class="p">[</span><span class="s1">&#39;y&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">frombuffer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_objDict</span><span class="p">[</span><span class="s1">&#39;y&#39;</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
            <span class="n">screenShare</span><span class="p">[</span><span class="s1">&#39;alpha&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_objDict</span><span class="p">[</span><span class="s1">&#39;alpha&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">value</span>
            <span class="n">screenShare</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_objDict</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">value</span>
            <span class="n">screenShare</span><span class="p">[</span><span class="s1">&#39;kmin&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_objDict</span><span class="p">[</span><span class="s1">&#39;kmin&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">value</span>
            <span class="n">screenShare</span><span class="p">[</span><span class="s1">&#39;kmax&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_objDict</span><span class="p">[</span><span class="s1">&#39;kmax&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">value</span>
            <span class="n">screenShare</span><span class="p">[</span><span class="s1">&#39;x0&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_objDict</span><span class="p">[</span><span class="s1">&#39;x0&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">value</span>
            <span class="n">screenShare</span><span class="p">[</span><span class="s1">&#39;y0&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_objDict</span><span class="p">[</span><span class="s1">&#39;y0&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">value</span>
            <span class="n">screenShare</span><span class="p">[</span><span class="s1">&#39;xperiod&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_objDict</span><span class="p">[</span><span class="s1">&#39;xperiod&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">value</span>
            <span class="n">screenShare</span><span class="p">[</span><span class="s1">&#39;yperiod&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_objDict</span><span class="p">[</span><span class="s1">&#39;yperiod&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">value</span>
            <span class="n">screenShare</span><span class="p">[</span><span class="s1">&#39;instantiated&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_objDict</span><span class="p">[</span><span class="s1">&#39;instantiated&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">value</span>
        <span class="k">return</span> <span class="n">screenShare</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">altitude</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The altitude of the screen in km.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_altitude</span> <span class="o">/</span> <span class="mf">1000.</span>  <span class="c1"># convert back to km</span>

    <span class="nd">@lazy_property</span>
    <span class="k">def</span> <span class="nf">_xs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">npix</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">screen_size</span>

    <span class="nd">@lazy_property</span>
    <span class="k">def</span> <span class="nf">_ys</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xs</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;galsim.AtmosphericScreen(altitude=</span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">altitude</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="s2">&quot;galsim.AtmosphericScreen(</span><span class="si">%r</span><span class="s2">, </span><span class="si">%r</span><span class="s2">, altitude=</span><span class="si">%r</span><span class="s2">, r0_500=</span><span class="si">%r</span><span class="s2">, L0=</span><span class="si">%r</span><span class="s2">, &quot;</span>
                <span class="s2">&quot;vx=</span><span class="si">%r</span><span class="s2">, vy=</span><span class="si">%r</span><span class="s2">, alpha=</span><span class="si">%r</span><span class="s2">, time_step=</span><span class="si">%r</span><span class="s2">, rng=</span><span class="si">%r</span><span class="s2">)&quot;</span><span class="p">)</span> <span class="o">%</span> <span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">screen_size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">screen_scale</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">altitude</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">r0_500</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">L0</span><span class="p">,</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">vx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">vy</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_step</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_orig_rng</span><span class="p">)</span>

    <span class="c1"># While AtmosphericScreen does have mutable internal state, it&#39;s still possible to treat the</span>
    <span class="c1"># object as hashable under the python data model.  The requirements for hashability are that</span>
    <span class="c1"># the hash value never changes during the lifetime of the object, __eq__ is defined, and a == b</span>
    <span class="c1"># implies hash(a) == hash(b).  We also require that if a == b, then f(a) == f(b) for any public</span>
    <span class="c1"># function on an AtmosphericScreen, such as producing a PSF.  Generally, it&#39;s a good idea to</span>
    <span class="c1"># try for hash(a) == hash(b) to imply that it&#39;s very likely that a == b, too.  This is mostly</span>
    <span class="c1"># True for AtmosphericScreen (and derived objects, like PSFs), but note that while we don&#39;t</span>
    <span class="c1"># use the object&#39;s mutable internal state for the hash value, we do use it for the __eq__ test.</span>
    <span class="c1"># In particular, the hash value doesn&#39;t change after the screen is instantiated from its value</span>
    <span class="c1"># before instantiation.  Equality, on the other hand, does change.  An instantiated screen is</span>
    <span class="c1"># not equal to an otherwise identical uninstantiated screen.</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span> <span class="ow">is</span> <span class="n">other</span> <span class="ow">or</span>
                <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">AtmosphericScreen</span><span class="p">)</span> <span class="ow">and</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">screen_size</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">screen_size</span> <span class="ow">and</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">screen_scale</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">screen_scale</span> <span class="ow">and</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">_altitude</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_altitude</span> <span class="ow">and</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">r0_500</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">r0_500</span> <span class="ow">and</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">L0</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">L0</span> <span class="ow">and</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">vx</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">vx</span> <span class="ow">and</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">vy</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">vy</span> <span class="ow">and</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">alpha</span> <span class="ow">and</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">time_step</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">time_step</span> <span class="ow">and</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">_orig_rng</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_orig_rng</span> <span class="ow">and</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">kmin</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">kmin</span> <span class="ow">and</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">kmax</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">kmax</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_hash&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_hash</span> <span class="o">=</span> <span class="nb">hash</span><span class="p">((</span>
                    <span class="s2">&quot;galsim.AtmosphericScreen&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">screen_size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">screen_scale</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">altitude</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">r0_500</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">L0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">vx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">vy</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_step</span><span class="p">,</span>
                    <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_orig_rng</span><span class="o">.</span><span class="n">serialize</span><span class="p">())))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hash</span>

    <span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span> <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">other</span>

<div class="viewcode-block" id="AtmosphericScreen.instantiate"><a class="viewcode-back" href="../../phase_psf.html#galsim.AtmosphericScreen.instantiate">[docs]</a>    <span class="k">def</span> <span class="nf">instantiate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kmin</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span> <span class="n">kmax</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters:</span>
<span class="sd">            kmin:     Minimum k-mode to include when generating phase screens.  Generally this will</span>
<span class="sd">                      only be used when testing the geometric approximation for atmospheric PSFs.</span>
<span class="sd">                      [default: 0]</span>
<span class="sd">            kmax:     Maximum k-mode to include when generating phase screens.  This may be used in</span>
<span class="sd">                      conjunction with SecondKick to complete the geometric approximation for</span>
<span class="sd">                      atmospheric PSFs.  [default: np.inf]</span>
<span class="sd">            check:    Sanity check indicator.  If equal to &#39;FFT&#39;, then check that phase screen</span>
<span class="sd">                      Fourier modes are not being truncated, which is appropriate for full Fourier</span>
<span class="sd">                      optics.  If equal to &#39;phot&#39;, then check that phase screen Fourier modes *are*</span>
<span class="sd">                      being truncated, which is appropriate for the geometric optics approximation.</span>
<span class="sd">                      If ``None``, then don&#39;t perform a check.  Also, don&#39;t perform a check if</span>
<span class="sd">                      self.suppress_warning is True.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_objDict</span><span class="p">[</span><span class="s1">&#39;instantiated&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>
            <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">_objDict</span><span class="p">[</span><span class="s1">&#39;lock&#39;</span><span class="p">]:</span>
                <span class="c1"># Check that another process didn&#39;t finish instantiating</span>
                <span class="c1"># while this process was waiting for the lock</span>
                <span class="c1"># Since this is a race, both branches are only covered probabilistically</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_objDict</span><span class="p">[</span><span class="s1">&#39;instantiated&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>  <span class="c1"># pragma: no branch</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_objDict</span><span class="p">[</span><span class="s1">&#39;kmin&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">kmin</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_objDict</span><span class="p">[</span><span class="s1">&#39;kmax&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">kmax</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_init_psi</span><span class="p">()</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_reset</span><span class="p">()</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">reversible</span><span class="p">:</span>
                        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_psi</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_screen</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ys</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_objDict</span><span class="p">[</span><span class="s1">&#39;instantiated&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="n">check</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_suppress_warning</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">check</span> <span class="o">==</span> <span class="s1">&#39;FFT&#39;</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">kmax</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">:</span>
                    <span class="n">galsim_warn</span><span class="p">(</span><span class="s2">&quot;AtmosphericScreen was instantiated for photon shooting. &quot;</span>
                                <span class="s2">&quot;Drawing now with FFT may yield surprising results.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">check</span> <span class="o">==</span> <span class="s1">&#39;phot&#39;</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">kmax</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">:</span>
                    <span class="n">galsim_warn</span><span class="p">(</span><span class="s2">&quot;AtmosphericScreen was instantiated for FFT drawing. &quot;</span>
                                <span class="s2">&quot;Drawing now with photon shooting may yield surprising results.&quot;</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">kmin</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The minimum k value being used.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_objDict</span><span class="p">[</span><span class="s1">&#39;kmin&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">kmax</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The maximum k value being used.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_objDict</span><span class="p">[</span><span class="s1">&#39;kmax&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_time</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Should only be set in serial context, so no lock</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_objDict</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">value</span>

    <span class="nd">@_time</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">_time</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_objDict</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>

    <span class="c1"># Note the magic number 0.00058 is actually ... wait for it ...</span>
    <span class="c1"># (5 * (24/5 * gamma(6/5))**(5/6) * gamma(11/6)) / (6 * pi**(8/3) * gamma(1/6)) / (2 pi)**2</span>
    <span class="c1"># It&#39;s nearly impossible to figure this out from a single source, but it can be derived from a</span>
    <span class="c1"># combination of Roddier (1981), Sasiela (1994), and Noll (1976).  (These atmosphere people</span>
    <span class="c1"># sure like to work alone... )</span>
    <span class="n">_kolmogorov_constant</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">0.00058</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_init_psi</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Assemble 2D von Karman sqrt power spectrum.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">fx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftfreq</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">npix</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">screen_scale</span><span class="p">)</span>
        <span class="n">fx</span><span class="p">,</span> <span class="n">fy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">fx</span><span class="p">,</span> <span class="n">fx</span><span class="p">)</span>
        <span class="c1"># Faster to avoid as many temporary arrays as possible.  This is just ksq = fx**2 + fy**2.</span>
        <span class="n">ksq</span> <span class="o">=</span> <span class="n">fx</span>
        <span class="n">ksq</span><span class="p">[:,:]</span> <span class="o">*=</span> <span class="n">fx</span>
        <span class="n">ksq</span><span class="p">[:,:]</span> <span class="o">+=</span> <span class="n">fy</span><span class="o">*</span><span class="n">fy</span>

        <span class="c1"># We&#39;ll use ksq as our array for psi too.  So save this mask for later.</span>
        <span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">ksq</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">kmin</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">ksq</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">kmax</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

        <span class="n">old_settings</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">seterr</span><span class="p">(</span><span class="nb">all</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_psi</span> <span class="o">=</span> <span class="n">ksq</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">L0</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">L0_inv</span> <span class="o">=</span> <span class="mf">1.</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">L0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_psi</span><span class="p">[:,:]</span> <span class="o">+=</span> <span class="n">L0_inv</span><span class="o">*</span><span class="n">L0_inv</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_psi</span><span class="p">[:,:]</span> <span class="o">**=</span> <span class="o">-</span><span class="mf">11.</span><span class="o">/</span><span class="mf">12.</span>
        <span class="c1"># Note the multiplication by 500 here so we can divide by arbitrary lam later.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_psi</span><span class="p">[:,:]</span> <span class="o">*=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_kolmogorov_constant</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">r0_500</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="mf">5.0</span><span class="o">/</span><span class="mf">6.0</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">npix</span> <span class="o">*</span>
                           <span class="mf">500.</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">screen_size</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_psi</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_psi</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">np</span><span class="o">.</span><span class="n">seterr</span><span class="p">(</span><span class="o">**</span><span class="n">old_settings</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_random_screen</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate a random phase screen with power spectrum given by self._psi**2&quot;&quot;&quot;</span>
        <span class="n">gd</span> <span class="o">=</span> <span class="n">GaussianDeviate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rng</span><span class="p">)</span>
        <span class="n">noise</span> <span class="o">=</span> <span class="n">utilities</span><span class="o">.</span><span class="n">rand_arr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_psi</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">gd</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">fft</span><span class="o">.</span><span class="n">ifft2</span><span class="p">(</span><span class="n">fft</span><span class="o">.</span><span class="n">fft2</span><span class="p">(</span><span class="n">noise</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_psi</span><span class="p">)</span><span class="o">.</span><span class="n">real</span>

    <span class="k">def</span> <span class="nf">_setShare</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">tab2d</span> <span class="o">=</span> <span class="n">LookupTable2D</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_xs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ys</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_screen</span><span class="p">,</span> <span class="n">edge_mode</span><span class="o">=</span><span class="s1">&#39;wrap&#39;</span><span class="p">)</span>

        <span class="n">xshare</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">frombuffer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_objDict</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">yshare</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">frombuffer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_objDict</span><span class="p">[</span><span class="s1">&#39;y&#39;</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">fshare</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">frombuffer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_objDict</span><span class="p">[</span><span class="s1">&#39;f&#39;</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">fshare</span> <span class="o">=</span> <span class="n">fshare</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">npix</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">npix</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">xshare</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">tab2d</span><span class="o">.</span><span class="n">x</span>
        <span class="n">yshare</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">tab2d</span><span class="o">.</span><span class="n">y</span>
        <span class="n">fshare</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">tab2d</span><span class="o">.</span><span class="n">f</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_objDict</span><span class="p">[</span><span class="s1">&#39;x0&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">tab2d</span><span class="o">.</span><span class="n">x0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_objDict</span><span class="p">[</span><span class="s1">&#39;y0&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">tab2d</span><span class="o">.</span><span class="n">y0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_objDict</span><span class="p">[</span><span class="s1">&#39;xperiod&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">tab2d</span><span class="o">.</span><span class="n">xperiod</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_objDict</span><span class="p">[</span><span class="s1">&#39;yperiod&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">tab2d</span><span class="o">.</span><span class="n">yperiod</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;_tab2d&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

    <span class="nd">@lazy_property</span>
    <span class="k">def</span> <span class="nf">_tab2d</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># If _tab2d hasn&#39;t been overwritten in this process, but it&#39;s use is requested, then</span>
        <span class="c1"># set it up from shared memory.</span>
        <span class="n">xshare</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">frombuffer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_objDict</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">yshare</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">frombuffer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_objDict</span><span class="p">[</span><span class="s1">&#39;y&#39;</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">fshare</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">frombuffer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_objDict</span><span class="p">[</span><span class="s1">&#39;f&#39;</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">fshare</span> <span class="o">=</span> <span class="n">fshare</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">npix</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">npix</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">_LookupTable2D</span><span class="p">(</span>
            <span class="n">xshare</span><span class="p">,</span> <span class="n">yshare</span><span class="p">,</span> <span class="n">fshare</span><span class="p">,</span> <span class="s1">&#39;linear&#39;</span><span class="p">,</span> <span class="s1">&#39;wrap&#39;</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span>
            <span class="n">x0</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_objDict</span><span class="p">[</span><span class="s1">&#39;x0&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">y0</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_objDict</span><span class="p">[</span><span class="s1">&#39;y0&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
            <span class="n">xperiod</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_objDict</span><span class="p">[</span><span class="s1">&#39;xperiod&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">yperiod</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_objDict</span><span class="p">[</span><span class="s1">&#39;yperiod&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">value</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_seek</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set layer&#39;s internal clock to time t.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">t</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">reversible</span><span class="p">:</span>
            <span class="c1"># Can&#39;t reverse, so reset and move forward.</span>
            <span class="k">if</span> <span class="n">t</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">t</span> <span class="o">&lt;</span> <span class="mf">0.0</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">GalSimRangeError</span><span class="p">(</span><span class="s2">&quot;Can&#39;t rewind irreversible screen to t &lt; 0.0&quot;</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="mf">0.</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_reset</span><span class="p">()</span>
            <span class="c1"># Find number of boiling updates we need to perform.</span>
            <span class="n">previous_update_number</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_time</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_step</span><span class="p">)</span>
            <span class="n">final_update_number</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">t</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_step</span><span class="p">)</span>
            <span class="n">n_updates</span> <span class="o">=</span> <span class="n">final_update_number</span> <span class="o">-</span> <span class="n">previous_update_number</span>
            <span class="k">if</span> <span class="n">n_updates</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_updates</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_screen</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_screen</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">1.</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_random_screen</span><span class="p">()</span>
                <span class="c1"># Make a table, copy the x,y,f arrays to shared memory, make a new table that</span>
                <span class="c1"># points to those locations.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_setShare</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_time</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_reset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Reset phase screen back to time=0.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rng</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_orig_rng</span><span class="o">.</span><span class="n">duplicate</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_time</span> <span class="o">=</span> <span class="mf">0.0</span>

        <span class="c1"># Only need to reset/create tab2d if not frozen or doesn&#39;t already exist</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">reversible</span> <span class="ow">or</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_objDict</span><span class="p">[</span><span class="s1">&#39;instantiated&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_screen</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_random_screen</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_setShare</span><span class="p">()</span>

    <span class="c1"># Note -- use **kwargs here so that AtmosphericScreen.stepk and OpticalScreen.stepk</span>
    <span class="c1"># can use the same signature, even though they depend on different parameters.</span>
    <span class="k">def</span> <span class="nf">_getStepK</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return an appropriate stepk for this atmospheric layer.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            lam:            Wavelength in nanometers.</span>
<span class="sd">            gsparams:       An optional `GSParams` argument. [default: None]</span>

<span class="sd">        Returns:</span>
<span class="sd">            Good pupil scale size in meters.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">lam</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;lam&#39;</span><span class="p">]</span>
        <span class="n">gsparams</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;gsparams&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_calcAtmStepK</span><span class="p">(</span><span class="n">lam</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">r0_500</span><span class="p">,</span> <span class="n">gsparams</span><span class="p">)</span>

<div class="viewcode-block" id="AtmosphericScreen.wavefront"><a class="viewcode-back" href="../../phase_psf.html#galsim.AtmosphericScreen.wavefront">[docs]</a>    <span class="k">def</span> <span class="nf">wavefront</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="p">(</span><span class="mf">0.0</span><span class="o">*</span><span class="n">radians</span><span class="p">,</span> <span class="mf">0.0</span><span class="o">*</span><span class="n">radians</span><span class="p">)):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Compute wavefront due to atmospheric phase screen.</span>

<span class="sd">        Wavefront here indicates the distance by which the physical wavefront lags or leads the</span>
<span class="sd">        ideal plane wave.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            u:      Horizontal pupil coordinate (in meters) at which to evaluate wavefront.  Can</span>
<span class="sd">                    be a scalar or an iterable.  The shapes of u and v must match.</span>
<span class="sd">            v:      Vertical pupil coordinate (in meters) at which to evaluate wavefront.  Can</span>
<span class="sd">                    be a scalar or an iterable.  The shapes of u and v must match.</span>
<span class="sd">            t:      Times (in seconds) at which to evaluate wavefront.  Can be None, a scalar or</span>
<span class="sd">                    an iterable.  If None, then the internal time of the phase screens will be</span>
<span class="sd">                    used for all u, v.  If scalar, then the size will be broadcast up to match</span>
<span class="sd">                    that of u and v.  If iterable, then the shape must match the shapes of u and</span>
<span class="sd">                    v.  [default: None]</span>
<span class="sd">            theta:  Field angle at which to evaluate wavefront, as a 2-tuple of `galsim.Angle`</span>
<span class="sd">                    instances. [default: (0.0*galsim.arcmin, 0.0*galsim.arcmin)]  Only a single</span>
<span class="sd">                    theta is permitted.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Array of wavefront lag or lead in nanometers.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">u</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">v</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">GalSimIncompatibleValuesError</span><span class="p">(</span><span class="s2">&quot;u.shape not equal to v.shape&quot;</span><span class="p">,</span><span class="n">u</span><span class="o">=</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="o">=</span><span class="n">v</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">t</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">Real</span><span class="p">):</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
            <span class="n">tmp</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">tmp</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">t</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">u</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">GalSimIncompatibleValuesError</span><span class="p">(</span>
                    <span class="s2">&quot;t.shape must match u.shape if t is not a scalar&quot;</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="n">t</span><span class="p">,</span> <span class="n">u</span><span class="o">=</span><span class="n">u</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">instantiate</span><span class="p">()</span>  <span class="c1"># noop if already instantiated</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">reversible</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wavefront</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">theta</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="n">tmin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
            <span class="n">tmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
            <span class="n">tt</span> <span class="o">=</span> <span class="p">(</span><span class="n">tmin</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_step</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_step</span>
            <span class="k">while</span> <span class="n">tt</span> <span class="o">&lt;=</span> <span class="n">tmax</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_seek</span><span class="p">(</span><span class="n">tt</span><span class="p">)</span>
                <span class="n">here</span> <span class="o">=</span> <span class="p">((</span><span class="n">tt</span> <span class="o">&lt;=</span> <span class="n">t</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">t</span> <span class="o">&lt;</span> <span class="n">tt</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">time_step</span><span class="p">))</span>
                <span class="n">out</span><span class="p">[</span><span class="n">here</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wavefront</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">here</span><span class="p">],</span> <span class="n">v</span><span class="p">[</span><span class="n">here</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="n">here</span><span class="p">],</span> <span class="n">theta</span><span class="p">)</span>
                <span class="n">tt</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_step</span>
            <span class="k">return</span> <span class="n">out</span></div>

    <span class="k">def</span> <span class="nf">_wavefront</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">theta</span><span class="p">):</span>
        <span class="c1"># Same as wavefront(), but no argument checking, no boiling updates, no</span>
        <span class="c1"># screen instantiation checking</span>
        <span class="k">if</span> <span class="n">t</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">u</span> <span class="o">-</span> <span class="n">t</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">vx</span>
        <span class="k">if</span> <span class="n">theta</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">rad</span> <span class="o">!=</span> <span class="mf">0.</span><span class="p">:</span>
            <span class="n">u</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_altitude</span><span class="o">*</span><span class="n">theta</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">tan</span><span class="p">()</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">v</span> <span class="o">-</span> <span class="n">t</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">vy</span>
        <span class="k">if</span> <span class="n">theta</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">rad</span> <span class="o">!=</span> <span class="mf">0.</span><span class="p">:</span>
            <span class="n">v</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_altitude</span><span class="o">*</span><span class="n">theta</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">tan</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tab2d</span><span class="o">.</span><span class="n">_call_wrap</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="n">v</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

<div class="viewcode-block" id="AtmosphericScreen.wavefront_gradient"><a class="viewcode-back" href="../../phase_psf.html#galsim.AtmosphericScreen.wavefront_gradient">[docs]</a>    <span class="k">def</span> <span class="nf">wavefront_gradient</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="p">(</span><span class="mf">0.0</span><span class="o">*</span><span class="n">radians</span><span class="p">,</span> <span class="mf">0.0</span><span class="o">*</span><span class="n">radians</span><span class="p">)):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Compute gradient of wavefront due to atmospheric phase screen.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            u:      Horizontal pupil coordinate (in meters) at which to evaluate wavefront.  Can</span>
<span class="sd">                    be a scalar or an iterable.  The shapes of u and v must match.</span>
<span class="sd">            v:      Vertical pupil coordinate (in meters) at which to evaluate wavefront.  Can</span>
<span class="sd">                    be a scalar or an iterable.  The shapes of u and v must match.</span>
<span class="sd">            t:      Times (in seconds) at which to evaluate wavefront gradient.  Can be None, a</span>
<span class="sd">                    scalar or an iterable.  If None, then the internal time of the phase screens</span>
<span class="sd">                    will be used for all u, v.  If scalar, then the size will be broadcast up to</span>
<span class="sd">                    match that of u and v.  If iterable, then the shape must match the shapes of</span>
<span class="sd">                    u and v.  [default: None]</span>
<span class="sd">            theta:  Field angle at which to evaluate wavefront, as a 2-tuple of `galsim.Angle`</span>
<span class="sd">                    instances. [default: (0.0*galsim.arcmin, 0.0*galsim.arcmin)]  Only a single</span>
<span class="sd">                    theta is permitted.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Arrays dWdu and dWdv of wavefront lag or lead gradient in nm/m.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">u</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">v</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">GalSimIncompatibleValuesError</span><span class="p">(</span><span class="s2">&quot;u.shape not equal to v.shape&quot;</span><span class="p">,</span> <span class="n">u</span><span class="o">=</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="o">=</span><span class="n">v</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">Real</span><span class="p">):</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
            <span class="n">tmp</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">tmp</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">t</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">u</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">GalSimIncompatibleValuesError</span><span class="p">(</span>
                    <span class="s2">&quot;t.shape must match u.shape if t is not a scalar&quot;</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="n">t</span><span class="p">,</span> <span class="n">u</span><span class="o">=</span><span class="n">u</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">instantiate</span><span class="p">()</span>  <span class="c1"># noop if already instantiated</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">reversible</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wavefront_gradient</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">theta</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dwdu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
            <span class="n">dwdv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
            <span class="n">tmin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
            <span class="n">tmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
            <span class="n">tt</span> <span class="o">=</span> <span class="p">(</span><span class="n">tmin</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_step</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_step</span>
            <span class="k">while</span> <span class="n">tt</span> <span class="o">&lt;=</span> <span class="n">tmax</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_seek</span><span class="p">(</span><span class="n">tt</span><span class="p">)</span>
                <span class="n">here</span> <span class="o">=</span> <span class="p">((</span><span class="n">tt</span> <span class="o">&lt;=</span> <span class="n">t</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">t</span> <span class="o">&lt;</span> <span class="n">tt</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">time_step</span><span class="p">))</span>
                <span class="n">dwdu</span><span class="p">[</span><span class="n">here</span><span class="p">],</span> <span class="n">dwdv</span><span class="p">[</span><span class="n">here</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wavefront_gradient</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">here</span><span class="p">],</span> <span class="n">v</span><span class="p">[</span><span class="n">here</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="n">here</span><span class="p">],</span> <span class="n">theta</span><span class="p">)</span>
                <span class="n">tt</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_step</span>
            <span class="k">return</span> <span class="n">dwdu</span><span class="p">,</span> <span class="n">dwdv</span></div>

    <span class="k">def</span> <span class="nf">_wavefront_gradient</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">theta</span><span class="p">):</span>
        <span class="c1"># Same as wavefront(), but no argument checking and no boiling updates.</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">u</span> <span class="o">-</span> <span class="n">t</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">vx</span>
        <span class="k">if</span> <span class="n">theta</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">rad</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">u</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_altitude</span><span class="o">*</span><span class="n">theta</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">tan</span><span class="p">()</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">v</span> <span class="o">-</span> <span class="n">t</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">vy</span>
        <span class="k">if</span> <span class="n">theta</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">rad</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">v</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_altitude</span><span class="o">*</span><span class="n">theta</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">tan</span><span class="p">()</span>
        <span class="n">dfdx</span><span class="p">,</span> <span class="n">dfdy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tab2d</span><span class="o">.</span><span class="n">_gradient_wrap</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="n">v</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">dfdx</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">shape</span><span class="p">),</span> <span class="n">dfdy</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span></div>


<div class="viewcode-block" id="Atmosphere"><a class="viewcode-back" href="../../phase_psf.html#galsim.Atmosphere">[docs]</a><span class="k">def</span> <span class="nf">Atmosphere</span><span class="p">(</span><span class="n">screen_size</span><span class="p">,</span> <span class="n">rng</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">_bar</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Create an atmosphere as a list of turbulent phase screens at different altitudes.  The</span>
<span class="sd">    atmosphere model can then be used to simulate atmospheric PSFs.</span>

<span class="sd">    Simulating an atmospheric PSF is typically accomplished by first representing the 3-dimensional</span>
<span class="sd">    turbulence in the atmosphere as a series of discrete 2-dimensional phase screens.  These screens</span>
<span class="sd">    may blow around in the wind, and may or may not also evolve in time.  This function allows one</span>
<span class="sd">    to quickly assemble a list of atmospheric phase screens into a `galsim.PhaseScreenList` object,</span>
<span class="sd">    which can then be used to evaluate PSFs through various columns of atmosphere at different field</span>
<span class="sd">    angles.</span>

<span class="sd">    The atmospheric screens currently available represent turbulence following a von Karman power</span>
<span class="sd">    spectrum.  Specifically, the phase power spectrum in each screen can be written</span>

<span class="sd">    .. math::</span>
<span class="sd">        \psi(\nu) = 0.023 r_0^{-5/3} \left(\nu^2 + \frac{1}{L_0^2}\right)^{11/6}</span>

<span class="sd">    where :math:`\psi(\nu)` is the power spectral density at spatial frequency :math:`\nu`,</span>
<span class="sd">    :math:`r_0` is the Fried parameter (which has dimensions of length) and sets the amplitude of</span>
<span class="sd">    the turbulence, and :math:`L_0` is the outer scale (also dimensions of length) beyond which the</span>
<span class="sd">    power asymptotically flattens.</span>

<span class="sd">    Typical values for :math:`r_0` are ~0.1 to 0.2 meters, which corresponds roughly to PSF FWHMs</span>
<span class="sd">    of ~0.5 to 1.0 arcsec for optical wavelengths.  Note that :math:`r_0` is a function of</span>
<span class="sd">    wavelength, scaling like :math:`r_0 \sim \lambda^{6/5}`.  To reduce confusion, the input</span>
<span class="sd">    parameter here is named ``r0_500`` and refers explicitly to the Fried parameter at a wavelength</span>
<span class="sd">    of 500 nm.  The outer scale is typically in the 10s of meters and does not vary with wavelength.</span>

<span class="sd">    To create multiple layers, simply specify keyword arguments as length-N lists instead of scalars</span>
<span class="sd">    (works for all arguments except ``rng``).  If, for any of these keyword arguments, you want to</span>
<span class="sd">    use the same value for each layer, then you can just specify the argument as a scalar and the</span>
<span class="sd">    function will automatically broadcast it into a list with length equal to the longest found</span>
<span class="sd">    keyword argument list.  Note that it is an error to specify keywords with lists of different</span>
<span class="sd">    lengths (unless only one of them has length &gt; 1).</span>

<span class="sd">    The one exception to the above is the keyword ``r0_500``.  The effective Fried parameter for a</span>
<span class="sd">    set of atmospheric layers is::</span>

<span class="sd">        r0_500_effective = (sum(r**(-5./3) for r in r0_500s))**(-3./5)</span>

<span class="sd">    Providing ``r0_500`` as a scalar or single-element list will result in broadcasting such that</span>
<span class="sd">    the effective Fried parameter for the whole set of layers equals the input argument.  You can</span>
<span class="sd">    weight the contribution of each layer with the ``r0_weights`` keyword.</span>

<span class="sd">    As an example, the following code approximately creates the atmosphere used by Jee+Tyson(2011)</span>
<span class="sd">    for their study of atmospheric PSFs for LSST.  Note this code takes about ~2 minutes to run on</span>
<span class="sd">    a fast laptop, and will consume about (8192**2 pixels) * (8 bytes) * (6 screens) ~ 3 GB of</span>
<span class="sd">    RAM in its final state, and more at intermediate states.::</span>

<span class="sd">        &gt;&gt;&gt; altitude = [0, 2.58, 5.16, 7.73, 12.89, 15.46]  # km</span>
<span class="sd">        &gt;&gt;&gt; r0_500 = 0.16  # m</span>
<span class="sd">        &gt;&gt;&gt; weights = [0.652, 0.172, 0.055, 0.025, 0.074, 0.022]</span>
<span class="sd">        &gt;&gt;&gt; speed = np.random.uniform(0, 20, size=6)  # m/s</span>
<span class="sd">        &gt;&gt;&gt; direction = [np.random.uniform(0, 360)*galsim.degrees for i in range(6)]</span>
<span class="sd">        &gt;&gt;&gt; npix = 8192</span>
<span class="sd">        &gt;&gt;&gt; screen_scale = r0_500</span>
<span class="sd">        &gt;&gt;&gt; atm = galsim.Atmosphere(r0_500=r0_500, r0_weights=weights,</span>
<span class="sd">                                    screen_size=screen_scale*npix,</span>
<span class="sd">                                    altitude=altitude, L0=25.0, speed=speed,</span>
<span class="sd">                                    direction=direction, screen_scale=screen_scale)</span>

<span class="sd">    Once the atmosphere is constructed, a 15-sec exposure length, 5ms time step, monochromatic PSF</span>
<span class="sd">    at 700nm (using an 8.4 meter aperture, 0.6 fractional obscuration and otherwise default</span>
<span class="sd">    settings) takes about 7 minutes to draw on a fast laptop.::</span>

<span class="sd">        &gt;&gt;&gt; psf = atm.makePSF(lam=700.0, exptime=15.0, time_step=0.005, diam=8.4, obscuration=0.6)</span>
<span class="sd">        &gt;&gt;&gt; img1 = psf.drawImage()  # ~7 min</span>

<span class="sd">    The same psf, if drawn using photon-shooting on the same laptop, will generate photons at a rate</span>
<span class="sd">    of about 1 million per second.::</span>

<span class="sd">        &gt;&gt;&gt; img2 = psf.drawImage(nx=32, ny=32, scale=0.2, method=&#39;phot&#39;, n_photons=1e6)  # ~1 sec.</span>

<span class="sd">    Note that the Fourier-based calculation compute time will scale linearly with exposure time,</span>
<span class="sd">    while the photon-shooting calculation compute time will scale linearly with the number of</span>
<span class="sd">    photons being shot.</span>

<span class="sd">    Many factors will affect the timing of results, of course, including aperture diameter, gsparams</span>
<span class="sd">    settings, pad_factor and oversampling options to makePSF, time_step and exposure time, frozen</span>
<span class="sd">    vs. non-frozen atmospheric layers, and so on.  We recommend that users try varying these</span>
<span class="sd">    settings to find a balance of speed and fidelity.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        r0_500:         Fried parameter setting the amplitude of turbulence; contributes to &quot;size&quot;</span>
<span class="sd">                        of the resulting atmospheric PSF.  Specified at wavelength 500 nm, in units</span>
<span class="sd">                        of meters.  [default: 0.2]</span>
<span class="sd">        r0_weights:     Weights for splitting up the contribution of r0_500 between different</span>
<span class="sd">                        layers.  Note that this keyword is only allowed if r0_500 is either a</span>
<span class="sd">                        scalar or a single-element list.  [default: None]</span>
<span class="sd">        screen_size:    Physical extent of square phase screen in meters.  This should be large</span>
<span class="sd">                        enough to accommodate the desired field-of-view of the telescope as well as</span>
<span class="sd">                        the meta-pupil defined by the wind speed and exposure time.  Note that</span>
<span class="sd">                        the screen will have periodic boundary conditions, so the code will run</span>
<span class="sd">                        with a smaller sized screen, though this may introduce artifacts into PSFs</span>
<span class="sd">                        or PSF correlation functions. Note that screen_size may be tweaked by the</span>
<span class="sd">                        initializer to ensure screen_size is a multiple of screen_scale.</span>
<span class="sd">        screen_scale:   Physical pixel scale of phase screen in meters.  A fraction of the Fried</span>
<span class="sd">                        parameter is usually sufficiently small, but users should test the effects</span>
<span class="sd">                        of this parameter to ensure robust results.</span>
<span class="sd">                        [default: same as each screen&#39;s r0_500]</span>
<span class="sd">        altitude:       Altitude of phase screen in km.  This is with respect to the telescope, not</span>
<span class="sd">                        sea-level.  [default: 0.0]</span>
<span class="sd">        L0:             Outer scale in meters.  The turbulence power spectrum will smoothly</span>
<span class="sd">                        approach a constant at scales larger than L0.  Set to ``None`` or ``np.inf``</span>
<span class="sd">                        for a power spectrum without an outer scale.  [default: 25.0]</span>
<span class="sd">        speed:          Wind speed in meters/second.  [default: 0.0]</span>
<span class="sd">        direction:      Wind direction as `galsim.Angle` [default: 0.0 * galsim.degrees]</span>
<span class="sd">        alpha:          Square root of fraction of phase that is &quot;remembered&quot; between time_steps</span>
<span class="sd">                        (i.e., alpha**2 is the fraction remembered). The fraction sqrt(1-alpha**2)</span>
<span class="sd">                        is then the amount of turbulence freshly generated in each step.  Setting</span>
<span class="sd">                        alpha=1.0 results in a frozen-flow atmosphere.  Note that computing PSFs</span>
<span class="sd">                        from frozen-flow atmospheres may be significantly faster than computing</span>
<span class="sd">                        PSFs with non-frozen-flow atmospheres.  [default: 1.0]</span>
<span class="sd">        time_step:      Time interval between phase boiling updates.  Note that this is distinct</span>
<span class="sd">                        from the time interval used when integrating the PSF over time, which is</span>
<span class="sd">                        set by the ``time_step`` keyword argument to `PhaseScreenPSF` or</span>
<span class="sd">                        `PhaseScreenList.makePSF`.  If ``time_step`` is not None, then it is</span>
<span class="sd">                        required that ``alpha`` is set to something other than 1.0.  [default: None]</span>
<span class="sd">        rng:            Random number generator as a `BaseDeviate`.  If None, then use the</span>
<span class="sd">                        clock time or system entropy to seed a new generator.  [default: None]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Fill in screen_size here, since there isn&#39;t a default in AtmosphericScreen</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;screen_size&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">utilities</span><span class="o">.</span><span class="n">listify</span><span class="p">(</span><span class="n">screen_size</span><span class="p">)</span>

    <span class="c1"># Set default r0_500 here; it will get broadcasted below such that the _total_ r0_500 from _all_</span>
    <span class="c1"># screens is 0.2 m.</span>
    <span class="k">if</span> <span class="s1">&#39;r0_500&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;r0_500&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">]</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;r0_500&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">utilities</span><span class="o">.</span><span class="n">listify</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;r0_500&#39;</span><span class="p">])</span>

    <span class="c1"># Turn speed, direction into vx, vy</span>
    <span class="k">if</span> <span class="s1">&#39;speed&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;speed&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">utilities</span><span class="o">.</span><span class="n">listify</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;speed&#39;</span><span class="p">])</span>
        <span class="k">if</span> <span class="s1">&#39;direction&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;direction&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="o">*</span><span class="n">radians</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;speed&#39;</span><span class="p">])</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;vx&#39;</span><span class="p">],</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;vy&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">v</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">sincos</span><span class="p">())</span>
                                           <span class="k">for</span> <span class="n">v</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;speed&#39;</span><span class="p">],</span>
                                                           <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;direction&#39;</span><span class="p">])])</span>
        <span class="k">del</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;speed&#39;</span><span class="p">]</span>
        <span class="k">del</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;direction&#39;</span><span class="p">]</span>

    <span class="c1"># Determine broadcast size.</span>
    <span class="c1"># Note: treat string as a single scalar value, not a vector of characters</span>
    <span class="n">nmax</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">values</span><span class="p">()</span> <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="s1">&#39;__len__&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="nb">str</span><span class="p">))</span>

    <span class="c1"># Broadcast r0_500 here, since logical combination of indiv layers&#39; r0s is complex:</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;r0_500&#39;</span><span class="p">])</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">r0_weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;r0_weights&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mf">1.</span><span class="p">]</span><span class="o">*</span><span class="n">nmax</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">r0_weights</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">r0_weights</span><span class="p">)</span>
        <span class="n">r0_500</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;r0_500&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;r0_500&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">r0_500</span> <span class="o">*</span> <span class="n">w</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="mf">3.</span><span class="o">/</span><span class="mi">5</span><span class="p">)</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">r0_weights</span><span class="p">]</span>
        <span class="c1"># kwargs[&#39;r0_500&#39;] = [nmax**(3./5) * kwargs[&#39;r0_500&#39;][0]] * nmax</span>
    <span class="k">elif</span> <span class="s1">&#39;r0_weights&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">GalSimIncompatibleValuesError</span><span class="p">(</span>
            <span class="s2">&quot;Cannot use r0_weights if r0_500 is specified as a list.&quot;</span><span class="p">,</span>
            <span class="n">r0_weights</span><span class="o">=</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;r0_weights&#39;</span><span class="p">],</span> <span class="n">r0_500</span><span class="o">=</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;r0_500&#39;</span><span class="p">])</span>

    <span class="k">if</span> <span class="n">rng</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">rng</span> <span class="o">=</span> <span class="n">BaseDeviate</span><span class="p">()</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;rng&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">BaseDeviate</span><span class="p">(</span><span class="n">rng</span><span class="o">.</span><span class="n">raw</span><span class="p">())</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nmax</span><span class="p">)]</span>
    <span class="k">return</span> <span class="n">PhaseScreenList</span><span class="p">([</span><span class="n">AtmosphericScreen</span><span class="p">(</span><span class="o">**</span><span class="n">kw</span><span class="p">)</span> <span class="k">for</span> <span class="n">kw</span> <span class="ow">in</span> <span class="n">utilities</span><span class="o">.</span><span class="n">dol_to_lod</span><span class="p">(</span><span class="n">kwargs</span><span class="p">,</span> <span class="n">nmax</span><span class="p">)])</span></div>


<div class="viewcode-block" id="OpticalScreen"><a class="viewcode-back" href="../../phase_psf.html#galsim.OpticalScreen">[docs]</a><span class="k">class</span> <span class="nc">OpticalScreen</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class to describe optical aberrations in terms of Zernike polynomial coefficients.</span>

<span class="sd">    Input aberration coefficients are assumed to be supplied in units of wavelength, and correspond</span>
<span class="sd">    to the Zernike polynomials in the Noll convention defined in</span>
<span class="sd">    Noll, J. Opt. Soc. Am. 66, 207-211(1976).  For a brief summary of the polynomials, refer to</span>
<span class="sd">    http://en.wikipedia.org/wiki/Zernike_polynomials#Zernike_polynomials.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        diam:               Diameter of pupil in meters.</span>
<span class="sd">        tip:                Tip aberration in units of reference wavelength.  [default: 0]</span>
<span class="sd">        tilt:               Tilt aberration in units of reference wavelength.  [default: 0]</span>
<span class="sd">        defocus:            Defocus in units of reference wavelength. [default: 0]</span>
<span class="sd">        astig1:             Astigmatism (like e2) in units of reference wavelength.</span>
<span class="sd">                            [default: 0]</span>
<span class="sd">        astig2:             Astigmatism (like e1) in units of reference wavelength.</span>
<span class="sd">                            [default: 0]</span>
<span class="sd">        coma1:              Coma along y in units of reference wavelength. [default: 0]</span>
<span class="sd">        coma2:              Coma along x in units of reference wavelength. [default: 0]</span>
<span class="sd">        trefoil1:           Trefoil (one of the arrows along y) in units of reference wavelength.</span>
<span class="sd">                            [default: 0]</span>
<span class="sd">        trefoil2:           Trefoil (one of the arrows along x) in units of reference wavelength.</span>
<span class="sd">                            [default: 0]</span>
<span class="sd">        spher:              Spherical aberration in units of reference wavelength.</span>
<span class="sd">                            [default: 0]</span>
<span class="sd">        aberrations:        Optional keyword, to pass in a list, tuple, or NumPy array of</span>
<span class="sd">                            aberrations in units of reference wavelength (ordered according to</span>
<span class="sd">                            the Noll convention), rather than passing in individual values for each</span>
<span class="sd">                            individual aberration.  Note that aberrations[1] is piston (and not</span>
<span class="sd">                            aberrations[0], which is unused.)  This list can be arbitrarily long to</span>
<span class="sd">                            handle Zernike polynomial aberrations of arbitrary order.</span>
<span class="sd">        annular_zernike:    Boolean indicating that aberrations specify the amplitudes of annular</span>
<span class="sd">                            Zernike polynomials instead of circular Zernike polynomials.</span>
<span class="sd">                            [default: False]</span>
<span class="sd">        obscuration:        Linear dimension of central obscuration as fraction of aperture linear</span>
<span class="sd">                            dimension. [0., 1.).  Note it is the user&#39;s responsibility to ensure</span>
<span class="sd">                            consistency of `OpticalScreen` obscuration and `Aperture` obscuration.</span>
<span class="sd">                            [default: 0.0]</span>
<span class="sd">        lam_0:              Reference wavelength in nanometers at which Zernike aberrations are</span>
<span class="sd">                            being specified.  [default: 500]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dynamic</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">reversible</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">diam</span><span class="p">,</span> <span class="n">tip</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">tilt</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">defocus</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">astig1</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">astig2</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">coma1</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
                 <span class="n">coma2</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">trefoil1</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">trefoil2</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">spher</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">aberrations</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">annular_zernike</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">obscuration</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">lam_0</span><span class="o">=</span><span class="mf">500.0</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">diam</span> <span class="o">=</span> <span class="n">diam</span>
        <span class="k">if</span> <span class="n">aberrations</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">aberrations</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span>
            <span class="n">aberrations</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">tip</span>
            <span class="n">aberrations</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">tilt</span>
            <span class="n">aberrations</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">defocus</span>
            <span class="n">aberrations</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="n">astig1</span>
            <span class="n">aberrations</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="n">astig2</span>
            <span class="n">aberrations</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="n">coma1</span>
            <span class="n">aberrations</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="n">coma2</span>
            <span class="n">aberrations</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span> <span class="o">=</span> <span class="n">trefoil1</span>
            <span class="n">aberrations</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="n">trefoil2</span>
            <span class="n">aberrations</span><span class="p">[</span><span class="mi">11</span><span class="p">]</span> <span class="o">=</span> <span class="n">spher</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Make sure no individual aberrations were passed in, since they will be ignored.</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">([</span><span class="n">tip</span><span class="p">,</span> <span class="n">tilt</span><span class="p">,</span> <span class="n">defocus</span><span class="p">,</span> <span class="n">astig1</span><span class="p">,</span> <span class="n">astig2</span><span class="p">,</span> <span class="n">coma1</span><span class="p">,</span> <span class="n">coma2</span><span class="p">,</span> <span class="n">trefoil1</span><span class="p">,</span> <span class="n">trefoil2</span><span class="p">,</span> <span class="n">spher</span><span class="p">]):</span>
                <span class="k">raise</span> <span class="n">GalSimIncompatibleValuesError</span><span class="p">(</span>
                    <span class="s2">&quot;Cannot pass in individual aberrations and array.&quot;</span><span class="p">,</span>
                    <span class="n">tip</span><span class="o">=</span><span class="n">tip</span><span class="p">,</span> <span class="n">tilt</span><span class="o">=</span><span class="n">tilt</span><span class="p">,</span> <span class="n">defocus</span><span class="o">=</span><span class="n">defocus</span><span class="p">,</span> <span class="n">astig1</span><span class="o">=</span><span class="n">astig1</span><span class="p">,</span> <span class="n">astig2</span><span class="o">=</span><span class="n">astig2</span><span class="p">,</span>
                    <span class="n">coma1</span><span class="o">=</span><span class="n">coma1</span><span class="p">,</span> <span class="n">coma2</span><span class="o">=</span><span class="n">coma2</span><span class="p">,</span> <span class="n">trefoil1</span><span class="o">=</span><span class="n">trefoil1</span><span class="p">,</span> <span class="n">trefoil2</span><span class="o">=</span><span class="n">trefoil2</span><span class="p">,</span>
                    <span class="n">spher</span><span class="o">=</span><span class="n">spher</span><span class="p">,</span> <span class="n">aberrations</span><span class="o">=</span><span class="n">aberrations</span><span class="p">)</span>
            <span class="c1"># Aberrations were passed in, so check for right number of entries.</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">aberrations</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">GalSimValueError</span><span class="p">(</span><span class="s2">&quot;Aberrations keyword must have length &gt;= 2&quot;</span><span class="p">,</span> <span class="n">aberrations</span><span class="p">)</span>
            <span class="c1"># Check for non-zero value in first two places.  Probably a mistake.</span>
            <span class="k">if</span> <span class="n">aberrations</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mf">0.0</span><span class="p">:</span>
                <span class="n">galsim_warn</span><span class="p">(</span><span class="s2">&quot;Detected non-zero value in aberrations[0] -- this value is ignored!&quot;</span><span class="p">)</span>
            <span class="n">aberrations</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">aberrations</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">aberrations</span> <span class="o">=</span> <span class="n">aberrations</span>

        <span class="c1"># strip any trailing zeros.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">aberrations</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">aberrations</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">trim_zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">aberrations</span><span class="p">,</span> <span class="n">trim</span><span class="o">=</span><span class="s1">&#39;b&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">aberrations</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># Don&#39;t let it be length zero or one though.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">aberrations</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">annular_zernike</span> <span class="o">=</span> <span class="n">annular_zernike</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">obscuration</span> <span class="o">=</span> <span class="n">obscuration</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lam_0</span> <span class="o">=</span> <span class="n">lam_0</span>

        <span class="n">R_outer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">diam</span><span class="o">/</span><span class="mi">2</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">annular_zernike</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">obscuration</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_zernike</span> <span class="o">=</span> <span class="n">zernike</span><span class="o">.</span><span class="n">Zernike</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">aberrations</span><span class="p">,</span> <span class="n">R_outer</span><span class="o">=</span><span class="n">R_outer</span><span class="p">,</span>
                                            <span class="n">R_inner</span><span class="o">=</span><span class="n">R_outer</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">obscuration</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_zernike</span> <span class="o">=</span> <span class="n">zernike</span><span class="o">.</span><span class="n">Zernike</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">aberrations</span><span class="p">,</span> <span class="n">R_outer</span><span class="o">=</span><span class="n">R_outer</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;galsim.OpticalScreen(diam=</span><span class="si">%s</span><span class="s2">, lam_0=</span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">diam</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lam_0</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;galsim.OpticalScreen(diam=</span><span class="si">%r</span><span class="s2">, lam_0=</span><span class="si">%r</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">diam</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lam_0</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">aberrations</span><span class="p">):</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;, aberrations=</span><span class="si">%r</span><span class="s2">&quot;</span><span class="o">%</span><span class="bp">self</span><span class="o">.</span><span class="n">aberrations</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">annular_zernike</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;, annular_zernike=True&quot;</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;, obscuration=</span><span class="si">%r</span><span class="s2">&quot;</span><span class="o">%</span><span class="bp">self</span><span class="o">.</span><span class="n">obscuration</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;)&quot;</span>
        <span class="k">return</span> <span class="n">s</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span> <span class="ow">is</span> <span class="n">other</span> <span class="ow">or</span>
                <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">OpticalScreen</span><span class="p">)</span>
                 <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">diam</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">diam</span>
                 <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">aberrations</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">lam_0</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">aberrations</span><span class="o">*</span><span class="n">other</span><span class="o">.</span><span class="n">lam_0</span><span class="p">)</span>
                 <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">annular_zernike</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">annular_zernike</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span> <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">other</span>

    <span class="c1"># This screen is immutable, so make a hash for it.</span>
    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">((</span><span class="s2">&quot;galsim.OpticalScreen&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">diam</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">obscuration</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">annular_zernike</span><span class="p">,</span>
                     <span class="nb">tuple</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">aberrations</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">lam_0</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">())))</span>

    <span class="c1"># Note -- use **kwargs here so that AtmosphericScreen.stepk and OpticalScreen.stepk</span>
    <span class="c1"># can use the same signature, even though they depend on different parameters.</span>
    <span class="k">def</span> <span class="nf">_getStepK</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return an appropriate stepk for this phase screen.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            lam:            Wavelength in nanometers.</span>
<span class="sd">            diam:           Aperture diameter in meters.</span>
<span class="sd">            obscuration:    Fractional linear aperture obscuration. [default: 0.0]</span>
<span class="sd">            gsparams:       An optional `GSParams` argument. [default: None]</span>

<span class="sd">        Returns:</span>
<span class="sd">            stepk in inverse arcsec.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">lam</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;lam&#39;</span><span class="p">]</span>
        <span class="n">diam</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;diam&#39;</span><span class="p">]</span>
        <span class="n">obscuration</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;obscuration&#39;</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
        <span class="n">gsparams</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;gsparams&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_calcOptStepK</span><span class="p">(</span><span class="n">lam</span><span class="p">,</span> <span class="n">diam</span><span class="p">,</span> <span class="n">obscuration</span><span class="p">,</span> <span class="n">gsparams</span><span class="p">)</span>

<div class="viewcode-block" id="OpticalScreen.wavefront"><a class="viewcode-back" href="../../phase_psf.html#galsim.OpticalScreen.wavefront">[docs]</a>    <span class="k">def</span> <span class="nf">wavefront</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Compute wavefront due to optical phase screen.</span>

<span class="sd">        Wavefront here indicates the distance by which the physical wavefront lags or leads the</span>
<span class="sd">        ideal plane wave.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            u:      Horizontal pupil coordinate (in meters) at which to evaluate wavefront.  Can</span>
<span class="sd">                    be a scalar or an iterable.  The shapes of u and v must match.</span>
<span class="sd">            v:      Vertical pupil coordinate (in meters) at which to evaluate wavefront.  Can</span>
<span class="sd">                    be a scalar or an iterable.  The shapes of u and v must match.</span>
<span class="sd">            t:      Ignored for `OpticalScreen`.</span>
<span class="sd">            theta:  Ignored for `OpticalScreen`.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Array of wavefront lag or lead in nanometers.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">u</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">v</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">GalSimIncompatibleValuesError</span><span class="p">(</span><span class="s2">&quot;u.shape not equal to v.shape&quot;</span><span class="p">,</span> <span class="n">u</span><span class="o">=</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="o">=</span><span class="n">v</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wavefront</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">theta</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_wavefront</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">theta</span><span class="p">):</span>
        <span class="c1"># Same as wavefront(), but no argument checking.</span>
        <span class="c1"># Note, this phase screen is actually independent of time and theta.</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_zernike</span><span class="o">.</span><span class="n">evalCartesian</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">lam_0</span>

<div class="viewcode-block" id="OpticalScreen.wavefront_gradient"><a class="viewcode-back" href="../../phase_psf.html#galsim.OpticalScreen.wavefront_gradient">[docs]</a>    <span class="k">def</span> <span class="nf">wavefront_gradient</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Compute gradient of wavefront due to optical phase screen.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            u:      Horizontal pupil coordinate (in meters) at which to evaluate wavefront.  Can</span>
<span class="sd">                    be a scalar or an iterable.  The shapes of u and v must match.</span>
<span class="sd">            v:      Vertical pupil coordinate (in meters) at which to evaluate wavefront.  Can</span>
<span class="sd">                    be a scalar or an iterable.  The shapes of u and v must match.</span>
<span class="sd">            t:      Ignored for `OpticalScreen`.</span>
<span class="sd">            theta:  Ignored for `OpticalScreen`.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Arrays dWdu and dWdv of wavefront lag or lead gradient in nm/m.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">u</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">v</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">GalSimIncompatibleValuesError</span><span class="p">(</span><span class="s2">&quot;u.shape not equal to v.shape&quot;</span><span class="p">,</span> <span class="n">u</span><span class="o">=</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="o">=</span><span class="n">v</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wavefront_gradient</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">theta</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="nf">_wavefront_gradient</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">theta</span><span class="p">):</span>
        <span class="c1"># Same as wavefront(), but no argument checking.</span>
        <span class="c1"># Note, this phase screen is actually independent of time and theta.</span>
        <span class="n">gradx</span><span class="p">,</span> <span class="n">grady</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_zernike</span><span class="o">.</span><span class="n">evalCartesianGrad</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
        <span class="n">gradx</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lam_0</span>
        <span class="n">grady</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lam_0</span>
        <span class="k">return</span> <span class="n">gradx</span><span class="p">,</span> <span class="n">grady</span></div>


<span class="c1"># Used only for testing</span>
<span class="k">class</span> <span class="nc">_DummyScreen</span><span class="p">(</span><span class="n">OpticalScreen</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">_wavefront</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">GalSimError</span><span class="p">(</span><span class="s2">&quot;Shouldn&#39;t reach this&quot;</span><span class="p">)</span>


<div class="viewcode-block" id="UserScreen"><a class="viewcode-back" href="../../phase_psf.html#galsim.UserScreen">[docs]</a><span class="k">class</span> <span class="nc">UserScreen</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Create a (static) user-defined phase screen.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        table:        LookupTable2D instance representing the wavefront as a function on the</span>
<span class="sd">                      entrance pupil.  Units are (meters, meters) -&gt; nanometers.</span>
<span class="sd">        diam:         Diameter of entrance pupil in meters.  If None, then use the length of the</span>
<span class="sd">                      larger side of the LookupTable2D rectangle in ``table``.  This keyword is only</span>
<span class="sd">                      used to compute a value for stepk, and thus has no effect on the</span>
<span class="sd">                      ``wavefront()`` or ``wavefront_gradient()`` methods.</span>
<span class="sd">        obscuration:  Optional fractional circular obscuration of pupil.  Like ``diam``, only used</span>
<span class="sd">                      for computing a value for stepk.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dynamic</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">reversible</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">table</span><span class="p">,</span> <span class="n">diam</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">obscuration</span><span class="o">=</span><span class="mf">0.0</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">table</span> <span class="o">=</span> <span class="n">table</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">diam</span> <span class="o">=</span> <span class="n">diam</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">obscuration</span> <span class="o">=</span> <span class="n">obscuration</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">out</span> <span class="o">=</span> <span class="s2">&quot;galsim.UserScreen(</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">table</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">diam</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">+=</span> <span class="s2">&quot;, diam=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">diam</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">obscuration</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">+=</span> <span class="s2">&quot;, obscuration=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obscuration</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">+=</span> <span class="s2">&quot;)&quot;</span>
        <span class="k">return</span> <span class="n">out</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">out</span> <span class="o">=</span> <span class="s2">&quot;galsim.UserScreen(</span><span class="si">{!r}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">table</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">diam</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">+=</span> <span class="s2">&quot;, diam=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">diam</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">obscuration</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">+=</span> <span class="s2">&quot;, obscuration=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obscuration</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">+=</span> <span class="s2">&quot;)&quot;</span>
        <span class="k">return</span> <span class="n">out</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rhs</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">rhs</span><span class="p">,</span> <span class="n">UserScreen</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">table</span> <span class="o">==</span> <span class="n">rhs</span><span class="o">.</span><span class="n">table</span>
                <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">diam</span> <span class="o">==</span> <span class="n">rhs</span><span class="o">.</span><span class="n">diam</span>
                <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">obscuration</span> <span class="o">==</span> <span class="n">rhs</span><span class="o">.</span><span class="n">obscuration</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rhs</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">rhs</span>

    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">((</span><span class="s2">&quot;UserScreen&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">table</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">diam</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">obscuration</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_getStepK</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return an appropriate stepk for this phase screen.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            lam:            Wavelength in nanometers.</span>
<span class="sd">            gsparams:       An optional `GSParams` argument. [default: None]</span>

<span class="sd">        Returns:</span>
<span class="sd">            stepk in inverse arcsec.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">lam</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;lam&#39;</span><span class="p">]</span>
        <span class="n">gsparams</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;gsparams&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">diam</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">diam</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">diam</span> <span class="k">else</span> <span class="nb">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ptp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">table</span><span class="o">.</span><span class="n">x</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">ptp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">table</span><span class="o">.</span><span class="n">y</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">_calcOptStepK</span><span class="p">(</span><span class="n">lam</span><span class="p">,</span> <span class="n">diam</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">obscuration</span><span class="p">,</span> <span class="n">gsparams</span><span class="p">)</span>

<div class="viewcode-block" id="UserScreen.wavefront"><a class="viewcode-back" href="../../phase_psf.html#galsim.UserScreen.wavefront">[docs]</a>    <span class="k">def</span> <span class="nf">wavefront</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Evaluate wavefront from lookup table.</span>

<span class="sd">        Wavefront here indicates the distance by which the physical wavefront lags or leads the</span>
<span class="sd">        ideal plane wave.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            u:      Horizontal pupil coordinate (in meters) at which to evaluate wavefront.  Can</span>
<span class="sd">                    be a scalar or an iterable.  The shapes of u and v must match.</span>
<span class="sd">            v:      Vertical pupil coordinate (in meters) at which to evaluate wavefront.  Can</span>
<span class="sd">                    be a scalar or an iterable.  The shapes of u and v must match.</span>
<span class="sd">            t:      Ignored for `UserScreen`.</span>
<span class="sd">            theta:  Ignored for `UserScreen`.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Array of wavefront lag or lead in nanometers.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">table</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_wavefront</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">theta</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">table</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>

<div class="viewcode-block" id="UserScreen.wavefront_gradient"><a class="viewcode-back" href="../../phase_psf.html#galsim.UserScreen.wavefront_gradient">[docs]</a>    <span class="k">def</span> <span class="nf">wavefront_gradient</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Evaluate gradient of wavefront from lookup table.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            u:      Horizontal pupil coordinate (in meters) at which to evaluate wavefront.  Can</span>
<span class="sd">                    be a scalar or an iterable.  The shapes of u and v must match.</span>
<span class="sd">            v:      Vertical pupil coordinate (in meters) at which to evaluate wavefront.  Can</span>
<span class="sd">                    be a scalar or an iterable.  The shapes of u and v must match.</span>
<span class="sd">            t:      Ignored for `UserScreen`.</span>
<span class="sd">            theta:  Ignored for `UserScreen`.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Arrays dWdu and dWdv of wavefront lag or lead gradient in nm/m.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">table</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_wavefront_gradient</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">theta</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">table</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span></div>

<span class="c1"># Put this at the end to avoid circular imports</span>
<span class="kn">from</span> <span class="nn">.phase_psf</span> <span class="kn">import</span> <span class="n">PhaseScreenList</span>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, GalSim-developers.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>