

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>galsim.phase_psf &mdash; GalSim 2.2.0 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../_static/language_data.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home"> GalSim
          

          
          </a>

          
            
            
              <div class="version">
                2.2
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../overview.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../install.html">Installation Instructions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tutorials.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../image.html">Images and Related Concepts</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../sb.html">Surface Brightness Profiles</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../chromatic.html">Wavelength-dependent Profiles</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../units.html">Units</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../wcs.html">World Coordinate Systems</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../random.html">Noise and Random Values</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../wl.html">Weak Lensing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../photon.html">Photon Shooting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../utilities.html">Helper Functions and Classes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../errors.html">Errors and Warnings</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../config.html">The Config Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../hsm.html">The HSM Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../des.html">The DES Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../wfirst.html">The WFIRST Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../shared.html">Shared Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../history.html">Revision History</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">GalSim</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
      <li>galsim.phase_psf</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for galsim.phase_psf</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright (c) 2012-2019 by the GalSim developers team on GitHub</span>
<span class="c1"># https://github.com/GalSim-developers</span>
<span class="c1">#</span>
<span class="c1"># This file is part of GalSim: The modular galaxy image simulation toolkit.</span>
<span class="c1"># https://github.com/GalSim-developers/GalSim</span>
<span class="c1">#</span>
<span class="c1"># GalSim is free software: redistribution and use in source and binary forms,</span>
<span class="c1"># with or without modification, are permitted provided that the following</span>
<span class="c1"># conditions are met:</span>
<span class="c1">#</span>
<span class="c1"># 1. Redistributions of source code must retain the above copyright notice, this</span>
<span class="c1">#    list of conditions, and the disclaimer given in the accompanying LICENSE</span>
<span class="c1">#    file.</span>
<span class="c1"># 2. Redistributions in binary form must reproduce the above copyright notice,</span>
<span class="c1">#    this list of conditions, and the disclaimer given in the documentation</span>
<span class="c1">#    and/or other materials provided with the distribution.</span>
<span class="c1">#</span>

<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">past.builtins</span> <span class="k">import</span> <span class="n">basestring</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="k">import</span> <span class="n">chain</span>
<span class="kn">from</span> <span class="nn">builtins</span> <span class="k">import</span> <span class="nb">range</span>
<span class="kn">from</span> <span class="nn">heapq</span> <span class="k">import</span> <span class="n">heappush</span><span class="p">,</span> <span class="n">heappop</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">.gsobject</span> <span class="k">import</span> <span class="n">GSObject</span>
<span class="kn">from</span> <span class="nn">.gsparams</span> <span class="k">import</span> <span class="n">GSParams</span>
<span class="kn">from</span> <span class="nn">.angle</span> <span class="k">import</span> <span class="n">radians</span><span class="p">,</span> <span class="n">degrees</span><span class="p">,</span> <span class="n">arcsec</span><span class="p">,</span> <span class="n">Angle</span><span class="p">,</span> <span class="n">AngleUnit</span>
<span class="kn">from</span> <span class="nn">.image</span> <span class="k">import</span> <span class="n">Image</span><span class="p">,</span> <span class="n">_Image</span>
<span class="kn">from</span> <span class="nn">.bounds</span> <span class="k">import</span> <span class="n">_BoundsI</span>
<span class="kn">from</span> <span class="nn">.wcs</span> <span class="k">import</span> <span class="n">PixelScale</span>
<span class="kn">from</span> <span class="nn">.interpolatedimage</span> <span class="k">import</span> <span class="n">InterpolatedImage</span>
<span class="kn">from</span> <span class="nn">.utilities</span> <span class="k">import</span> <span class="n">doc_inherit</span><span class="p">,</span> <span class="n">OrderedWeakRef</span><span class="p">,</span> <span class="n">rotate_xy</span><span class="p">,</span> <span class="n">lazy_property</span>
<span class="kn">from</span> <span class="nn">.errors</span> <span class="k">import</span> <span class="n">GalSimError</span><span class="p">,</span> <span class="n">GalSimValueError</span><span class="p">,</span> <span class="n">GalSimRangeError</span><span class="p">,</span> <span class="n">GalSimIncompatibleValuesError</span>
<span class="kn">from</span> <span class="nn">.errors</span> <span class="k">import</span> <span class="n">GalSimFFTSizeError</span><span class="p">,</span> <span class="n">galsim_warn</span>

<div class="viewcode-block" id="Aperture"><a class="viewcode-back" href="../../phase_psf.html#galsim.Aperture">[docs]</a><span class="k">class</span> <span class="nc">Aperture</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Class representing a telescope aperture embedded in a larger pupil plane array -- for use</span>
<span class="sd">    with the `PhaseScreenPSF` class to create PSFs via Fourier or geometric optics.</span>

<span class="sd">    The pupil plane array is completely specified by its size, sampling interval, and pattern of</span>
<span class="sd">    illuminated pixels.  Pupil plane arrays can be specified either geometrically or using an image</span>
<span class="sd">    to indicate the illuminated pixels.  In both cases, various options exist to control the pupil</span>
<span class="sd">    plane size and sampling interval.</span>

<span class="sd">    **Geometric pupil specification**:</span>

<span class="sd">    The first way to specify the details of the telescope aperture is through a series of keywords</span>
<span class="sd">    indicating the diameter, size of the central obscuration, and the nature of the struts</span>
<span class="sd">    holding up the secondary mirror (or prime focus cage, etc.).  The struts are assumed to be</span>
<span class="sd">    rectangular obscurations extending from the outer edge of the pupil to the outer edge of the</span>
<span class="sd">    obscuration disk (or to the pupil center if ``obscuration = 0.``).  You can specify how many</span>
<span class="sd">    struts there are (evenly spaced in angle), how thick they are as a fraction of the pupil</span>
<span class="sd">    diameter, and what angle they start at relative to the positive y direction.</span>

<span class="sd">    The size (in meters) and sampling interval (in meters) of the pupil plane array representing the</span>
<span class="sd">    aperture can be set directly using the the ``pupil_plane_size`` and ``pupil_plane_scale``</span>
<span class="sd">    keywords.  However, in most situations, it&#39;s probably more convenient to let GalSim set these</span>
<span class="sd">    automatically based on the pupil geometry and the nature of the (potentially time-varying)</span>
<span class="sd">    phase aberrations from which a PSF is being derived.</span>

<span class="sd">    The pupil plane array physical size is by default set to twice the pupil diameter producing a</span>
<span class="sd">    Nyquist sampled PSF image.  While this would always be sufficient if using sinc interpolation</span>
<span class="sd">    over the PSF image for subsequent operations, GalSim by default uses the much faster (though</span>
<span class="sd">    approximate) quintic interpolant, which means that in some cases -- in particular, for</span>
<span class="sd">    significantly aberrated optical PSFs without atmospheric aberrations -- it may be useful to</span>
<span class="sd">    further increase the size of the pupil plane array, thereby increasing the sampling rate of the</span>
<span class="sd">    resulting PSF image.  This can be done by increasing the ``oversampling`` keyword.</span>

<span class="sd">    A caveat to the above occurs when using ``geometric_shooting=True`` to draw using</span>
<span class="sd">    photon-shooting.  In this case, we only need an array just large enough to avoid clipping the</span>
<span class="sd">    pupil, which we can get by setting ``oversampling=0.5``.</span>

<span class="sd">    The pupil plane array physical sampling interval (which is directly related to the resulting PSF</span>
<span class="sd">    image physical size) is set by default to the same interval as would be used to avoid</span>
<span class="sd">    significant aliasing (image folding) for an obscured `Airy` profile with matching diameter and</span>
<span class="sd">    obscuration and for the value of ``folding_threshold`` in the optionally specified gsparams</span>
<span class="sd">    argument.  If the phase aberrations are significant, however, the PSF image size computed this</span>
<span class="sd">    way may still not be sufficiently large to avoid aliasing.  To further increase the pupil plane</span>
<span class="sd">    sampling rate (and hence the PSF image size), you can increase the value of the ``pad_factor``</span>
<span class="sd">    keyword.</span>

<span class="sd">    An additional way to set the pupil sampling interval for a particular set of phase screens</span>
<span class="sd">    (i.e., for a particular `PhaseScreenList`) is to provide the screens in the ``screen_list``</span>
<span class="sd">    argument.  Each screen in the list computes its own preferred sampling rate and the</span>
<span class="sd">    `PhaseScreenList` appropriately aggregates these. This last option also requires that a</span>
<span class="sd">    wavelength ``lam`` be specified, and is particularly helpful for creating PSFs derived from</span>
<span class="sd">    turbulent atmospheric screens.</span>

<span class="sd">    Finally, when specifying the pupil geometrically, Aperture may choose to make a small adjustment</span>
<span class="sd">    to ``pupil_plane_scale`` in order to produce an array with a good size for FFTs.  If your</span>
<span class="sd">    application depends on knowing the size and scale used with the Fourier optics framework, you</span>
<span class="sd">    can obtain these from the ``aper.pupil_plane_size`` and ``aper.pupil_plane_scale`` attributes.</span>

<span class="sd">    **Pupil image specification**:</span>

<span class="sd">    The second way to specify the pupil plane configuration is by passing in an image of it.  This</span>
<span class="sd">    can be useful, for example, if the struts are not evenly spaced or are not radially directed, as</span>
<span class="sd">    is assumed by the simple model for struts described above.  In this case, an exception is raised</span>
<span class="sd">    if keywords related to struts are also given.  On the other hand, the ``obscuration`` keyword is</span>
<span class="sd">    still used to ensure that the PSF images are not aliased, though it is ignored during the actual</span>
<span class="sd">    construction of the pupil plane illumination pattern.  Note that for complicated pupil</span>
<span class="sd">    configurations, it may be desireable to increase ``pad_factor`` for more fidelity at the expense</span>
<span class="sd">    of slower running time.  Finally, the ``pupil_plane_im`` that is passed in can be rotated during</span>
<span class="sd">    internal calculations by specifying a ``pupil_angle`` keyword.</span>

<span class="sd">    If you choose to pass in a pupil plane image, it must be a square array in which the image of</span>
<span class="sd">    the pupil is centered.  The areas that are illuminated should have some value &gt;0, and the other</span>
<span class="sd">    areas should have a value of precisely zero.  Based on what the Aperture class determines is a</span>
<span class="sd">    good PSF sampling interval, the image of the pupil plane that is passed in might be zero-padded</span>
<span class="sd">    during internal calculations.  (The pupil plane array size and scale values can be accessed via</span>
<span class="sd">    the ``aper.pupil_plane_size`` and ``aper.pupil_plane_scale`` attributes.) The pixel scale of</span>
<span class="sd">    the pupil plane can be specified in one of three ways.  In descending order of priority, these</span>
<span class="sd">    are:</span>

<span class="sd">      1.  The ``pupil_plane_scale`` keyword argument (units are meters).</span>
<span class="sd">      2.  The ``pupil_plane_im.scale`` attribute (units are meters).</span>
<span class="sd">      3.  If (1) and (2) are both None, then the scale will be inferred by assuming that the</span>
<span class="sd">          illuminated pixel farthest from the image center is at a physical distance of self.diam/2.</span>

<span class="sd">    The ``pupil_plane_size`` and ``lam`` keywords are both ignored when constructing an Aperture</span>
<span class="sd">    from an image.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        diam:               Aperture diameter in meters.</span>
<span class="sd">        lam:                Wavelength in nanometers.  [default: None]</span>
<span class="sd">        circular_pupil:     Adopt a circular pupil?  [default: True]</span>
<span class="sd">        obscuration:        Linear dimension of central obscuration as fraction of aperture</span>
<span class="sd">                            linear dimension. [0., 1.).  [default: 0.0]</span>
<span class="sd">        nstruts:            Number of radial support struts to add to the central obscuration.</span>
<span class="sd">                            [default: 0]</span>
<span class="sd">        strut_thick:        Thickness of support struts as a fraction of aperture diameter.</span>
<span class="sd">                            [default: 0.05]</span>
<span class="sd">        strut_angle:        `Angle` made between the vertical and the strut starting closest to it,</span>
<span class="sd">                            defined to be positive in the counter-clockwise direction; must be an</span>
<span class="sd">                            `Angle` instance. [default: 0. * galsim.degrees]</span>
<span class="sd">        oversampling:       Optional oversampling factor *in the image plane* for the PSF</span>
<span class="sd">                            eventually constructed using this `Aperture`.  Setting</span>
<span class="sd">                            ``oversampling &lt; 1`` will produce aliasing in the PSF (not good).</span>
<span class="sd">                            [default: 1.0]</span>
<span class="sd">        pad_factor:         Additional multiple by which to extend the PSF image to avoid</span>
<span class="sd">                            folding.  [default: 1.0]</span>
<span class="sd">        screen_list:        An optional `PhaseScreenList` object.  If present, then get a good</span>
<span class="sd">                            pupil sampling interval using this object.  [default: None]</span>
<span class="sd">        pupil_plane_im:     The GalSim.Image, NumPy array, or name of file containing the pupil</span>
<span class="sd">                            plane image, to be used instead of generating one based on the</span>
<span class="sd">                            obscuration and strut parameters.  [default: None]</span>
<span class="sd">        pupil_angle:        If ``pupil_plane_im`` is not None, rotation angle for the pupil plane</span>
<span class="sd">                            (positive in the counter-clockwise direction).  Must be an `Angle`</span>
<span class="sd">                            instance. [default: 0. * galsim.degrees]</span>
<span class="sd">        pupil_plane_scale:  Sampling interval in meters to use for the pupil plane array.  In</span>
<span class="sd">                            most cases, it&#39;s a good idea to leave this as None, in which case</span>
<span class="sd">                            GalSim will attempt to find a good value automatically.  The</span>
<span class="sd">                            exception is when specifying the pupil arrangement via an image, in</span>
<span class="sd">                            which case this keyword can be used to indicate the sampling of that</span>
<span class="sd">                            image.  See also ``pad_factor`` for adjusting the pupil sampling scale.</span>
<span class="sd">                            [default: None]</span>
<span class="sd">        pupil_plane_size:   Size in meters to use for the pupil plane array.  In most cases, it&#39;s</span>
<span class="sd">                            a good idea to leave this as None, in which case GalSim will attempt</span>
<span class="sd">                            to find a good value automatically.  See also ``oversampling`` for</span>
<span class="sd">                            adjusting the pupil size.  [default: None]</span>
<span class="sd">        gsparams:           An optional `GSParams` argument. [default: None]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">diam</span><span class="p">,</span> <span class="n">lam</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">circular_pupil</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">obscuration</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
                 <span class="n">nstruts</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">strut_thick</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span> <span class="n">strut_angle</span><span class="o">=</span><span class="mf">0.0</span><span class="o">*</span><span class="n">radians</span><span class="p">,</span>
                 <span class="n">oversampling</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">pad_factor</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">screen_list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">pupil_plane_im</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pupil_angle</span><span class="o">=</span><span class="mf">0.0</span><span class="o">*</span><span class="n">radians</span><span class="p">,</span>
                 <span class="n">pupil_plane_scale</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pupil_plane_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">gsparams</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_diam</span> <span class="o">=</span> <span class="n">diam</span>  <span class="c1"># Always need to explicitly specify an aperture diameter.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lam</span> <span class="o">=</span> <span class="n">lam</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_circular_pupil</span> <span class="o">=</span> <span class="n">circular_pupil</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_obscuration</span> <span class="o">=</span> <span class="n">obscuration</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_nstruts</span> <span class="o">=</span> <span class="n">nstruts</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_strut_thick</span> <span class="o">=</span> <span class="n">strut_thick</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_strut_angle</span> <span class="o">=</span> <span class="n">strut_angle</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_oversampling</span> <span class="o">=</span> <span class="n">oversampling</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pad_factor</span> <span class="o">=</span> <span class="n">pad_factor</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_screen_list</span> <span class="o">=</span> <span class="n">screen_list</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pupil_plane_im</span> <span class="o">=</span> <span class="n">pupil_plane_im</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pupil_angle</span> <span class="o">=</span> <span class="n">pupil_angle</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_input_pupil_plane_scale</span> <span class="o">=</span> <span class="n">pupil_plane_scale</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_input_pupil_plane_size</span> <span class="o">=</span> <span class="n">pupil_plane_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_gsparams</span> <span class="o">=</span> <span class="n">GSParams</span><span class="o">.</span><span class="n">check</span><span class="p">(</span><span class="n">gsparams</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">diam</span> <span class="o">&lt;=</span> <span class="mf">0.</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">GalSimRangeError</span><span class="p">(</span><span class="s2">&quot;Invalid diam.&quot;</span><span class="p">,</span> <span class="n">diam</span><span class="p">,</span> <span class="mf">0.</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">obscuration</span> <span class="o">&lt;</span> <span class="mf">0.</span> <span class="ow">or</span> <span class="n">obscuration</span> <span class="o">&gt;=</span> <span class="mf">1.</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">GalSimRangeError</span><span class="p">(</span><span class="s2">&quot;Invalid obscuration.&quot;</span><span class="p">,</span> <span class="n">obscuration</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">strut_angle</span><span class="p">,</span> <span class="n">Angle</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;strut_angle must be a galsim.Angle instance.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pupil_angle</span><span class="p">,</span> <span class="n">Angle</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;pupil_angle must be a galsim.Angle instance.&quot;</span><span class="p">)</span>

        <span class="c1"># You can either set geometric properties, or use a pupil image, but not both, so check for</span>
        <span class="c1"># that here.  One caveat is that we allow sanity checking the sampling of a pupil_image by</span>
        <span class="c1"># comparing it to the sampling GalSim would have used for an (obscured) Airy profile.  So</span>
        <span class="c1"># it&#39;s okay to specify an obscuration and a pupil_plane_im together, for example, but not</span>
        <span class="c1"># a pupil_plane_im and struts.</span>
        <span class="n">is_default_geom</span> <span class="o">=</span> <span class="p">(</span><span class="n">circular_pupil</span> <span class="ow">and</span>
                           <span class="n">nstruts</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span>
                           <span class="n">strut_thick</span> <span class="o">==</span> <span class="mf">0.05</span> <span class="ow">and</span>
                           <span class="n">strut_angle</span> <span class="o">==</span> <span class="mf">0.0</span><span class="o">*</span><span class="n">radians</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_default_geom</span> <span class="ow">and</span> <span class="n">pupil_plane_im</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">GalSimIncompatibleValuesError</span><span class="p">(</span>
                <span class="s2">&quot;Can&#39;t specify both geometric parameters and pupil_plane_im.&quot;</span><span class="p">,</span>
                <span class="n">circular_pupil</span><span class="o">=</span><span class="n">circular_pupil</span><span class="p">,</span> <span class="n">nstruts</span><span class="o">=</span><span class="n">nstruts</span><span class="p">,</span> <span class="n">strut_thick</span><span class="o">=</span><span class="n">strut_thick</span><span class="p">,</span>
                <span class="n">strut_angle</span><span class="o">=</span><span class="n">strut_angle</span><span class="p">,</span> <span class="n">pupil_plane_im</span><span class="o">=</span><span class="n">pupil_plane_im</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">screen_list</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">lam</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">GalSimIncompatibleValuesError</span><span class="p">(</span>
                <span class="s2">&quot;Wavelength ``lam`` must be specified with ``screen_list``.&quot;</span><span class="p">,</span>
                <span class="n">screen_list</span><span class="o">=</span><span class="n">screen_list</span><span class="p">,</span> <span class="n">lam</span><span class="o">=</span><span class="n">lam</span><span class="p">)</span>

    <span class="c1"># For each of these, the actual value is defined during the construction of the _illuminated</span>
    <span class="c1"># array, so access that (lazy) property first.</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">pupil_plane_scale</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The scale_size of the pupil-plane image.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_illuminated</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pupil_plane_scale</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">pupil_plane_size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The size of the pupil-plane image.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_illuminated</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pupil_plane_size</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">npix</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The number of pixels in each direction of the pupil-plane image.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_illuminated</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_npix</span>

    <span class="nd">@lazy_property</span>
    <span class="k">def</span> <span class="nf">good_pupil_size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;An estimate of a good pupil-plane image size.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Although the user can set the pupil plane size and scale directly if desired, in most</span>
        <span class="c1"># cases it&#39;s nicer to have GalSim try to pick good values for these.</span>

        <span class="c1"># For the pupil plane size, we&#39;ll achieve Nyquist sampling in the focal plane if we sample</span>
        <span class="c1"># out to twice the diameter of the actual aperture in the pupil plane (completely</span>
        <span class="c1"># independent of wavelength, struts, obscurations, GSparams, and so on!).  This corresponds</span>
        <span class="c1"># to oversampling=1.0.  In fact, if we were willing to always use sinc interpolation, there</span>
        <span class="c1"># would never be any reason to go beyond this.  In practice, we usually use a faster, but</span>
        <span class="c1"># less accurate, quintic interpolant, which means we can benefit from improved sampling</span>
        <span class="c1"># (oversampling &gt; 1.0) in some cases, especially when we&#39;re *not* modeling an atmosphere</span>
        <span class="c1"># which would otherwise tend to damp contributions at large k.</span>
        <span class="k">return</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">diam</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_oversampling</span>

    <span class="nd">@lazy_property</span>
    <span class="k">def</span> <span class="nf">good_pupil_scale</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;An estimate of a good pupil-plane image scale.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.airy</span> <span class="k">import</span> <span class="n">Airy</span>
        <span class="c1"># For the pupil plane sampling interval, details like the obscuration and GSParams *are*</span>
        <span class="c1"># important as they affect the amount of aliasing encountered.  (An Airy profile has an</span>
        <span class="c1"># infinite extent in real space, so it *always* aliases at some level, more so with an</span>
        <span class="c1"># obscuration than without.  The GSParams settings indicate how much aliasing we&#39;re</span>
        <span class="c1"># willing to tolerate, so it&#39;s required here.)  To pick a good sampling interval, we start</span>
        <span class="c1"># with the interval that would be used for an obscured Airy GSObject profile.  If the</span>
        <span class="c1"># `screen_list` argument was supplied, then we also check its .stepk propertry, which</span>
        <span class="c1"># aggregates a good sampling interval from all of the wrapped PhaseScreens, and keep the</span>
        <span class="c1"># smaller stepk.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lam</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># For Airy, pupil_plane_scale is independent of wavelength.  We could build an Airy with</span>
            <span class="c1"># lam_over_diam=1.0 and then alter the `good_pupil_scale = ...` line below</span>
            <span class="c1"># appropriately, but it&#39;s easier to just arbitrarily set `lam=500` if it wasn&#39;t set.</span>
            <span class="n">lam</span> <span class="o">=</span> <span class="mf">500.0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">lam</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lam</span>
        <span class="n">airy</span> <span class="o">=</span> <span class="n">Airy</span><span class="p">(</span><span class="n">diam</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">diam</span><span class="p">,</span> <span class="n">lam</span><span class="o">=</span><span class="n">lam</span><span class="p">,</span> <span class="n">obscuration</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">obscuration</span><span class="p">,</span> <span class="n">gsparams</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">gsparams</span><span class="p">)</span>
        <span class="n">stepk</span> <span class="o">=</span> <span class="n">airy</span><span class="o">.</span><span class="n">stepk</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_screen_list</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">screen_list</span> <span class="o">=</span> <span class="n">PhaseScreenList</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_screen_list</span><span class="p">)</span>
            <span class="n">stepk</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">stepk</span><span class="p">,</span>
                        <span class="n">screen_list</span><span class="o">.</span><span class="n">_getStepK</span><span class="p">(</span><span class="n">lam</span><span class="o">=</span><span class="n">lam</span><span class="p">,</span> <span class="n">diam</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">diam</span><span class="p">,</span> <span class="n">obscuration</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">obscuration</span><span class="p">,</span>
                                              <span class="n">gsparams</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">gsparams</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">stepk</span> <span class="o">*</span> <span class="n">lam</span> <span class="o">*</span> <span class="mf">1.e-9</span> <span class="o">*</span> <span class="p">(</span><span class="n">radians</span> <span class="o">/</span> <span class="n">arcsec</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pad_factor</span><span class="p">)</span>

    <span class="nd">@lazy_property</span>
    <span class="k">def</span> <span class="nf">_illuminated</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Now that we have good candidate sizes and scales, we load or generate the pupil plane</span>
        <span class="c1"># array.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pupil_plane_im</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># Use image of pupil plane</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_load_pupil_plane</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># Use geometric parameters.</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_input_pupil_plane_scale</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_pupil_plane_scale</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_input_pupil_plane_scale</span>
                <span class="c1"># Check input scale and warn if looks suspicious.</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pupil_plane_scale</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">good_pupil_scale</span><span class="p">:</span>
                    <span class="n">ratio</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">good_pupil_scale</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pupil_plane_scale</span>
                    <span class="n">galsim_warn</span><span class="p">(</span><span class="s2">&quot;Input pupil_plane_scale may be too large for good sampling.</span><span class="se">\n</span><span class="s2">&quot;</span>
                                <span class="s2">&quot;Consider decreasing pupil_plane_scale by a factor </span><span class="si">%f</span><span class="s2">, and/or &quot;</span>
                                <span class="s2">&quot;check PhaseScreenPSF outputs for signs of folding in real &quot;</span>
                                <span class="s2">&quot;space.&quot;</span><span class="o">%</span><span class="p">(</span><span class="mf">1.</span><span class="o">/</span><span class="n">ratio</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_pupil_plane_scale</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">good_pupil_scale</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_input_pupil_plane_size</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_pupil_plane_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_input_pupil_plane_size</span>
                <span class="c1"># Check input size and warn if looks suspicious</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pupil_plane_size</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">good_pupil_size</span><span class="p">:</span>
                    <span class="n">ratio</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">good_pupil_size</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pupil_plane_size</span>
                    <span class="n">galsim_warn</span><span class="p">(</span><span class="s2">&quot;Input pupil_plane_size may be too small for good focal-plane&quot;</span>
                                <span class="s2">&quot;sampling.</span><span class="se">\n</span><span class="s2">&quot;</span>
                                <span class="s2">&quot;Consider increasing pupil_plane_size by a factor </span><span class="si">%f</span><span class="s2">, and/or &quot;</span>
                                <span class="s2">&quot;check PhaseScreenPSF outputs for signs of undersampling.&quot;</span><span class="o">%</span><span class="n">ratio</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_pupil_plane_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">good_pupil_size</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_generate_pupil_plane</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_generate_pupil_plane</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Create an array of illuminated pixels parameterically.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ratio</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pupil_plane_size</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">_pupil_plane_scale</span>
        <span class="c1"># Fudge a little to prevent good_fft_size() from turning 512.0001 into 768.</span>
        <span class="n">ratio</span> <span class="o">*=</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="mf">1.0</span><span class="o">/</span><span class="mi">2</span><span class="o">**</span><span class="mi">14</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_npix</span> <span class="o">=</span> <span class="n">Image</span><span class="o">.</span><span class="n">good_fft_size</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">ratio</span><span class="p">)))</span>

        <span class="c1"># Check FFT size</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_npix</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">gsparams</span><span class="o">.</span><span class="n">maximum_fft_size</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">GalSimFFTSizeError</span><span class="p">(</span><span class="s2">&quot;Created pupil plane array that is too large.&quot;</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_npix</span><span class="p">)</span>

        <span class="c1"># Shrink scale such that size = scale * npix exactly.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pupil_plane_scale</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pupil_plane_size</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_npix</span>

        <span class="n">radius</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">diam</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_circular_pupil</span><span class="p">:</span>
            <span class="n">illuminated</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rsqr</span> <span class="o">&lt;</span> <span class="n">radius</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">obscuration</span> <span class="o">&gt;</span> <span class="mf">0.</span><span class="p">:</span>
                <span class="n">illuminated</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rsqr</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="n">radius</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">obscuration</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">illuminated</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">radius</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">v</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">radius</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">obscuration</span> <span class="o">&gt;</span> <span class="mf">0.</span><span class="p">:</span>
                <span class="n">illuminated</span> <span class="o">*=</span> <span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">radius</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">obscuration</span><span class="p">)</span> <span class="o">*</span>
                                      <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">v</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">radius</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">obscuration</span><span class="p">))</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nstruts</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Add the initial rotation if requested, converting to radians.</span>
            <span class="n">rot_u</span><span class="p">,</span> <span class="n">rot_v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">v</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_strut_angle</span><span class="o">.</span><span class="n">rad</span> <span class="o">!=</span> <span class="mf">0.</span><span class="p">:</span>
                <span class="n">rot_u</span><span class="p">,</span> <span class="n">rot_v</span> <span class="o">=</span> <span class="n">rotate_xy</span><span class="p">(</span><span class="n">rot_u</span><span class="p">,</span> <span class="n">rot_v</span><span class="p">,</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">_strut_angle</span><span class="p">)</span>
            <span class="n">rotang</span> <span class="o">=</span> <span class="mf">360.</span> <span class="o">*</span> <span class="n">degrees</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nstruts</span>
            <span class="c1"># Then loop through struts setting to zero the regions which lie under the strut</span>
            <span class="k">for</span> <span class="n">istrut</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_nstruts</span><span class="p">):</span>
                <span class="n">rot_u</span><span class="p">,</span> <span class="n">rot_v</span> <span class="o">=</span> <span class="n">rotate_xy</span><span class="p">(</span><span class="n">rot_u</span><span class="p">,</span> <span class="n">rot_v</span><span class="p">,</span> <span class="o">-</span><span class="n">rotang</span><span class="p">)</span>
                <span class="n">illuminated</span> <span class="o">*=</span> <span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">rot_u</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">radius</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_strut_thick</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">rot_v</span> <span class="o">&lt;</span> <span class="mf">0.0</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">illuminated</span>

    <span class="k">def</span> <span class="nf">_load_pupil_plane</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Create an array of illuminated pixels with appropriate size and scale from an input</span>
<span class="sd">        image of the pupil.  The basic strategy is:</span>

<span class="sd">        1.  Read in array.</span>
<span class="sd">        2.  Determine the scale.</span>
<span class="sd">        3.  Pad the input array with zeros to meet the requested pupil size.</span>
<span class="sd">        4.  Check that the pupil plane sampling interval is at least as small as requested.</span>
<span class="sd">        5.  Optionally rotate pupil plane.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">fits</span>
        <span class="c1"># Handle multiple types of input: NumPy array, galsim.Image, or string for filename with</span>
        <span class="c1"># image.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_pupil_plane_im</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="c1"># Make it into an image.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_pupil_plane_im</span> <span class="o">=</span> <span class="n">Image</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_pupil_plane_im</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_pupil_plane_im</span><span class="p">,</span> <span class="n">Image</span><span class="p">):</span>
            <span class="c1"># Make sure not to overwrite input image.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_pupil_plane_im</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pupil_plane_im</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Read in image of pupil plane from file.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_pupil_plane_im</span> <span class="o">=</span> <span class="n">fits</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_pupil_plane_im</span><span class="p">)</span>
        <span class="c1"># scale = pupil_plane_im.scale # Interpret as either the pixel scale in meters, or None.</span>
        <span class="n">pp_arr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pupil_plane_im</span><span class="o">.</span><span class="n">array</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_npix</span> <span class="o">=</span> <span class="n">pp_arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Check FFT size</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_npix</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">gsparams</span><span class="o">.</span><span class="n">maximum_fft_size</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">GalSimFFTSizeError</span><span class="p">(</span><span class="s2">&quot;Loaded pupil plane array that is too large.&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_npix</span><span class="p">)</span>

        <span class="c1"># Sanity checks</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pupil_plane_im</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pupil_plane_im</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="n">GalSimValueError</span><span class="p">(</span><span class="s2">&quot;Input pupil_plane_im must be square.&quot;</span><span class="p">,</span>
                                   <span class="bp">self</span><span class="o">.</span><span class="n">_pupil_plane_im</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pupil_plane_im</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">GalSimValueError</span><span class="p">(</span><span class="s2">&quot;Input pupil_plane_im must have even sizes.&quot;</span><span class="p">,</span>
                                   <span class="bp">self</span><span class="o">.</span><span class="n">_pupil_plane_im</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

        <span class="c1"># Set the scale, priority is:</span>
        <span class="c1"># 1.  pupil_plane_scale kwarg</span>
        <span class="c1"># 2.  image.scale if not None</span>
        <span class="c1"># 3.  Use diameter and farthest illuminated pixel.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_input_pupil_plane_scale</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_pupil_plane_scale</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_input_pupil_plane_scale</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pupil_plane_im</span><span class="o">.</span><span class="n">scale</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_pupil_plane_scale</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pupil_plane_im</span><span class="o">.</span><span class="n">scale</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># If self._pupil_plane_scale is not set yet, then figure it out from the distance</span>
            <span class="c1"># of the farthest illuminated pixel from the image center and the aperture diameter.</span>
            <span class="c1"># below is essentially np.linspace(-0.5, 0.5, self._npix)</span>
            <span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftfreq</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_npix</span><span class="p">))</span>
            <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hypot</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
            <span class="n">rmax_illum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">r</span><span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_pupil_plane_im</span><span class="o">.</span><span class="n">array</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_pupil_plane_scale</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">diam</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">rmax_illum</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_npix</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pupil_plane_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pupil_plane_scale</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_npix</span>

        <span class="c1"># Check the pupil plane size here and bump it up if necessary.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pupil_plane_size</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">good_pupil_size</span><span class="p">:</span>
            <span class="n">new_npix</span> <span class="o">=</span> <span class="n">Image</span><span class="o">.</span><span class="n">good_fft_size</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">good_pupil_size</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">_pupil_plane_scale</span><span class="p">)))</span>
            <span class="n">pad_width</span> <span class="o">=</span> <span class="p">(</span><span class="n">new_npix</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">_npix</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span>
            <span class="n">pp_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">pp_arr</span><span class="p">,</span> <span class="p">[(</span><span class="n">pad_width</span><span class="p">,</span> <span class="n">pad_width</span><span class="p">)]</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;constant&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_npix</span> <span class="o">=</span> <span class="n">new_npix</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_pupil_plane_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pupil_plane_scale</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_npix</span>

        <span class="c1"># Check sampling interval and warn if it&#39;s not good enough.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pupil_plane_scale</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">good_pupil_scale</span><span class="p">:</span>
            <span class="n">ratio</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pupil_plane_scale</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">good_pupil_scale</span>
            <span class="n">galsim_warn</span><span class="p">(</span><span class="s2">&quot;Input pupil plane image may not be sampled well enough!</span><span class="se">\n</span><span class="s2">&quot;</span>
                        <span class="s2">&quot;Consider increasing sampling by a factor </span><span class="si">%f</span><span class="s2">, and/or check &quot;</span>
                        <span class="s2">&quot;PhaseScreenPSF outputs for signs of folding in real space.&quot;</span><span class="o">%</span><span class="n">ratio</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pupil_angle</span><span class="o">.</span><span class="n">rad</span> <span class="o">==</span> <span class="mf">0.</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">pp_arr</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Rotate the pupil plane image as required based on the `pupil_angle`, being careful to</span>
            <span class="c1"># ensure that the image is one of the allowed types.  We ignore the scale.</span>
            <span class="n">b</span> <span class="o">=</span> <span class="n">_BoundsI</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_npix</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_npix</span><span class="p">)</span>
            <span class="n">im</span> <span class="o">=</span> <span class="n">_Image</span><span class="p">(</span><span class="n">pp_arr</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">PixelScale</span><span class="p">(</span><span class="mf">1.</span><span class="p">))</span>
            <span class="n">int_im</span> <span class="o">=</span> <span class="n">InterpolatedImage</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">x_interpolant</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">,</span>
                                       <span class="n">calculate_stepk</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">calculate_maxk</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">int_im</span> <span class="o">=</span> <span class="n">int_im</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_pupil_angle</span><span class="p">)</span>
            <span class="n">new_im</span> <span class="o">=</span> <span class="n">Image</span><span class="p">(</span><span class="n">pp_arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">pp_arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">new_im</span> <span class="o">=</span> <span class="n">int_im</span><span class="o">.</span><span class="n">drawImage</span><span class="p">(</span><span class="n">image</span><span class="o">=</span><span class="n">new_im</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;no_pixel&#39;</span><span class="p">)</span>
            <span class="n">pp_arr</span> <span class="o">=</span> <span class="n">new_im</span><span class="o">.</span><span class="n">array</span>
            <span class="c1"># Restore hard edges that might have been lost during the interpolation.  To do this, we</span>
            <span class="c1"># check the maximum value of the entries.  Values after interpolation that are &gt;half</span>
            <span class="c1"># that maximum value are kept as nonzero (True), but those that are &lt;half the maximum</span>
            <span class="c1"># value are set to zero (False).</span>
            <span class="n">max_pp_val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">pp_arr</span><span class="p">)</span>
            <span class="n">pp_arr</span><span class="p">[</span><span class="n">pp_arr</span> <span class="o">&lt;</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">max_pp_val</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.</span>
            <span class="k">return</span> <span class="n">pp_arr</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">gsparams</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The `GSParams` of this object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gsparams</span>

<div class="viewcode-block" id="Aperture.withGSParams"><a class="viewcode-back" href="../../phase_psf.html#galsim.Aperture.withGSParams">[docs]</a>    <span class="k">def</span> <span class="nf">withGSParams</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gsparams</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create a version of the current aperture with the given gsparams</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">gsparams</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">gsparams</span><span class="p">:</span> <span class="k">return</span> <span class="bp">self</span>
        <span class="kn">from</span> <span class="nn">copy</span> <span class="k">import</span> <span class="n">copy</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">_gsparams</span> <span class="o">=</span> <span class="n">GSParams</span><span class="o">.</span><span class="n">check</span><span class="p">(</span><span class="n">gsparams</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ret</span></div>

    <span class="c1"># Used in Aperture.__str__ and OpticalPSF.__str__</span>
    <span class="k">def</span> <span class="nf">_geometry_str</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_circular_pupil</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;, circular_pupil=False&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">obscuration</span> <span class="o">!=</span> <span class="mf">0.0</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;, obscuration=</span><span class="si">%s</span><span class="s2">&quot;</span><span class="o">%</span><span class="bp">self</span><span class="o">.</span><span class="n">obscuration</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nstruts</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;, nstruts=</span><span class="si">%s</span><span class="s2">&quot;</span><span class="o">%</span><span class="bp">self</span><span class="o">.</span><span class="n">_nstruts</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_strut_thick</span> <span class="o">!=</span> <span class="mf">0.05</span><span class="p">:</span>
                <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;, strut_thick=</span><span class="si">%s</span><span class="s2">&quot;</span><span class="o">%</span><span class="bp">self</span><span class="o">.</span><span class="n">_strut_thick</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_strut_angle</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">*</span><span class="n">radians</span><span class="p">:</span>
                <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;, strut_angle=</span><span class="si">%s</span><span class="s2">&quot;</span><span class="o">%</span><span class="bp">self</span><span class="o">.</span><span class="n">_strut_angle</span>
        <span class="k">return</span> <span class="n">s</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;galsim.Aperture(diam=</span><span class="si">%r</span><span class="s2">&quot;</span><span class="o">%</span><span class="bp">self</span><span class="o">.</span><span class="n">diam</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pupil_plane_im</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Pupil was created geometrically, so use that here.</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_geometry_str</span><span class="p">()</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;)&quot;</span>
        <span class="k">return</span> <span class="n">s</span>

    <span class="k">def</span> <span class="nf">_geometry_repr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_circular_pupil</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;, circular_pupil=False&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">obscuration</span> <span class="o">!=</span> <span class="mf">0.0</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;, obscuration=</span><span class="si">%r</span><span class="s2">&quot;</span><span class="o">%</span><span class="bp">self</span><span class="o">.</span><span class="n">obscuration</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nstruts</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;, nstruts=</span><span class="si">%r</span><span class="s2">&quot;</span><span class="o">%</span><span class="bp">self</span><span class="o">.</span><span class="n">_nstruts</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_strut_thick</span> <span class="o">!=</span> <span class="mf">0.05</span><span class="p">:</span>
                <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;, strut_thick=</span><span class="si">%r</span><span class="s2">&quot;</span><span class="o">%</span><span class="bp">self</span><span class="o">.</span><span class="n">_strut_thick</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_strut_angle</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">*</span><span class="n">radians</span><span class="p">:</span>
                <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;, strut_angle=</span><span class="si">%r</span><span class="s2">&quot;</span><span class="o">%</span><span class="bp">self</span><span class="o">.</span><span class="n">_strut_angle</span>
        <span class="k">return</span> <span class="n">s</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;galsim.Aperture(diam=</span><span class="si">%r</span><span class="s2">&quot;</span><span class="o">%</span><span class="bp">self</span><span class="o">.</span><span class="n">diam</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pupil_plane_im</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Pupil was created geometrically, so use that here.</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_geometry_repr</span><span class="p">()</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;, pupil_plane_scale=</span><span class="si">%r</span><span class="s2">&quot;</span><span class="o">%</span><span class="bp">self</span><span class="o">.</span><span class="n">_input_pupil_plane_scale</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;, pupil_plane_size=</span><span class="si">%r</span><span class="s2">&quot;</span><span class="o">%</span><span class="bp">self</span><span class="o">.</span><span class="n">_input_pupil_plane_size</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;, oversampling=</span><span class="si">%r</span><span class="s2">&quot;</span><span class="o">%</span><span class="bp">self</span><span class="o">.</span><span class="n">_oversampling</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;, pad_factor=</span><span class="si">%r</span><span class="s2">&quot;</span><span class="o">%</span><span class="bp">self</span><span class="o">.</span><span class="n">_pad_factor</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Pupil was created from image, so use that instead.</span>
            <span class="c1"># It&#39;s slightly less annoying to see an enormous stream of zeros fly by than an enormous</span>
            <span class="c1"># stream of Falses, so convert to int16.</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">illuminated</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;, pupil_plane_im=array(</span><span class="si">%r</span><span class="s2">&quot;</span><span class="o">%</span><span class="n">tmp</span><span class="o">+</span><span class="s2">&quot;, dtype=&#39;int16&#39;)&quot;</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;, pupil_plane_scale=</span><span class="si">%r</span><span class="s2">&quot;</span><span class="o">%</span><span class="bp">self</span><span class="o">.</span><span class="n">_pupil_plane_scale</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">gsparams</span> <span class="o">!=</span> <span class="n">GSParams</span><span class="p">():</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;, gsparams=</span><span class="si">%r</span><span class="s2">&quot;</span><span class="o">%</span><span class="bp">self</span><span class="o">.</span><span class="n">gsparams</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;)&quot;</span>
        <span class="k">return</span> <span class="n">s</span>

    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span> <span class="ow">is</span> <span class="n">other</span><span class="p">:</span> <span class="k">return</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Aperture</span><span class="p">)</span> <span class="ow">and</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">diam</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">diam</span> <span class="ow">and</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_gsparams</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_gsparams</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pupil_plane_im</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pupil_plane_scale</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">pupil_plane_scale</span> <span class="ow">and</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">illuminated</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">illuminated</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">_pupil_plane_im</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_circular_pupil</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_circular_pupil</span> <span class="ow">and</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_obscuration</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_obscuration</span> <span class="ow">and</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_nstruts</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_nstruts</span> <span class="ow">and</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_strut_thick</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_strut_thick</span> <span class="ow">and</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_strut_angle</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_strut_angle</span> <span class="ow">and</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_input_pupil_plane_scale</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_input_pupil_plane_scale</span> <span class="ow">and</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_input_pupil_plane_size</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_input_pupil_plane_size</span> <span class="ow">and</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_oversampling</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_oversampling</span> <span class="ow">and</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_pad_factor</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_pad_factor</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Cache since self.illuminated may be large.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_hash&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_hash</span> <span class="o">=</span> <span class="nb">hash</span><span class="p">((</span><span class="s2">&quot;galsim.Aperture&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">diam</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pupil_plane_scale</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_hash</span> <span class="o">^=</span> <span class="nb">hash</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">illuminated</span><span class="o">.</span><span class="n">ravel</span><span class="p">()))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hash</span>

    <span class="c1"># Properties show up nicely in the interactive terminal for</span>
    <span class="c1">#     &gt;&gt;&gt;help(Aperture)</span>
    <span class="c1"># So we make a thin wrapper here.</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">illuminated</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;A boolean array indicating which positions in the pupil plane are exposed to the sky.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_illuminated</span>

    <span class="nd">@lazy_property</span>
    <span class="k">def</span> <span class="nf">rho</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Unit-disk normalized pupil plane coordinate as a complex number:</span>
<span class="sd">        (x, y) =&gt; x + 1j * y.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_illuminated</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftfreq</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_npix</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">diam</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">_pupil_plane_size</span><span class="o">/</span><span class="mf">2.0</span><span class="p">))</span>
        <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">u</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">v</span>

    <span class="nd">@lazy_property</span>
    <span class="k">def</span> <span class="nf">_uv</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_npix&#39;</span><span class="p">):</span>
            <span class="c1"># Need this check, since `_uv` is used by `_illuminated`, so need to make sure we</span>
            <span class="c1"># don&#39;t have an infinite loop.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_illuminated</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftfreq</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_npix</span><span class="p">,</span> <span class="mf">1.</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">_pupil_plane_size</span><span class="p">))</span>
        <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span>  <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">u</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Pupil horizontal coordinate array in meters.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_uv</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">v</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Pupil vertical coordinate array in meters.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_uv</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="nd">@lazy_property</span>
    <span class="k">def</span> <span class="nf">u_illuminated</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The u values for only the `illuminated` pixels.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">illuminated</span><span class="p">]</span>

    <span class="nd">@lazy_property</span>
    <span class="k">def</span> <span class="nf">v_illuminated</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The v values for only the `illuminated` pixels.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">v</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">illuminated</span><span class="p">]</span>

    <span class="nd">@lazy_property</span>
    <span class="k">def</span> <span class="nf">rsqr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Pupil radius squared array in meters squared.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">v</span><span class="o">**</span><span class="mi">2</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">diam</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Aperture diameter in meters&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_diam</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">obscuration</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Fraction linear obscuration of pupil.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_obscuration</span>

    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Let unpickled object reconstruct cached values on-the-fly instead of including them in the</span>
        <span class="c1"># pickle.</span>
        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;rho&#39;</span><span class="p">,</span> <span class="s1">&#39;_uv&#39;</span><span class="p">,</span> <span class="s1">&#39;rsqr&#39;</span><span class="p">,</span> <span class="s1">&#39;u_illuminated&#39;</span><span class="p">,</span> <span class="s1">&#39;v_illuminated&#39;</span><span class="p">):</span>
            <span class="n">d</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="c1"># Only reconstruct _illuminated if we made it from geometry.  If loaded, it&#39;s probably</span>
        <span class="c1"># faster to serialize the array.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pupil_plane_im</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">d</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;_illuminated&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">d</span>

    <span class="c1"># Some quick notes for Josh:</span>
    <span class="c1"># - Relation between real-space grid with size theta and pitch dtheta (dimensions of angle)</span>
    <span class="c1">#   and corresponding (fast) Fourier grid with size 2*maxk and pitch stepk (dimensions of</span>
    <span class="c1">#   inverse angle):</span>
    <span class="c1">#     stepk = 2*pi/theta</span>
    <span class="c1">#     maxk = pi/dtheta</span>
    <span class="c1"># - Relation between aperture of size L and pitch dL (dimensions of length, not angle!) and</span>
    <span class="c1">#   (fast) Fourier grid:</span>
    <span class="c1">#     dL = stepk * lambda / (2 * pi)</span>
    <span class="c1">#     L = maxk * lambda / pi</span>
    <span class="c1"># - Implies relation between aperture grid and real-space grid:</span>
    <span class="c1">#     dL = lambda/theta</span>
    <span class="c1">#     L = lambda/dtheta</span>
    <span class="c1">#</span>
    <span class="c1"># MJ: Of these four, only _sky_scale is still used.  The rest are left here for informational</span>
    <span class="c1"># purposes, but nothing actually calls them.</span>
    <span class="k">def</span> <span class="nf">_getStepK</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lam</span><span class="p">,</span> <span class="n">scale_unit</span><span class="o">=</span><span class="n">arcsec</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the Fourier grid spacing for this aperture at given wavelength.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            lam:        Wavelength in nanometers.</span>
<span class="sd">            scale_unit: Inverse units in which to return result [default: galsim.arcsec]</span>

<span class="sd">        Returns:</span>
<span class="sd">            Fourier grid spacing.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">pupil_plane_scale</span><span class="o">/</span><span class="p">(</span><span class="n">lam</span><span class="o">*</span><span class="mf">1e-9</span><span class="p">)</span> <span class="o">*</span> <span class="n">scale_unit</span><span class="o">/</span><span class="n">radians</span>

    <span class="k">def</span> <span class="nf">_getMaxK</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lam</span><span class="p">,</span> <span class="n">scale_unit</span><span class="o">=</span><span class="n">arcsec</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the Fourier grid half-size for this aperture at given wavelength.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            lam:        Wavelength in nanometers.</span>
<span class="sd">            scale_unit: Inverse units in which to return result [default: galsim.arcsec]</span>

<span class="sd">        Returns:</span>
<span class="sd">            Fourier grid half-size.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">pupil_plane_size</span><span class="o">/</span><span class="p">(</span><span class="n">lam</span><span class="o">*</span><span class="mf">1e-9</span><span class="p">)</span> <span class="o">*</span> <span class="n">scale_unit</span><span class="o">/</span><span class="n">radians</span>

    <span class="k">def</span> <span class="nf">_sky_scale</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lam</span><span class="p">,</span> <span class="n">scale_unit</span><span class="o">=</span><span class="n">arcsec</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the image scale for this aperture at given wavelength.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            lam:        Wavelength in nanometers.</span>
<span class="sd">            scale_unit: Units in which to return result [default: galsim.arcsec]</span>

<span class="sd">        Returns:</span>
<span class="sd">            Image scale.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">lam</span><span class="o">*</span><span class="mf">1e-9</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">pupil_plane_size</span> <span class="o">*</span> <span class="n">radians</span><span class="o">/</span><span class="n">scale_unit</span>

    <span class="k">def</span> <span class="nf">_sky_size</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lam</span><span class="p">,</span> <span class="n">scale_unit</span><span class="o">=</span><span class="n">arcsec</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the image size for this aperture at given wavelength.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            lam:        Wavelength in nanometers.</span>
<span class="sd">            scale_unit: Units in which to return result [default: galsim.arcsec]</span>

<span class="sd">        Returns:</span>
<span class="sd">            Image size.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">lam</span><span class="o">*</span><span class="mf">1e-9</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">pupil_plane_scale</span> <span class="o">*</span> <span class="n">radians</span><span class="o">/</span><span class="n">scale_unit</span></div>


<div class="viewcode-block" id="PhaseScreenList"><a class="viewcode-back" href="../../phase_psf.html#galsim.PhaseScreenList">[docs]</a><span class="k">class</span> <span class="nc">PhaseScreenList</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;List of phase screens that can be turned into a PSF.  Screens can be either atmospheric</span>
<span class="sd">    layers or optical phase screens.  Generally, one would assemble a PhaseScreenList object using</span>
<span class="sd">    the function `Atmosphere`.  Layers can be added, removed, appended, etc. just like items can</span>
<span class="sd">    be manipulated in a python list.  For example::</span>

<span class="sd">        # Create an atmosphere with three layers.</span>
<span class="sd">        &gt;&gt;&gt; screens = galsim.PhaseScreenList([galsim.AtmosphericScreen(...),</span>
<span class="sd">                                              galsim.AtmosphericScreen(...),</span>
<span class="sd">                                              galsim.AtmosphericScreen(...)])</span>
<span class="sd">        # Add another layer</span>
<span class="sd">        &gt;&gt;&gt; screens.append(galsim.AtmosphericScreen(...))</span>
<span class="sd">        # Remove the second layer</span>
<span class="sd">        &gt;&gt;&gt; del screens[1]</span>
<span class="sd">        # Switch the first and second layer.  Silly, but works...</span>
<span class="sd">        &gt;&gt;&gt; screens[0], screens[1] = screens[1], screens[0]</span>

<span class="sd">    Parameters:</span>
<span class="sd">        layers:     Sequence of phase screens.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">layers</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">.phase_screens</span> <span class="k">import</span> <span class="n">AtmosphericScreen</span><span class="p">,</span> <span class="n">OpticalScreen</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">layers</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># First check if layers[0] is a PhaseScreenList, so we avoid nesting.</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">layers</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">PhaseScreenList</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_layers</span> <span class="o">=</span> <span class="n">layers</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">_layers</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Next, see if layers[0] is iterable.  E.g., to catch generator expressions.</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_layers</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">layers</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_layers</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">layers</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_layers</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">layers</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_attrs</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pending</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># Pending PSFs to calculate upon first drawImage.</span>

    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_layers</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">items</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_layers</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{cls.__name__}</span><span class="s2"> indices must be integers or slices&quot;</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">cls</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">))</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">index</span> <span class="o">+</span> <span class="mi">1</span>   <span class="c1"># Regular in indices are the norm, so try something that works for it,</span>
                        <span class="c1"># but not for slices, where we need different handling.</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="c1"># index is a slice, so items is a list.</span>
            <span class="k">return</span> <span class="n">PhaseScreenList</span><span class="p">(</span><span class="n">items</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># index is an int, so items is just one screen.</span>
            <span class="k">return</span> <span class="n">items</span>

    <span class="k">def</span> <span class="nf">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">layer</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_layers</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">layer</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_attrs</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_layers</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_attrs</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">append</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">layer</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_layers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">layer</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_attrs</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">extend</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">layers</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_layers</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">layers</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_attrs</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;galsim.PhaseScreenList([</span><span class="si">%s</span><span class="s2">])&quot;</span> <span class="o">%</span> <span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_layers</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;galsim.PhaseScreenList(</span><span class="si">%r</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">_layers</span>

    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span> <span class="ow">is</span> <span class="n">other</span> <span class="ow">or</span>
                <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="n">PhaseScreenList</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_layers</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_layers</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span> <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">other</span>

    <span class="fm">__hash__</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># Mutable means not hashable.</span>

    <span class="k">def</span> <span class="nf">_update_attrs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># If any of the wrapped PhaseScreens have an rng, then eval(repr(screen_list)) will run, but</span>
        <span class="c1"># fail to round-trip to the original object.  So we search for that here and set/delete a</span>
        <span class="c1"># dummy rng sentinel attribute so do_pickle() will know to skip the obj == eval(repr(obj))</span>
        <span class="c1"># test.</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;rng&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dynamic</span> <span class="o">=</span> <span class="nb">any</span><span class="p">(</span><span class="n">l</span><span class="o">.</span><span class="n">dynamic</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reversible</span> <span class="o">=</span> <span class="nb">all</span><span class="p">(</span><span class="n">l</span><span class="o">.</span><span class="n">reversible</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;r0_500_effective&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_seek</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set all layers&#39; internal clocks to time t.&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">layer</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">layer</span><span class="o">.</span><span class="n">_seek</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="c1"># Time indep phase screen</span>
                <span class="k">pass</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_attrs</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_reset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Reset phase screens back to time=0.&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">layer</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">layer</span><span class="o">.</span><span class="n">_reset</span><span class="p">()</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="c1"># Time indep phase screen</span>
                <span class="k">pass</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_attrs</span><span class="p">()</span>

<div class="viewcode-block" id="PhaseScreenList.instantiate"><a class="viewcode-back" href="../../phase_psf.html#galsim.PhaseScreenList.instantiate">[docs]</a>    <span class="k">def</span> <span class="nf">instantiate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pool</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">_bar</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Instantiate the screens in this `PhaseScreenList`.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            pool:       A multiprocessing.Pool object to use to instantiate screens in parallel.</span>
<span class="sd">            **kwargs:   Keyword arguments to forward to screen.instantiate().</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">pool</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">layer</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pool</span><span class="o">.</span><span class="n">apply_async</span><span class="p">(</span><span class="n">layer</span><span class="o">.</span><span class="n">instantiate</span><span class="p">,</span> <span class="n">kwds</span><span class="o">=</span><span class="n">kwargs</span><span class="p">))</span>
                <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>  <span class="c1"># OpticalScreen has no instantiate method</span>
                    <span class="k">pass</span>
                <span class="k">if</span> <span class="n">_bar</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
                    <span class="n">_bar</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">results</span><span class="p">:</span>
                <span class="n">r</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">layer</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">layer</span><span class="o">.</span><span class="n">instantiate</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                    <span class="k">pass</span>
                <span class="k">if</span> <span class="n">_bar</span><span class="p">:</span>
                    <span class="n">_bar</span><span class="o">.</span><span class="n">update</span><span class="p">()</span></div>

    <span class="k">def</span> <span class="nf">_delayCalculation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">psf</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add psf to delayed calculation list.&quot;&quot;&quot;</span>
        <span class="n">heappush</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_pending</span><span class="p">,</span> <span class="p">(</span><span class="n">psf</span><span class="o">.</span><span class="n">t0</span><span class="p">,</span> <span class="n">OrderedWeakRef</span><span class="p">(</span><span class="n">psf</span><span class="p">)))</span>

    <span class="k">def</span> <span class="nf">_prepareDraw</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate previously delayed PSFs.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pending</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="c1"># See if we have any dynamic screens.  If not, then we can immediately compute each PSF</span>
        <span class="c1"># in a simple loop.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">dynamic</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">psfref</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pending</span><span class="p">:</span>
                <span class="n">psf</span> <span class="o">=</span> <span class="n">psfref</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">psf</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">psf</span><span class="o">.</span><span class="n">_step</span><span class="p">()</span>
                    <span class="n">psf</span><span class="o">.</span><span class="n">_finalize</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_pending</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_time_heap</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">return</span>

        <span class="c1"># If we do have time-evolving screens, then iteratively increment the time while being</span>
        <span class="c1"># careful to always stop at multiples of each PSF&#39;s time_step attribute to update that PSF.</span>
        <span class="c1"># Use a heap (in _pending list) to track the next time to stop at.</span>
        <span class="k">while</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_pending</span><span class="p">):</span>
            <span class="c1"># Get and seek to next time that has a PSF update.</span>
            <span class="n">t</span><span class="p">,</span> <span class="n">psfref</span> <span class="o">=</span> <span class="n">heappop</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_pending</span><span class="p">)</span>
            <span class="c1"># Check if this PSF weakref is still alive</span>
            <span class="n">psf</span> <span class="o">=</span> <span class="n">psfref</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">psf</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># If it&#39;s alive, update this PSF</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_seek</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
                <span class="n">psf</span><span class="o">.</span><span class="n">_step</span><span class="p">()</span>
                <span class="c1"># If that PSF&#39;s next possible update time doesn&#39;t extend past its exptime, then</span>
                <span class="c1"># push it back on the heap.</span>
                <span class="n">t</span> <span class="o">+=</span> <span class="n">psf</span><span class="o">.</span><span class="n">time_step</span>
                <span class="k">if</span> <span class="n">t</span> <span class="o">&lt;</span> <span class="n">psf</span><span class="o">.</span><span class="n">t0</span> <span class="o">+</span> <span class="n">psf</span><span class="o">.</span><span class="n">exptime</span><span class="p">:</span>
                    <span class="n">heappush</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_pending</span><span class="p">,</span> <span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">OrderedWeakRef</span><span class="p">(</span><span class="n">psf</span><span class="p">)))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">psf</span><span class="o">.</span><span class="n">_finalize</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pending</span> <span class="o">=</span> <span class="p">[]</span>

<div class="viewcode-block" id="PhaseScreenList.wavefront"><a class="viewcode-back" href="../../phase_psf.html#galsim.PhaseScreenList.wavefront">[docs]</a>    <span class="k">def</span> <span class="nf">wavefront</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="p">(</span><span class="mf">0.0</span><span class="o">*</span><span class="n">radians</span><span class="p">,</span> <span class="mf">0.0</span><span class="o">*</span><span class="n">radians</span><span class="p">)):</span>
        <span class="sd">&quot;&quot;&quot; Compute cumulative wavefront due to all phase screens in `PhaseScreenList`.</span>

<span class="sd">        Wavefront here indicates the distance by which the physical wavefront lags or leads the</span>
<span class="sd">        ideal plane wave (pre-optics) or spherical wave (post-optics).</span>

<span class="sd">        Parameters:</span>
<span class="sd">            u:      Horizontal pupil coordinate (in meters) at which to evaluate wavefront.  Can</span>
<span class="sd">                    be a scalar or an iterable.  The shapes of u and v must match.</span>
<span class="sd">            v:      Vertical pupil coordinate (in meters) at which to evaluate wavefront.  Can</span>
<span class="sd">                    be a scalar or an iterable.  The shapes of u and v must match.</span>
<span class="sd">            t:      Times (in seconds) at which to evaluate wavefront.  Can be None, a scalar or an</span>
<span class="sd">                    iterable.  If None, then the internal time of the phase screens will be used</span>
<span class="sd">                    for all u, v.  If scalar, then the size will be broadcast up to match that of</span>
<span class="sd">                    u and v.  If iterable, then the shape must match the shapes of u and v.</span>
<span class="sd">            theta:  Field angle at which to evaluate wavefront, as a 2-tuple of `galsim.Angle`</span>
<span class="sd">                    instances. [default: (0.0*galsim.arcmin, 0.0*galsim.arcmin)]</span>
<span class="sd">                    Only a single theta is permitted.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Array of wavefront lag or lead in nanometers.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_layers</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="n">layer</span><span class="o">.</span><span class="n">wavefront</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">theta</span><span class="p">)</span> <span class="k">for</span> <span class="n">layer</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_layers</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">wavefront</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">theta</span><span class="p">)</span></div>

<div class="viewcode-block" id="PhaseScreenList.wavefront_gradient"><a class="viewcode-back" href="../../phase_psf.html#galsim.PhaseScreenList.wavefront_gradient">[docs]</a>    <span class="k">def</span> <span class="nf">wavefront_gradient</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="p">(</span><span class="mf">0.0</span><span class="o">*</span><span class="n">radians</span><span class="p">,</span> <span class="mf">0.0</span><span class="o">*</span><span class="n">radians</span><span class="p">)):</span>
        <span class="sd">&quot;&quot;&quot; Compute cumulative wavefront gradient due to all phase screens in `PhaseScreenList`.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            u:      Horizontal pupil coordinate (in meters) at which to evaluate wavefront.  Can</span>
<span class="sd">                    be a scalar or an iterable.  The shapes of u and v must match.</span>
<span class="sd">            v:      Vertical pupil coordinate (in meters) at which to evaluate wavefront.  Can</span>
<span class="sd">                    be a scalar or an iterable.  The shapes of u and v must match.</span>
<span class="sd">            t:      Times (in seconds) at which to evaluate wavefront gradient.  Can be None, a</span>
<span class="sd">                    scalar or an iterable.  If None, then the internal time of the phase screens</span>
<span class="sd">                    will be used for all u, v.  If scalar, then the size will be broadcast up to</span>
<span class="sd">                    match that of u and v.  If iterable, then the shape must match the shapes of</span>
<span class="sd">                    u and v.</span>
<span class="sd">            theta:  Field angle at which to evaluate wavefront, as a 2-tuple of `galsim.Angle`</span>
<span class="sd">                    instances. [default: (0.0*galsim.arcmin, 0.0*galsim.arcmin)]</span>
<span class="sd">                    Only a single theta is permitted.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Arrays dWdu and dWdv of wavefront lag or lead gradient in nm/m.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_layers</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="n">layer</span><span class="o">.</span><span class="n">wavefront_gradient</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">theta</span><span class="p">)</span> <span class="k">for</span> <span class="n">layer</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_layers</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">wavefront_gradient</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">theta</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_wavefront</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">theta</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_layers</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="n">layer</span><span class="o">.</span><span class="n">_wavefront</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">theta</span><span class="p">)</span> <span class="k">for</span> <span class="n">layer</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_layers</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">_wavefront</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">theta</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_wavefront_gradient</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">theta</span><span class="p">):</span>
        <span class="n">gradx</span><span class="p">,</span> <span class="n">grady</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_layers</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">_wavefront_gradient</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">theta</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">layer</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_layers</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="n">gx</span><span class="p">,</span> <span class="n">gy</span> <span class="o">=</span> <span class="n">layer</span><span class="o">.</span><span class="n">_wavefront_gradient</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">theta</span><span class="p">)</span>
            <span class="n">gradx</span> <span class="o">+=</span> <span class="n">gx</span>
            <span class="n">grady</span> <span class="o">+=</span> <span class="n">gy</span>
        <span class="k">return</span> <span class="n">gradx</span><span class="p">,</span> <span class="n">grady</span>

<div class="viewcode-block" id="PhaseScreenList.makePSF"><a class="viewcode-back" href="../../phase_psf.html#galsim.PhaseScreenList.makePSF">[docs]</a>    <span class="k">def</span> <span class="nf">makePSF</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lam</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create a PSF from the current `PhaseScreenList`.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            lam:                Wavelength in nanometers at which to compute PSF.</span>
<span class="sd">            t0:                 Time at which to start exposure in seconds.  [default: 0.0]</span>
<span class="sd">            exptime:            Time in seconds over which to accumulate evolving instantaneous</span>
<span class="sd">                                PSF.  [default: 0.0]</span>
<span class="sd">            time_step:          Time interval in seconds with which to sample phase screens when</span>
<span class="sd">                                drawing using real-space or Fourier methods, or when using</span>
<span class="sd">                                photon-shooting without the geometric optics approximation.  Note</span>
<span class="sd">                                that the default value of 0.025 is fairly arbitrary.  For careful</span>
<span class="sd">                                studies, we recommend checking that results are stable when</span>
<span class="sd">                                decreasing time_step.  Also note that when drawing using</span>
<span class="sd">                                photon-shooting with the geometric optics approximation this</span>
<span class="sd">                                keyword is ignored, as the phase screen can be sampled</span>
<span class="sd">                                continuously in this case instead of at discrete intervals.</span>
<span class="sd">                                [default: 0.025]</span>
<span class="sd">            flux:               Flux of output PSF.  [default: 1.0]</span>
<span class="sd">            theta:              Field angle of PSF as a 2-tuple of `Angle` instances.</span>
<span class="sd">                                [default: (0.0*galsim.arcmin, 0.0*galsim.arcmin)]</span>
<span class="sd">            interpolant:        Either an Interpolant instance or a string indicating which</span>
<span class="sd">                                interpolant should be used.  Options are &#39;nearest&#39;, &#39;sinc&#39;,</span>
<span class="sd">                                &#39;linear&#39;, &#39;cubic&#39;, &#39;quintic&#39;, or &#39;lanczosN&#39; where N should be the</span>
<span class="sd">                                integer order to use. [default: galsim.Quintic()]</span>
<span class="sd">            scale_unit:         Units to use for the sky coordinates of the output profile.</span>
<span class="sd">                                [default: galsim.arcsec]</span>
<span class="sd">            ii_pad_factor:      Zero-padding factor by which to extend the image of the PSF when</span>
<span class="sd">                                creating the ``InterpolatedImage``.  See the</span>
<span class="sd">                                ``InterpolatedImage`` docstring for more details.  [default: 4.]</span>
<span class="sd">            suppress_warning:   If ``pad_factor`` is too small, the code will emit a warning</span>
<span class="sd">                                telling you its best guess about how high you might want to raise</span>
<span class="sd">                                it.  However, you can suppress this warning by using</span>
<span class="sd">                                ``suppress_warning=True``.  [default: False]</span>
<span class="sd">            geometric_shooting: If True, then when drawing using photon shooting, use geometric</span>
<span class="sd">                                optics approximation where the photon angles are derived from the</span>
<span class="sd">                                phase screen gradient.  If False, then first draw using Fourier</span>
<span class="sd">                                optics and then shoot from the derived InterpolatedImage.</span>
<span class="sd">                                [default: True]</span>
<span class="sd">            aper:               `Aperture` to use to compute PSF(s).  [default: None]</span>
<span class="sd">            gsparams:           An optional `GSParams` argument. [default: None]</span>

<span class="sd">        The following are optional keywords to use to setup the aperture if ``aper`` is not</span>
<span class="sd">        provided.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            diam:               Aperture diameter in meters.</span>
<span class="sd">            circular_pupil:     Adopt a circular pupil?  [default: True]</span>
<span class="sd">            obscuration:        Linear dimension of central obscuration as fraction of aperture</span>
<span class="sd">                                linear dimension. [0., 1.).  [default: 0.0]</span>
<span class="sd">            nstruts:            Number of radial support struts to add to the central</span>
<span class="sd">                                obscuration. [default: 0]</span>
<span class="sd">            strut_thick:        Thickness of support struts as a fraction of aperture diameter.</span>
<span class="sd">                                [default: 0.05]</span>
<span class="sd">            strut_angle:        `Angle` made between the vertical and the strut starting closest to</span>
<span class="sd">                                it, defined to be positive in the counter-clockwise direction;</span>
<span class="sd">                                must be an `Angle` instance. [default: 0. * galsim.degrees]</span>
<span class="sd">            oversampling:       Optional oversampling factor *in the image plane* for the PSF</span>
<span class="sd">                                eventually constructed using this `Aperture`.  Setting</span>
<span class="sd">                                ``oversampling &lt; 1`` will produce aliasing in the PSF (not good).</span>
<span class="sd">                                [default: 1.0]</span>
<span class="sd">            pad_factor:         Additional multiple by which to extend the PSF image to avoid</span>
<span class="sd">                                folding.  [default: 1.0]</span>
<span class="sd">            pupil_plane_im:     The GalSim.Image, NumPy array, or name of file containing the</span>
<span class="sd">                                pupil plane image, to be used instead of generating one based on</span>
<span class="sd">                                the obscuration and strut parameters.  [default: None]</span>
<span class="sd">            pupil_angle:        If ``pupil_plane_im`` is not None, rotation angle for the pupil</span>
<span class="sd">                                plane (positive in the counter-clockwise direction).  Must be an</span>
<span class="sd">                                `Angle` instance. [default: 0. * galsim.degrees]</span>
<span class="sd">            pupil_plane_scale:  Sampling interval in meters to use for the pupil plane array.  In</span>
<span class="sd">                                most cases, it&#39;s a good idea to leave this as None, in which case</span>
<span class="sd">                                GalSim will attempt to find a good value automatically.  The</span>
<span class="sd">                                exception is when specifying the pupil arrangement via an image,</span>
<span class="sd">                                in which case this keyword can be used to indicate the sampling</span>
<span class="sd">                                of that image.  See also ``pad_factor`` for adjusting the pupil</span>
<span class="sd">                                sampling scale. [default: None]</span>
<span class="sd">            pupil_plane_size:   Size in meters to use for the pupil plane array.  In most cases,</span>
<span class="sd">                                it&#39;s a good idea to leave this as None, in which case GalSim will</span>
<span class="sd">                                attempt to find a good value automatically.  See also</span>
<span class="sd">                                ``oversampling`` for adjusting the pupil size.  [default: None]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">PhaseScreenPSF</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lam</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

    <span class="nd">@lazy_property</span>
    <span class="k">def</span> <span class="nf">r0_500_effective</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Effective r0_500 for set of screens in list that define an r0_500 attribute.&quot;&quot;&quot;</span>
        <span class="n">r0_500s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">l</span><span class="o">.</span><span class="n">r0_500</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="bp">self</span> <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="s1">&#39;r0_500&#39;</span><span class="p">)])</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">r0_500s</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">r0_500s</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="mf">5.</span><span class="o">/</span><span class="mi">3</span><span class="p">))</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="mf">3.</span><span class="o">/</span><span class="mi">5</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_getStepK</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return an appropriate stepk for this list of phase screens.</span>

<span class="sd">        The required set of parameters depends on the types of the individual `PhaseScreen`</span>
<span class="sd">        instances in the `PhaseScreenList`.  See the documentation for the individual</span>
<span class="sd">        `PhaseScreen.pupil_plane_scale` methods for more details.</span>

<span class="sd">        Returns:</span>
<span class="sd">            stepk.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Generically, GalSim propagates stepk for convolutions using</span>
        <span class="c1">#   stepk = sum(s**-2 for s in stepks)**(-0.5)</span>
        <span class="c1"># We&#39;re not actually doing convolution between screens here, though.  In fact, the right</span>
        <span class="c1"># relation for Kolmogorov screens uses exponents -5./3 and -3./5:</span>
        <span class="c1">#   stepk = sum(s**(-5./3) for s in stepks)**(-3./5)</span>
        <span class="c1"># Since most of the layers in a PhaseScreenList are likely to be (nearly) Kolmogorov</span>
        <span class="c1"># screens, we&#39;ll use that relation.</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="n">layer</span><span class="o">.</span><span class="n">_getStepK</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="mf">5.</span><span class="o">/</span><span class="mi">3</span><span class="p">)</span> <span class="k">for</span> <span class="n">layer</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">])</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="mf">3.</span><span class="o">/</span><span class="mi">5</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">d</span><span class="p">[</span><span class="s1">&#39;_pending&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">return</span> <span class="n">d</span></div>


<div class="viewcode-block" id="PhaseScreenPSF"><a class="viewcode-back" href="../../phase_psf.html#galsim.PhaseScreenPSF">[docs]</a><span class="k">class</span> <span class="nc">PhaseScreenPSF</span><span class="p">(</span><span class="n">GSObject</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A PSF surface brightness profile constructed by integrating over time the instantaneous PSF</span>
<span class="sd">    derived from a set of phase screens and an aperture.</span>

<span class="sd">    There are two equivalent ways to construct a PhaseScreenPSF given a `PhaseScreenList`::</span>

<span class="sd">        &gt;&gt;&gt; psf = screen_list.makePSF(...)</span>
<span class="sd">        &gt;&gt;&gt; psf = PhaseScreenPSF(screen_list, ...)</span>

<span class="sd">    Computing a PSF from a phase screen also requires an `Aperture` be specified.  This can be done</span>
<span class="sd">    either directly via the ``aper`` keyword, or by setting a number of keywords that will be passed</span>
<span class="sd">    to the `Aperture` constructor.  The ``aper`` keyword always takes precedence.</span>

<span class="sd">    There are effectively three ways to draw a PhaseScreenPSF (or `GSObject` that includes a</span>
<span class="sd">    PhaseScreenPSF):</span>

<span class="sd">    1) Fourier optics</span>

<span class="sd">        This is the default, and is performed for all drawImage methods except method=&#39;phot&#39;.  This</span>
<span class="sd">        is generally the most accurate option.  For a `PhaseScreenList` that includes an</span>
<span class="sd">        `AtmosphericScreen`, however, this can be prohibitively slow.  For `OpticalPSF`, though,</span>
<span class="sd">        this can sometimes be a good option.</span>

<span class="sd">    2) Photon-shooting from an image produced using Fourier optics.</span>

<span class="sd">        This is done if geometric_shooting=False when creating the PhaseScreenPSF, and method=&#39;phot&#39;</span>
<span class="sd">        when calling drawImage.  This actually performs the same calculations as the Fourier optics</span>
<span class="sd">        option above, but then proceeds by shooting photons from that result.  This can sometimes be</span>
<span class="sd">        a good option for OpticalPSFs, especially if the same OpticalPSF can be reused for may</span>
<span class="sd">        objects, since the Fourier part of the process would only be performed once in this case.</span>

<span class="sd">    3) Photon-shooting using the &quot;geometric approximation&quot;.</span>

<span class="sd">        This is done if geometric_shooting=True when creating the PhaseScreenPSF, and method=&#39;phot&#39;</span>
<span class="sd">        when calling drawImage.  In this case, a completely different algorithm is used make an</span>
<span class="sd">        image.  Photons are uniformly generated in the `Aperture` pupil, and then the phase gradient</span>
<span class="sd">        at that location is used to deflect each photon in the image plane.  This method, which</span>
<span class="sd">        corresponds to geometric optics, is broadly accurate for phase screens that vary slowly</span>
<span class="sd">        across the aperture, and is usually several orders of magnitude or more faster than Fourier</span>
<span class="sd">        optics (depending on the flux of the object, of course, but much faster even for rather</span>
<span class="sd">        bright flux levels).</span>

<span class="sd">        One short-coming of this method is that it neglects interference effects, i.e. diffraction.</span>
<span class="sd">        For `PhaseScreenList` that include at least one `AtmosphericScreen`, a correction, dubbed</span>
<span class="sd">        the &quot;second kick&quot;, will automatically be applied to handle both the quickly varying modes</span>
<span class="sd">        of the screens and the diffraction pattern of the `Aperture`.  For PhaseScreenLists without</span>
<span class="sd">        an `AtmosphericScreen`, the correction is simply an Airy function.  Note that this</span>
<span class="sd">        correction can be overridden using the second_kick keyword argument, and also tuned to some</span>
<span class="sd">        extent using the kcrit keyword argument.</span>

<span class="sd">    Note also that calling drawImage on a PhaseScreenPSF that uses a `PhaseScreenList` with any</span>
<span class="sd">    uninstantiated `AtmosphericScreen` will perform that instantiation, and that the details of the</span>
<span class="sd">    instantiation depend on the drawing method used, and also the kcrit keyword argument to</span>
<span class="sd">    PhaseScreenPSF.  See the `AtmosphericScreen` docstring for more details.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        screen_list:        `PhaseScreenList` object from which to create PSF.</span>
<span class="sd">        lam:                Wavelength in nanometers at which to compute PSF.</span>
<span class="sd">        t0:                 Time at which to start exposure in seconds.  [default: 0.0]</span>
<span class="sd">        exptime:            Time in seconds over which to accumulate evolving instantaneous PSF.</span>
<span class="sd">                            [default: 0.0]</span>
<span class="sd">        time_step:          Time interval in seconds with which to sample phase screens when</span>
<span class="sd">                            drawing using real-space or Fourier methods, or when using</span>
<span class="sd">                            photon-shooting without the geometric optics approximation.  Note</span>
<span class="sd">                            that the default value of 0.025 is fairly arbitrary.  For careful</span>
<span class="sd">                            studies, we recommend checking that results are stable when</span>
<span class="sd">                            decreasing time_step.  Also note that when drawing using</span>
<span class="sd">                            photon-shooting with the geometric optics approximation this</span>
<span class="sd">                            keyword is ignored, as the phase screen can be sampled</span>
<span class="sd">                            continuously in this case instead of at discrete intervals.</span>
<span class="sd">                            [default: 0.025]</span>
<span class="sd">        flux:               Flux of output PSF [default: 1.0]</span>
<span class="sd">        theta:              Field angle of PSF as a 2-tuple of `Angle` instances.</span>
<span class="sd">                            [default: (0.0*galsim.arcmin, 0.0*galsim.arcmin)]</span>
<span class="sd">        interpolant:        Either an Interpolant instance or a string indicating which</span>
<span class="sd">                            interpolant should be used.  Options are &#39;nearest&#39;, &#39;sinc&#39;, &#39;linear&#39;,</span>
<span class="sd">                            &#39;cubic&#39;, &#39;quintic&#39;, or &#39;lanczosN&#39; where N should be the integer order</span>
<span class="sd">                            to use.  [default: galsim.Quintic()]</span>
<span class="sd">        scale_unit:         Units to use for the sky coordinates of the output profile.</span>
<span class="sd">                            [default: galsim.arcsec]</span>
<span class="sd">        ii_pad_factor:      Zero-padding factor by which to extend the image of the PSF when</span>
<span class="sd">                            creating the ``InterpolatedImage``.  See the ``InterpolatedImage``</span>
<span class="sd">                            docstring for more details.  [default: 4.]</span>
<span class="sd">        suppress_warning:   If ``pad_factor`` is too small, the code will emit a warning telling</span>
<span class="sd">                            you its best guess about how high you might want to raise it.</span>
<span class="sd">                            However, you can suppress this warning by using</span>
<span class="sd">                            ``suppress_warning=True``.  [default: False]</span>
<span class="sd">        geometric_shooting: If True, then when drawing using photon shooting, use geometric</span>
<span class="sd">                            optics approximation where the photon angles are derived from the</span>
<span class="sd">                            phase screen gradient.  If False, then first draw using Fourier</span>
<span class="sd">                            optics and then shoot from the derived InterpolatedImage.</span>
<span class="sd">                            [default: True]</span>
<span class="sd">        aper:               `Aperture` to use to compute PSF(s).  [default: None]</span>
<span class="sd">        second_kick:        An optional second kick to also convolve by when using geometric</span>
<span class="sd">                            photon-shooting.  (This can technically be any `GSObject`, though</span>
<span class="sd">                            usually it should probably be a SecondKick object).  If None, then a</span>
<span class="sd">                            good second kick will be chosen automatically based on</span>
<span class="sd">                            ``screen_list``.  If False, then a second kick won&#39;t be applied.</span>
<span class="sd">                            [default: None]</span>
<span class="sd">        kcrit:              Critical Fourier scale (in units of 1/r0) at which to separate low-k</span>
<span class="sd">                            and high-k turbulence.  The default value was chosen based on</span>
<span class="sd">                            comparisons between Fourier optics and geometric optics with a second</span>
<span class="sd">                            kick correction.  While most values of kcrit smaller than the default</span>
<span class="sd">                            produce similar results, we caution the user to compare the affected</span>
<span class="sd">                            geometric PSFs against Fourier optics PSFs carefully before changing</span>
<span class="sd">                            this value.  [default: 0.2]</span>
<span class="sd">        gsparams:           An optional `GSParams` argument. [default: None]</span>

<span class="sd">    The following are optional keywords to use to setup the aperture if ``aper`` is not provided:</span>

<span class="sd">    Parameters:</span>
<span class="sd">        diam:               Aperture diameter in meters. [default: None]</span>
<span class="sd">        circular_pupil:     Adopt a circular pupil?  [default: True]</span>
<span class="sd">        obscuration:        Linear dimension of central obscuration as fraction of aperture</span>
<span class="sd">                            linear dimension. [0., 1.).  [default: 0.0]</span>
<span class="sd">        nstruts:            Number of radial support struts to add to the central obscuration.</span>
<span class="sd">                            [default: 0]</span>
<span class="sd">        strut_thick:        Thickness of support struts as a fraction of aperture diameter.</span>
<span class="sd">                            [default: 0.05]</span>
<span class="sd">        strut_angle:        `Angle` made between the vertical and the strut starting closest to it,</span>
<span class="sd">                            defined to be positive in the counter-clockwise direction; must be an</span>
<span class="sd">                            `Angle` instance. [default: 0. * galsim.degrees]</span>
<span class="sd">        oversampling:       Optional oversampling factor *in the image plane* for the PSF</span>
<span class="sd">                            eventually constructed using this `Aperture`.  Setting</span>
<span class="sd">                            ``oversampling &lt; 1`` will produce aliasing in the PSF (not good).</span>
<span class="sd">                            [default: 1.0]</span>
<span class="sd">        pad_factor:         Additional multiple by which to extend the PSF image to avoid</span>
<span class="sd">                            folding.  [default: 1.0]</span>
<span class="sd">        pupil_plane_im:     The GalSim.Image, NumPy array, or name of file containing the pupil</span>
<span class="sd">                            plane image, to be used instead of generating one based on the</span>
<span class="sd">                            obscuration and strut parameters.  [default: None]</span>
<span class="sd">        pupil_angle:        If ``pupil_plane_im`` is not None, rotation angle for the pupil plane</span>
<span class="sd">                            (positive in the counter-clockwise direction).  Must be an `Angle`</span>
<span class="sd">                            instance. [default: 0. * galsim.degrees]</span>
<span class="sd">        pupil_plane_scale:  Sampling interval in meters to use for the pupil plane array.  In</span>
<span class="sd">                            most cases, it&#39;s a good idea to leave this as None, in which case</span>
<span class="sd">                            GalSim will attempt to find a good value automatically.  The</span>
<span class="sd">                            exception is when specifying the pupil arrangement via an image, in</span>
<span class="sd">                            which case this keyword can be used to indicate the sampling of that</span>
<span class="sd">                            image.  See also ``pad_factor`` for adjusting the pupil sampling</span>
<span class="sd">                            scale.  [default: None]</span>
<span class="sd">        pupil_plane_size:   Size in meters to use for the pupil plane array.  In most cases, it&#39;s</span>
<span class="sd">                            a good idea to leave this as None, in which case GalSim will attempt</span>
<span class="sd">                            to find a good value automatically.  See also ``oversampling`` for</span>
<span class="sd">                            adjusting the pupil size.  [default: None]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_has_hard_edges</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">_is_axisymmetric</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">_is_analytic_x</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">_is_analytic_k</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">screen_list</span><span class="p">,</span> <span class="n">lam</span><span class="p">,</span> <span class="n">t0</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">exptime</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">time_step</span><span class="o">=</span><span class="mf">0.025</span><span class="p">,</span> <span class="n">flux</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
                 <span class="n">theta</span><span class="o">=</span><span class="p">(</span><span class="mf">0.0</span><span class="o">*</span><span class="n">arcsec</span><span class="p">,</span> <span class="mf">0.0</span><span class="o">*</span><span class="n">arcsec</span><span class="p">),</span> <span class="n">interpolant</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">scale_unit</span><span class="o">=</span><span class="n">arcsec</span><span class="p">,</span> <span class="n">ii_pad_factor</span><span class="o">=</span><span class="mf">4.</span><span class="p">,</span> <span class="n">suppress_warning</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">geometric_shooting</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">aper</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">second_kick</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">kcrit</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span>
                 <span class="n">gsparams</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">_force_stepk</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span> <span class="n">_force_maxk</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span> <span class="n">_bar</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># Hidden `_bar` kwarg can be used with astropy.console.utils.ProgressBar to print out a</span>
        <span class="c1"># progress bar during long calculations.</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_screen_list</span> <span class="o">=</span> <span class="n">screen_list</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">t0</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">t0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lam</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">lam</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">exptime</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">exptime</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">time_step</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">time_step</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">aper</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Check here for diameter.</span>
            <span class="k">if</span> <span class="s1">&#39;diam&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">GalSimIncompatibleValuesError</span><span class="p">(</span>
                    <span class="s2">&quot;Diameter required if aperture not specified directly.&quot;</span><span class="p">,</span> <span class="n">diam</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">aper</span><span class="o">=</span><span class="n">aper</span><span class="p">)</span>
            <span class="n">aper</span> <span class="o">=</span> <span class="n">Aperture</span><span class="p">(</span><span class="n">lam</span><span class="o">=</span><span class="n">lam</span><span class="p">,</span> <span class="n">screen_list</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_screen_list</span><span class="p">,</span> <span class="n">gsparams</span><span class="o">=</span><span class="n">gsparams</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">gsparams</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">gsparams</span> <span class="o">=</span> <span class="n">aper</span><span class="o">.</span><span class="n">gsparams</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">aper</span> <span class="o">=</span> <span class="n">aper</span><span class="o">.</span><span class="n">withGSParams</span><span class="p">(</span><span class="n">gsparams</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">aper</span> <span class="o">=</span> <span class="n">aper</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">theta</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Angle</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">theta</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">Angle</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;theta must be 2-tuple of galsim.Angle&#39;s.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">theta</span> <span class="o">=</span> <span class="n">theta</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">interpolant</span> <span class="o">=</span> <span class="n">interpolant</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">scale_unit</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">scale_unit</span> <span class="o">=</span> <span class="n">AngleUnit</span><span class="o">.</span><span class="n">from_name</span><span class="p">(</span><span class="n">scale_unit</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scale_unit</span> <span class="o">=</span> <span class="n">scale_unit</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_gsparams</span> <span class="o">=</span> <span class="n">GSParams</span><span class="o">.</span><span class="n">check</span><span class="p">(</span><span class="n">gsparams</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scale</span> <span class="o">=</span> <span class="n">aper</span><span class="o">.</span><span class="n">_sky_scale</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lam</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale_unit</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_force_stepk</span> <span class="o">=</span> <span class="n">_force_stepk</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_force_maxk</span> <span class="o">=</span> <span class="n">_force_maxk</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_img</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">exptime</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">GalSimRangeError</span><span class="p">(</span><span class="s2">&quot;Cannot integrate PSF for negative time.&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">exptime</span><span class="p">,</span> <span class="mf">0.</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_ii_pad_factor</span> <span class="o">=</span> <span class="n">ii_pad_factor</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_bar</span> <span class="o">=</span> <span class="n">_bar</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_flux</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">flux</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_suppress_warning</span> <span class="o">=</span> <span class="n">suppress_warning</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_geometric_shooting</span> <span class="o">=</span> <span class="n">geometric_shooting</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_kcrit</span> <span class="o">=</span> <span class="n">kcrit</span>
        <span class="c1"># We&#39;ll set these more intelligently as needed below</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_second_kick</span> <span class="o">=</span> <span class="n">second_kick</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_screen_list</span><span class="o">.</span><span class="n">_delayCalculation</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_finalized</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="nd">@lazy_property</span>
    <span class="k">def</span> <span class="nf">_real_ii</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">ii</span> <span class="o">=</span> <span class="n">InterpolatedImage</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_img</span><span class="p">,</span> <span class="n">x_interpolant</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">interpolant</span><span class="p">,</span>
                <span class="n">_force_stepk</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_force_stepk</span><span class="p">,</span> <span class="n">_force_maxk</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_force_maxk</span><span class="p">,</span>
                <span class="n">pad_factor</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_ii_pad_factor</span><span class="p">,</span>
                <span class="n">use_true_center</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">gsparams</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_gsparams</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_suppress_warning</span><span class="p">:</span>
            <span class="n">specified_stepk</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_img</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">)</span>
            <span class="n">observed_stepk</span> <span class="o">=</span> <span class="n">ii</span><span class="o">.</span><span class="n">stepk</span>

            <span class="k">if</span> <span class="n">observed_stepk</span> <span class="o">&lt;</span> <span class="n">specified_stepk</span><span class="p">:</span>
                <span class="n">galsim_warn</span><span class="p">(</span>
                    <span class="s2">&quot;The calculated stepk (</span><span class="si">%g</span><span class="s2">) for PhaseScreenPSF is smaller than what was used &quot;</span>
                    <span class="s2">&quot;to build the wavefront (</span><span class="si">%g</span><span class="s2">). This could lead to aliasing problems. &quot;</span>
                    <span class="s2">&quot;Increasing pad_factor is recommended.&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">observed_stepk</span><span class="p">,</span> <span class="n">specified_stepk</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">ii</span>

    <span class="nd">@lazy_property</span>
    <span class="k">def</span> <span class="nf">_dummy_ii</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># If we need self._ii before we&#39;ve done _prepareDraw, then build a placeholder that has</span>
        <span class="c1"># roughly the right properties. All we really need is for the stepk and maxk to be</span>
        <span class="c1"># correct, so use the force_ options to set them how we want.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_force_stepk</span> <span class="o">&gt;</span> <span class="mf">0.</span><span class="p">:</span>
            <span class="n">stepk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_force_stepk</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">stepk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_screen_list</span><span class="o">.</span><span class="n">_getStepK</span><span class="p">(</span><span class="n">lam</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">lam</span><span class="p">,</span> <span class="n">diam</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">aper</span><span class="o">.</span><span class="n">diam</span><span class="p">,</span>
                                                <span class="n">obscuration</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">aper</span><span class="o">.</span><span class="n">obscuration</span><span class="p">,</span>
                                                <span class="n">gsparams</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_gsparams</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_force_maxk</span> <span class="o">&gt;</span> <span class="mf">0.</span><span class="p">:</span>
            <span class="n">maxk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_force_maxk</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">maxk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">aper</span><span class="o">.</span><span class="n">_getMaxK</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lam</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale_unit</span><span class="p">)</span>
        <span class="n">image</span> <span class="o">=</span> <span class="n">_Image</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="bp">self</span><span class="o">.</span><span class="n">_flux</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">),</span>
                       <span class="n">_BoundsI</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">PixelScale</span><span class="p">(</span><span class="mf">1.</span><span class="p">))</span>
        <span class="n">interpolant</span> <span class="o">=</span> <span class="s1">&#39;delta&#39;</span>  <span class="c1"># Use delta so it doesn&#39;t contribute to stepk</span>
        <span class="k">return</span> <span class="n">InterpolatedImage</span><span class="p">(</span>
                <span class="n">image</span><span class="p">,</span> <span class="n">pad_factor</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">x_interpolant</span><span class="o">=</span><span class="n">interpolant</span><span class="p">,</span>
                <span class="n">_force_stepk</span><span class="o">=</span><span class="n">stepk</span><span class="p">,</span> <span class="n">_force_maxk</span><span class="o">=</span><span class="n">maxk</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_ii</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_finalized</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_real_ii</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dummy_ii</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">kcrit</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The critical Fourier scale being used for this object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kcrit</span>

    <span class="nd">@lazy_property</span>
    <span class="k">def</span> <span class="nf">screen_kmax</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The maximum k value to use in the screen.  Typically `kcrit`/r0.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">r0_500</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_screen_list</span><span class="o">.</span><span class="n">r0_500_effective</span>
        <span class="k">if</span> <span class="n">r0_500</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">r0</span> <span class="o">=</span> <span class="n">r0_500</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lam</span><span class="o">/</span><span class="mi">500</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="mf">6.</span><span class="o">/</span><span class="mi">5</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">kcrit</span> <span class="o">/</span> <span class="n">r0</span>

    <span class="nd">@lazy_property</span>
    <span class="k">def</span> <span class="nf">second_kick</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Make a SecondKick object based on contents of screen_list and aper.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.airy</span> <span class="k">import</span> <span class="n">Airy</span>
        <span class="kn">from</span> <span class="nn">.second_kick</span> <span class="k">import</span> <span class="n">SecondKick</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_second_kick</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">r0_500</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_screen_list</span><span class="o">.</span><span class="n">r0_500_effective</span>
            <span class="k">if</span> <span class="n">r0_500</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># No AtmosphericScreens in list</span>
                <span class="k">return</span> <span class="n">Airy</span><span class="p">(</span><span class="n">lam</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">lam</span><span class="p">,</span> <span class="n">diam</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">aper</span><span class="o">.</span><span class="n">diam</span><span class="p">,</span>
                            <span class="n">obscuration</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">aper</span><span class="o">.</span><span class="n">obscuration</span><span class="p">,</span> <span class="n">gsparams</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_gsparams</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">r0</span> <span class="o">=</span> <span class="n">r0_500</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lam</span><span class="o">/</span><span class="mf">500.</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="mf">6.</span><span class="o">/</span><span class="mi">5</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">SecondKick</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">lam</span><span class="p">,</span> <span class="n">r0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">aper</span><span class="o">.</span><span class="n">diam</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">aper</span><span class="o">.</span><span class="n">obscuration</span><span class="p">,</span>
                        <span class="n">kcrit</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">kcrit</span><span class="p">,</span> <span class="n">scale_unit</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">scale_unit</span><span class="p">,</span>
                        <span class="n">gsparams</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_gsparams</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_second_kick</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">flux</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The flux of the profile.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flux</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">screen_list</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The `PhaseScreenList` being used for this object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_screen_list</span>

<div class="viewcode-block" id="PhaseScreenPSF.withGSParams"><a class="viewcode-back" href="../../phase_psf.html#galsim.PhaseScreenPSF.withGSParams">[docs]</a>    <span class="nd">@doc_inherit</span>
    <span class="k">def</span> <span class="nf">withGSParams</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gsparams</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">gsparams</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">gsparams</span><span class="p">:</span> <span class="k">return</span> <span class="bp">self</span>
        <span class="n">gsparams</span> <span class="o">=</span> <span class="n">GSParams</span><span class="o">.</span><span class="n">check</span><span class="p">(</span><span class="n">gsparams</span><span class="p">)</span>
        <span class="n">aper</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">aper</span><span class="o">.</span><span class="n">withGSParams</span><span class="p">(</span><span class="n">gsparams</span><span class="p">)</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">)</span>
        <span class="n">ret</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">)</span>
        <span class="c1"># Make sure we generate fresh versions of any attrs that depend on gsparams</span>
        <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;second_kick&#39;</span><span class="p">,</span> <span class="s1">&#39;_real_ii&#39;</span><span class="p">,</span> <span class="s1">&#39;_dummy_ii&#39;</span><span class="p">]:</span>
            <span class="n">ret</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">attr</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">_gsparams</span> <span class="o">=</span> <span class="n">gsparams</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">aper</span> <span class="o">=</span> <span class="n">aper</span>
        <span class="c1"># Make sure we mark that we need to recalculate any previously finalized InterpolatedImage</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">_finalized</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">_screen_list</span><span class="o">.</span><span class="n">_delayCalculation</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">_img</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">ret</span></div>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="s2">&quot;galsim.PhaseScreenPSF(</span><span class="si">%s</span><span class="s2">, lam=</span><span class="si">%s</span><span class="s2">, exptime=</span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span>
                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_screen_list</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lam</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">exptime</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">outstr</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;galsim.PhaseScreenPSF(</span><span class="si">%r</span><span class="s2">, lam=</span><span class="si">%r</span><span class="s2">, exptime=</span><span class="si">%r</span><span class="s2">, flux=</span><span class="si">%r</span><span class="s2">, aper=</span><span class="si">%r</span><span class="s2">, theta=</span><span class="si">%r</span><span class="s2">, &quot;</span>
                  <span class="s2">&quot;interpolant=</span><span class="si">%r</span><span class="s2">, scale_unit=</span><span class="si">%r</span><span class="s2">, gsparams=</span><span class="si">%r</span><span class="s2">)&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">outstr</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_screen_list</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lam</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">exptime</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">flux</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">aper</span><span class="p">,</span>
                         <span class="bp">self</span><span class="o">.</span><span class="n">theta</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">interpolant</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale_unit</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gsparams</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="c1"># Even if two PSFs were generated with different sets of parameters, they will act</span>
        <span class="c1"># identically if their img, interpolant, stepk, maxk, pad_factor, and gsparams match.</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span> <span class="ow">is</span> <span class="n">other</span> <span class="ow">or</span>
                <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">PhaseScreenPSF</span><span class="p">)</span> <span class="ow">and</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">_screen_list</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_screen_list</span> <span class="ow">and</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">lam</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">lam</span> <span class="ow">and</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">aper</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">aper</span> <span class="ow">and</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">t0</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">t0</span> <span class="ow">and</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">exptime</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">exptime</span> <span class="ow">and</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">time_step</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">time_step</span> <span class="ow">and</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">_flux</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_flux</span> <span class="ow">and</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">interpolant</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">interpolant</span> <span class="ow">and</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">_force_stepk</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_force_stepk</span> <span class="ow">and</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">_force_maxk</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_force_maxk</span> <span class="ow">and</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">_ii_pad_factor</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_ii_pad_factor</span> <span class="ow">and</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">gsparams</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">gsparams</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">((</span><span class="s2">&quot;galsim.PhaseScreenPSF&quot;</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_screen_list</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">lam</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">aper</span><span class="p">,</span>
                     <span class="bp">self</span><span class="o">.</span><span class="n">t0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">exptime</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_step</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flux</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">interpolant</span><span class="p">,</span>
                     <span class="bp">self</span><span class="o">.</span><span class="n">_force_stepk</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_force_maxk</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ii_pad_factor</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gsparams</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_prepareDraw</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Trigger delayed computation of all pending PSFs.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_screen_list</span><span class="o">.</span><span class="n">_prepareDraw</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_step</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute the current instantaneous PSF and add it to the developing integrated PSF.&quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">fft</span>
        <span class="n">u</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">aper</span><span class="o">.</span><span class="n">u_illuminated</span>
        <span class="n">v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">aper</span><span class="o">.</span><span class="n">v_illuminated</span>
        <span class="c1"># This is where I need to make sure the screens are instantiated for FFT.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_screen_list</span><span class="o">.</span><span class="n">instantiate</span><span class="p">(</span><span class="n">check</span><span class="o">=</span><span class="s1">&#39;FFT&#39;</span><span class="p">)</span>
        <span class="n">wf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_screen_list</span><span class="o">.</span><span class="n">_wavefront</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">theta</span><span class="p">)</span>
        <span class="n">expwf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">((</span><span class="mi">2</span><span class="n">j</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">lam</span><span class="p">)</span> <span class="o">*</span> <span class="n">wf</span><span class="p">)</span>
        <span class="n">expwf_grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">aper</span><span class="o">.</span><span class="n">illuminated</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">)</span>
        <span class="n">expwf_grid</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">aper</span><span class="o">.</span><span class="n">illuminated</span><span class="p">]</span> <span class="o">=</span> <span class="n">expwf</span>
        <span class="n">ftexpwf</span> <span class="o">=</span> <span class="n">fft</span><span class="o">.</span><span class="n">fft2</span><span class="p">(</span><span class="n">expwf_grid</span><span class="p">,</span> <span class="n">shift_in</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">shift_out</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_img</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_img</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">aper</span><span class="o">.</span><span class="n">illuminated</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_img</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">ftexpwf</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bar</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_bar</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_finalize</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Take accumulated integrated PSF image and turn it into a proper GSObject.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_img</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flux</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_img</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">_BoundsI</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">aper</span><span class="o">.</span><span class="n">npix</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">aper</span><span class="o">.</span><span class="n">npix</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_img</span> <span class="o">=</span> <span class="n">_Image</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_img</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">PixelScale</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_finalized</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_sbp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ii</span><span class="o">.</span><span class="n">_sbp</span>

    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="c1"># The SBProfile is picklable, but it is pretty inefficient, due to the large images being</span>
        <span class="c1"># written as a string.  Better to pickle the image and remake the InterpolatedImage.</span>
        <span class="n">d</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;_dummy_ii&#39;</span><span class="p">,</span><span class="kc">None</span><span class="p">)</span>
        <span class="n">d</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;_real_ii&#39;</span><span class="p">,</span><span class="kc">None</span><span class="p">)</span>
        <span class="n">d</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;second_kick&#39;</span><span class="p">,</span><span class="kc">None</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">d</span>

    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span> <span class="o">=</span> <span class="n">d</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_finalized</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_screen_list</span><span class="o">.</span><span class="n">_delayCalculation</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_maxk</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ii</span><span class="o">.</span><span class="n">maxk</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_stepk</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ii</span><span class="o">.</span><span class="n">stepk</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_centroid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_prepareDraw</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ii</span><span class="o">.</span><span class="n">centroid</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_positive_flux</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_geometric_shooting</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flux</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ii</span><span class="o">.</span><span class="n">positive_flux</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_negative_flux</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_geometric_shooting</span><span class="p">:</span>
            <span class="k">return</span> <span class="mf">0.</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ii</span><span class="o">.</span><span class="n">negative_flux</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_max_sb</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ii</span><span class="o">.</span><span class="n">max_sb</span>

    <span class="nd">@doc_inherit</span>
    <span class="k">def</span> <span class="nf">_xValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pos</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_prepareDraw</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ii</span><span class="o">.</span><span class="n">_xValue</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span>

    <span class="nd">@doc_inherit</span>
    <span class="k">def</span> <span class="nf">_kValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kpos</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_prepareDraw</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ii</span><span class="o">.</span><span class="n">_kValue</span><span class="p">(</span><span class="n">kpos</span><span class="p">)</span>

    <span class="nd">@doc_inherit</span>
    <span class="k">def</span> <span class="nf">_drawReal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">image</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ii</span><span class="o">.</span><span class="n">_drawReal</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>

    <span class="nd">@doc_inherit</span>
    <span class="k">def</span> <span class="nf">_shoot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">photons</span><span class="p">,</span> <span class="n">rng</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">.photon_array</span> <span class="k">import</span> <span class="n">PhotonArray</span>
        <span class="kn">from</span> <span class="nn">.random</span> <span class="k">import</span> <span class="n">UniformDeviate</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_geometric_shooting</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_prepareDraw</span><span class="p">()</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ii</span><span class="o">.</span><span class="n">_shoot</span><span class="p">(</span><span class="n">photons</span><span class="p">,</span> <span class="n">rng</span><span class="p">)</span>

        <span class="n">n_photons</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">photons</span><span class="p">)</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">n_photons</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">ud</span> <span class="o">=</span> <span class="n">UniformDeviate</span><span class="p">(</span><span class="n">rng</span><span class="p">)</span>
        <span class="n">ud</span><span class="o">.</span><span class="n">generate</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
        <span class="n">t</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exptime</span>
        <span class="n">t</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">t0</span>
        <span class="n">u</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">aper</span><span class="o">.</span><span class="n">u_illuminated</span>
        <span class="n">v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">aper</span><span class="o">.</span><span class="n">v_illuminated</span>
        <span class="n">pick</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">n_photons</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">ud</span><span class="o">.</span><span class="n">generate</span><span class="p">(</span><span class="n">pick</span><span class="p">)</span>
        <span class="n">pick</span> <span class="o">*=</span> <span class="nb">len</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
        <span class="n">pick</span> <span class="o">=</span> <span class="n">pick</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="n">pick</span><span class="p">]</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="n">pick</span><span class="p">]</span>

        <span class="c1"># This is where the screens need to be instantiated for drawing with geometric photon</span>
        <span class="c1"># shooting.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_screen_list</span><span class="o">.</span><span class="n">instantiate</span><span class="p">(</span><span class="n">kmax</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">screen_kmax</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="s1">&#39;phot&#39;</span><span class="p">)</span>
        <span class="n">nm_to_arcsec</span> <span class="o">=</span> <span class="mf">1.e-9</span> <span class="o">*</span> <span class="n">radians</span> <span class="o">/</span> <span class="n">arcsec</span>
        <span class="n">photons</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">photons</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_screen_list</span><span class="o">.</span><span class="n">_wavefront_gradient</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">theta</span><span class="p">)</span>
        <span class="n">photons</span><span class="o">.</span><span class="n">x</span> <span class="o">*=</span> <span class="n">nm_to_arcsec</span>
        <span class="n">photons</span><span class="o">.</span><span class="n">y</span> <span class="o">*=</span> <span class="n">nm_to_arcsec</span>
        <span class="n">photons</span><span class="o">.</span><span class="n">flux</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flux</span> <span class="o">/</span> <span class="n">n_photons</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">second_kick</span><span class="p">:</span>
            <span class="n">p2</span> <span class="o">=</span> <span class="n">PhotonArray</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">photons</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">second_kick</span><span class="o">.</span><span class="n">_shoot</span><span class="p">(</span><span class="n">p2</span><span class="p">,</span> <span class="n">rng</span><span class="p">)</span>
            <span class="n">photons</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="n">p2</span><span class="p">,</span> <span class="n">rng</span><span class="p">)</span>

    <span class="nd">@doc_inherit</span>
    <span class="k">def</span> <span class="nf">_drawKImage</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">image</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ii</span><span class="o">.</span><span class="n">_drawKImage</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">img</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">.deprecated</span> <span class="k">import</span> <span class="n">depr</span>
        <span class="n">depr</span><span class="p">(</span><span class="s1">&#39;img&#39;</span><span class="p">,</span> <span class="mf">2.1</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="s2">&quot;This functionality has been removed.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_img</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">finalized</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">.deprecated</span> <span class="k">import</span> <span class="n">depr</span>
        <span class="n">depr</span><span class="p">(</span><span class="s1">&#39;finalized&#39;</span><span class="p">,</span> <span class="mf">2.1</span><span class="p">,</span> <span class="s2">&quot;This functionality has been removed.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_finalized</span>

<div class="viewcode-block" id="PhaseScreenPSF.withFlux"><a class="viewcode-back" href="../../phase_psf.html#galsim.PhaseScreenPSF.withFlux">[docs]</a>    <span class="nd">@doc_inherit</span>
    <span class="k">def</span> <span class="nf">withFlux</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">flux</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_finalized</span><span class="p">:</span>
            <span class="c1"># Then it&#39;s probably not faster to rebuild with a different flux.</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">withScaledFlux</span><span class="p">(</span><span class="n">flux</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">flux</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">PhaseScreenPSF</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_screen_list</span><span class="p">,</span> <span class="n">lam</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">lam</span><span class="p">,</span> <span class="n">exptime</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">exptime</span><span class="p">,</span> <span class="n">flux</span><span class="o">=</span><span class="n">flux</span><span class="p">,</span>
                                  <span class="n">aper</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">aper</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">theta</span><span class="p">,</span> <span class="n">interpolant</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">interpolant</span><span class="p">,</span>
                                  <span class="n">scale_unit</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">scale_unit</span><span class="p">,</span> <span class="n">gsparams</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">gsparams</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="OpticalPSF"><a class="viewcode-back" href="../../psf.html#galsim.OpticalPSF">[docs]</a><span class="k">class</span> <span class="nc">OpticalPSF</span><span class="p">(</span><span class="n">GSObject</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A class describing aberrated PSFs due to telescope optics.  Its underlying implementation</span>
<span class="sd">    uses an InterpolatedImage to characterize the profile.</span>

<span class="sd">    The diffraction effects are characterized by the diffraction angle, which is a function of the</span>
<span class="sd">    ratio lambda / D, where lambda is the wavelength of the light and D is the diameter of the</span>
<span class="sd">    telescope.  The natural unit for this value is radians, which is not normally a convenient</span>
<span class="sd">    unit to use for other `GSObject` dimensions.  Assuming that the other sky coordinates you are</span>
<span class="sd">    using are all in arcsec (e.g. the pixel scale when you draw the image, the size of the galaxy,</span>
<span class="sd">    etc.), then you should convert this to arcsec as well::</span>

<span class="sd">        &gt;&gt;&gt; lam = 700  # nm</span>
<span class="sd">        &gt;&gt;&gt; diam = 4.0    # meters</span>
<span class="sd">        &gt;&gt;&gt; lam_over_diam = (lam * 1.e-9) / diam  # radians</span>
<span class="sd">        &gt;&gt;&gt; lam_over_diam *= 206265  # Convert to arcsec</span>
<span class="sd">        &gt;&gt;&gt; psf = galsim.OpticalPSF(lam_over_diam, ...)</span>

<span class="sd">    To make this process a bit simpler, we recommend instead providing the wavelength and diameter</span>
<span class="sd">    separately using the parameters ``lam`` (in nm) and ``diam`` (in m).  GalSim will then convert</span>
<span class="sd">    this to any of the normal kinds of angular units using the ``scale_unit`` parameter::</span>

<span class="sd">        &gt;&gt;&gt; psf = galsim.OpticalPSF(lam=lam, diam=diam, scale_unit=galsim.arcsec, ...)</span>

<span class="sd">    When drawing images, the scale_unit should match the unit used for the pixel scale or the WCS.</span>
<span class="sd">    e.g. in this case, a pixel scale of 0.2 arcsec/pixel would be specified as ``pixel_scale=0.2``.</span>

<span class="sd">    Input aberration coefficients are assumed to be supplied in units of wavelength, and correspond</span>
<span class="sd">    to the Zernike polynomials in the Noll convention defined in</span>
<span class="sd">    Noll, J. Opt. Soc. Am. 66, 207-211(1976).  For a brief summary of the polynomials, refer to</span>
<span class="sd">    http://en.wikipedia.org/wiki/Zernike_polynomials#Zernike_polynomials.  By default, the</span>
<span class="sd">    aberration coefficients indicate the amplitudes of _circular_ Zernike polynomials, which are</span>
<span class="sd">    orthogonal over a circle.  If you would like the aberration coefficients to instead be</span>
<span class="sd">    interpretted as the amplitudes of _annular_ Zernike polynomials, which are orthogonal over an</span>
<span class="sd">    annulus (see Mahajan, J. Opt. Soc. Am. 71, 1 (1981)), set the ``annular_zernike`` keyword</span>
<span class="sd">    argument to True.</span>

<span class="sd">    There are two ways to specify the geometry of the pupil plane, i.e., the obscuration disk size</span>
<span class="sd">    and the areas that will be illuminated outside of it.  The first way is to use keywords that</span>
<span class="sd">    specify the size of the obscuration, and the nature of the support struts holding up the</span>
<span class="sd">    secondary mirror (or prime focus cage, etc.).  These are taken to be rectangular obscurations</span>
<span class="sd">    extending from the outer edge of the pupil to the outer edge of the obscuration disk (or the</span>
<span class="sd">    pupil center if ``obscuration = 0.``).  You can specify how many struts there are (evenly spaced</span>
<span class="sd">    in angle), how thick they are as a fraction of the pupil diameter, and what angle they start at</span>
<span class="sd">    relative to the positive y direction.</span>

<span class="sd">    The second way to specify the pupil plane configuration is by passing in an image of it.  This</span>
<span class="sd">    can be useful for example if the struts are not evenly spaced or are not radially directed, as</span>
<span class="sd">    is assumed by the simple model for struts described above.  In this case, keywords related to</span>
<span class="sd">    struts are ignored; moreover, the ``obscuration`` keyword is used to ensure that the images are</span>
<span class="sd">    properly sampled (so it is still needed), but the keyword is then ignored when using the</span>
<span class="sd">    supplied image of the pupil plane.  Note that for complicated pupil configurations, it may be</span>
<span class="sd">    desireable to increase ``pad_factor`` for more fidelity at the expense of slower running time.</span>
<span class="sd">    The ``pupil_plane_im`` that is passed in can be rotated during internal calculations by</span>
<span class="sd">    specifying a ``pupil_angle`` keyword.</span>

<span class="sd">    If you choose to pass in a pupil plane image, it must be a square array in which the image of</span>
<span class="sd">    the pupil is centered.  The areas that are illuminated should have some value &gt;0, and the other</span>
<span class="sd">    areas should have a value of precisely zero.  Based on what the OpticalPSF class thinks is the</span>
<span class="sd">    required sampling to make the PSF image, the image that is passed in of the pupil plane might be</span>
<span class="sd">    zero-padded during internal calculations.  The pixel scale of the pupil plane can be specified</span>
<span class="sd">    in one of three ways.  In descending order of priority, these are:</span>

<span class="sd">    1.  The ``pupil_plane_scale`` keyword argument (units are meters).</span>
<span class="sd">    2.  The ``pupil_plane_im.scale`` attribute (units are meters).</span>
<span class="sd">    3.  If (1) and (2) are both None, then the scale will be inferred by assuming that the</span>
<span class="sd">        illuminated pixel farthest from the image center is at a physical distance of self.diam/2.</span>

<span class="sd">    Note that if the scale is specified by either (1) or (2) above (which always includes specifying</span>
<span class="sd">    the pupil_plane_im as a filename, since the default scale then will be 1.0), then the</span>
<span class="sd">    lam_over_diam keyword must not be used, but rather the lam and diam keywords are required</span>
<span class="sd">    separately.  Finally, to ensure accuracy of calculations using a pupil plane image, we recommend</span>
<span class="sd">    sampling it as finely as possible.</span>

<span class="sd">    As described above, either specify the lam/diam ratio directly in arbitrary units::</span>

<span class="sd">        &gt;&gt;&gt; optical_psf = galsim.OpticalPSF(lam_over_diam=lam_over_diam, defocus=0., ...)</span>

<span class="sd">    or, use separate keywords for the telescope diameter and wavelength in meters and nanometers,</span>
<span class="sd">    respectively::</span>

<span class="sd">        &gt;&gt;&gt; optical_psf = galsim.OpticalPSF(lam=lam, diam=diam, defocus=0., ...)</span>

<span class="sd">    Either of these options initializes ``optical_psf`` as an OpticalPSF instance.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        lam_over_diam:      Lambda / telescope diameter in the physical units adopted for ``scale``</span>
<span class="sd">                            (user responsible for consistency).  Either ``lam_over_diam``, or</span>
<span class="sd">                            ``lam`` and ``diam``, must be supplied.</span>
<span class="sd">        lam:                Lambda (wavelength) in units of nanometers.  Must be supplied with</span>
<span class="sd">                            ``diam``, and in this case, image scales (``scale``) should be</span>
<span class="sd">                            specified in units of ``scale_unit``.</span>
<span class="sd">        diam :              Telescope diameter in units of meters.  Must be supplied with</span>
<span class="sd">                            ``lam``, and in this case, image scales (``scale``) should be</span>
<span class="sd">                            specified in units of ``scale_unit``.</span>
<span class="sd">        tip:                Tip in units of incident light wavelength. [default: 0]</span>
<span class="sd">        tilt:               Tilt in units of incident light wavelength. [default: 0]</span>
<span class="sd">        defocus:            Defocus in units of incident light wavelength. [default: 0]</span>
<span class="sd">        astig1:             Astigmatism (like e2) in units of incident light wavelength.</span>
<span class="sd">                            [default: 0]</span>
<span class="sd">        astig2:             Astigmatism (like e1) in units of incident light wavelength.</span>
<span class="sd">                            [default: 0]</span>
<span class="sd">        coma1:              Coma along y in units of incident light wavelength. [default: 0]</span>
<span class="sd">        coma2:              Coma along x in units of incident light wavelength. [default: 0]</span>
<span class="sd">        trefoil1:           Trefoil (one of the arrows along y) in units of incident light</span>
<span class="sd">                            wavelength. [default: 0]</span>
<span class="sd">        trefoil2:           Trefoil (one of the arrows along x) in units of incident light</span>
<span class="sd">                            wavelength. [default: 0]</span>
<span class="sd">        spher:              Spherical aberration in units of incident light wavelength.</span>
<span class="sd">                            [default: 0]</span>
<span class="sd">        aberrations:        Optional keyword, to pass in a list, tuple, or NumPy array of</span>
<span class="sd">                            aberrations in units of reference wavelength (ordered according to</span>
<span class="sd">                            the Noll convention), rather than passing in individual values for each</span>
<span class="sd">                            individual aberration.  Note that aberrations[1] is piston (and not</span>
<span class="sd">                            aberrations[0], which is unused.)  This list can be arbitrarily long to</span>
<span class="sd">                            handle Zernike polynomial aberrations of arbitrary order.</span>
<span class="sd">        annular_zernike:    Boolean indicating that aberrations specify the amplitudes of annular</span>
<span class="sd">                            Zernike polynomials instead of circular Zernike polynomials.</span>
<span class="sd">                            [default: False]</span>
<span class="sd">        aper:               `Aperture` object to use when creating PSF.  [default: None]</span>
<span class="sd">        circular_pupil:     Adopt a circular pupil?  [default: True]</span>
<span class="sd">        obscuration:        Linear dimension of central obscuration as fraction of pupil linear</span>
<span class="sd">                            dimension, [0., 1.). This should be specified even if you are providing</span>
<span class="sd">                            a ``pupil_plane_im``, since we need an initial value of obscuration to</span>
<span class="sd">                            use to figure out the necessary image sampling. [default: 0]</span>
<span class="sd">        interpolant:        Either an Interpolant instance or a string indicating which interpolant</span>
<span class="sd">                            should be used.  Options are &#39;nearest&#39;, &#39;sinc&#39;, &#39;linear&#39;, &#39;cubic&#39;,</span>
<span class="sd">                            &#39;quintic&#39;, or &#39;lanczosN&#39; where N should be the integer order to use.</span>
<span class="sd">                            [default: galsim.Quintic()]</span>
<span class="sd">        oversampling:       Optional oversampling factor for the InterpolatedImage. Setting</span>
<span class="sd">                            ``oversampling &lt; 1`` will produce aliasing in the PSF (not good).</span>
<span class="sd">                            Usually ``oversampling`` should be somewhat larger than 1.  1.5 is</span>
<span class="sd">                            usually a safe choice.  [default: 1.5]</span>
<span class="sd">        pad_factor:         Additional multiple by which to zero-pad the PSF image to avoid folding</span>
<span class="sd">                            compared to what would be employed for a simple `Airy`.  Note that</span>
<span class="sd">                            ``pad_factor`` may need to be increased for stronger aberrations, i.e.</span>
<span class="sd">                            those larger than order unity.  [default: 1.5]</span>
<span class="sd">        ii_pad_factor:      Zero-padding factor by which to extend the image of the PSF when</span>
<span class="sd">                            creating the ``InterpolatedImage``.  See the ``InterpolatedImage``</span>
<span class="sd">                            docstring for more details.  [default: 4.]</span>
<span class="sd">        suppress_warning:   If ``pad_factor`` is too small, the code will emit a warning telling you</span>
<span class="sd">                            its best guess about how high you might want to raise it.  However,</span>
<span class="sd">                            you can suppress this warning by using ``suppress_warning=True``.</span>
<span class="sd">                            [default: False]</span>
<span class="sd">        geometric_shooting: If True, then when drawing using photon shooting, use geometric</span>
<span class="sd">                            optics approximation where the photon angles are derived from the</span>
<span class="sd">                            phase screen gradient.  If False, then first draw using Fourier</span>
<span class="sd">                            optics and then shoot from the derived InterpolatedImage.</span>
<span class="sd">                            [default: False]</span>
<span class="sd">        flux:               Total flux of the profile. [default: 1.]</span>
<span class="sd">        nstruts:            Number of radial support struts to add to the central obscuration.</span>
<span class="sd">                            [default: 0]</span>
<span class="sd">        strut_thick:        Thickness of support struts as a fraction of pupil diameter.</span>
<span class="sd">                            [default: 0.05]</span>
<span class="sd">        strut_angle:        `Angle` made between the vertical and the strut starting closest to it,</span>
<span class="sd">                            defined to be positive in the counter-clockwise direction; must be an</span>
<span class="sd">                            `Angle` instance. [default: 0. * galsim.degrees]</span>
<span class="sd">        pupil_plane_im:     The GalSim.Image, NumPy array, or name of file containing the pupil</span>
<span class="sd">                            plane image, to be used instead of generating one based on the</span>
<span class="sd">                            obscuration and strut parameters.  [default: None]</span>
<span class="sd">        pupil_angle:        If ``pupil_plane_im`` is not None, rotation angle for the pupil plane</span>
<span class="sd">                            (positive in the counter-clockwise direction).  Must be an `Angle`</span>
<span class="sd">                            instance. [default: 0. * galsim.degrees]</span>
<span class="sd">        pupil_plane_scale:  Sampling interval in meters to use for the pupil plane array.  In</span>
<span class="sd">                            most cases, it&#39;s a good idea to leave this as None, in which case</span>
<span class="sd">                            GalSim will attempt to find a good value automatically.  The</span>
<span class="sd">                            exception is when specifying the pupil arrangement via an image, in</span>
<span class="sd">                            which case this keyword can be used to indicate the sampling of that</span>
<span class="sd">                            image.  See also ``pad_factor`` for adjusting the pupil sampling scale.</span>
<span class="sd">                            [default: None]</span>
<span class="sd">        pupil_plane_size:   Size in meters to use for the pupil plane array.  In most cases, it&#39;s</span>
<span class="sd">                            a good idea to leave this as None, in which case GalSim will attempt</span>
<span class="sd">                            to find a good value automatically.  See also ``oversampling`` for</span>
<span class="sd">                            adjusting the pupil size.  [default: None]</span>
<span class="sd">        scale_unit:         Units to use for the sky coordinates when calculating lam/diam if these</span>
<span class="sd">                            are supplied separately.  Should be either a `galsim.AngleUnit` or a</span>
<span class="sd">                            string that can be used to construct one (e.g., &#39;arcsec&#39;, &#39;radians&#39;,</span>
<span class="sd">                            etc.).  [default: galsim.arcsec]</span>
<span class="sd">        gsparams:           An optional `GSParams` argument. [default: None]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_req_params</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">_opt_params</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;diam&quot;</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="s2">&quot;defocus&quot;</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="s2">&quot;astig1&quot;</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="s2">&quot;astig2&quot;</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="s2">&quot;coma1&quot;</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="s2">&quot;coma2&quot;</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="s2">&quot;trefoil1&quot;</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="s2">&quot;trefoil2&quot;</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="s2">&quot;spher&quot;</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="s2">&quot;annular_zernike&quot;</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
        <span class="s2">&quot;circular_pupil&quot;</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
        <span class="s2">&quot;obscuration&quot;</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="s2">&quot;oversampling&quot;</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="s2">&quot;pad_factor&quot;</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="s2">&quot;suppress_warning&quot;</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
        <span class="s2">&quot;interpolant&quot;</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="s2">&quot;flux&quot;</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="s2">&quot;nstruts&quot;</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="s2">&quot;strut_thick&quot;</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="s2">&quot;strut_angle&quot;</span><span class="p">:</span> <span class="n">Angle</span><span class="p">,</span>
        <span class="s2">&quot;pupil_plane_im&quot;</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="s2">&quot;pupil_angle&quot;</span><span class="p">:</span> <span class="n">Angle</span><span class="p">,</span>
        <span class="s2">&quot;pupil_plane_scale&quot;</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="s2">&quot;pupil_plane_size&quot;</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="s2">&quot;scale_unit&quot;</span><span class="p">:</span> <span class="nb">str</span><span class="p">}</span>
    <span class="n">_single_params</span> <span class="o">=</span> <span class="p">[{</span><span class="s2">&quot;lam_over_diam&quot;</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="s2">&quot;lam&quot;</span><span class="p">:</span> <span class="nb">float</span><span class="p">}]</span>
    <span class="n">_takes_rng</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="n">_has_hard_edges</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">_is_axisymmetric</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">_is_analytic_x</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">_is_analytic_k</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lam_over_diam</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">lam</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">diam</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tip</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span> <span class="n">tilt</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span> <span class="n">defocus</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span>
                 <span class="n">astig1</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span> <span class="n">astig2</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span> <span class="n">coma1</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span> <span class="n">coma2</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span> <span class="n">trefoil1</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span> <span class="n">trefoil2</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span> <span class="n">spher</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span>
                 <span class="n">aberrations</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">annular_zernike</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">aper</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">circular_pupil</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">obscuration</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span> <span class="n">interpolant</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">oversampling</span><span class="o">=</span><span class="mf">1.5</span><span class="p">,</span> <span class="n">pad_factor</span><span class="o">=</span><span class="mf">1.5</span><span class="p">,</span> <span class="n">ii_pad_factor</span><span class="o">=</span><span class="mf">4.</span><span class="p">,</span> <span class="n">flux</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span>
                 <span class="n">nstruts</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">strut_thick</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span> <span class="n">strut_angle</span><span class="o">=</span><span class="mf">0.</span><span class="o">*</span><span class="n">radians</span><span class="p">,</span>
                 <span class="n">pupil_plane_im</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pupil_plane_scale</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pupil_plane_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">pupil_angle</span><span class="o">=</span><span class="mf">0.</span><span class="o">*</span><span class="n">radians</span><span class="p">,</span> <span class="n">scale_unit</span><span class="o">=</span><span class="n">arcsec</span><span class="p">,</span> <span class="n">gsparams</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">_force_stepk</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span> <span class="n">_force_maxk</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span>
                 <span class="n">suppress_warning</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">geometric_shooting</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">.phase_screens</span> <span class="k">import</span> <span class="n">OpticalScreen</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">scale_unit</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">scale_unit</span> <span class="o">=</span> <span class="n">AngleUnit</span><span class="o">.</span><span class="n">from_name</span><span class="p">(</span><span class="n">scale_unit</span><span class="p">)</span>
        <span class="c1"># Need to handle lam/diam vs. lam_over_diam here since lam by itself is needed for</span>
        <span class="c1"># OpticalScreen.</span>
        <span class="k">if</span> <span class="n">lam_over_diam</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">lam</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">diam</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">GalSimIncompatibleValuesError</span><span class="p">(</span>
                    <span class="s2">&quot;If specifying lam_over_diam, then do not specify lam or diam&quot;</span><span class="p">,</span>
                    <span class="n">lam_over_diam</span><span class="o">=</span><span class="n">lam_over_diam</span><span class="p">,</span> <span class="n">lam</span><span class="o">=</span><span class="n">lam</span><span class="p">,</span> <span class="n">diam</span><span class="o">=</span><span class="n">diam</span><span class="p">)</span>
            <span class="c1"># For combination of lam_over_diam and pupil_plane_im with a specified scale, it&#39;s</span>
            <span class="c1"># tricky to determine the actual diameter of the pupil needed by Aperture.  So for now,</span>
            <span class="c1"># we just disallow this combination.  Please feel free to raise an issue at</span>
            <span class="c1"># https://github.com/GalSim-developers/GalSim/issues if you need this functionality.</span>
            <span class="k">if</span> <span class="n">pupil_plane_im</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pupil_plane_im</span><span class="p">,</span> <span class="n">basestring</span><span class="p">):</span>
                    <span class="c1"># Filename, therefore specific scale exists.</span>
                    <span class="k">raise</span> <span class="n">GalSimIncompatibleValuesError</span><span class="p">(</span>
                        <span class="s2">&quot;If specifying lam_over_diam, then do not specify pupil_plane_im as &quot;</span>
                        <span class="s2">&quot;as a filename.&quot;</span><span class="p">,</span>
                        <span class="n">lam_over_diam</span><span class="o">=</span><span class="n">lam_over_diam</span><span class="p">,</span> <span class="n">pupil_plane_im</span><span class="o">=</span><span class="n">pupil_plane_im</span><span class="p">)</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pupil_plane_im</span><span class="p">,</span> <span class="n">Image</span><span class="p">)</span> <span class="ow">and</span> <span class="n">pupil_plane_im</span><span class="o">.</span><span class="n">scale</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">GalSimIncompatibleValuesError</span><span class="p">(</span>
                        <span class="s2">&quot;If specifying lam_over_diam, then do not specify pupil_plane_im &quot;</span>
                        <span class="s2">&quot;with definite scale attribute.&quot;</span><span class="p">,</span>
                        <span class="n">lam_over_diam</span><span class="o">=</span><span class="n">lam_over_diam</span><span class="p">,</span> <span class="n">pupil_plane_im</span><span class="o">=</span><span class="n">pupil_plane_im</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">pupil_plane_scale</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">GalSimIncompatibleValuesError</span><span class="p">(</span>
                        <span class="s2">&quot;If specifying lam_over_diam, then do not specify pupil_plane_scale. &quot;</span><span class="p">,</span>
                        <span class="n">lam_over_diam</span><span class="o">=</span><span class="n">lam_over_diam</span><span class="p">,</span> <span class="n">pupil_plane_scale</span><span class="o">=</span><span class="n">pupil_plane_scale</span><span class="p">)</span>
            <span class="n">lam</span> <span class="o">=</span> <span class="mf">500.</span>  <span class="c1"># Arbitrary</span>
            <span class="n">diam</span> <span class="o">=</span> <span class="n">lam</span><span class="o">*</span><span class="mf">1.e-9</span> <span class="o">/</span> <span class="n">lam_over_diam</span> <span class="o">*</span> <span class="n">radians</span> <span class="o">/</span> <span class="n">scale_unit</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">lam</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">diam</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">GalSimIncompatibleValuesError</span><span class="p">(</span>
                    <span class="s2">&quot;If not specifying lam_over_diam, then specify lam AND diam&quot;</span><span class="p">,</span>
                    <span class="n">lam_over_diam</span><span class="o">=</span><span class="n">lam_over_diam</span><span class="p">,</span> <span class="n">lam</span><span class="o">=</span><span class="n">lam</span><span class="p">,</span> <span class="n">diam</span><span class="o">=</span><span class="n">diam</span><span class="p">)</span>

        <span class="c1"># Make the optical screen.</span>
        <span class="n">optics_screen</span> <span class="o">=</span> <span class="n">OpticalScreen</span><span class="p">(</span>
                <span class="n">diam</span><span class="o">=</span><span class="n">diam</span><span class="p">,</span> <span class="n">defocus</span><span class="o">=</span><span class="n">defocus</span><span class="p">,</span> <span class="n">astig1</span><span class="o">=</span><span class="n">astig1</span><span class="p">,</span> <span class="n">astig2</span><span class="o">=</span><span class="n">astig2</span><span class="p">,</span> <span class="n">coma1</span><span class="o">=</span><span class="n">coma1</span><span class="p">,</span> <span class="n">coma2</span><span class="o">=</span><span class="n">coma2</span><span class="p">,</span>
                <span class="n">trefoil1</span><span class="o">=</span><span class="n">trefoil1</span><span class="p">,</span> <span class="n">trefoil2</span><span class="o">=</span><span class="n">trefoil2</span><span class="p">,</span> <span class="n">spher</span><span class="o">=</span><span class="n">spher</span><span class="p">,</span> <span class="n">aberrations</span><span class="o">=</span><span class="n">aberrations</span><span class="p">,</span>
                <span class="n">obscuration</span><span class="o">=</span><span class="n">obscuration</span><span class="p">,</span> <span class="n">annular_zernike</span><span class="o">=</span><span class="n">annular_zernike</span><span class="p">,</span> <span class="n">lam_0</span><span class="o">=</span><span class="n">lam</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_screens</span> <span class="o">=</span> <span class="n">PhaseScreenList</span><span class="p">(</span><span class="n">optics_screen</span><span class="p">)</span>

        <span class="c1"># Make the aperture.</span>
        <span class="k">if</span> <span class="n">aper</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">aper</span> <span class="o">=</span> <span class="n">Aperture</span><span class="p">(</span>
                    <span class="n">diam</span><span class="p">,</span> <span class="n">lam</span><span class="o">=</span><span class="n">lam</span><span class="p">,</span> <span class="n">circular_pupil</span><span class="o">=</span><span class="n">circular_pupil</span><span class="p">,</span> <span class="n">obscuration</span><span class="o">=</span><span class="n">obscuration</span><span class="p">,</span>
                    <span class="n">nstruts</span><span class="o">=</span><span class="n">nstruts</span><span class="p">,</span> <span class="n">strut_thick</span><span class="o">=</span><span class="n">strut_thick</span><span class="p">,</span> <span class="n">strut_angle</span><span class="o">=</span><span class="n">strut_angle</span><span class="p">,</span>
                    <span class="n">oversampling</span><span class="o">=</span><span class="n">oversampling</span><span class="p">,</span> <span class="n">pad_factor</span><span class="o">=</span><span class="n">pad_factor</span><span class="p">,</span>
                    <span class="n">pupil_plane_im</span><span class="o">=</span><span class="n">pupil_plane_im</span><span class="p">,</span> <span class="n">pupil_angle</span><span class="o">=</span><span class="n">pupil_angle</span><span class="p">,</span>
                    <span class="n">pupil_plane_scale</span><span class="o">=</span><span class="n">pupil_plane_scale</span><span class="p">,</span> <span class="n">pupil_plane_size</span><span class="o">=</span><span class="n">pupil_plane_size</span><span class="p">,</span>
                    <span class="n">gsparams</span><span class="o">=</span><span class="n">gsparams</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">obscuration</span> <span class="o">=</span> <span class="n">obscuration</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">obscuration</span> <span class="o">=</span> <span class="n">aper</span><span class="o">.</span><span class="n">obscuration</span>

        <span class="c1"># Save for pickling</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lam</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">lam</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_flux</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">flux</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_interpolant</span> <span class="o">=</span> <span class="n">interpolant</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_scale_unit</span> <span class="o">=</span> <span class="n">scale_unit</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_gsparams</span> <span class="o">=</span> <span class="n">GSParams</span><span class="o">.</span><span class="n">check</span><span class="p">(</span><span class="n">gsparams</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_suppress_warning</span> <span class="o">=</span> <span class="n">suppress_warning</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_geometric_shooting</span> <span class="o">=</span> <span class="n">geometric_shooting</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_aper</span> <span class="o">=</span> <span class="n">aper</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_force_stepk</span> <span class="o">=</span> <span class="n">_force_stepk</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_force_maxk</span> <span class="o">=</span> <span class="n">_force_maxk</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ii_pad_factor</span> <span class="o">=</span> <span class="n">ii_pad_factor</span>

    <span class="nd">@lazy_property</span>
    <span class="k">def</span> <span class="nf">_psf</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">psf</span> <span class="o">=</span> <span class="n">PhaseScreenPSF</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_screens</span><span class="p">,</span> <span class="n">lam</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_lam</span><span class="p">,</span> <span class="n">flux</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_flux</span><span class="p">,</span>
                             <span class="n">aper</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_aper</span><span class="p">,</span> <span class="n">interpolant</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_interpolant</span><span class="p">,</span>
                             <span class="n">scale_unit</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_scale_unit</span><span class="p">,</span> <span class="n">gsparams</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_gsparams</span><span class="p">,</span>
                             <span class="n">suppress_warning</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_suppress_warning</span><span class="p">,</span>
                             <span class="n">geometric_shooting</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_geometric_shooting</span><span class="p">,</span>
                             <span class="n">_force_stepk</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_force_stepk</span><span class="p">,</span> <span class="n">_force_maxk</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_force_maxk</span><span class="p">,</span>
                             <span class="n">ii_pad_factor</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_ii_pad_factor</span><span class="p">)</span>
        <span class="n">psf</span><span class="o">.</span><span class="n">_prepareDraw</span><span class="p">()</span>  <span class="c1"># No need to delay an OpticalPSF.</span>
        <span class="k">return</span> <span class="n">psf</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">screen</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_psf</span><span class="o">.</span><span class="n">screen_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;galsim.OpticalPSF(lam=</span><span class="si">%s</span><span class="s2">, diam=</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">screen</span><span class="o">.</span><span class="n">lam_0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_psf</span><span class="o">.</span><span class="n">aper</span><span class="o">.</span><span class="n">diam</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">screen</span><span class="o">.</span><span class="n">aberrations</span><span class="p">):</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;, aberrations=[&quot;</span> <span class="o">+</span> <span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">ab</span><span class="p">)</span> <span class="k">for</span> <span class="n">ab</span> <span class="ow">in</span> <span class="n">screen</span><span class="o">.</span><span class="n">aberrations</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;]&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_psf</span><span class="o">.</span><span class="n">aper</span><span class="o">.</span><span class="n">_pupil_plane_im</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_psf</span><span class="o">.</span><span class="n">aper</span><span class="o">.</span><span class="n">_geometry_str</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">screen</span><span class="o">.</span><span class="n">annular_zernike</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;, annular_zernike=True&quot;</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;, obscuration=</span><span class="si">%r</span><span class="s2">&quot;</span><span class="o">%</span><span class="bp">self</span><span class="o">.</span><span class="n">obscuration</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flux</span> <span class="o">!=</span> <span class="mf">1.0</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;, flux=</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flux</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;)&quot;</span>
        <span class="k">return</span> <span class="n">s</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">screen</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_psf</span><span class="o">.</span><span class="n">screen_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;galsim.OpticalPSF(lam=</span><span class="si">%r</span><span class="s2">, diam=</span><span class="si">%r</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_lam</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_psf</span><span class="o">.</span><span class="n">aper</span><span class="o">.</span><span class="n">diam</span><span class="p">)</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;, aper=</span><span class="si">%r</span><span class="s2">&quot;</span><span class="o">%</span><span class="bp">self</span><span class="o">.</span><span class="n">_psf</span><span class="o">.</span><span class="n">aper</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">screen</span><span class="o">.</span><span class="n">aberrations</span><span class="p">):</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;, aberrations=[&quot;</span> <span class="o">+</span> <span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">ab</span><span class="p">)</span> <span class="k">for</span> <span class="n">ab</span> <span class="ow">in</span> <span class="n">screen</span><span class="o">.</span><span class="n">aberrations</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;]&quot;</span>
        <span class="k">if</span> <span class="n">screen</span><span class="o">.</span><span class="n">annular_zernike</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;, annular_zernike=True&quot;</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;, obscuration=</span><span class="si">%r</span><span class="s2">&quot;</span><span class="o">%</span><span class="bp">self</span><span class="o">.</span><span class="n">obscuration</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flux</span> <span class="o">!=</span> <span class="mf">1.0</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;, flux=</span><span class="si">%r</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flux</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_force_stepk</span> <span class="o">!=</span> <span class="mf">0.</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;, _force_stepk=</span><span class="si">%r</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">_force_stepk</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_force_maxk</span> <span class="o">!=</span> <span class="mf">0.</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;, _force_maxk=</span><span class="si">%r</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">_force_maxk</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ii_pad_factor</span> <span class="o">!=</span> <span class="mf">4.</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;, ii_pad_factor=</span><span class="si">%r</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ii_pad_factor</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;)&quot;</span>
        <span class="k">return</span> <span class="n">s</span>

    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span> <span class="ow">is</span> <span class="n">other</span> <span class="ow">or</span>
                <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">OpticalPSF</span><span class="p">)</span> <span class="ow">and</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">_lam</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_lam</span> <span class="ow">and</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">_aper</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_aper</span> <span class="ow">and</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">_psf</span><span class="o">.</span><span class="n">screen_list</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_psf</span><span class="o">.</span><span class="n">screen_list</span> <span class="ow">and</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">_flux</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_flux</span> <span class="ow">and</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">_interpolant</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_interpolant</span> <span class="ow">and</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">_scale_unit</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_scale_unit</span> <span class="ow">and</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">_force_stepk</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_force_stepk</span> <span class="ow">and</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">_force_maxk</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_force_maxk</span> <span class="ow">and</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">_ii_pad_factor</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_ii_pad_factor</span> <span class="ow">and</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">_gsparams</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_gsparams</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">((</span><span class="s2">&quot;galsim.OpticalPSF&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lam</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_aper</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_psf</span><span class="o">.</span><span class="n">screen_list</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                     <span class="bp">self</span><span class="o">.</span><span class="n">_flux</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_interpolant</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scale_unit</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_force_stepk</span><span class="p">,</span>
                     <span class="bp">self</span><span class="o">.</span><span class="n">_force_maxk</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ii_pad_factor</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gsparams</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_sbp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_psf</span><span class="o">.</span><span class="n">_sbp</span>

    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># The SBProfile is picklable, but it is pretty inefficient, due to the large images being</span>
        <span class="c1"># written as a string.  Better to pickle the psf and remake the PhaseScreenPSF.</span>
        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">d</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;_psf&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">d</span>

    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span> <span class="o">=</span> <span class="n">d</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_maxk</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_psf</span><span class="o">.</span><span class="n">maxk</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_stepk</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_psf</span><span class="o">.</span><span class="n">stepk</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_centroid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_psf</span><span class="o">.</span><span class="n">centroid</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_positive_flux</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_psf</span><span class="o">.</span><span class="n">positive_flux</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_negative_flux</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_psf</span><span class="o">.</span><span class="n">negative_flux</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_max_sb</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_psf</span><span class="o">.</span><span class="n">max_sb</span>

    <span class="nd">@doc_inherit</span>
    <span class="k">def</span> <span class="nf">_xValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pos</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_psf</span><span class="o">.</span><span class="n">_xValue</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span>

    <span class="nd">@doc_inherit</span>
    <span class="k">def</span> <span class="nf">_kValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kpos</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_psf</span><span class="o">.</span><span class="n">_kValue</span><span class="p">(</span><span class="n">kpos</span><span class="p">)</span>

    <span class="nd">@doc_inherit</span>
    <span class="k">def</span> <span class="nf">_drawReal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">image</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_psf</span><span class="o">.</span><span class="n">_drawReal</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>

    <span class="nd">@doc_inherit</span>
    <span class="k">def</span> <span class="nf">_shoot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">photons</span><span class="p">,</span> <span class="n">rng</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_psf</span><span class="o">.</span><span class="n">_shoot</span><span class="p">(</span><span class="n">photons</span><span class="p">,</span> <span class="n">rng</span><span class="p">)</span>

    <span class="nd">@doc_inherit</span>
    <span class="k">def</span> <span class="nf">_drawKImage</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">image</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_psf</span><span class="o">.</span><span class="n">_drawKImage</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>

<div class="viewcode-block" id="OpticalPSF.withFlux"><a class="viewcode-back" href="../../psf.html#galsim.OpticalPSF.withFlux">[docs]</a>    <span class="nd">@doc_inherit</span>
    <span class="k">def</span> <span class="nf">withFlux</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">flux</span><span class="p">):</span>
        <span class="n">screen</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_psf</span><span class="o">.</span><span class="n">screen_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">OpticalPSF</span><span class="p">(</span>
                <span class="n">lam</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_lam</span><span class="p">,</span> <span class="n">diam</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_psf</span><span class="o">.</span><span class="n">aper</span><span class="o">.</span><span class="n">diam</span><span class="p">,</span> <span class="n">aper</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_psf</span><span class="o">.</span><span class="n">aper</span><span class="p">,</span>
                <span class="n">aberrations</span><span class="o">=</span><span class="n">screen</span><span class="o">.</span><span class="n">aberrations</span><span class="p">,</span> <span class="n">annular_zernike</span><span class="o">=</span><span class="n">screen</span><span class="o">.</span><span class="n">annular_zernike</span><span class="p">,</span>
                <span class="n">flux</span><span class="o">=</span><span class="n">flux</span><span class="p">,</span> <span class="n">_force_stepk</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_force_stepk</span><span class="p">,</span> <span class="n">_force_maxk</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_force_maxk</span><span class="p">,</span>
                <span class="n">ii_pad_factor</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_ii_pad_factor</span><span class="p">)</span></div></div>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, GalSim-developers

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>