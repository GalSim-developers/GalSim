

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>World Coordinate Systems &mdash; GalSim 2.2.2 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script type="text/javascript" src="_static/jquery.js"></script>
        <script type="text/javascript" src="_static/underscore.js"></script>
        <script type="text/javascript" src="_static/doctools.js"></script>
        <script type="text/javascript" src="_static/language_data.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Noise and Random Values" href="random.html" />
    <link rel="prev" title="Units" href="units.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> GalSim
          

          
          </a>

          
            
            
              <div class="version">
                2.2
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="overview.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="install.html">Installation Instructions</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorials.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="image.html">Images and Related Concepts</a></li>
<li class="toctree-l1"><a class="reference internal" href="sb.html">Surface Brightness Profiles</a></li>
<li class="toctree-l1"><a class="reference internal" href="chromatic.html">Wavelength-dependent Profiles</a></li>
<li class="toctree-l1"><a class="reference internal" href="units.html">Units</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">World Coordinate Systems</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#wcs-base-classes">WCS Base Classes</a></li>
<li class="toctree-l2"><a class="reference internal" href="#euclidean-wcs-s">Euclidean WCS’s</a></li>
<li class="toctree-l2"><a class="reference internal" href="#celestial-wcs-s">Celestial WCS’s</a></li>
<li class="toctree-l2"><a class="reference internal" href="#celestial-coordinates">Celestial Coordinates</a></li>
<li class="toctree-l2"><a class="reference internal" href="#wcs-utilities">WCS Utilities</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="random.html">Noise and Random Values</a></li>
<li class="toctree-l1"><a class="reference internal" href="wl.html">Weak Lensing</a></li>
<li class="toctree-l1"><a class="reference internal" href="photon.html">Photon Shooting</a></li>
<li class="toctree-l1"><a class="reference internal" href="utilities.html">Helper Functions and Classes</a></li>
<li class="toctree-l1"><a class="reference internal" href="errors.html">Errors and Warnings</a></li>
<li class="toctree-l1"><a class="reference internal" href="config.html">The Config Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="hsm.html">The HSM Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="des.html">The DES Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="wfirst.html">The WFIRST Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="shared.html">Shared Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="history.html">Revision History</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">GalSim</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>World Coordinate Systems</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/wcs.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="world-coordinate-systems">
<h1>World Coordinate Systems<a class="headerlink" href="#world-coordinate-systems" title="Permalink to this headline">¶</a></h1>
<p>The World Coordinate System (or WCS) is the traditional term for the mapping from pixel coordinates
to the coordinate system on the sky.
(I know, the world’s down here, and the sky’s up there, so you’d think it would
be reversed, but that’s the way it goes.  Astronomy is full of terms that don’t quite make sense
when you look at them too closely.)</p>
<p>There are two kinds of world coordinates that we use here:</p>
<ul class="simple">
<li><p>Celestial coordinates are defined in terms of right ascension (RA) and declination (Dec).
They are a spherical coordinate system on the sky, akin to longitude and latitude on Earth.
cf. <a class="reference external" href="http://en.wikipedia.org/wiki/Celestial_coordinate_system">http://en.wikipedia.org/wiki/Celestial_coordinate_system</a></p></li>
<li><p>Euclidean coordinates are defined relative to a tangent plane projection of the sky.
If you imagine the sky coordinates on an actual sphere with a particular radius, then the
tangent plane is tangent to that sphere.  We use the labels (u,v) for the coordinates in
this system, where +v points north and +u points west.  (Yes, west, not east.  As you look
up into the sky, if north is up, then west is to the right.)</p></li>
</ul>
<p>The classes in this file provide a mapping from image coordinates (in pixels) to one of these
two kinds of world coordinates.  We use the labels <code class="docutils literal notranslate"><span class="pre">(x,y)</span></code> for the image coordinates.</p>
<div class="section" id="wcs-base-classes">
<h2>WCS Base Classes<a class="headerlink" href="#wcs-base-classes" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="galsim.BaseWCS">
<em class="property">class </em><code class="sig-prename descclassname">galsim.</code><code class="sig-name descname">BaseWCS</code><a class="reference internal" href="_modules/galsim/wcs.html#BaseWCS"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.BaseWCS" title="Permalink to this definition">¶</a></dt>
<dd><p>The base class for all other kinds of WCS transformations.</p>
<p>All the functions the user will typically need are defined here.  Most subclasses just
define helper functions to implement each particular WCS definition.  So this base
class defines the common interface for all WCS classes.</p>
<p>There are several types of WCS classes that we implement. The basic class hierarchy is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>`BaseWCS`
    --- `EuclideanWCS`
            --- `UniformWCS`
                    --- `LocalWCS`
    --- `CelestialWCS`
</pre></div>
</div>
<p>These base classes are not constructible.  They do not have __init__ defined.</p>
<ol class="arabic">
<li><p><a class="reference internal" href="#galsim.wcs.LocalWCS" title="galsim.wcs.LocalWCS"><code class="xref any py py-class docutils literal notranslate"><span class="pre">LocalWCS</span></code></a> classes are those which really just define a pixel size and shape.
They implicitly have the origin in image coordinates correspond to the origin
in world coordinates.  They are primarily designed to handle local transformations
at the location of a single galaxy, where it should usually be a good approximation
to consider the pixel shape to be constant over the size of the galaxy.</p>
<p>Currently we define the following <a class="reference internal" href="#galsim.wcs.LocalWCS" title="galsim.wcs.LocalWCS"><code class="xref any py py-class docutils literal notranslate"><span class="pre">LocalWCS</span></code></a> classes:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>- `PixelScale`
- `ShearWCS`
- `JacobianWCS`
</pre></div>
</div>
</li>
<li><p><a class="reference internal" href="#galsim.wcs.UniformWCS" title="galsim.wcs.UniformWCS"><code class="xref any py py-class docutils literal notranslate"><span class="pre">UniformWCS</span></code></a> classes have a constant pixel size and shape, but they have an arbitrary origin
in both image coordinates and world coordinates.  A <a class="reference internal" href="#galsim.wcs.LocalWCS" title="galsim.wcs.LocalWCS"><code class="xref any py py-class docutils literal notranslate"><span class="pre">LocalWCS</span></code></a> class can be turned into a
non-local <a class="reference internal" href="#galsim.wcs.UniformWCS" title="galsim.wcs.UniformWCS"><code class="xref any py py-class docutils literal notranslate"><span class="pre">UniformWCS</span></code></a> class when an image has its bounds changed, e.g. by the commands
<a class="reference internal" href="image_class.html#galsim.Image.setCenter" title="galsim.Image.setCenter"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">Image.setCenter</span></code></a>, <a class="reference internal" href="image_class.html#galsim.Image.setOrigin" title="galsim.Image.setOrigin"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">Image.setOrigin</span></code></a> or <a class="reference internal" href="image_class.html#galsim.Image.shift" title="galsim.Image.shift"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">Image.shift</span></code></a>.</p>
<p>Currently we define the following non-local, <a class="reference internal" href="#galsim.wcs.UniformWCS" title="galsim.wcs.UniformWCS"><code class="xref any py py-class docutils literal notranslate"><span class="pre">UniformWCS</span></code></a> classes:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>- `OffsetWCS`
- `OffsetShearWCS`
- `AffineTransform`
</pre></div>
</div>
</li>
<li><p><a class="reference internal" href="#galsim.wcs.EuclideanWCS" title="galsim.wcs.EuclideanWCS"><code class="xref any py py-class docutils literal notranslate"><span class="pre">EuclideanWCS</span></code></a> classes use a regular Euclidean coordinate system for the world coordinates,
using <a class="reference internal" href="pos.html#galsim.PositionD" title="galsim.PositionD"><code class="xref any py py-class docutils literal notranslate"><span class="pre">PositionD</span></code></a> for the world positions.  We use the notation (u,v) for the world
coordinates and (x,y) for the image coordinates.</p>
<p>Currently we define the following non-uniform, <a class="reference internal" href="#galsim.wcs.EuclideanWCS" title="galsim.wcs.EuclideanWCS"><code class="xref any py py-class docutils literal notranslate"><span class="pre">EuclideanWCS</span></code></a> class:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>- `UVFunction`
</pre></div>
</div>
</li>
<li><p><a class="reference internal" href="#galsim.wcs.CelestialWCS" title="galsim.wcs.CelestialWCS"><code class="xref any py py-class docutils literal notranslate"><span class="pre">CelestialWCS</span></code></a> classes are defined with their world coordinates on the celestial sphere
in terms of right ascension (RA) and declination (Dec).  The pixel size and shape are
always variable.  We use <a class="reference internal" href="#galsim.CelestialCoord" title="galsim.CelestialCoord"><code class="xref any py py-class docutils literal notranslate"><span class="pre">CelestialCoord</span></code></a> for the world coordinates, which helps
facilitate the spherical trigonometry that is sometimes required.</p>
<p>Currently we define the following <a class="reference internal" href="#galsim.wcs.CelestialWCS" title="galsim.wcs.CelestialWCS"><code class="xref any py py-class docutils literal notranslate"><span class="pre">CelestialWCS</span></code></a> classes: (All but the first are defined
in the file fitswcs.py.)</p>
<ul class="simple">
<li><p><a class="reference internal" href="#galsim.RaDecFunction" title="galsim.RaDecFunction"><code class="xref any py py-class docutils literal notranslate"><span class="pre">RaDecFunction</span></code></a></p></li>
<li><p><a class="reference internal" href="#galsim.AstropyWCS" title="galsim.AstropyWCS"><code class="xref any py py-class docutils literal notranslate"><span class="pre">AstropyWCS</span></code></a>          – requires astropy.wcs python module to be installed</p></li>
<li><p><a class="reference internal" href="#galsim.PyAstWCS" title="galsim.PyAstWCS"><code class="xref any py py-class docutils literal notranslate"><span class="pre">PyAstWCS</span></code></a>            – requires starlink.Ast python module to be installed</p></li>
<li><p><a class="reference internal" href="#galsim.WcsToolsWCS" title="galsim.WcsToolsWCS"><code class="xref any py py-class docutils literal notranslate"><span class="pre">WcsToolsWCS</span></code></a>         – requires wcstools command line functions to be installed</p></li>
<li><p><a class="reference internal" href="#galsim.GSFitsWCS" title="galsim.GSFitsWCS"><code class="xref any py py-class docutils literal notranslate"><span class="pre">GSFitsWCS</span></code></a>           – native code, but has less functionality than the above</p></li>
</ul>
</li>
</ol>
<p>There is also a factory function called <a class="reference internal" href="#galsim.FitsWCS" title="galsim.FitsWCS"><code class="xref any py py-func docutils literal notranslate"><span class="pre">FitsWCS</span></code></a> (also defined in fitswcs.py), which is
intended to act like a class initializer.  It tries to read a fits file using one of the
above classes and returns an instance of whichever one it found was successful.  It should
always be successful, since its final attempt uses <a class="reference internal" href="#galsim.AffineTransform" title="galsim.AffineTransform"><code class="xref any py py-class docutils literal notranslate"><span class="pre">AffineTransform</span></code></a>, which has reasonable
defaults when the WCS key words are not in the file, but of course this will only be
a very rough approximation of the true WCS.</p>
<p>Some things you can do with a WCS instance:</p>
<ul>
<li><p>Convert positions between image coordinates and world coordinates (sometimes referred
to as sky coordinates):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">world_pos</span> <span class="o">=</span> <span class="n">wcs</span><span class="o">.</span><span class="n">toWorld</span><span class="p">(</span><span class="n">image_pos</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image_pos</span> <span class="o">=</span> <span class="n">wcs</span><span class="o">.</span><span class="n">toImage</span><span class="p">(</span><span class="n">world_pos</span><span class="p">)</span>
</pre></div>
</div>
<p>Note: the transformation from world to image coordinates is not guaranteed to be
implemented.  If it is not implemented for a particular WCS class, a NotImplementedError
will be raised.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">image_pos</span></code> parameter should be a <a class="reference internal" href="pos.html#galsim.PositionD" title="galsim.PositionD"><code class="xref any py py-class docutils literal notranslate"><span class="pre">PositionD</span></code></a>.  However, <code class="docutils literal notranslate"><span class="pre">world_pos</span></code> will
be a <a class="reference internal" href="#galsim.CelestialCoord" title="galsim.CelestialCoord"><code class="xref any py py-class docutils literal notranslate"><span class="pre">CelestialCoord</span></code></a> if the transformation is in terms of celestial coordinates
(if <code class="docutils literal notranslate"><span class="pre">wcs.isCelestial()</span> <span class="pre">==</span> <span class="pre">True</span></code>).  Otherwise, it will be a <a class="reference internal" href="pos.html#galsim.PositionD" title="galsim.PositionD"><code class="xref any py py-class docutils literal notranslate"><span class="pre">PositionD</span></code></a> as well.</p>
</li>
<li><p>Convert a <a class="reference internal" href="gsobject.html#galsim.GSObject" title="galsim.GSObject"><code class="xref any py py-class docutils literal notranslate"><span class="pre">GSObject</span></code></a> that is defined in world coordinates to the equivalent profile defined
in terms of image coordinates (or vice versa):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">image_profile</span> <span class="o">=</span> <span class="n">wcs</span><span class="o">.</span><span class="n">toImage</span><span class="p">(</span><span class="n">world_profile</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">world_profile</span> <span class="o">=</span> <span class="n">wcs</span><span class="o">.</span><span class="n">toWorld</span><span class="p">(</span><span class="n">image_profile</span><span class="p">)</span>
</pre></div>
</div>
<p>For non-uniform WCS types (for which <code class="docutils literal notranslate"><span class="pre">wcs.isUniform()</span> <span class="pre">==</span> <span class="pre">False</span></code>), these need either an
<code class="docutils literal notranslate"><span class="pre">image_pos</span></code> or <code class="docutils literal notranslate"><span class="pre">world_pos</span></code> parameter to say where this conversion should happen:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">image_profile</span> <span class="o">=</span> <span class="n">wcs</span><span class="o">.</span><span class="n">toImage</span><span class="p">(</span><span class="n">world_profile</span><span class="p">,</span> <span class="n">image_pos</span><span class="o">=</span><span class="n">image_pos</span><span class="p">)</span>
</pre></div>
</div>
</li>
<li><p>Construct a local linear approximation of a WCS at a given location:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">local_wcs</span> <span class="o">=</span> <span class="n">wcs</span><span class="o">.</span><span class="n">local</span><span class="p">(</span><span class="n">image_pos</span> <span class="o">=</span> <span class="n">image_pos</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">local_wcs</span> <span class="o">=</span> <span class="n">wcs</span><span class="o">.</span><span class="n">local</span><span class="p">(</span><span class="n">world_pos</span> <span class="o">=</span> <span class="n">world_pos</span><span class="p">)</span>
</pre></div>
</div>
<p>If <code class="docutils literal notranslate"><span class="pre">wcs.toWorld(image_pos)</span></code> is not implemented for a particular WCS class, then a
NotImplementedError will be raised if you pass in a <code class="docutils literal notranslate"><span class="pre">world_pos</span></code> argument.</p>
<p>The returned <code class="docutils literal notranslate"><span class="pre">local_wcs</span></code> is usually a <a class="reference internal" href="#galsim.JacobianWCS" title="galsim.JacobianWCS"><code class="xref any py py-class docutils literal notranslate"><span class="pre">JacobianWCS</span></code></a> instance, but see the doc string for
<a class="reference internal" href="#galsim.BaseWCS.local" title="galsim.BaseWCS.local"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">local</span></code></a> for more details.</p>
</li>
<li><p>Construct a full affine approximation of a WCS at a given location:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">affine_wcs</span> <span class="o">=</span> <span class="n">wcs</span><span class="o">.</span><span class="n">affine</span><span class="p">(</span><span class="n">image_pos</span> <span class="o">=</span> <span class="n">image_pos</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">affine_wcs</span> <span class="o">=</span> <span class="n">wcs</span><span class="o">.</span><span class="n">affine</span><span class="p">(</span><span class="n">world_pos</span> <span class="o">=</span> <span class="n">world_pos</span><span class="p">)</span>
</pre></div>
</div>
<p>This preserves the transformation near the location of <code class="docutils literal notranslate"><span class="pre">image_pos</span></code>, but it is linear, so
the transformed values may not agree as you get farther from the given point.</p>
<p>The returned <code class="docutils literal notranslate"><span class="pre">affine_wcs</span></code> is always an <a class="reference internal" href="#galsim.AffineTransform" title="galsim.AffineTransform"><code class="xref any py py-class docutils literal notranslate"><span class="pre">AffineTransform</span></code></a> instance.</p>
</li>
<li><p>Get some properties of the pixel size and shape:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">area</span> <span class="o">=</span> <span class="n">local_wcs</span><span class="o">.</span><span class="n">pixelArea</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">min_linear_scale</span> <span class="o">=</span> <span class="n">local_wcs</span><span class="o">.</span><span class="n">minLinearScale</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">max_linear_scale</span> <span class="o">=</span> <span class="n">local_wcs</span><span class="o">.</span><span class="n">maxLinearScale</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">jac</span> <span class="o">=</span> <span class="n">local_wcs</span><span class="o">.</span><span class="n">jacobian</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Use jac.dudx, jac.dudy, jac.dvdx, jac.dvdy</span>
</pre></div>
</div>
<p>Non-uniform WCS types also have these functions, but for them, you must supply either
<code class="docutils literal notranslate"><span class="pre">image_pos</span></code> or <code class="docutils literal notranslate"><span class="pre">world_pos</span></code>.  So the following are equivalent:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">area</span> <span class="o">=</span> <span class="n">wcs</span><span class="o">.</span><span class="n">pixelArea</span><span class="p">(</span><span class="n">image_pos</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">area</span> <span class="o">=</span> <span class="n">wcs</span><span class="o">.</span><span class="n">local</span><span class="p">(</span><span class="n">image_pos</span><span class="p">)</span><span class="o">.</span><span class="n">pixelArea</span><span class="p">()</span>
</pre></div>
</div>
</li>
<li><p>Query some overall attributes of the WCS transformation:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">wcs</span><span class="o">.</span><span class="n">isLocal</span><span class="p">()</span>       <span class="c1"># is this a local WCS?</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">wcs</span><span class="o">.</span><span class="n">isUniform</span><span class="p">()</span>     <span class="c1"># does this WCS have a uniform pixel size/shape?</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">wcs</span><span class="o">.</span><span class="n">isCelestial</span><span class="p">()</span>   <span class="c1"># are the world coordinates on the celestial sphere?</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">wcs</span><span class="o">.</span><span class="n">isPixelScale</span><span class="p">()</span>  <span class="c1"># is this either a PixelScale or an OffsetWCS?</span>
</pre></div>
</div>
</li>
</ul>
<dl class="method">
<dt id="galsim.BaseWCS.affine">
<code class="sig-name descname">affine</code><span class="sig-paren">(</span><em class="sig-param">image_pos=None</em>, <em class="sig-param">world_pos=None</em>, <em class="sig-param">color=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/wcs.html#BaseWCS.affine"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.BaseWCS.affine" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the local <a class="reference internal" href="#galsim.AffineTransform" title="galsim.AffineTransform"><code class="xref any py py-class docutils literal notranslate"><span class="pre">AffineTransform</span></code></a> of the WCS at a given point.</p>
<p>This returns a linearized version of the current WCS at a given point.  It
returns an <a class="reference internal" href="#galsim.AffineTransform" title="galsim.AffineTransform"><code class="xref any py py-class docutils literal notranslate"><span class="pre">AffineTransform</span></code></a> that is locally approximately the same as the WCS in
the vicinity of the given point.</p>
<p>It is similar to jacobian(), except that this preserves the offset information
between the image coordinates and world coordinates rather than setting both
origins to (0,0).  Instead, the image origin is taken to be <code class="docutils literal notranslate"><span class="pre">image_pos</span></code>.</p>
<p>For non-celestial coordinate systems, the world origin is taken to be
<code class="docutils literal notranslate"><span class="pre">wcs.toWorld(image_pos)</span></code>.  In fact, <code class="docutils literal notranslate"><span class="pre">wcs.affine(image_pos)</span></code> is really just
shorthand for:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">wcs</span><span class="o">.</span><span class="n">jacobian</span><span class="p">(</span><span class="n">image_pos</span><span class="p">)</span><span class="o">.</span><span class="n">withOrigin</span><span class="p">(</span><span class="n">image_pos</span><span class="p">,</span> <span class="n">wcs</span><span class="o">.</span><span class="n">toWorld</span><span class="p">(</span><span class="n">image_pos</span><span class="p">))</span>
</pre></div>
</div>
<p>For celestial coordinate systems, there is no well-defined choice for the
origin of the Euclidean world coordinate system.  So we just take (u,v) = (0,0)
at the given position.  So, <code class="docutils literal notranslate"><span class="pre">wcs.affine(image_pos)</span></code> is equivalent to:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">wcs</span><span class="o">.</span><span class="n">jacobian</span><span class="p">(</span><span class="n">image_pos</span><span class="p">)</span><span class="o">.</span><span class="n">withOrigin</span><span class="p">(</span><span class="n">image_pos</span><span class="p">)</span>
</pre></div>
</div>
<p>You can use the returned <a class="reference internal" href="#galsim.AffineTransform" title="galsim.AffineTransform"><code class="xref any py py-class docutils literal notranslate"><span class="pre">AffineTransform</span></code></a> to access the relevant values of the 2x2
Jacobian matrix and the origins directly:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">affine</span> <span class="o">=</span> <span class="n">wcs</span><span class="o">.</span><span class="n">affine</span><span class="p">(</span><span class="n">image_pos</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">32</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">32</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span> <span class="o">=</span> <span class="n">affine</span><span class="o">.</span><span class="n">dudx</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">affine</span><span class="o">.</span><span class="n">x0</span><span class="p">)</span> <span class="o">+</span> <span class="n">jac</span><span class="o">.</span><span class="n">dudy</span> <span class="o">*</span> <span class="p">(</span><span class="n">y</span><span class="o">-</span><span class="n">affine</span><span class="o">.</span><span class="n">y0</span><span class="p">)</span> <span class="o">+</span> <span class="n">affine</span><span class="o">.</span><span class="n">u0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="n">affine</span><span class="o">.</span><span class="n">dvdx</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">affine</span><span class="o">.</span><span class="n">x0</span><span class="p">)</span> <span class="o">+</span> <span class="n">jac</span><span class="o">.</span><span class="n">dvdy</span> <span class="o">*</span> <span class="p">(</span><span class="n">y</span><span class="o">-</span><span class="n">affine</span><span class="o">.</span><span class="n">y0</span><span class="p">)</span> <span class="o">+</span> <span class="n">affine</span><span class="o">.</span><span class="n">v0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># ... use u,v values to work directly in sky coordinates.</span>
</pre></div>
</div>
<p>As usual, you may provide either <code class="docutils literal notranslate"><span class="pre">image_pos</span></code> or <code class="docutils literal notranslate"><span class="pre">world_pos</span></code> as you prefer to
specify the location at which to approximate the WCS.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>image_pos</strong> – The image coordinate position (for non-uniform WCS types)</p></li>
<li><p><strong>world_pos</strong> – The world coordinate position (for non-uniform WCS types)</p></li>
<li><p><strong>color</strong> – For color-dependent WCS’s, the color term for which to evaluate the
local affine transform. [default: None]</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>an <a class="reference internal" href="#galsim.AffineTransform" title="galsim.AffineTransform"><code class="xref any py py-class docutils literal notranslate"><span class="pre">AffineTransform</span></code></a> instance</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.BaseWCS.fixColor">
<code class="sig-name descname">fixColor</code><span class="sig-paren">(</span><em class="sig-param">color</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/wcs.html#BaseWCS.fixColor"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.BaseWCS.fixColor" title="Permalink to this definition">¶</a></dt>
<dd><p>Fix the color to a particular value.</p>
<p>This changes a color-dependent WCS into the corresponding color-independent WCS
for the given color.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>color</strong> – The value of the color term to use.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the new color-independent WCS</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.BaseWCS.isCelestial">
<code class="sig-name descname">isCelestial</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/wcs.html#BaseWCS.isCelestial"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.BaseWCS.isCelestial" title="Permalink to this definition">¶</a></dt>
<dd><p>Return whether the world coordinates are <a class="reference internal" href="#galsim.CelestialCoord" title="galsim.CelestialCoord"><code class="xref any py py-class docutils literal notranslate"><span class="pre">CelestialCoord</span></code></a> (i.e. ra,dec).</p>
<p><code class="docutils literal notranslate"><span class="pre">wcs.isCelestial()</span></code> is shorthand for <code class="docutils literal notranslate"><span class="pre">isinstance(wcs,</span> <span class="pre">galsim.CelestialWCS)</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="galsim.BaseWCS.isLocal">
<code class="sig-name descname">isLocal</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/wcs.html#BaseWCS.isLocal"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.BaseWCS.isLocal" title="Permalink to this definition">¶</a></dt>
<dd><p>Return whether the WCS transformation is a local, linear approximation.</p>
<p><code class="docutils literal notranslate"><span class="pre">wcs.isLocal()</span></code> is shorthand for <code class="docutils literal notranslate"><span class="pre">isinstance(wcs,</span> <span class="pre">galsim.LocalWCS)</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="galsim.BaseWCS.isPixelScale">
<code class="sig-name descname">isPixelScale</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/wcs.html#BaseWCS.isPixelScale"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.BaseWCS.isPixelScale" title="Permalink to this definition">¶</a></dt>
<dd><p>Return whether the WCS transformation is a simple <a class="reference internal" href="#galsim.PixelScale" title="galsim.PixelScale"><code class="xref any py py-class docutils literal notranslate"><span class="pre">PixelScale</span></code></a> or <a class="reference internal" href="#galsim.OffsetWCS" title="galsim.OffsetWCS"><code class="xref any py py-class docutils literal notranslate"><span class="pre">OffsetWCS</span></code></a>.</p>
<p>These are the simplest two WCS transformations.  <a class="reference internal" href="#galsim.PixelScale" title="galsim.PixelScale"><code class="xref any py py-class docutils literal notranslate"><span class="pre">PixelScale</span></code></a> is local and <a class="reference internal" href="#galsim.OffsetWCS" title="galsim.OffsetWCS"><code class="xref any py py-class docutils literal notranslate"><span class="pre">OffsetWCS</span></code></a>
is non-local.  If an <a class="reference internal" href="image_class.html#galsim.Image" title="galsim.Image"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Image</span></code></a> has one of these WCS transformations as its WCS, then
<code class="docutils literal notranslate"><span class="pre">im.scale</span></code> works to read and write the pixel scale.  If not, <code class="docutils literal notranslate"><span class="pre">im.scale</span></code> will raise a
TypeError exception.</p>
<p><code class="docutils literal notranslate"><span class="pre">wcs.isPixelScale()</span></code> is shorthand for <code class="docutils literal notranslate"><span class="pre">isinstance(wcs,</span> <span class="pre">(galsim.PixelScale,</span>
<span class="pre">galsim.OffsetWCS))</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="galsim.BaseWCS.isUniform">
<code class="sig-name descname">isUniform</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/wcs.html#BaseWCS.isUniform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.BaseWCS.isUniform" title="Permalink to this definition">¶</a></dt>
<dd><p>Return whether the pixels in this WCS have uniform size and shape.</p>
<p><code class="docutils literal notranslate"><span class="pre">wcs.isUniform()</span></code> is shorthand for <code class="docutils literal notranslate"><span class="pre">isinstance(wcs,</span> <span class="pre">galsim.UniformWCS)</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="galsim.BaseWCS.jacobian">
<code class="sig-name descname">jacobian</code><span class="sig-paren">(</span><em class="sig-param">image_pos=None</em>, <em class="sig-param">world_pos=None</em>, <em class="sig-param">color=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/wcs.html#BaseWCS.jacobian"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.BaseWCS.jacobian" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the local <a class="reference internal" href="#galsim.JacobianWCS" title="galsim.JacobianWCS"><code class="xref any py py-class docutils literal notranslate"><span class="pre">JacobianWCS</span></code></a> of the WCS at a given point.</p>
<p>This is basically the same as local(), but the return value is guaranteed to be a
<a class="reference internal" href="#galsim.JacobianWCS" title="galsim.JacobianWCS"><code class="xref any py py-class docutils literal notranslate"><span class="pre">JacobianWCS</span></code></a>, which can be useful in some situations, since you can access the values
of the 2x2 Jacobian matrix directly:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">jac</span> <span class="o">=</span> <span class="n">wcs</span><span class="o">.</span><span class="n">jacobian</span><span class="p">(</span><span class="n">image_pos</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">32</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">32</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span> <span class="o">=</span> <span class="n">jac</span><span class="o">.</span><span class="n">dudx</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">jac</span><span class="o">.</span><span class="n">dudy</span> <span class="o">*</span> <span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="n">jac</span><span class="o">.</span><span class="n">dvdx</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">jac</span><span class="o">.</span><span class="n">dvdy</span> <span class="o">*</span> <span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># ... use u,v values to work directly in world coordinates.</span>
</pre></div>
</div>
<p>If you do not need the extra functionality, then you should use local()
instead, since it may be more efficient.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>image_pos</strong> – The image coordinate position (for non-uniform WCS types)</p></li>
<li><p><strong>world_pos</strong> – The world coordinate position (for non-uniform WCS types)</p></li>
<li><p><strong>color</strong> – For color-dependent WCS’s, the color term for which to evaluate the
local jacobian. [default: None]</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a <a class="reference internal" href="#galsim.JacobianWCS" title="galsim.JacobianWCS"><code class="xref any py py-class docutils literal notranslate"><span class="pre">JacobianWCS</span></code></a> instance.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.BaseWCS.local">
<code class="sig-name descname">local</code><span class="sig-paren">(</span><em class="sig-param">image_pos=None</em>, <em class="sig-param">world_pos=None</em>, <em class="sig-param">color=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/wcs.html#BaseWCS.local"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.BaseWCS.local" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the local linear approximation of the WCS at a given point.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>image_pos</strong> – The image coordinate position (for non-uniform WCS types)</p></li>
<li><p><strong>world_pos</strong> – The world coordinate position (for non-uniform WCS types)</p></li>
<li><p><strong>color</strong> – For color-dependent WCS’s, the color term for which to evaluate the
local WCS. [default: None]</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a <a class="reference internal" href="#galsim.wcs.LocalWCS" title="galsim.wcs.LocalWCS"><code class="xref any py py-class docutils literal notranslate"><span class="pre">LocalWCS</span></code></a> instance.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.BaseWCS.makeSkyImage">
<code class="sig-name descname">makeSkyImage</code><span class="sig-paren">(</span><em class="sig-param">image</em>, <em class="sig-param">sky_level</em>, <em class="sig-param">color=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/wcs.html#BaseWCS.makeSkyImage"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.BaseWCS.makeSkyImage" title="Permalink to this definition">¶</a></dt>
<dd><p>Make an image of the sky, correctly accounting for the pixel area, which might be
variable over the image.</p>
<dl class="simple">
<dt>Note: This uses finite differences of the wcs mapping to calculate the area of each</dt><dd><p>pixel in world coordinates.  It is usually pretty accurate everywhere except
within a few arcsec of the north or south poles.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>image</strong> – The image onto which the sky values will be put.</p></li>
<li><p><strong>sky_level</strong> – The sky level in ADU/arcsec^2 (or whatever your world coordinate
system units are, if not arcsec).</p></li>
<li><p><strong>color</strong> – For color-dependent WCS’s, the color term to use for making the
sky image. [default: None]</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.BaseWCS.maxLinearScale">
<code class="sig-name descname">maxLinearScale</code><span class="sig-paren">(</span><em class="sig-param">image_pos=None</em>, <em class="sig-param">world_pos=None</em>, <em class="sig-param">color=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/wcs.html#BaseWCS.maxLinearScale"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.BaseWCS.maxLinearScale" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the maximum linear scale of the transformation in any direction.</p>
<p>This is basically the semi-major axis of the Jacobian.  Sometimes you need a
linear scale size for some calculation.  This function returns the largest
scale in any direction.  The function minLinearScale() returns the smallest.</p>
<p>For non-uniform WCS transforms, you must provide either <code class="docutils literal notranslate"><span class="pre">image_pos</span></code> or <code class="docutils literal notranslate"><span class="pre">world_pos</span></code>
to say where the pixel is located.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>image_pos</strong> – The image coordinate position (for non-uniform WCS types)</p></li>
<li><p><strong>world_pos</strong> – The world coordinate position (for non-uniform WCS types)</p></li>
<li><p><strong>color</strong> – For color-dependent WCS’s, the color term for which to evaluate the
scale. [default: None]</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the maximum pixel area in any direction in arcsec.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.BaseWCS.minLinearScale">
<code class="sig-name descname">minLinearScale</code><span class="sig-paren">(</span><em class="sig-param">image_pos=None</em>, <em class="sig-param">world_pos=None</em>, <em class="sig-param">color=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/wcs.html#BaseWCS.minLinearScale"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.BaseWCS.minLinearScale" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the minimum linear scale of the transformation in any direction.</p>
<p>This is basically the semi-minor axis of the Jacobian.  Sometimes you need a
linear scale size for some calculation.  This function returns the smallest
scale in any direction.  The function maxLinearScale() returns the largest.</p>
<p>For non-uniform WCS transforms, you must provide either <code class="docutils literal notranslate"><span class="pre">image_pos</span></code> or <code class="docutils literal notranslate"><span class="pre">world_pos</span></code>
to say where the pixel is located.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>image_pos</strong> – The image coordinate position (for non-uniform WCS types)</p></li>
<li><p><strong>world_pos</strong> – The world coordinate position (for non-uniform WCS types)</p></li>
<li><p><strong>color</strong> – For color-dependent WCS’s, the color term for which to evaluate the
scale. [default: None]</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the minimum pixel area in any direction in arcsec.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.BaseWCS.pixelArea">
<code class="sig-name descname">pixelArea</code><span class="sig-paren">(</span><em class="sig-param">image_pos=None</em>, <em class="sig-param">world_pos=None</em>, <em class="sig-param">color=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/wcs.html#BaseWCS.pixelArea"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.BaseWCS.pixelArea" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the area of a pixel in arcsec**2 (or in whatever units you are using for
world coordinates if it is a <a class="reference internal" href="#galsim.wcs.EuclideanWCS" title="galsim.wcs.EuclideanWCS"><code class="xref any py py-class docutils literal notranslate"><span class="pre">EuclideanWCS</span></code></a>).</p>
<p>For non-uniform WCS transforms, you must provide either <code class="docutils literal notranslate"><span class="pre">image_pos</span></code> or <code class="docutils literal notranslate"><span class="pre">world_pos</span></code>
to say where the pixel is located.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>image_pos</strong> – The image coordinate position (for non-uniform WCS types)</p></li>
<li><p><strong>world_pos</strong> – The world coordinate position (for non-uniform WCS types)</p></li>
<li><p><strong>color</strong> – For color-dependent WCS’s, the color term for which to evaluate the
pixel area. [default: None]</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the pixel area in arcsec**2.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.BaseWCS.posToImage">
<code class="sig-name descname">posToImage</code><span class="sig-paren">(</span><em class="sig-param">world_pos</em>, <em class="sig-param">color=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/wcs.html#BaseWCS.posToImage"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.BaseWCS.posToImage" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a position from world coordinates to image coordinates.</p>
<p>This is equivalent to <code class="docutils literal notranslate"><span class="pre">wcs.toImage(world_pos)</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>world_pos</strong> – The world coordinate position</p></li>
<li><p><strong>color</strong> – For color-dependent WCS’s, the color term to use. [default: None]</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.BaseWCS.posToWorld">
<code class="sig-name descname">posToWorld</code><span class="sig-paren">(</span><em class="sig-param">image_pos</em>, <em class="sig-param">color=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/wcs.html#BaseWCS.posToWorld"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.BaseWCS.posToWorld" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a position from image coordinates to world coordinates.</p>
<p>This is equivalent to <code class="docutils literal notranslate"><span class="pre">wcs.toWorld(image_pos)</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>image_pos</strong> – The position in image coordinates</p></li>
<li><p><strong>color</strong> – For color-dependent WCS’s, the color term to use. [default: None]</p></li>
<li><p><strong>project_center</strong> – (Only valid for <a class="reference internal" href="#galsim.wcs.CelestialWCS" title="galsim.wcs.CelestialWCS"><code class="xref any py py-class docutils literal notranslate"><span class="pre">CelestialWCS</span></code></a>) A <a class="reference internal" href="#galsim.CelestialCoord" title="galsim.CelestialCoord"><code class="xref any py py-class docutils literal notranslate"><span class="pre">CelestialCoord</span></code></a> to use for
projecting the result onto a tangent plane world system rather
than returning a <a class="reference internal" href="#galsim.CelestialCoord" title="galsim.CelestialCoord"><code class="xref any py py-class docutils literal notranslate"><span class="pre">CelestialCoord</span></code></a>. [default: None]</p></li>
<li><p><strong>projection</strong> – If project_center != None, the kind of projection to use.  See
<a class="reference internal" href="#galsim.CelestialCoord.project" title="galsim.CelestialCoord.project"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">CelestialCoord.project</span></code></a> for the valid options. [default: ‘gnomonic’]</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>world_pos</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.BaseWCS.profileToImage">
<code class="sig-name descname">profileToImage</code><span class="sig-paren">(</span><em class="sig-param">world_profile</em>, <em class="sig-param">image_pos=None</em>, <em class="sig-param">world_pos=None</em>, <em class="sig-param">color=None</em>, <em class="sig-param">flux_ratio=1.0</em>, <em class="sig-param">offset=(0</em>, <em class="sig-param">0)</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/wcs.html#BaseWCS.profileToImage"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.BaseWCS.profileToImage" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a profile from world coordinates to image coordinates.</p>
<p>This is equivalent to <code class="docutils literal notranslate"><span class="pre">wcs.toImage(world_profile,</span> <span class="pre">...)</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>world_profile</strong> – The profile in world coordinates to transform.</p></li>
<li><p><strong>image_pos</strong> – The image coordinate position (for non-uniform WCS types)</p></li>
<li><p><strong>world_pos</strong> – The world coordinate position (for non-uniform WCS types)</p></li>
<li><p><strong>color</strong> – For color-dependent WCS’s, the color term to use. [default: None]</p></li>
<li><p><strong>flux_ratio</strong> – An optional flux scaling to be applied at the same time.
[default: 1]</p></li>
<li><p><strong>offset</strong> – An optional offset to be applied at the same time. [default: 0,0]</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.BaseWCS.profileToWorld">
<code class="sig-name descname">profileToWorld</code><span class="sig-paren">(</span><em class="sig-param">image_profile</em>, <em class="sig-param">image_pos=None</em>, <em class="sig-param">world_pos=None</em>, <em class="sig-param">color=None</em>, <em class="sig-param">flux_ratio=1.0</em>, <em class="sig-param">offset=(0</em>, <em class="sig-param">0)</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/wcs.html#BaseWCS.profileToWorld"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.BaseWCS.profileToWorld" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a profile from image coordinates to world coordinates.</p>
<p>This is equivalent to <code class="docutils literal notranslate"><span class="pre">wcs.toWorld(image_profile,</span> <span class="pre">...)</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>image_profile</strong> – The profile in image coordinates to transform.</p></li>
<li><p><strong>image_pos</strong> – The image coordinate position (for non-uniform WCS types)</p></li>
<li><p><strong>world_pos</strong> – The world coordinate position (for non-uniform WCS types)</p></li>
<li><p><strong>color</strong> – For color-dependent WCS’s, the color term to use. [default: None]</p></li>
<li><p><strong>flux_ratio</strong> – An optional flux scaling to be applied at the same time.
[default: 1]</p></li>
<li><p><strong>offset</strong> – An optional offset to be applied at the same time. [default: 0,0]</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.BaseWCS.toImage">
<code class="sig-name descname">toImage</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/wcs.html#BaseWCS.toImage"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.BaseWCS.toImage" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert from world coordinates to image coordinates</p>
<p>There are essentially three overloaded versions of this function here.</p>
<ol class="arabic">
<li><p>The first converts a position from world coordinates to image coordinates.
If the WCS is a <a class="reference internal" href="#galsim.wcs.EuclideanWCS" title="galsim.wcs.EuclideanWCS"><code class="xref any py py-class docutils literal notranslate"><span class="pre">EuclideanWCS</span></code></a>, the argument may be either a <a class="reference internal" href="pos.html#galsim.PositionD" title="galsim.PositionD"><code class="xref any py py-class docutils literal notranslate"><span class="pre">PositionD</span></code></a> or <a class="reference internal" href="pos.html#galsim.PositionI" title="galsim.PositionI"><code class="xref any py py-class docutils literal notranslate"><span class="pre">PositionI</span></code></a>
argument.  If it is a <a class="reference internal" href="#galsim.wcs.CelestialWCS" title="galsim.wcs.CelestialWCS"><code class="xref any py py-class docutils literal notranslate"><span class="pre">CelestialWCS</span></code></a>, then the argument must be a <a class="reference internal" href="#galsim.CelestialCoord" title="galsim.CelestialCoord"><code class="xref any py py-class docutils literal notranslate"><span class="pre">CelestialCoord</span></code></a>.
It returns the corresponding position in image coordinates as a <a class="reference internal" href="pos.html#galsim.PositionD" title="galsim.PositionD"><code class="xref any py py-class docutils literal notranslate"><span class="pre">PositionD</span></code></a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">image_pos</span> <span class="o">=</span> <span class="n">wcs</span><span class="o">.</span><span class="n">toImage</span><span class="p">(</span><span class="n">world_pos</span><span class="p">)</span>
</pre></div>
</div>
<p>Equivalent to <a class="reference internal" href="#galsim.BaseWCS.posToImage" title="galsim.BaseWCS.posToImage"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">posToImage</span></code></a>.</p>
</li>
<li><p>The second is nearly the same, but takes either u and v values or ra and dec values
(depending on the kind of wcs being used) directly and returns x and y values.
For this version, the inputs may be numpy arrays, in which case the returned values
are also numpy arrays:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">wcs</span><span class="o">.</span><span class="n">toImage</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>                 <span class="c1"># For EuclideanWCS types</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">wcs</span><span class="o">.</span><span class="n">toImage</span><span class="p">(</span><span class="n">ra</span><span class="p">,</span> <span class="n">dec</span><span class="p">,</span> <span class="n">units</span><span class="o">=</span><span class="n">units</span><span class="p">)</span> <span class="c1"># For CelestialWCS types</span>
</pre></div>
</div>
<p>Equivalent to <a class="reference internal" href="#galsim.wcs.EuclideanWCS.uvToxy" title="galsim.wcs.EuclideanWCS.uvToxy"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">uvToxy</span></code></a> or <a class="reference internal" href="#galsim.wcs.CelestialWCS.radecToxy" title="galsim.wcs.CelestialWCS.radecToxy"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">radecToxy</span></code></a>.</p>
</li>
<li><p>The third converts a surface brightness profile (a <a class="reference internal" href="gsobject.html#galsim.GSObject" title="galsim.GSObject"><code class="xref any py py-class docutils literal notranslate"><span class="pre">GSObject</span></code></a>) from world
coordinates to image coordinates, returning the profile in image coordinates
as a new <a class="reference internal" href="gsobject.html#galsim.GSObject" title="galsim.GSObject"><code class="xref any py py-class docutils literal notranslate"><span class="pre">GSObject</span></code></a>.  For non-uniform WCS transforms, you must provide either
<code class="docutils literal notranslate"><span class="pre">image_pos</span></code> or <code class="docutils literal notranslate"><span class="pre">world_pos</span></code> to say where the profile is located so the right
transformation can be performed.  And optionally, you may provide a flux scaling
to be performed at the same time:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">image_profile</span> <span class="o">=</span> <span class="n">wcs</span><span class="o">.</span><span class="n">toImage</span><span class="p">(</span><span class="n">world_profile</span><span class="p">,</span> <span class="n">image_pos</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">world_pos</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="go">                                flux_ratio=1, offset=(0,0))</span>
</pre></div>
</div>
<p>Equivalent to <a class="reference internal" href="#galsim.BaseWCS.profileToImage" title="galsim.BaseWCS.profileToImage"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">profileToImage</span></code></a>.</p>
</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="galsim.BaseWCS.toWorld">
<code class="sig-name descname">toWorld</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/wcs.html#BaseWCS.toWorld"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.BaseWCS.toWorld" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert from image coordinates to world coordinates.</p>
<p>There are essentially three overloaded versions of this function here.</p>
<ol class="arabic">
<li><p>The first converts a <a class="reference internal" href="pos.html#galsim.Position" title="galsim.Position"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Position</span></code></a> from image coordinates to world coordinates.
It returns the corresponding position in world coordinates as a <a class="reference internal" href="pos.html#galsim.PositionD" title="galsim.PositionD"><code class="xref any py py-class docutils literal notranslate"><span class="pre">PositionD</span></code></a> if the WCS
is a <a class="reference internal" href="#galsim.wcs.EuclideanWCS" title="galsim.wcs.EuclideanWCS"><code class="xref any py py-class docutils literal notranslate"><span class="pre">EuclideanWCS</span></code></a>, or a <a class="reference internal" href="#galsim.CelestialCoord" title="galsim.CelestialCoord"><code class="xref any py py-class docutils literal notranslate"><span class="pre">CelestialCoord</span></code></a> if it is a <a class="reference internal" href="#galsim.wcs.CelestialWCS" title="galsim.wcs.CelestialWCS"><code class="xref any py py-class docutils literal notranslate"><span class="pre">CelestialWCS</span></code></a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">world_pos</span> <span class="o">=</span> <span class="n">wcs</span><span class="o">.</span><span class="n">toWorld</span><span class="p">(</span><span class="n">image_pos</span><span class="p">)</span>
</pre></div>
</div>
<p>Equivalent to <code class="docutils literal notranslate"><span class="pre">wcs.posToWorld(image_pos)</span></code>.</p>
</li>
<li><p>The second is nearly the same, but takes x and y values directly and returns
either u, v or ra, dec, depending on the kind of wcs being used.  For this version,
x and y may be numpy arrays, in which case the returned values are also numpy
arrays:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">wcs</span><span class="o">.</span><span class="n">toWorld</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>                 <span class="c1"># For EuclideanWCS types</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ra</span><span class="p">,</span> <span class="n">dec</span> <span class="o">=</span> <span class="n">wcs</span><span class="o">.</span><span class="n">toWorld</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">units</span><span class="o">=</span><span class="n">units</span><span class="p">)</span> <span class="c1"># For CelestialWCS types</span>
</pre></div>
</div>
<p>Equivalent to <code class="docutils literal notranslate"><span class="pre">wcs.xyTouv(x,</span> <span class="pre">y)</span></code> or <code class="docutils literal notranslate"><span class="pre">wcs.xyToradec(x,</span> <span class="pre">y,</span> <span class="pre">units=units)</span></code>.</p>
</li>
<li><p>The third converts a surface brightness profile (a <a class="reference internal" href="gsobject.html#galsim.GSObject" title="galsim.GSObject"><code class="xref any py py-class docutils literal notranslate"><span class="pre">GSObject</span></code></a>) from image
coordinates to world coordinates, returning the profile in world coordinates
as a new <a class="reference internal" href="gsobject.html#galsim.GSObject" title="galsim.GSObject"><code class="xref any py py-class docutils literal notranslate"><span class="pre">GSObject</span></code></a>.  For non-uniform WCS transforms, you must provide either
<code class="docutils literal notranslate"><span class="pre">image_pos</span></code> or <code class="docutils literal notranslate"><span class="pre">world_pos</span></code> to say where the profile is located, so the right
transformation can be performed.  And optionally, you may provide a flux scaling
to be performed at the same time:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">world_profile</span> <span class="o">=</span> <span class="n">wcs</span><span class="o">.</span><span class="n">toWorld</span><span class="p">(</span><span class="n">image_profile</span><span class="p">,</span> <span class="n">image_pos</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">world_pos</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="go">                                flux_ratio=1, offset=(0,0))</span>
</pre></div>
</div>
<p>Equivalent to <code class="docutils literal notranslate"><span class="pre">wcs.profileToWorld(image_profile,</span> <span class="pre">...)</span></code>.</p>
</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="galsim.BaseWCS.withOrigin">
<code class="sig-name descname">withOrigin</code><span class="sig-paren">(</span><em class="sig-param">origin</em>, <em class="sig-param">world_origin=None</em>, <em class="sig-param">color=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/wcs.html#BaseWCS.withOrigin"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.BaseWCS.withOrigin" title="Permalink to this definition">¶</a></dt>
<dd><p>Recenter the current WCS function at a new origin location, returning the new WCS.</p>
<p>This function creates a new WCS instance (always a non-local WCS) that treats
the origin position the same way the current WCS treats (x,y) = (0,0).</p>
<p>If the current WCS is a local WCS, this essentially declares where on the image
you want the origin of the world coordinate system to be.  i.e. where is (u,v) = (0,0).
So, for example, to set a WCS that has a constant pixel size with the world coordinates
centered at the center of an image, you could write:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">wcs</span> <span class="o">=</span> <span class="n">galsim</span><span class="o">.</span><span class="n">PixelScale</span><span class="p">(</span><span class="n">scale</span><span class="p">)</span><span class="o">.</span><span class="n">withOrigin</span><span class="p">(</span><span class="n">im</span><span class="o">.</span><span class="n">center</span><span class="p">)</span>
</pre></div>
</div>
<p>This is equivalent to the following:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">wcs</span> <span class="o">=</span> <span class="n">galsim</span><span class="o">.</span><span class="n">OffsetWCS</span><span class="p">(</span><span class="n">scale</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="n">im</span><span class="o">.</span><span class="n">center</span><span class="p">)</span>
</pre></div>
</div>
<p>For non-local WCS types, the origin defines the location in the image coordinate system
should mean the same thing as (x,y) = (0,0) does for the current WCS.  The following
example should work regardless of what kind of WCS this is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">world_pos1</span> <span class="o">=</span> <span class="n">wcs</span><span class="o">.</span><span class="n">toWorld</span><span class="p">(</span><span class="n">PositionD</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">wcs2</span> <span class="o">=</span> <span class="n">wcs</span><span class="o">.</span><span class="n">withOrigin</span><span class="p">(</span><span class="n">new_origin</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">world_pos2</span> <span class="o">=</span> <span class="n">wcs2</span><span class="o">.</span><span class="n">toWorld</span><span class="p">(</span><span class="n">new_origin</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># world_pos1 should be equal to world_pos2</span>
</pre></div>
</div>
<p>Furthermore, if the current WCS is a <a class="reference internal" href="#galsim.wcs.EuclideanWCS" title="galsim.wcs.EuclideanWCS"><code class="xref any py py-class docutils literal notranslate"><span class="pre">EuclideanWCS</span></code></a> (wcs.isCelestial() == False) you may
also provide a <code class="docutils literal notranslate"><span class="pre">world_origin</span></code> argument which defines what (u,v) position you want to
correspond to the new origin.  Continuing the previous example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">wcs3</span> <span class="o">=</span> <span class="n">wcs</span><span class="o">.</span><span class="n">withOrigin</span><span class="p">(</span><span class="n">new_origin</span><span class="p">,</span> <span class="n">new_world_origin</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">world_pos3</span> <span class="o">=</span> <span class="n">wcs3</span><span class="o">.</span><span class="n">toWorld</span><span class="p">(</span><span class="n">new_origin</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># world_pos3 should be equal to new_world_origin</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>origin</strong> – The image coordinate position to use as the origin.</p></li>
<li><p><strong>world_origin</strong> – The world coordinate position to use as the origin.  Only valid if
wcs.isCelestial() == False. [default: None]</p></li>
<li><p><strong>color</strong> – For color-dependent WCS’s, the color term to use in the connection
between the current origin and world_origin. [default: None]</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the new recentered WCS</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.BaseWCS.writeToFitsHeader">
<code class="sig-name descname">writeToFitsHeader</code><span class="sig-paren">(</span><em class="sig-param">header</em>, <em class="sig-param">bounds</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/wcs.html#BaseWCS.writeToFitsHeader"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.BaseWCS.writeToFitsHeader" title="Permalink to this definition">¶</a></dt>
<dd><p>Write this WCS function to a FITS header.</p>
<p>This is normally called automatically from within the galsim.fits.write() function.</p>
<p>The code will attempt to write standard FITS WCS keys so that the WCS will be readable
by other software (e.g. ds9).  It may not be able to do so accurately, in which case a
linearized version will be used instead.  (Specifically, it will use the local affine
transform with respect to the image center.)</p>
<p>However, this is not necessary for the WCS to survive a round trip through the FITS
header, as it will also write GalSim-specific key words that should allow it to
reconstruct the WCS correctly.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>header</strong> – A FitsHeader (or dict-like) object to write the data to.</p></li>
<li><p><strong>bounds</strong> – The bounds of the image.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="galsim.wcs.CelestialWCS">
<em class="property">class </em><code class="sig-prename descclassname">galsim.wcs.</code><code class="sig-name descname">CelestialWCS</code><a class="reference internal" href="_modules/galsim/wcs.html#CelestialWCS"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.wcs.CelestialWCS" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">galsim.wcs.BaseWCS</span></code></p>
<p>A CelestialWCS is a <a class="reference internal" href="#galsim.BaseWCS" title="galsim.BaseWCS"><code class="xref any py py-class docutils literal notranslate"><span class="pre">BaseWCS</span></code></a> whose world coordinates are on the celestial sphere.
We use the <a class="reference internal" href="#galsim.CelestialCoord" title="galsim.CelestialCoord"><code class="xref any py py-class docutils literal notranslate"><span class="pre">CelestialCoord</span></code></a> class for the world coordinates.</p>
<dl class="method">
<dt id="galsim.wcs.CelestialWCS.isCelestial">
<code class="sig-name descname">isCelestial</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/wcs.html#CelestialWCS.isCelestial"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.wcs.CelestialWCS.isCelestial" title="Permalink to this definition">¶</a></dt>
<dd><p>Return whether the world coordinates are <a class="reference internal" href="#galsim.CelestialCoord" title="galsim.CelestialCoord"><code class="xref any py py-class docutils literal notranslate"><span class="pre">CelestialCoord</span></code></a> (i.e. ra,dec).</p>
<p><code class="docutils literal notranslate"><span class="pre">wcs.isCelestial()</span></code> is shorthand for <code class="docutils literal notranslate"><span class="pre">isinstance(wcs,</span> <span class="pre">galsim.CelestialWCS)</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="galsim.wcs.CelestialWCS.radecToxy">
<code class="sig-name descname">radecToxy</code><span class="sig-paren">(</span><em class="sig-param">ra</em>, <em class="sig-param">dec</em>, <em class="sig-param">units</em>, <em class="sig-param">color=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/wcs.html#CelestialWCS.radecToxy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.wcs.CelestialWCS.radecToxy" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert ra,dec from world coordinates to image coordinates.</p>
<p>This is equivalent to <code class="docutils literal notranslate"><span class="pre">wcs.toWorld(ra,dec,</span> <span class="pre">units=units)</span></code>.</p>
<p>It is also equivalent to <code class="docutils literal notranslate"><span class="pre">wcs.posToImage(galsim.CelestialCoord(ra</span> <span class="pre">*</span> <span class="pre">units,</span> <span class="pre">dec</span> <span class="pre">*</span> <span class="pre">units))</span></code>
when ra and dec are scalars; however, this routine allows ra and dec to be numpy arrays,
in which case, the calculation will be vectorized, which is often much faster than using
the pos interface.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ra</strong> – The ra value(s) in world coordinates</p></li>
<li><p><strong>dec</strong> – The dec value(s) in world coordinates</p></li>
<li><p><strong>units</strong> – The units to use for the input ra, dec values.</p></li>
<li><p><strong>color</strong> – For color-dependent WCS’s, the color term to use. [default: None]</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.wcs.CelestialWCS.x0">
<em class="property">property </em><code class="sig-name descname">x0</code><a class="headerlink" href="#galsim.wcs.CelestialWCS.x0" title="Permalink to this definition">¶</a></dt>
<dd><p>The x coordinate of self.origin.</p>
</dd></dl>

<dl class="method">
<dt id="galsim.wcs.CelestialWCS.xyToradec">
<code class="sig-name descname">xyToradec</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">y</em>, <em class="sig-param">units=None</em>, <em class="sig-param">color=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/wcs.html#CelestialWCS.xyToradec"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.wcs.CelestialWCS.xyToradec" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert x,y from image coordinates to world coordinates.</p>
<p>This is equivalent to <code class="docutils literal notranslate"><span class="pre">wcs.toWorld(x,y,</span> <span class="pre">units=units)</span></code>.</p>
<p>It is also equivalent to <code class="docutils literal notranslate"><span class="pre">wcs.posToWorld(galsim.PositionD(x,y)).rad</span></code> when x and y are
scalars if units is ‘radians’; however, this routine allows x and y to be numpy arrays,
in which case, the calculation will be vectorized, which is often much faster than using
the pos interface.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> – The x value(s) in image coordinates</p></li>
<li><p><strong>y</strong> – The y value(s) in image coordinates</p></li>
<li><p><strong>units</strong> – (Only valid for <a class="reference internal" href="#galsim.wcs.CelestialWCS" title="galsim.wcs.CelestialWCS"><code class="xref any py py-class docutils literal notranslate"><span class="pre">CelestialWCS</span></code></a>, in which case it is required)
The units to use for the returned ra, dec values.</p></li>
<li><p><strong>color</strong> – For color-dependent WCS’s, the color term to use. [default: None]</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>ra, dec</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.wcs.CelestialWCS.y0">
<em class="property">property </em><code class="sig-name descname">y0</code><a class="headerlink" href="#galsim.wcs.CelestialWCS.y0" title="Permalink to this definition">¶</a></dt>
<dd><p>The y coordinate of self.origin.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="galsim.wcs.EuclideanWCS">
<em class="property">class </em><code class="sig-prename descclassname">galsim.wcs.</code><code class="sig-name descname">EuclideanWCS</code><a class="reference internal" href="_modules/galsim/wcs.html#EuclideanWCS"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.wcs.EuclideanWCS" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">galsim.wcs.BaseWCS</span></code></p>
<p>A EuclideanWCS is a <a class="reference internal" href="#galsim.BaseWCS" title="galsim.BaseWCS"><code class="xref any py py-class docutils literal notranslate"><span class="pre">BaseWCS</span></code></a> whose world coordinates are on a Euclidean plane.
We usually use the notation (u,v) to refer to positions in world coordinates, and
they use the class <a class="reference internal" href="pos.html#galsim.PositionD" title="galsim.PositionD"><code class="xref any py py-class docutils literal notranslate"><span class="pre">PositionD</span></code></a>.</p>
<dl class="method">
<dt id="galsim.wcs.EuclideanWCS.u0">
<em class="property">property </em><code class="sig-name descname">u0</code><a class="headerlink" href="#galsim.wcs.EuclideanWCS.u0" title="Permalink to this definition">¶</a></dt>
<dd><p>The x component of self.world_origin (aka u).</p>
</dd></dl>

<dl class="method">
<dt id="galsim.wcs.EuclideanWCS.uvToxy">
<code class="sig-name descname">uvToxy</code><span class="sig-paren">(</span><em class="sig-param">u</em>, <em class="sig-param">v</em>, <em class="sig-param">color=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/wcs.html#EuclideanWCS.uvToxy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.wcs.EuclideanWCS.uvToxy" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert u,v from world coordinates to image coordinates.</p>
<p>This is equivalent to <code class="docutils literal notranslate"><span class="pre">wcs.toWorld(u,v)</span></code>.</p>
<p>It is also equivalent to <code class="docutils literal notranslate"><span class="pre">wcs.posToImage(galsim.PositionD(u,v))</span></code> when u and v are scalars;
however, this routine allows u and v to be numpy arrays, in which case, the calculation
will be vectorized, which is often much faster than using the pos interface.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>u</strong> – The u value(s) in world coordinates</p></li>
<li><p><strong>v</strong> – The v value(s) in world coordinates</p></li>
<li><p><strong>color</strong> – For color-dependent WCS’s, the color term to use. [default: None]</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.wcs.EuclideanWCS.v0">
<em class="property">property </em><code class="sig-name descname">v0</code><a class="headerlink" href="#galsim.wcs.EuclideanWCS.v0" title="Permalink to this definition">¶</a></dt>
<dd><p>The y component of self.world_origin (aka v).</p>
</dd></dl>

<dl class="method">
<dt id="galsim.wcs.EuclideanWCS.x0">
<em class="property">property </em><code class="sig-name descname">x0</code><a class="headerlink" href="#galsim.wcs.EuclideanWCS.x0" title="Permalink to this definition">¶</a></dt>
<dd><p>The x component of self.origin.</p>
</dd></dl>

<dl class="method">
<dt id="galsim.wcs.EuclideanWCS.xyTouv">
<code class="sig-name descname">xyTouv</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">y</em>, <em class="sig-param">color=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/wcs.html#EuclideanWCS.xyTouv"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.wcs.EuclideanWCS.xyTouv" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert x,y from image coordinates to world coordinates.</p>
<p>This is equivalent to <code class="docutils literal notranslate"><span class="pre">wcs.toWorld(x,y)</span></code>.</p>
<p>It is also equivalent to <code class="docutils literal notranslate"><span class="pre">wcs.posToWorld(galsim.PositionD(x,y))</span></code> when x and y are scalars;
however, this routine allows x and y to be numpy arrays, in which case, the calculation
will be vectorized, which is often much faster than using the pos interface.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> – The x value(s) in image coordinates</p></li>
<li><p><strong>y</strong> – The y value(s) in image coordinates</p></li>
<li><p><strong>color</strong> – For color-dependent WCS’s, the color term to use. [default: None]</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>ra, dec</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.wcs.EuclideanWCS.y0">
<em class="property">property </em><code class="sig-name descname">y0</code><a class="headerlink" href="#galsim.wcs.EuclideanWCS.y0" title="Permalink to this definition">¶</a></dt>
<dd><p>The y component of self.origin.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="galsim.wcs.UniformWCS">
<em class="property">class </em><code class="sig-prename descclassname">galsim.wcs.</code><code class="sig-name descname">UniformWCS</code><a class="reference internal" href="_modules/galsim/wcs.html#UniformWCS"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.wcs.UniformWCS" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#galsim.wcs.EuclideanWCS" title="galsim.wcs.EuclideanWCS"><code class="xref py py-class docutils literal notranslate"><span class="pre">galsim.wcs.EuclideanWCS</span></code></a></p>
<p>A UniformWCS is a <a class="reference internal" href="#galsim.wcs.EuclideanWCS" title="galsim.wcs.EuclideanWCS"><code class="xref any py py-class docutils literal notranslate"><span class="pre">EuclideanWCS</span></code></a> which has a uniform pixel size and shape.</p>
<dl class="method">
<dt id="galsim.wcs.UniformWCS.inverse">
<code class="sig-name descname">inverse</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/wcs.html#UniformWCS.inverse"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.wcs.UniformWCS.inverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the inverse transformation, i.e. the transformation that swaps the roles of
the “image” and “world” coordinates.</p>
</dd></dl>

<dl class="method">
<dt id="galsim.wcs.UniformWCS.isUniform">
<code class="sig-name descname">isUniform</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/wcs.html#UniformWCS.isUniform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.wcs.UniformWCS.isUniform" title="Permalink to this definition">¶</a></dt>
<dd><p>Return whether the pixels in this WCS have uniform size and shape.</p>
<p><code class="docutils literal notranslate"><span class="pre">wcs.isUniform()</span></code> is shorthand for <code class="docutils literal notranslate"><span class="pre">isinstance(wcs,</span> <span class="pre">galsim.UniformWCS)</span></code>.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="galsim.wcs.LocalWCS">
<em class="property">class </em><code class="sig-prename descclassname">galsim.wcs.</code><code class="sig-name descname">LocalWCS</code><a class="reference internal" href="_modules/galsim/wcs.html#LocalWCS"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.wcs.LocalWCS" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#galsim.wcs.UniformWCS" title="galsim.wcs.UniformWCS"><code class="xref py py-class docutils literal notranslate"><span class="pre">galsim.wcs.UniformWCS</span></code></a></p>
<p>A LocalWCS is a <a class="reference internal" href="#galsim.wcs.UniformWCS" title="galsim.wcs.UniformWCS"><code class="xref any py py-class docutils literal notranslate"><span class="pre">UniformWCS</span></code></a> in which (0,0) in image coordinates is at the same place
as (0,0) in world coordinates</p>
<dl class="method">
<dt id="galsim.wcs.LocalWCS.isLocal">
<code class="sig-name descname">isLocal</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/wcs.html#LocalWCS.isLocal"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.wcs.LocalWCS.isLocal" title="Permalink to this definition">¶</a></dt>
<dd><p>Return whether the WCS transformation is a local, linear approximation.</p>
<p><code class="docutils literal notranslate"><span class="pre">wcs.isLocal()</span></code> is shorthand for <code class="docutils literal notranslate"><span class="pre">isinstance(wcs,</span> <span class="pre">galsim.LocalWCS)</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="galsim.wcs.LocalWCS.origin">
<em class="property">property </em><code class="sig-name descname">origin</code><a class="headerlink" href="#galsim.wcs.LocalWCS.origin" title="Permalink to this definition">¶</a></dt>
<dd><p>The image coordinate position to use as the origin.</p>
</dd></dl>

<dl class="method">
<dt id="galsim.wcs.LocalWCS.world_origin">
<em class="property">property </em><code class="sig-name descname">world_origin</code><a class="headerlink" href="#galsim.wcs.LocalWCS.world_origin" title="Permalink to this definition">¶</a></dt>
<dd><p>The world coordinate position to use as the origin.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="euclidean-wcs-s">
<h2>Euclidean WCS’s<a class="headerlink" href="#euclidean-wcs-s" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="galsim.PixelScale">
<em class="property">class </em><code class="sig-prename descclassname">galsim.</code><code class="sig-name descname">PixelScale</code><span class="sig-paren">(</span><em class="sig-param">scale</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/wcs.html#PixelScale"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.PixelScale" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#galsim.wcs.LocalWCS" title="galsim.wcs.LocalWCS"><code class="xref py py-class docutils literal notranslate"><span class="pre">galsim.wcs.LocalWCS</span></code></a></p>
<p>This is the simplest possible WCS transformation.  It only involves a unit conversion
from pixels to arcsec (or whatever units you want to take for your world coordinate system).</p>
<p>The conversion functions are:</p>
<blockquote>
<div><p>u = x * scale
v = y * scale</p>
</div></blockquote>
<p>A PixelScale is initialized with the command:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">wcs</span> <span class="o">=</span> <span class="n">galsim</span><span class="o">.</span><span class="n">PixelScale</span><span class="p">(</span><span class="n">scale</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>scale</strong> – The pixel scale, typically in units of arcsec/pixel.</p>
</dd>
</dl>
<dl class="method">
<dt id="galsim.PixelScale.isPixelScale">
<code class="sig-name descname">isPixelScale</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/wcs.html#PixelScale.isPixelScale"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.PixelScale.isPixelScale" title="Permalink to this definition">¶</a></dt>
<dd><p>Return whether the WCS transformation is a simple <a class="reference internal" href="#galsim.PixelScale" title="galsim.PixelScale"><code class="xref any py py-class docutils literal notranslate"><span class="pre">PixelScale</span></code></a> or <a class="reference internal" href="#galsim.OffsetWCS" title="galsim.OffsetWCS"><code class="xref any py py-class docutils literal notranslate"><span class="pre">OffsetWCS</span></code></a>.</p>
<p>These are the simplest two WCS transformations.  <a class="reference internal" href="#galsim.PixelScale" title="galsim.PixelScale"><code class="xref any py py-class docutils literal notranslate"><span class="pre">PixelScale</span></code></a> is local and <a class="reference internal" href="#galsim.OffsetWCS" title="galsim.OffsetWCS"><code class="xref any py py-class docutils literal notranslate"><span class="pre">OffsetWCS</span></code></a>
is non-local.  If an <a class="reference internal" href="image_class.html#galsim.Image" title="galsim.Image"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Image</span></code></a> has one of these WCS transformations as its WCS, then
<code class="docutils literal notranslate"><span class="pre">im.scale</span></code> works to read and write the pixel scale.  If not, <code class="docutils literal notranslate"><span class="pre">im.scale</span></code> will raise a
TypeError exception.</p>
<p><code class="docutils literal notranslate"><span class="pre">wcs.isPixelScale()</span></code> is shorthand for <code class="docutils literal notranslate"><span class="pre">isinstance(wcs,</span> <span class="pre">(galsim.PixelScale,</span>
<span class="pre">galsim.OffsetWCS))</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="galsim.PixelScale.scale">
<em class="property">property </em><code class="sig-name descname">scale</code><a class="headerlink" href="#galsim.PixelScale.scale" title="Permalink to this definition">¶</a></dt>
<dd><p>The pixel scale</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="galsim.OffsetWCS">
<em class="property">class </em><code class="sig-prename descclassname">galsim.</code><code class="sig-name descname">OffsetWCS</code><span class="sig-paren">(</span><em class="sig-param">scale</em>, <em class="sig-param">origin=None</em>, <em class="sig-param">world_origin=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/wcs.html#OffsetWCS"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.OffsetWCS" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#galsim.wcs.UniformWCS" title="galsim.wcs.UniformWCS"><code class="xref py py-class docutils literal notranslate"><span class="pre">galsim.wcs.UniformWCS</span></code></a></p>
<p>This WCS is similar to <a class="reference internal" href="#galsim.PixelScale" title="galsim.PixelScale"><code class="xref any py py-class docutils literal notranslate"><span class="pre">PixelScale</span></code></a>, except the origin is not necessarily (0,0) in both
the image and world coordinates.</p>
<p>The conversion functions are:</p>
<blockquote>
<div><p>u = (x-x0) * scale + u0
v = (y-y0) * scale + v0</p>
</div></blockquote>
<p>An OffsetWCS is initialized with the command:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">wcs</span> <span class="o">=</span> <span class="n">galsim</span><span class="o">.</span><span class="n">OffsetWCS</span><span class="p">(</span><span class="n">scale</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">world_origin</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>scale</strong> – The pixel scale, typically in units of arcsec/pixel.</p></li>
<li><p><strong>origin</strong> – Optional origin position for the image coordinate system.
If provided, it should be a <a class="reference internal" href="pos.html#galsim.PositionD" title="galsim.PositionD"><code class="xref any py py-class docutils literal notranslate"><span class="pre">PositionD</span></code></a> or <a class="reference internal" href="pos.html#galsim.PositionI" title="galsim.PositionI"><code class="xref any py py-class docutils literal notranslate"><span class="pre">PositionI</span></code></a>.
[default: PositionD(0., 0.)]</p></li>
<li><p><strong>world_origin</strong> – Optional origin position for the world coordinate system.
If provided, it should be a <a class="reference internal" href="pos.html#galsim.PositionD" title="galsim.PositionD"><code class="xref any py py-class docutils literal notranslate"><span class="pre">PositionD</span></code></a>.
[default: galsim.PositionD(0., 0.)]</p></li>
</ul>
</dd>
</dl>
<dl class="method">
<dt id="galsim.OffsetWCS.isPixelScale">
<code class="sig-name descname">isPixelScale</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/wcs.html#OffsetWCS.isPixelScale"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.OffsetWCS.isPixelScale" title="Permalink to this definition">¶</a></dt>
<dd><p>Return whether the WCS transformation is a simple <a class="reference internal" href="#galsim.PixelScale" title="galsim.PixelScale"><code class="xref any py py-class docutils literal notranslate"><span class="pre">PixelScale</span></code></a> or <a class="reference internal" href="#galsim.OffsetWCS" title="galsim.OffsetWCS"><code class="xref any py py-class docutils literal notranslate"><span class="pre">OffsetWCS</span></code></a>.</p>
<p>These are the simplest two WCS transformations.  <a class="reference internal" href="#galsim.PixelScale" title="galsim.PixelScale"><code class="xref any py py-class docutils literal notranslate"><span class="pre">PixelScale</span></code></a> is local and <a class="reference internal" href="#galsim.OffsetWCS" title="galsim.OffsetWCS"><code class="xref any py py-class docutils literal notranslate"><span class="pre">OffsetWCS</span></code></a>
is non-local.  If an <a class="reference internal" href="image_class.html#galsim.Image" title="galsim.Image"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Image</span></code></a> has one of these WCS transformations as its WCS, then
<code class="docutils literal notranslate"><span class="pre">im.scale</span></code> works to read and write the pixel scale.  If not, <code class="docutils literal notranslate"><span class="pre">im.scale</span></code> will raise a
TypeError exception.</p>
<p><code class="docutils literal notranslate"><span class="pre">wcs.isPixelScale()</span></code> is shorthand for <code class="docutils literal notranslate"><span class="pre">isinstance(wcs,</span> <span class="pre">(galsim.PixelScale,</span>
<span class="pre">galsim.OffsetWCS))</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="galsim.OffsetWCS.origin">
<em class="property">property </em><code class="sig-name descname">origin</code><a class="headerlink" href="#galsim.OffsetWCS.origin" title="Permalink to this definition">¶</a></dt>
<dd><p>The image coordinate position to use as the origin.</p>
</dd></dl>

<dl class="method">
<dt id="galsim.OffsetWCS.scale">
<em class="property">property </em><code class="sig-name descname">scale</code><a class="headerlink" href="#galsim.OffsetWCS.scale" title="Permalink to this definition">¶</a></dt>
<dd><p>The pixel scale.</p>
</dd></dl>

<dl class="method">
<dt id="galsim.OffsetWCS.world_origin">
<em class="property">property </em><code class="sig-name descname">world_origin</code><a class="headerlink" href="#galsim.OffsetWCS.world_origin" title="Permalink to this definition">¶</a></dt>
<dd><p>The world coordinate position to use as the origin.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="galsim.ShearWCS">
<em class="property">class </em><code class="sig-prename descclassname">galsim.</code><code class="sig-name descname">ShearWCS</code><span class="sig-paren">(</span><em class="sig-param">scale</em>, <em class="sig-param">shear</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/wcs.html#ShearWCS"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.ShearWCS" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#galsim.wcs.LocalWCS" title="galsim.wcs.LocalWCS"><code class="xref py py-class docutils literal notranslate"><span class="pre">galsim.wcs.LocalWCS</span></code></a></p>
<p>This WCS is a uniformly sheared coordinate system.</p>
<p>The shear is given as the shape that a round object has when observed in image coordinates.</p>
<p>The conversion functions in terms of (g1,g2) are therefore:</p>
<blockquote>
<div><p>x = (u + g1 u + g2 v) / scale / sqrt(1-g1**2-g2**2)
y = (v - g1 v + g2 u) / scale / sqrt(1-g1**2-g2**2)</p>
</div></blockquote>
<p>or, writing this in the usual way of (u,v) as a function of (x,y):</p>
<blockquote>
<div><p>u = (x - g1 x - g2 y) * scale / sqrt(1-g1**2-g2**2)
v = (y + g1 y - g2 x) * scale / sqrt(1-g1**2-g2**2)</p>
</div></blockquote>
<p>A ShearWCS is initialized with the command:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">wcs</span> <span class="o">=</span> <span class="n">galsim</span><span class="o">.</span><span class="n">ShearWCS</span><span class="p">(</span><span class="n">scale</span><span class="p">,</span> <span class="n">shear</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>scale</strong> – The pixel scale, typically in units of arcsec/pixel.</p></li>
<li><p><strong>shear</strong> – The shear, which should be a <a class="reference internal" href="shear.html#galsim.Shear" title="galsim.Shear"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Shear</span></code></a> instance.</p></li>
</ul>
</dd>
</dl>
<p>The Shear transformation conserves object area, so if the input <code class="docutils literal notranslate"><span class="pre">scale</span> <span class="pre">==</span> <span class="pre">1</span></code> then the
transformation represented by the ShearWCS will conserve object area also.</p>
<dl class="method">
<dt id="galsim.ShearWCS.scale">
<em class="property">property </em><code class="sig-name descname">scale</code><a class="headerlink" href="#galsim.ShearWCS.scale" title="Permalink to this definition">¶</a></dt>
<dd><p>The pixel scale.</p>
</dd></dl>

<dl class="method">
<dt id="galsim.ShearWCS.shear">
<em class="property">property </em><code class="sig-name descname">shear</code><a class="headerlink" href="#galsim.ShearWCS.shear" title="Permalink to this definition">¶</a></dt>
<dd><p>The applied <a class="reference internal" href="shear.html#galsim.Shear" title="galsim.Shear"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Shear</span></code></a>.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="galsim.OffsetShearWCS">
<em class="property">class </em><code class="sig-prename descclassname">galsim.</code><code class="sig-name descname">OffsetShearWCS</code><span class="sig-paren">(</span><em class="sig-param">scale</em>, <em class="sig-param">shear</em>, <em class="sig-param">origin=None</em>, <em class="sig-param">world_origin=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/wcs.html#OffsetShearWCS"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.OffsetShearWCS" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#galsim.wcs.UniformWCS" title="galsim.wcs.UniformWCS"><code class="xref py py-class docutils literal notranslate"><span class="pre">galsim.wcs.UniformWCS</span></code></a></p>
<p>This WCS is a uniformly sheared coordinate system with image and world origins
that are not necessarily coincident.</p>
<p>The conversion functions are:</p>
<blockquote>
<div><p>x = ( (1+g1) (u-u0) + g2 (v-v0) ) / scale / sqrt(1-g1**2-g2**2) + x0
y = ( (1-g1) (v-v0) + g2 (u-u0) ) / scale / sqrt(1-g1**2-g2**2) + y0</p>
<p>u = ( (1-g1) (x-x0) - g2 (y-y0) ) * scale / sqrt(1-g1**2-g2**2) + u0
v = ( (1+g1) (y-y0) - g2 (x-x0) ) * scale / sqrt(1-g1**2-g2**2) + v0</p>
</div></blockquote>
<p>An OffsetShearWCS is initialized with the command:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">wcs</span> <span class="o">=</span> <span class="n">galsim</span><span class="o">.</span><span class="n">OffsetShearWCS</span><span class="p">(</span><span class="n">scale</span><span class="p">,</span> <span class="n">shear</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">world_origin</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>scale</strong> – The pixel scale, typically in units of arcsec/pixel.</p></li>
<li><p><strong>shear</strong> – The shear, which should be a <a class="reference internal" href="shear.html#galsim.Shear" title="galsim.Shear"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Shear</span></code></a> instance.</p></li>
<li><p><strong>origin</strong> – Optional origin position for the image coordinate system.
If provided, it should be a <a class="reference internal" href="pos.html#galsim.PositionD" title="galsim.PositionD"><code class="xref any py py-class docutils literal notranslate"><span class="pre">PositionD</span></code></a> or <a class="reference internal" href="pos.html#galsim.PositionI" title="galsim.PositionI"><code class="xref any py py-class docutils literal notranslate"><span class="pre">PositionI</span></code></a>.
[default: PositionD(0., 0.)]</p></li>
<li><p><strong>world_origin</strong> – Optional origin position for the world coordinate system.
If provided, it should be a <a class="reference internal" href="pos.html#galsim.PositionD" title="galsim.PositionD"><code class="xref any py py-class docutils literal notranslate"><span class="pre">PositionD</span></code></a>.
[default: PositionD(0., 0.)]</p></li>
</ul>
</dd>
</dl>
<dl class="method">
<dt id="galsim.OffsetShearWCS.origin">
<em class="property">property </em><code class="sig-name descname">origin</code><a class="headerlink" href="#galsim.OffsetShearWCS.origin" title="Permalink to this definition">¶</a></dt>
<dd><p>The image coordinate position to use as the origin.</p>
</dd></dl>

<dl class="method">
<dt id="galsim.OffsetShearWCS.scale">
<em class="property">property </em><code class="sig-name descname">scale</code><a class="headerlink" href="#galsim.OffsetShearWCS.scale" title="Permalink to this definition">¶</a></dt>
<dd><p>The pixel scale.</p>
</dd></dl>

<dl class="method">
<dt id="galsim.OffsetShearWCS.shear">
<em class="property">property </em><code class="sig-name descname">shear</code><a class="headerlink" href="#galsim.OffsetShearWCS.shear" title="Permalink to this definition">¶</a></dt>
<dd><p>The applied <a class="reference internal" href="shear.html#galsim.Shear" title="galsim.Shear"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Shear</span></code></a>.</p>
</dd></dl>

<dl class="method">
<dt id="galsim.OffsetShearWCS.world_origin">
<em class="property">property </em><code class="sig-name descname">world_origin</code><a class="headerlink" href="#galsim.OffsetShearWCS.world_origin" title="Permalink to this definition">¶</a></dt>
<dd><p>The world coordinate position to use as the origin.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="galsim.JacobianWCS">
<em class="property">class </em><code class="sig-prename descclassname">galsim.</code><code class="sig-name descname">JacobianWCS</code><span class="sig-paren">(</span><em class="sig-param">dudx</em>, <em class="sig-param">dudy</em>, <em class="sig-param">dvdx</em>, <em class="sig-param">dvdy</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/wcs.html#JacobianWCS"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.JacobianWCS" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#galsim.wcs.LocalWCS" title="galsim.wcs.LocalWCS"><code class="xref py py-class docutils literal notranslate"><span class="pre">galsim.wcs.LocalWCS</span></code></a></p>
<p>This WCS is the most general local linear WCS implementing a 2x2 Jacobian matrix.</p>
<p>The conversion functions are:</p>
<blockquote>
<div><p>u = dudx x + dudy y
v = dvdx x + dvdy y</p>
</div></blockquote>
<p>A JacobianWCS has attributes dudx, dudy, dvdx, dvdy that you can access directly if that
is convenient.  You can also access these as a NumPy array directly with:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">J</span> <span class="o">=</span> <span class="n">jac_wcs</span><span class="o">.</span><span class="n">getMatrix</span><span class="p">()</span>
</pre></div>
</div>
<p>Also, JacobianWCS has another method that other WCS classes do not have. The call:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">scale</span><span class="p">,</span> <span class="n">shear</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">flip</span> <span class="o">=</span> <span class="n">jac_wcs</span><span class="o">.</span><span class="n">getDecomposition</span><span class="p">()</span>
</pre></div>
</div>
<p>will return the equivalent expansion, shear, rotation and possible flip corresponding to
this transformation.  See the docstring for that method for more information.</p>
<p>A JacobianWCS is initialized with the command:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">wcs</span> <span class="o">=</span> <span class="n">galsim</span><span class="o">.</span><span class="n">JacobianWCS</span><span class="p">(</span><span class="n">dudx</span><span class="p">,</span> <span class="n">dudy</span><span class="p">,</span> <span class="n">dvdx</span><span class="p">,</span> <span class="n">dvdy</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dudx</strong> – du/dx</p></li>
<li><p><strong>dudy</strong> – du/dy</p></li>
<li><p><strong>dvdx</strong> – dv/dx</p></li>
<li><p><strong>dvdy</strong> – dv/dy</p></li>
</ul>
</dd>
</dl>
<dl class="method">
<dt id="galsim.JacobianWCS.dudx">
<em class="property">property </em><code class="sig-name descname">dudx</code><a class="headerlink" href="#galsim.JacobianWCS.dudx" title="Permalink to this definition">¶</a></dt>
<dd><p>du/dx</p>
</dd></dl>

<dl class="method">
<dt id="galsim.JacobianWCS.dudy">
<em class="property">property </em><code class="sig-name descname">dudy</code><a class="headerlink" href="#galsim.JacobianWCS.dudy" title="Permalink to this definition">¶</a></dt>
<dd><p>du/dy</p>
</dd></dl>

<dl class="method">
<dt id="galsim.JacobianWCS.dvdx">
<em class="property">property </em><code class="sig-name descname">dvdx</code><a class="headerlink" href="#galsim.JacobianWCS.dvdx" title="Permalink to this definition">¶</a></dt>
<dd><p>dv/dx</p>
</dd></dl>

<dl class="method">
<dt id="galsim.JacobianWCS.dvdy">
<em class="property">property </em><code class="sig-name descname">dvdy</code><a class="headerlink" href="#galsim.JacobianWCS.dvdy" title="Permalink to this definition">¶</a></dt>
<dd><p>dv/dy</p>
</dd></dl>

<dl class="method">
<dt id="galsim.JacobianWCS.getDecomposition">
<code class="sig-name descname">getDecomposition</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/wcs.html#JacobianWCS.getDecomposition"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.JacobianWCS.getDecomposition" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the equivalent expansion, shear, rotation and possible flip corresponding to
this Jacobian transformation.</p>
<p>A non-singular real matrix can always be decomposed into a symmetric positive definite
matrix times an orthogonal matrix:</p>
<blockquote>
<div><p>M = P Q</p>
</div></blockquote>
<p>In our case, P includes an overall scale and a shear, and Q is a rotation and possibly
a flip of (x,y) -&gt; (y,x).</p>
<blockquote>
<div><p>( dudx  dudy ) = scale/sqrt(1-g1^2-g2^2) ( 1+g1  g2  ) ( cos(theta)  -sin(theta) ) F
( dvdx  dvdy )                           (  g2  1-g1 ) ( sin(theta)   cos(theta) )</p>
</div></blockquote>
<dl class="simple">
<dt>where F is either the identity matrix, ( 1 0 ), or a flip matrix, ( 0 1 ).</dt><dd><p>( 0 1 )                    ( 1 0 )</p>
</dd>
</dl>
<p>If there is no flip, then this means that the effect of:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">prof</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">dudx</span><span class="p">,</span> <span class="n">dudy</span><span class="p">,</span> <span class="n">dvdx</span><span class="p">,</span> <span class="n">dvdy</span><span class="p">)</span>
</pre></div>
</div>
<p>is equivalent to:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">prof</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span><span class="o">.</span><span class="n">shear</span><span class="p">(</span><span class="n">shear</span><span class="p">)</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="n">scale</span><span class="p">)</span>
</pre></div>
</div>
<p>in that order.  (Rotation and shear do not commute.)</p>
<p>The decomposition is returned as a tuple: (scale, shear, theta, flip), where scale is a
float, shear is a <a class="reference internal" href="shear.html#galsim.Shear" title="galsim.Shear"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Shear</span></code></a>, theta is an <a class="reference internal" href="units.html#galsim.Angle" title="galsim.Angle"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Angle</span></code></a>, and flip is a bool.</p>
</dd></dl>

<dl class="method">
<dt id="galsim.JacobianWCS.getMatrix">
<code class="sig-name descname">getMatrix</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/wcs.html#JacobianWCS.getMatrix"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.JacobianWCS.getMatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the Jacobian as a NumPy matrix:</p>
<dl class="simple">
<dt>numpy.array( [[ dudx, dudy ],</dt><dd><p>[ dvdx, dvdy ]] )</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="galsim.AffineTransform">
<em class="property">class </em><code class="sig-prename descclassname">galsim.</code><code class="sig-name descname">AffineTransform</code><span class="sig-paren">(</span><em class="sig-param">dudx</em>, <em class="sig-param">dudy</em>, <em class="sig-param">dvdx</em>, <em class="sig-param">dvdy</em>, <em class="sig-param">origin=None</em>, <em class="sig-param">world_origin=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/wcs.html#AffineTransform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.AffineTransform" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#galsim.wcs.UniformWCS" title="galsim.wcs.UniformWCS"><code class="xref py py-class docutils literal notranslate"><span class="pre">galsim.wcs.UniformWCS</span></code></a></p>
<p>This WCS is the most general linear transformation.  It involves a 2x2 Jacobian
matrix and an offset.  You can provide the offset in terms of either the <code class="docutils literal notranslate"><span class="pre">image_pos</span></code>
(x0,y0) where (u,v) = (0,0), or the <code class="docutils literal notranslate"><span class="pre">world_pos</span></code> (u0,v0) where (x,y) = (0,0).
Or, in fact, you may provide both, in which case the <code class="docutils literal notranslate"><span class="pre">image_pos</span></code> (x0,y0) corresponds
to the <code class="docutils literal notranslate"><span class="pre">world_pos</span></code> (u0,v0).</p>
<p>The conversion functions are:</p>
<blockquote>
<div><p>u = dudx (x-x0) + dudy (y-y0) + u0
v = dvdx (x-x0) + dvdy (y-y0) + v0</p>
</div></blockquote>
<p>An AffineTransform has attributes dudx, dudy, dvdx, dvdy, x0, y0, u0, v0 that you can
access directly if that is convenient.</p>
<p>An AffineTransform is initialized with the command:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">wcs</span> <span class="o">=</span> <span class="n">galsim</span><span class="o">.</span><span class="n">AffineTransform</span><span class="p">(</span><span class="n">dudx</span><span class="p">,</span> <span class="n">dudy</span><span class="p">,</span> <span class="n">dvdx</span><span class="p">,</span> <span class="n">dvdy</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">world_origin</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dudx</strong> – du/dx</p></li>
<li><p><strong>dudy</strong> – du/dy</p></li>
<li><p><strong>dvdx</strong> – dv/dx</p></li>
<li><p><strong>dvdy</strong> – dv/dy</p></li>
<li><p><strong>origin</strong> – Optional origin position for the image coordinate system.
If provided, it should be a <a class="reference internal" href="pos.html#galsim.PositionD" title="galsim.PositionD"><code class="xref any py py-class docutils literal notranslate"><span class="pre">PositionD</span></code></a> or <a class="reference internal" href="pos.html#galsim.PositionI" title="galsim.PositionI"><code class="xref any py py-class docutils literal notranslate"><span class="pre">PositionI</span></code></a>.
[default: PositionD(0., 0.)]</p></li>
<li><p><strong>world_origin</strong> – Optional origin position for the world coordinate system.
If provided, it should be a <a class="reference internal" href="pos.html#galsim.PositionD" title="galsim.PositionD"><code class="xref any py py-class docutils literal notranslate"><span class="pre">PositionD</span></code></a>.
[default: PositionD(0., 0.)]</p></li>
</ul>
</dd>
</dl>
<dl class="method">
<dt id="galsim.AffineTransform.dudx">
<em class="property">property </em><code class="sig-name descname">dudx</code><a class="headerlink" href="#galsim.AffineTransform.dudx" title="Permalink to this definition">¶</a></dt>
<dd><p>du/dx</p>
</dd></dl>

<dl class="method">
<dt id="galsim.AffineTransform.dudy">
<em class="property">property </em><code class="sig-name descname">dudy</code><a class="headerlink" href="#galsim.AffineTransform.dudy" title="Permalink to this definition">¶</a></dt>
<dd><p>du/dy</p>
</dd></dl>

<dl class="method">
<dt id="galsim.AffineTransform.dvdx">
<em class="property">property </em><code class="sig-name descname">dvdx</code><a class="headerlink" href="#galsim.AffineTransform.dvdx" title="Permalink to this definition">¶</a></dt>
<dd><p>dv/dx</p>
</dd></dl>

<dl class="method">
<dt id="galsim.AffineTransform.dvdy">
<em class="property">property </em><code class="sig-name descname">dvdy</code><a class="headerlink" href="#galsim.AffineTransform.dvdy" title="Permalink to this definition">¶</a></dt>
<dd><p>dv/dy</p>
</dd></dl>

<dl class="method">
<dt id="galsim.AffineTransform.origin">
<em class="property">property </em><code class="sig-name descname">origin</code><a class="headerlink" href="#galsim.AffineTransform.origin" title="Permalink to this definition">¶</a></dt>
<dd><p>The image coordinate position to use as the origin.</p>
</dd></dl>

<dl class="method">
<dt id="galsim.AffineTransform.world_origin">
<em class="property">property </em><code class="sig-name descname">world_origin</code><a class="headerlink" href="#galsim.AffineTransform.world_origin" title="Permalink to this definition">¶</a></dt>
<dd><p>The world coordinate position to use as the origin.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="galsim.UVFunction">
<em class="property">class </em><code class="sig-prename descclassname">galsim.</code><code class="sig-name descname">UVFunction</code><span class="sig-paren">(</span><em class="sig-param">ufunc</em>, <em class="sig-param">vfunc</em>, <em class="sig-param">xfunc=None</em>, <em class="sig-param">yfunc=None</em>, <em class="sig-param">origin=None</em>, <em class="sig-param">world_origin=None</em>, <em class="sig-param">uses_color=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/wcs.html#UVFunction"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.UVFunction" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#galsim.wcs.EuclideanWCS" title="galsim.wcs.EuclideanWCS"><code class="xref py py-class docutils literal notranslate"><span class="pre">galsim.wcs.EuclideanWCS</span></code></a></p>
<p>This WCS takes two arbitrary functions for u(x,y) and v(x,y).</p>
<dl class="simple">
<dt>The ufunc and vfunc parameters may be:</dt><dd><ul class="simple">
<li><p>python functions that take (x,y) arguments</p></li>
<li><p>python objects with a __call__ method that takes (x,y) arguments</p></li>
<li><p>strings which can be parsed with eval(‘lambda x,y: ‘+str)</p></li>
</ul>
</dd>
</dl>
<p>You may also provide the inverse functions x(u,v) and y(u,v) as xfunc and yfunc.
These are not required, but if you do not provide them, then any operation that requires
going from world to image coordinates will raise a NotImplementedError.</p>
<p>Note: some internal calculations will be faster if the functions can take NumPy arrays
for x,y and output arrays for u,v.  Usually this does not require any change to your
function, but it is worth keeping in mind.  For example, if you want to do a sqrt, you
may be better off using <code class="docutils literal notranslate"><span class="pre">numpy.sqrt</span></code> rather than <code class="docutils literal notranslate"><span class="pre">math.sqrt</span></code>.</p>
<p>A UVFunction is initialized with the command:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">wcs</span> <span class="o">=</span> <span class="n">galsim</span><span class="o">.</span><span class="n">UVFunction</span><span class="p">(</span><span class="n">ufunc</span><span class="p">,</span> <span class="n">vfunc</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">world_origin</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ufunc</strong> – The function u(x,y)</p></li>
<li><p><strong>vfunc</strong> – The function v(x,y)</p></li>
<li><p><strong>xfunc</strong> – The function x(u,v) (optional)</p></li>
<li><p><strong>yfunc</strong> – The function y(u,v) (optional)</p></li>
<li><p><strong>origin</strong> – Optional origin position for the image coordinate system.
If provided, it should be a <a class="reference internal" href="pos.html#galsim.PositionD" title="galsim.PositionD"><code class="xref any py py-class docutils literal notranslate"><span class="pre">PositionD</span></code></a> or <a class="reference internal" href="pos.html#galsim.PositionI" title="galsim.PositionI"><code class="xref any py py-class docutils literal notranslate"><span class="pre">PositionI</span></code></a>.
[default: PositionD(0., 0.)]</p></li>
<li><p><strong>Optional origin position for the world coordinate system.</strong> (<em>world_origin</em>) – If provided, it should be a <a class="reference internal" href="pos.html#galsim.PositionD" title="galsim.PositionD"><code class="xref any py py-class docutils literal notranslate"><span class="pre">PositionD</span></code></a>.
[default: PositionD(0., 0.)]</p></li>
<li><p><strong>uses_color</strong> – If True, then the functions take three parameters (x,y,c) or (u,v,c)
where the third term is some kind of color value.  (The exact meaning
of “color” here is user-defined. You just need to be consistent with
the color values you use when using the wcs.) [default: False]</p></li>
</ul>
</dd>
</dl>
<dl class="method">
<dt id="galsim.UVFunction.origin">
<em class="property">property </em><code class="sig-name descname">origin</code><a class="headerlink" href="#galsim.UVFunction.origin" title="Permalink to this definition">¶</a></dt>
<dd><p>The image coordinate position to use as the origin.</p>
</dd></dl>

<dl class="method">
<dt id="galsim.UVFunction.ufunc">
<em class="property">property </em><code class="sig-name descname">ufunc</code><a class="headerlink" href="#galsim.UVFunction.ufunc" title="Permalink to this definition">¶</a></dt>
<dd><p>The input ufunc</p>
</dd></dl>

<dl class="method">
<dt id="galsim.UVFunction.vfunc">
<em class="property">property </em><code class="sig-name descname">vfunc</code><a class="headerlink" href="#galsim.UVFunction.vfunc" title="Permalink to this definition">¶</a></dt>
<dd><p>The input vfunc</p>
</dd></dl>

<dl class="method">
<dt id="galsim.UVFunction.world_origin">
<em class="property">property </em><code class="sig-name descname">world_origin</code><a class="headerlink" href="#galsim.UVFunction.world_origin" title="Permalink to this definition">¶</a></dt>
<dd><p>The world coordinate position to use as the origin.</p>
</dd></dl>

<dl class="method">
<dt id="galsim.UVFunction.xfunc">
<em class="property">property </em><code class="sig-name descname">xfunc</code><a class="headerlink" href="#galsim.UVFunction.xfunc" title="Permalink to this definition">¶</a></dt>
<dd><p>The input xfunc</p>
</dd></dl>

<dl class="method">
<dt id="galsim.UVFunction.yfunc">
<em class="property">property </em><code class="sig-name descname">yfunc</code><a class="headerlink" href="#galsim.UVFunction.yfunc" title="Permalink to this definition">¶</a></dt>
<dd><p>The input yfunc</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="celestial-wcs-s">
<h2>Celestial WCS’s<a class="headerlink" href="#celestial-wcs-s" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="galsim.RaDecFunction">
<em class="property">class </em><code class="sig-prename descclassname">galsim.</code><code class="sig-name descname">RaDecFunction</code><span class="sig-paren">(</span><em class="sig-param">ra_func</em>, <em class="sig-param">dec_func=None</em>, <em class="sig-param">origin=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/wcs.html#RaDecFunction"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.RaDecFunction" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#galsim.wcs.CelestialWCS" title="galsim.wcs.CelestialWCS"><code class="xref py py-class docutils literal notranslate"><span class="pre">galsim.wcs.CelestialWCS</span></code></a></p>
<p>This WCS takes an arbitrary function for the Right Ascension (ra) and Declination (dec).</p>
<p>In many cases, it can be more convenient to calculate both ra and dec in a single function,
since there will typically be intermediate values that are common to both, so it may be more
efficient to just calculate those once and thence calculate both ra and dec.  Thus, we
provide the option to provide either a single function or two separate functions.</p>
<dl class="simple">
<dt>The function parameters used to initialize an RaDecFunction may be:</dt><dd><ul class="simple">
<li><p>a python functions that take (x,y) arguments</p></li>
<li><p>a python object with a __call__ method that takes (x,y) arguments</p></li>
<li><p>a string which can be parsed with eval(‘lambda x,y: ‘+str)</p></li>
</ul>
</dd>
</dl>
<p>The return values, ra and dec, should be given in _radians_.</p>
<p>The first argument is called <code class="docutils literal notranslate"><span class="pre">ra_func</span></code>, but if <code class="docutils literal notranslate"><span class="pre">dec_func</span></code> is omitted, then it is assumed
to calculate both ra and dec.  The two values should be returned as a tuple (ra,dec).</p>
<p>We don’t want a function that returns <a class="reference internal" href="units.html#galsim.Angle" title="galsim.Angle"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Angle</span></code></a> instances, because we want to allow for the
possibility of using NumPy arrays as inputs and outputs to speed up some calculations.  The
function isn’t _required_ to work with NumPy arrays, but it is possible that some things
will be faster if it does.  If it were expected to return <a class="reference internal" href="units.html#galsim.Angle" title="galsim.Angle"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Angle</span></code></a> instances, then it definitely
couldn’t work with arrays.</p>
<p>An RaDecFunction is initialized with either of the following commands:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">wcs</span> <span class="o">=</span> <span class="n">galsim</span><span class="o">.</span><span class="n">RaDecFunction</span><span class="p">(</span><span class="n">radec_func</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">wcs</span> <span class="o">=</span> <span class="n">galsim</span><span class="o">.</span><span class="n">RaDecFunction</span><span class="p">(</span><span class="n">ra_func</span><span class="p">,</span> <span class="n">dec_func</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ra_func</strong> – If <code class="docutils literal notranslate"><span class="pre">dec_func</span></code> is also given: A function ra(x,y) returning ra in radians.
If <code class="docutils literal notranslate"><span class="pre">dec_func=None</span></code>: A function returning a tuple (ra,dec), both in radians.</p></li>
<li><p><strong>dec_func</strong> – Either a function dec(x,y) returning dec in radians, or None (in which
case <code class="docutils literal notranslate"><span class="pre">ra_func</span></code> is expected to return both ra and dec. [default: None]</p></li>
<li><p><strong>origin</strong> – Optional origin position for the image coordinate system.
If provided, it should be a <a class="reference internal" href="pos.html#galsim.PositionD" title="galsim.PositionD"><code class="xref any py py-class docutils literal notranslate"><span class="pre">PositionD</span></code></a> or <a class="reference internal" href="pos.html#galsim.PositionI" title="galsim.PositionI"><code class="xref any py py-class docutils literal notranslate"><span class="pre">PositionI</span></code></a>.
[default: PositionD(0., 0.)]</p></li>
</ul>
</dd>
</dl>
<dl class="method">
<dt id="galsim.RaDecFunction.origin">
<em class="property">property </em><code class="sig-name descname">origin</code><a class="headerlink" href="#galsim.RaDecFunction.origin" title="Permalink to this definition">¶</a></dt>
<dd><p>The image coordinate position to use as the origin.</p>
</dd></dl>

<dl class="method">
<dt id="galsim.RaDecFunction.radec_func">
<em class="property">property </em><code class="sig-name descname">radec_func</code><a class="headerlink" href="#galsim.RaDecFunction.radec_func" title="Permalink to this definition">¶</a></dt>
<dd><p>The input radec_func</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="galsim.AstropyWCS">
<em class="property">class </em><code class="sig-prename descclassname">galsim.</code><code class="sig-name descname">AstropyWCS</code><span class="sig-paren">(</span><em class="sig-param">file_name=None</em>, <em class="sig-param">dir=None</em>, <em class="sig-param">hdu=None</em>, <em class="sig-param">header=None</em>, <em class="sig-param">compression='auto'</em>, <em class="sig-param">wcs=None</em>, <em class="sig-param">origin=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/fitswcs.html#AstropyWCS"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.AstropyWCS" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#galsim.wcs.CelestialWCS" title="galsim.wcs.CelestialWCS"><code class="xref py py-class docutils literal notranslate"><span class="pre">galsim.wcs.CelestialWCS</span></code></a></p>
<p>This WCS uses astropy.wcs to read WCS information from a FITS file.
It requires the astropy.wcs python module to be installed.</p>
<p>Astropy may be installed using pip, fink, or port:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pip</span> <span class="n">install</span> <span class="n">astropy</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fink</span> <span class="n">install</span> <span class="n">astropy</span><span class="o">-</span><span class="n">py27</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">port</span> <span class="n">install</span> <span class="n">py27</span><span class="o">-</span><span class="n">astropy</span>
</pre></div>
</div>
<p>It also comes by default with Enthought and Anaconda. For more information, see their website:</p>
<blockquote>
<div><p><a class="reference external" href="http://www.astropy.org/">http://www.astropy.org/</a></p>
</div></blockquote>
<p>An AstropyWCS is initialized with one of the following commands:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">wcs</span> <span class="o">=</span> <span class="n">galsim</span><span class="o">.</span><span class="n">AstropyWCS</span><span class="p">(</span><span class="n">file_name</span><span class="o">=</span><span class="n">file_name</span><span class="p">)</span>  <span class="c1"># Open a file on disk</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">wcs</span> <span class="o">=</span> <span class="n">galsim</span><span class="o">.</span><span class="n">AstropyWCS</span><span class="p">(</span><span class="n">header</span><span class="o">=</span><span class="n">header</span><span class="p">)</span>        <span class="c1"># Use an existing pyfits header</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">wcs</span> <span class="o">=</span> <span class="n">galsim</span><span class="o">.</span><span class="n">AstropyWCS</span><span class="p">(</span><span class="n">wcs</span><span class="o">=</span><span class="n">wcs</span><span class="p">)</span>              <span class="c1"># Use an existing astropy.wcs.WCS instance</span>
</pre></div>
</div>
<p>Exactly one of the parameters <code class="docutils literal notranslate"><span class="pre">file_name</span></code>, <code class="docutils literal notranslate"><span class="pre">header</span></code> or <code class="docutils literal notranslate"><span class="pre">wcs</span></code> is required.  Also, since
the most common usage will probably be the first, you can also give a <code class="docutils literal notranslate"><span class="pre">file_name</span></code> without it
being named:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">wcs</span> <span class="o">=</span> <span class="n">galsim</span><span class="o">.</span><span class="n">AstropyWCS</span><span class="p">(</span><span class="n">file_name</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>file_name</strong> – The FITS file from which to read the WCS information.  This is probably
the usual parameter to provide.  [default: None]</p></li>
<li><p><strong>dir</strong> – Optional directory to prepend to <code class="docutils literal notranslate"><span class="pre">file_name</span></code>. [default: None]</p></li>
<li><p><strong>hdu</strong> – Optionally, the number of the HDU to use if reading from a file.
The default is to use either the primary or first extension as
appropriate for the given compression.  (e.g. for rice, the first
extension is the one you normally want.) [default: None]</p></li>
<li><p><strong>header</strong> – The header of an open pyfits (or astropy.io) hdu.  Or, it can be
a FitsHeader object.  [default: None]</p></li>
<li><p><strong>compression</strong> – Which decompression scheme to use (if any). See galsim.fits.read()
for the available options.  [default: ‘auto’]</p></li>
<li><p><strong>wcs</strong> – An existing astropy.wcs.WCS instance [default: None]</p></li>
<li><p><strong>origin</strong> – Optional origin position for the image coordinate system.
If provided, it should be a PositionD or PositionI.
[default: None]</p></li>
</ul>
</dd>
</dl>
<dl class="method">
<dt id="galsim.AstropyWCS.origin">
<em class="property">property </em><code class="sig-name descname">origin</code><a class="headerlink" href="#galsim.AstropyWCS.origin" title="Permalink to this definition">¶</a></dt>
<dd><p>The origin in image coordinates of the WCS function.</p>
</dd></dl>

<dl class="method">
<dt id="galsim.AstropyWCS.wcs">
<em class="property">property </em><code class="sig-name descname">wcs</code><a class="headerlink" href="#galsim.AstropyWCS.wcs" title="Permalink to this definition">¶</a></dt>
<dd><p>The underlying <code class="docutils literal notranslate"><span class="pre">astropy.wcs.WCS</span></code> object.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="galsim.PyAstWCS">
<em class="property">class </em><code class="sig-prename descclassname">galsim.</code><code class="sig-name descname">PyAstWCS</code><span class="sig-paren">(</span><em class="sig-param">file_name=None</em>, <em class="sig-param">dir=None</em>, <em class="sig-param">hdu=None</em>, <em class="sig-param">header=None</em>, <em class="sig-param">compression='auto'</em>, <em class="sig-param">wcsinfo=None</em>, <em class="sig-param">origin=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/fitswcs.html#PyAstWCS"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.PyAstWCS" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#galsim.wcs.CelestialWCS" title="galsim.wcs.CelestialWCS"><code class="xref py py-class docutils literal notranslate"><span class="pre">galsim.wcs.CelestialWCS</span></code></a></p>
<p>This WCS uses PyAst (the python front end for the Starlink AST code) to read WCS
information from a FITS file.  It requires the starlink.Ast python module to be installed.</p>
<p>Starlink may be installed using pip:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pip</span> <span class="n">install</span> <span class="n">starlink</span><span class="o">-</span><span class="n">pyast</span>
</pre></div>
</div>
<p>For more information, see their website:</p>
<p><a class="reference external" href="https://pypi.python.org/pypi/starlink-pyast/">https://pypi.python.org/pypi/starlink-pyast/</a></p>
<p>A PyAstWCS is initialized with one of the following commands:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">wcs</span> <span class="o">=</span> <span class="n">galsim</span><span class="o">.</span><span class="n">PyAstWCS</span><span class="p">(</span><span class="n">file_name</span><span class="o">=</span><span class="n">file_name</span><span class="p">)</span>  <span class="c1"># Open a file on disk</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">wcs</span> <span class="o">=</span> <span class="n">galsim</span><span class="o">.</span><span class="n">PyAstWCS</span><span class="p">(</span><span class="n">header</span><span class="o">=</span><span class="n">header</span><span class="p">)</span>        <span class="c1"># Use an existing pyfits header</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">wcs</span> <span class="o">=</span> <span class="n">galsim</span><span class="o">.</span><span class="n">PyAstWCS</span><span class="p">(</span><span class="n">wcsinfo</span><span class="o">=</span><span class="n">wcsinfo</span><span class="p">)</span>      <span class="c1"># Use an existing starlink.Ast.FrameSet</span>
</pre></div>
</div>
<p>Exactly one of the parameters <code class="docutils literal notranslate"><span class="pre">file_name</span></code>, <code class="docutils literal notranslate"><span class="pre">header</span></code> or <code class="docutils literal notranslate"><span class="pre">wcsinfo</span></code> is required.  Also,
since the most common usage will probably be the first, you can also give a file name without
it being named:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">wcs</span> <span class="o">=</span> <span class="n">galsim</span><span class="o">.</span><span class="n">PyAstWCS</span><span class="p">(</span><span class="n">file_name</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>file_name</strong> – The FITS file from which to read the WCS information.  This is probably
the usual parameter to provide.  [default: None]</p></li>
<li><p><strong>dir</strong> – Optional directory to prepend to <code class="docutils literal notranslate"><span class="pre">file_name</span></code>. [default: None]</p></li>
<li><p><strong>hdu</strong> – Optionally, the number of the HDU to use if reading from a file.
The default is to use either the primary or first extension as
appropriate for the given compression.  (e.g. for rice, the first
extension is the one you normally want.) [default: None]</p></li>
<li><p><strong>header</strong> – The header of an open pyfits (or astropy.io) hdu.  Or, it can be
a FitsHeader object.  [default: None]</p></li>
<li><p><strong>compression</strong> – Which decompression scheme to use (if any). See galsim.fits.read()
for the available options.  [default:’auto’]</p></li>
<li><p><strong>wcsinfo</strong> – An existing starlink.Ast.FrameSet [default: None]</p></li>
<li><p><strong>origin</strong> – Optional origin position for the image coordinate system.
If provided, it should be a PositionD or PositionI.
[default: None]</p></li>
</ul>
</dd>
</dl>
<dl class="method">
<dt id="galsim.PyAstWCS.origin">
<em class="property">property </em><code class="sig-name descname">origin</code><a class="headerlink" href="#galsim.PyAstWCS.origin" title="Permalink to this definition">¶</a></dt>
<dd><p>The origin in image coordinates of the WCS function.</p>
</dd></dl>

<dl class="method">
<dt id="galsim.PyAstWCS.wcsinfo">
<em class="property">property </em><code class="sig-name descname">wcsinfo</code><a class="headerlink" href="#galsim.PyAstWCS.wcsinfo" title="Permalink to this definition">¶</a></dt>
<dd><p>The underlying <code class="docutils literal notranslate"><span class="pre">starlink.Ast.FrameSet</span></code> for this object.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="galsim.WcsToolsWCS">
<em class="property">class </em><code class="sig-prename descclassname">galsim.</code><code class="sig-name descname">WcsToolsWCS</code><span class="sig-paren">(</span><em class="sig-param">file_name</em>, <em class="sig-param">dir=None</em>, <em class="sig-param">origin=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/fitswcs.html#WcsToolsWCS"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.WcsToolsWCS" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#galsim.wcs.CelestialWCS" title="galsim.wcs.CelestialWCS"><code class="xref py py-class docutils literal notranslate"><span class="pre">galsim.wcs.CelestialWCS</span></code></a></p>
<p>This WCS uses wcstools executables to perform the appropriate WCS transformations
for a given FITS file.  It requires wcstools command line functions to be installed.</p>
<p>Note: It uses the wcstools executables xy2sky and sky2xy, so it can be quite a bit less
efficient than other options that keep the WCS in memory.</p>
<p>See their website for information on downloading and installing wcstools:</p>
<blockquote>
<div><p><a class="reference external" href="http://tdc-www.harvard.edu/software/wcstools/">http://tdc-www.harvard.edu/software/wcstools/</a></p>
</div></blockquote>
<p>A WcsToolsWCS is initialized with the following command:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">wcs</span> <span class="o">=</span> <span class="n">galsim</span><span class="o">.</span><span class="n">WcsToolsWCS</span><span class="p">(</span><span class="n">file_name</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>file_name</strong> – The FITS file from which to read the WCS information.</p></li>
<li><p><strong>dir</strong> – Optional directory to prepend to <code class="docutils literal notranslate"><span class="pre">file_name</span></code>. [default: None]</p></li>
<li><p><strong>origin</strong> – Optional origin position for the image coordinate system.
If provided, it should be a PositionD or PositionI.
[default: None]</p></li>
</ul>
</dd>
</dl>
<dl class="method">
<dt id="galsim.WcsToolsWCS.file_name">
<em class="property">property </em><code class="sig-name descname">file_name</code><a class="headerlink" href="#galsim.WcsToolsWCS.file_name" title="Permalink to this definition">¶</a></dt>
<dd><p>The file name of the FITS file with the WCS information.</p>
</dd></dl>

<dl class="method">
<dt id="galsim.WcsToolsWCS.origin">
<em class="property">property </em><code class="sig-name descname">origin</code><a class="headerlink" href="#galsim.WcsToolsWCS.origin" title="Permalink to this definition">¶</a></dt>
<dd><p>The origin in image coordinates of the WCS function.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="galsim.GSFitsWCS">
<em class="property">class </em><code class="sig-prename descclassname">galsim.</code><code class="sig-name descname">GSFitsWCS</code><span class="sig-paren">(</span><em class="sig-param">file_name=None</em>, <em class="sig-param">dir=None</em>, <em class="sig-param">hdu=None</em>, <em class="sig-param">header=None</em>, <em class="sig-param">compression='auto'</em>, <em class="sig-param">origin=None</em>, <em class="sig-param">_data=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/fitswcs.html#GSFitsWCS"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.GSFitsWCS" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#galsim.wcs.CelestialWCS" title="galsim.wcs.CelestialWCS"><code class="xref py py-class docutils literal notranslate"><span class="pre">galsim.wcs.CelestialWCS</span></code></a></p>
<p>This WCS uses a GalSim implementation to read a WCS from a FITS file.</p>
<p>It doesn’t do nearly as many WCS types as the other options, and it does not try to be
as rigorous about supporting all possible valid variations in the FITS parameters.
However, it does several popular WCS types properly, and it doesn’t require any additional
python modules to be installed, which can be helpful.</p>
<p>Currrently, it is able to parse the following WCS types: TAN, STG, ZEA, ARC, TPV, TNX</p>
<p>A GSFitsWCS is initialized with one of the following commands:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">wcs</span> <span class="o">=</span> <span class="n">galsim</span><span class="o">.</span><span class="n">GSFitsWCS</span><span class="p">(</span><span class="n">file_name</span><span class="o">=</span><span class="n">file_name</span><span class="p">)</span>  <span class="c1"># Open a file on disk</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">wcs</span> <span class="o">=</span> <span class="n">galsim</span><span class="o">.</span><span class="n">GSFitsWCS</span><span class="p">(</span><span class="n">header</span><span class="o">=</span><span class="n">header</span><span class="p">)</span>        <span class="c1"># Use an existing pyfits header</span>
</pre></div>
</div>
<p>Also, since the most common usage will probably be the first, you can also give a file name
without it being named:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">wcs</span> <span class="o">=</span> <span class="n">galsim</span><span class="o">.</span><span class="n">GSFitsWCS</span><span class="p">(</span><span class="n">file_name</span><span class="p">)</span>
</pre></div>
</div>
<p>In addition to reading from a FITS file, there is also a factory function that builds
a GSFitsWCS object implementing a TAN projection.  See the docstring of <a class="reference internal" href="#galsim.TanWCS" title="galsim.TanWCS"><code class="xref any py py-func docutils literal notranslate"><span class="pre">TanWCS</span></code></a> for
more details.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>file_name</strong> – The FITS file from which to read the WCS information.  This is probably
the usual parameter to provide.  [default: None]</p></li>
<li><p><strong>dir</strong> – Optional directory to prepend to <code class="docutils literal notranslate"><span class="pre">file_name</span></code>. [default: None]</p></li>
<li><p><strong>hdu</strong> – Optionally, the number of the HDU to use if reading from a file.
The default is to use either the primary or first extension as
appropriate for the given compression.  (e.g. for rice, the first
extension is the one you normally want.) [default: None]</p></li>
<li><p><strong>header</strong> – The header of an open pyfits (or astropy.io) hdu.  Or, it can be
a FitsHeader object.  [default: None]</p></li>
<li><p><strong>compression</strong> – Which decompression scheme to use (if any). See galsim.fits.read()
for the available options.  [default: ‘auto’]</p></li>
<li><p><strong>origin</strong> – Optional origin position for the image coordinate system.
If provided, it should be a PositionD or PositionI.
[default: None]</p></li>
</ul>
</dd>
</dl>
<dl class="method">
<dt id="galsim.GSFitsWCS.origin">
<em class="property">property </em><code class="sig-name descname">origin</code><a class="headerlink" href="#galsim.GSFitsWCS.origin" title="Permalink to this definition">¶</a></dt>
<dd><p>The origin in image coordinates of the WCS function.</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="galsim.FitsWCS">
<code class="sig-prename descclassname">galsim.</code><code class="sig-name descname">FitsWCS</code><span class="sig-paren">(</span><em class="sig-param">file_name=None</em>, <em class="sig-param">dir=None</em>, <em class="sig-param">hdu=None</em>, <em class="sig-param">header=None</em>, <em class="sig-param">compression='auto'</em>, <em class="sig-param">text_file=False</em>, <em class="sig-param">suppress_warning=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/fitswcs.html#FitsWCS"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.FitsWCS" title="Permalink to this definition">¶</a></dt>
<dd><p>This factory function will try to read the WCS from a FITS file and return a WCS that will
work.  It tries a number of different WCS classes until it finds one that succeeds in reading
the file.</p>
<p>If none of them work, then the last class it tries, <a class="reference internal" href="#galsim.AffineTransform" title="galsim.AffineTransform"><code class="xref any py py-class docutils literal notranslate"><span class="pre">AffineTransform</span></code></a>, is guaranteed to succeed,
but it will only model the linear portion of the WCS (the CD matrix, CRPIX, and CRVAL), using
reasonable defaults if even these are missing.  If you think that you have the right software
for one of the WCS types, but FitsWCS still defaults to <a class="reference internal" href="#galsim.AffineTransform" title="galsim.AffineTransform"><code class="xref any py py-class docutils literal notranslate"><span class="pre">AffineTransform</span></code></a>, it may be helpful to
update your installation of astropy and/or starlink (if you don’t already have the latest
version).</p>
<p>Note: The list of classes this function will try may be edited, e.g. by an external module
that wants to add an additional WCS type.  The list is <code class="docutils literal notranslate"><span class="pre">galsim.fitswcs.fits_wcs_types</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>file_name</strong> – The FITS file from which to read the WCS information.  This is probably
the usual parameter to provide.  [default: None]</p></li>
<li><p><strong>dir</strong> – Optional directory to prepend to <code class="docutils literal notranslate"><span class="pre">file_name</span></code>. [default: None]</p></li>
<li><p><strong>hdu</strong> – Optionally, the number of the HDU to use if reading from a file.
The default is to use either the primary or first extension as
appropriate for the given compression.  (e.g. for rice, the first
extension is the one you normally want.) [default: None]</p></li>
<li><p><strong>header</strong> – The header of an open pyfits (or astropy.io) hdu.  Or, it can be
a FitsHeader object.  [default: None]</p></li>
<li><p><strong>compression</strong> – Which decompression scheme to use (if any). See galsim.fits.read()
for the available options.  [default: ‘auto’]</p></li>
<li><p><strong>text_file</strong> – Normally a file is taken to be a fits file, but you can also give it a
text file with the header information (like the .head file output from
SCamp).  In this case you should set <code class="docutils literal notranslate"><span class="pre">text_file</span> <span class="pre">=</span> <span class="pre">True</span></code> to tell GalSim
to parse the file this way.  [default: False]</p></li>
<li><p><strong>suppress_warning</strong> – Should a warning be emitted if none of the real FITS WCS classes
are able to successfully read the file, and we have to reset to
an <a class="reference internal" href="#galsim.AffineTransform" title="galsim.AffineTransform"><code class="xref any py py-class docutils literal notranslate"><span class="pre">AffineTransform</span></code></a> instead?  [default: False]
(Note: this is set to True when this function is implicitly called from
one of the galsim.fits.read* functions.)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="galsim.TanWCS">
<code class="sig-prename descclassname">galsim.</code><code class="sig-name descname">TanWCS</code><span class="sig-paren">(</span><em class="sig-param">affine</em>, <em class="sig-param">world_origin</em>, <em class="sig-param">units=coord.arcsec</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/fitswcs.html#TanWCS"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.TanWCS" title="Permalink to this definition">¶</a></dt>
<dd><p>This is a function that returns a <a class="reference internal" href="#galsim.GSFitsWCS" title="galsim.GSFitsWCS"><code class="xref any py py-class docutils literal notranslate"><span class="pre">GSFitsWCS</span></code></a> object for a TAN WCS projection.</p>
<p>The TAN projection is essentially an affine transformation from image coordinates to
Euclidean (u,v) coordinates on a tangent plane, and then a “deprojection” of this plane
onto the sphere given a particular RA, Dec for the location of the tangent point.
The tangent point will correspond to the location of (u,v) = (0,0) in the intermediate
coordinate system.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>affine</strong> – An <a class="reference internal" href="#galsim.AffineTransform" title="galsim.AffineTransform"><code class="xref any py py-class docutils literal notranslate"><span class="pre">AffineTransform</span></code></a> defining the transformation from image coordinates
to the coordinates on the tangent plane.</p></li>
<li><p><strong>world_origin</strong> – A <a class="reference internal" href="#galsim.CelestialCoord" title="galsim.CelestialCoord"><code class="xref any py py-class docutils literal notranslate"><span class="pre">CelestialCoord</span></code></a> defining the location on the sphere where the
tangent plane is centered.</p></li>
<li><p><strong>units</strong> – The angular units of the (u,v) intermediate coordinate system.
[default: galsim.arcsec]</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a <a class="reference internal" href="#galsim.GSFitsWCS" title="galsim.GSFitsWCS"><code class="xref any py py-class docutils literal notranslate"><span class="pre">GSFitsWCS</span></code></a> describing this WCS.</p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="celestial-coordinates">
<h2>Celestial Coordinates<a class="headerlink" href="#celestial-coordinates" title="Permalink to this headline">¶</a></h2>
<p>Our <a class="reference internal" href="#galsim.CelestialCoord" title="galsim.CelestialCoord"><code class="xref any py py-class docutils literal notranslate"><span class="pre">CelestialCoord</span></code></a> class is currently hosted as part of the <code class="docutils literal notranslate"><span class="pre">LSSTDESC.Coord</span></code> package:</p>
<p><a class="reference external" href="https://github.com/LSSTDESC/Coord">https://github.com/LSSTDESC/Coord</a></p>
<p>An earlier version of this code was originally implemented in GalSim, so we
still import the relevant classes into the <code class="docutils literal notranslate"><span class="pre">galsim</span></code> namespace.  You may therefore
use either <code class="docutils literal notranslate"><span class="pre">galsim.CelestialCoord</span></code> or <code class="docutils literal notranslate"><span class="pre">coord.CelestialCoord</span></code> as they are equivalent.</p>
<dl class="class">
<dt id="galsim.CelestialCoord">
<em class="property">class </em><code class="sig-prename descclassname">galsim.</code><code class="sig-name descname">CelestialCoord</code><span class="sig-paren">(</span><em class="sig-param">ra</em>, <em class="sig-param">dec=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/coord/celestial.html#CelestialCoord"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.CelestialCoord" title="Permalink to this definition">¶</a></dt>
<dd><p>This class defines a position on the celestial sphere, normally given by two angles,
<code class="docutils literal notranslate"><span class="pre">ra</span></code> and <code class="docutils literal notranslate"><span class="pre">dec</span></code>.</p>
<p>This class can be used to perform various calculations in spherical coordinates, such
as finding the angular distance between two points in the sky, calculating the angles in
spherical triangles, projecting from sky coordinates onto a Euclidean tangent plane, etc.</p>
<p><strong>Initialization:</strong></p>
<blockquote>
<div><p>A <a class="reference internal" href="#galsim.CelestialCoord" title="galsim.CelestialCoord"><code class="xref any py py-class docutils literal notranslate"><span class="pre">CelestialCoord</span></code></a> object is constructed from the right ascension and declination:</p>
<blockquote>
<div><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">coord.CelestialCoord.__init__()</span></code></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">CelestialCoord</span><span class="p">(</span><span class="n">ra</span><span class="o">=</span><span class="mi">12</span><span class="o">*</span><span class="n">hours</span><span class="p">,</span> <span class="n">dec</span><span class="o">=</span><span class="mi">31</span><span class="o">*</span><span class="n">degrees</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="go">coord.CelestialCoord(3.141592653589793 radians, 0.5410520681182421 radians)</span>
</pre></div>
</div>
</div></blockquote>
</div></blockquote>
<p><strong>Attributes:</strong></p>
<blockquote>
<div><p>A CelestialCoord has the following (read-only) attributes:</p>
<blockquote>
<div><dl class="field-list simple">
<dt class="field-odd">ra</dt>
<dd class="field-odd"><p>The right ascension (an Angle instance)</p>
</dd>
<dt class="field-even">dec</dt>
<dd class="field-even"><p>The declination (an Angle instance)</p>
</dd>
</dl>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">ra</span> <span class="o">/</span> <span class="n">degrees</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">dec</span> <span class="o">/</span> <span class="n">degrees</span><span class="p">)</span>
<span class="go">180.0 31.0</span>
</pre></div>
</div>
</div></blockquote>
<p>In addition there is a convenience access property that returns ra and dec in radians.</p>
<blockquote>
<div><dl class="field-list simple">
<dt class="field-odd">rad</dt>
<dd class="field-odd"><p>A tuple (ra.rad, dec.rad)</p>
</dd>
</dl>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">rad</span><span class="p">)</span>
<span class="go">(3.141592653589793, 0.5410520681182421)</span>
</pre></div>
</div>
</div></blockquote>
</div></blockquote>
<p><strong>Spherical Geometry:</strong></p>
<blockquote>
<div><p>The basic spherical geometry operations are available to work with spherical triangles</p>
<p>For three coordinates cA, cB, cC making a spherical triangle, one can calculate the
sides and angles via:</p>
<blockquote>
<div><div class="line-block">
<div class="line"><code class="xref py py-meth docutils literal notranslate"><span class="pre">coord.CelestialCoord.distanceTo()</span></code></div>
<div class="line"><code class="xref py py-meth docutils literal notranslate"><span class="pre">coord.CelestialCoord.angleBetween()</span></code></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cA</span> <span class="o">=</span> <span class="n">CelestialCoord</span><span class="p">(</span><span class="mi">0</span> <span class="o">*</span> <span class="n">degrees</span><span class="p">,</span> <span class="mi">0</span> <span class="o">*</span> <span class="n">degrees</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cB</span> <span class="o">=</span> <span class="n">CelestialCoord</span><span class="p">(</span><span class="mi">0</span> <span class="o">*</span> <span class="n">degrees</span><span class="p">,</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">degrees</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cC</span> <span class="o">=</span> <span class="n">CelestialCoord</span><span class="p">(</span><span class="mi">10</span> <span class="o">*</span> <span class="n">degrees</span><span class="p">,</span> <span class="mi">0</span> <span class="o">*</span> <span class="n">degrees</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">cB</span><span class="o">.</span><span class="n">distanceTo</span><span class="p">(</span><span class="n">cC</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">cC</span><span class="o">.</span><span class="n">distanceTo</span><span class="p">(</span><span class="n">cA</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">cA</span><span class="o">.</span><span class="n">distanceTo</span><span class="p">(</span><span class="n">cB</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">deg</span><span class="p">,</span> <span class="n">b</span><span class="o">.</span><span class="n">deg</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">deg</span><span class="p">)</span>
<span class="go">14.106044260566366 10.0 10.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">cA</span><span class="o">.</span><span class="n">angleBetween</span><span class="p">(</span><span class="n">cB</span><span class="p">,</span> <span class="n">cC</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">cB</span><span class="o">.</span><span class="n">angleBetween</span><span class="p">(</span><span class="n">cC</span><span class="p">,</span> <span class="n">cA</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="n">cC</span><span class="o">.</span><span class="n">angleBetween</span><span class="p">(</span><span class="n">cA</span><span class="p">,</span> <span class="n">cB</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">deg</span><span class="p">,</span> <span class="n">B</span><span class="o">.</span><span class="n">deg</span><span class="p">,</span> <span class="n">C</span><span class="o">.</span><span class="n">deg</span><span class="p">)</span>
<span class="go">90.0 45.43854858674231 45.43854858674231</span>
</pre></div>
</div>
</div></blockquote>
</div></blockquote>
<p><strong>Projections:</strong></p>
<blockquote>
<div><p>Local tangent plane projections of an area of the sky can be performed using the project
method:</p>
<blockquote>
<div><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">coord.CelestialCoord.project()</span></code></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">center</span> <span class="o">=</span> <span class="n">CelestialCoord</span><span class="p">(</span><span class="n">ra</span><span class="o">=</span><span class="mi">10</span><span class="o">*</span><span class="n">hours</span><span class="p">,</span> <span class="n">dec</span><span class="o">=</span><span class="mi">30</span><span class="o">*</span><span class="n">degrees</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sky_coord</span> <span class="o">=</span> <span class="n">CelestialCoord</span><span class="p">(</span><span class="n">ra</span><span class="o">=</span><span class="mf">10.5</span><span class="o">*</span><span class="n">hours</span><span class="p">,</span> <span class="n">dec</span><span class="o">=</span><span class="mi">31</span><span class="o">*</span><span class="n">degrees</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sky_coord</span><span class="p">)</span>
<span class="go">coord.CelestialCoord(2.748893571891069 radians, 0.5410520681182421 radians)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">center</span><span class="o">.</span><span class="n">project</span><span class="p">(</span><span class="n">sky_coord</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">deg</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">deg</span><span class="p">)</span>
<span class="go">-6.452371275343261 1.21794987288635</span>
</pre></div>
</div>
</div></blockquote>
<p>and back:</p>
<blockquote>
<div><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">coord.CelestialCoord.deproject()</span></code></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sky_coord</span> <span class="o">=</span> <span class="n">center</span><span class="o">.</span><span class="n">deproject</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sky_coord</span><span class="p">)</span>
<span class="go">coord.CelestialCoord(2.748893571891069 radians, 0.5410520681182421 radians)</span>
</pre></div>
</div>
</div></blockquote>
<p>where u and v are Angles and center and sky_coord are CelestialCoords.</p>
</div></blockquote>
<dl class="method">
<dt id="galsim.CelestialCoord.angleBetween">
<code class="sig-name descname">angleBetween</code><span class="sig-paren">(</span><em class="sig-param">coord2</em>, <em class="sig-param">coord3</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/coord/celestial.html#CelestialCoord.angleBetween"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.CelestialCoord.angleBetween" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the open angle at the location of the current coord between <code class="docutils literal notranslate"><span class="pre">coord2</span></code> and <code class="docutils literal notranslate"><span class="pre">coord3</span></code>.</p>
<p>The current coordinate along with the two other coordinates form a spherical triangle
on the sky.  This function calculates the angle between the two sides at the location of
the current coordinate.</p>
<p>Note that this returns a signed angle.  The angle is positive if the sweep direction from
<code class="docutils literal notranslate"><span class="pre">coord2</span></code> to <code class="docutils literal notranslate"><span class="pre">coord3</span></code> is counter-clockwise (as observed from Earth).  It is negative if
the direction is clockwise.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>coord2</strong> – A second CelestialCoord</p></li>
<li><p><strong>coord3</strong> – A third CelestialCoord</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the angle between the great circles joining the other two coordinates to the
current coordinate.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.CelestialCoord.area">
<code class="sig-name descname">area</code><span class="sig-paren">(</span><em class="sig-param">coord2</em>, <em class="sig-param">coord3</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/coord/celestial.html#CelestialCoord.area"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.CelestialCoord.area" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the area of a spherical triangle in steradians.</p>
<p>The current coordinate along with the two other coordinates form a spherical triangle
on the sky.  This function calculates the area of that spherical triangle, which is
measured in steradians (i.e. surface area of the triangle on the unit sphere).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>coord2</strong> – A second CelestialCoord</p></li>
<li><p><strong>coord3</strong> – A third CelestialCoord</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the area in steradians of the given spherical triangle.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.CelestialCoord.dec">
<em class="property">property </em><code class="sig-name descname">dec</code><a class="headerlink" href="#galsim.CelestialCoord.dec" title="Permalink to this definition">¶</a></dt>
<dd><p>A read-only attribute, giving the Declination as an Angle</p>
</dd></dl>

<dl class="method">
<dt id="galsim.CelestialCoord.deproject">
<code class="sig-name descname">deproject</code><span class="sig-paren">(</span><em class="sig-param">u</em>, <em class="sig-param">v</em>, <em class="sig-param">projection=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/coord/celestial.html#CelestialCoord.deproject"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.CelestialCoord.deproject" title="Permalink to this definition">¶</a></dt>
<dd><p>Do the reverse process from the project() function.</p>
<p>i.e. This takes in a position (u,v) and returns the corresponding celestial
coordinate, using the current coordinate as the center point of the tangent plane
projection.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>u</strong> – The u position on the tangent plane to deproject (must be an Angle
instance)</p></li>
<li><p><strong>v</strong> – The v position on the tangent plane to deproject (must be an Angle
instance)</p></li>
<li><p><strong>projection</strong> – The name of the projection to be used. [default: gnomonic, see <code class="docutils literal notranslate"><span class="pre">project</span></code>
docstring for other options]</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the corresponding CelestialCoord for that position.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.CelestialCoord.deproject_rad">
<code class="sig-name descname">deproject_rad</code><span class="sig-paren">(</span><em class="sig-param">u</em>, <em class="sig-param">v</em>, <em class="sig-param">projection=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/coord/celestial.html#CelestialCoord.deproject_rad"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.CelestialCoord.deproject_rad" title="Permalink to this definition">¶</a></dt>
<dd><p>This is basically identical to the deproject() function except that the output <code class="docutils literal notranslate"><span class="pre">ra</span></code>,
<code class="docutils literal notranslate"><span class="pre">dec</span></code> are returned as a tuple (ra, dec) in radians rather than packaged as a CelestialCoord
object and <code class="docutils literal notranslate"><span class="pre">u</span></code> and <code class="docutils literal notranslate"><span class="pre">v</span></code> are in radians rather than Angle instances.</p>
<p>The main advantage to this is that it will work if <code class="docutils literal notranslate"><span class="pre">u</span></code> and <code class="docutils literal notranslate"><span class="pre">v</span></code> are NumPy arrays, in which
case the output <code class="docutils literal notranslate"><span class="pre">ra</span></code>, <code class="docutils literal notranslate"><span class="pre">dec</span></code> will also be NumPy arrays.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>u</strong> – The u position in radians on the tangent plane to deproject</p></li>
<li><p><strong>v</strong> – The v position in radians on the tangent plane to deproject</p></li>
<li><p><strong>projection</strong> – The name of the projection to be used. [default: gnomonic, see <code class="docutils literal notranslate"><span class="pre">project</span></code>
docstring for other options]</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the corresponding RA, Dec in radians</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.CelestialCoord.distanceTo">
<code class="sig-name descname">distanceTo</code><span class="sig-paren">(</span><em class="sig-param">coord2</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/coord/celestial.html#CelestialCoord.distanceTo"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.CelestialCoord.distanceTo" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the great circle distance between this coord and another one.
The return value is an Angle object</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>coord2</strong> – The CelestialCoord to calculate the distance to.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the great circle distance to <code class="docutils literal notranslate"><span class="pre">coord2</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.CelestialCoord.ecliptic">
<code class="sig-name descname">ecliptic</code><span class="sig-paren">(</span><em class="sig-param">epoch=2000.0</em>, <em class="sig-param">date=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/coord/celestial.html#CelestialCoord.ecliptic"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.CelestialCoord.ecliptic" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the longitude and latitude in ecliptic coordinates corresponding to this position.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">epoch</span></code> parameter is used to get an accurate value for the (time-varying) obliquity of
the ecliptic.  The formulae for this are quite straightforward.  It requires just a single
parameter for the transformation, the obliquity of the ecliptic (the Earth’s axial tilt).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>epoch</strong> – The epoch to be used for estimating the obliquity of the ecliptic, if
<code class="docutils literal notranslate"><span class="pre">date</span></code> is None.  But if <code class="docutils literal notranslate"><span class="pre">date</span></code> is given, then use that to determine the
epoch.  [default: 2000.]</p></li>
<li><p><strong>date</strong> – If a date is given as a python datetime object, then return the
position in ecliptic coordinates with respect to the sun position at
that date.  If None, then return the true ecliptic coordiantes.
[default: None]</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the longitude and latitude as a tuple (lambda, beta), given as Angle instances.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.CelestialCoord.from_ecliptic">
<em class="property">static </em><code class="sig-name descname">from_ecliptic</code><span class="sig-paren">(</span><em class="sig-param">lam</em>, <em class="sig-param">beta</em>, <em class="sig-param">epoch=2000.0</em>, <em class="sig-param">date=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/coord/celestial.html#CelestialCoord.from_ecliptic"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.CelestialCoord.from_ecliptic" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a CelestialCoord from the given ecliptic coordinates</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>lam</strong> – The longitude in ecliptic coordinates (an Angle instance)</p></li>
<li><p><strong>beta</strong> – The latitude in ecliptic coordinates (an Angle instance)</p></li>
<li><p><strong>epoch</strong> – The epoch to be used for estimating the obliquity of the ecliptic, if
<code class="docutils literal notranslate"><span class="pre">date</span></code> is None.  But if <code class="docutils literal notranslate"><span class="pre">date</span></code> is given, then use that to determine the
epoch.  [default: 2000.]</p></li>
<li><p><strong>date</strong> – If a date is given as a python datetime object, then return the
position in ecliptic coordinates with respect to the sun position at
that date.  If None, then return the true ecliptic coordiantes.
[default: None]</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the CelestialCoord corresponding to these ecliptic coordinates.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.CelestialCoord.from_galactic">
<em class="property">static </em><code class="sig-name descname">from_galactic</code><span class="sig-paren">(</span><em class="sig-param">el</em>, <em class="sig-param">b</em>, <em class="sig-param">epoch=2000.0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/coord/celestial.html#CelestialCoord.from_galactic"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.CelestialCoord.from_galactic" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a CelestialCoord from the given galactic coordinates</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>el</strong> – The longitude in galactic coordinates (an Angle instance)</p></li>
<li><p><strong>b</strong> – The latitude in galactic coordinates (an Angle instance)</p></li>
<li><p><strong>epoch</strong> – The epoch of the returned coordinate. [default: 2000.]</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the CelestialCoord corresponding to these galactic coordinates.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.CelestialCoord.from_xyz">
<em class="property">static </em><code class="sig-name descname">from_xyz</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">y</em>, <em class="sig-param">z</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/coord/celestial.html#CelestialCoord.from_xyz"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.CelestialCoord.from_xyz" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct a CelestialCoord from a given (x,y,z) position in three dimensions.</p>
<p>The 3D (x,y,z) position does not need to fall on the unit sphere.  The RA, Dec will
be inferred from the relations:</p>
<div class="math notranslate nohighlight">
\[\begin{split}x &amp;= r \cos(dec) \cos(ra)  \\
y &amp;= r \cos(dec) \sin(ra)  \\
z &amp;= r \sin(dec)\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(r\)</span> is arbitrary.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> – The x position in 3 dimensions.  Corresponds to r cos(dec) cos(ra)</p></li>
<li><p><strong>y</strong> – The y position in 3 dimensions.  Corresponds to r cos(dec) sin(ra)</p></li>
<li><p><strong>z</strong> – The z position in 3 dimensions.  Corresponds to r sin(dec)</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a CelestialCoord instance</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.CelestialCoord.galactic">
<code class="sig-name descname">galactic</code><span class="sig-paren">(</span><em class="sig-param">epoch=2000.0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/coord/celestial.html#CelestialCoord.galactic"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.CelestialCoord.galactic" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the longitude and latitude in galactic coordinates corresponding to this position.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>epoch</strong> – The epoch of the current coordinate. [default: 2000.]</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the longitude and latitude as a tuple (el, b), given as Angle instances.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.CelestialCoord.get_xyz">
<code class="sig-name descname">get_xyz</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/coord/celestial.html#CelestialCoord.get_xyz"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.CelestialCoord.get_xyz" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the (x,y,z) coordinates on the unit sphere corresponding to this (RA, Dec).</p>
<div class="math notranslate nohighlight">
\[\begin{split}x &amp;= \cos(dec) \cos(ra)  \\
y &amp;= \cos(dec) \sin(ra)  \\
z &amp;= \sin(dec)\end{split}\]</div>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>a tuple (x,y,z)</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.CelestialCoord.greatCirclePoint">
<code class="sig-name descname">greatCirclePoint</code><span class="sig-paren">(</span><em class="sig-param">coord2</em>, <em class="sig-param">theta</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/coord/celestial.html#CelestialCoord.greatCirclePoint"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.CelestialCoord.greatCirclePoint" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a point on the great circle connecting self and coord2.</p>
<p>Two points, c1 and c2, on the unit sphere define a great circle (so long as the two points
are not either coincident or antipodal).  We can define points on this great circle by
their angle from c1, such that the angle for c2 has 0 &lt; theta2 &lt; pi.  I.e. theta increases
from 0 as the points move from c1 towards c2.</p>
<p>This function then returns the coordinate on this great circle (where c1 is <code class="docutils literal notranslate"><span class="pre">self</span></code> and
c2 is <code class="docutils literal notranslate"><span class="pre">coord2</span></code>) that corresponds to the given angle <code class="docutils literal notranslate"><span class="pre">theta</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>coord2</strong> – Another CelestialCoord defining the great circle to use.</p></li>
<li><p><strong>theta</strong> – The Angle along the great circle corresponding to the desired point.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the corresponding CelestialCoord</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.CelestialCoord.jac_deproject">
<code class="sig-name descname">jac_deproject</code><span class="sig-paren">(</span><em class="sig-param">u</em>, <em class="sig-param">v</em>, <em class="sig-param">projection=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/coord/celestial.html#CelestialCoord.jac_deproject"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.CelestialCoord.jac_deproject" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the jacobian of the deprojection.</p>
<p>i.e. if the input position is (u,v) then the return matrix is</p>
<div class="math notranslate nohighlight">
\[\begin{split}J \equiv \begin{bmatrix} J00 &amp; J01 \\ J10 &amp; J11 \end{bmatrix}
  = \begin{bmatrix}
    d\textrm{ra}/du \cos(\textrm{dec}) &amp; d\textrm{ra}/dv \cos(\textrm{dec})  \\
            d\textrm{dec}/du             &amp;      d\textrm{dec}/dv
     \end{bmatrix}\end{split}\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>u</strong> – The u position (as an Angle instance) on the tangent plane</p></li>
<li><p><strong>v</strong> – The v position (as an Angle instance) on the tangent plane</p></li>
<li><p><strong>projection</strong> – The name of the projection to be used. [default: gnomonic, see <code class="docutils literal notranslate"><span class="pre">project</span></code>
docstring for other options]</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the Jacobian as a 2x2 numpy array [[J00, J01], [J10, J11]]</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.CelestialCoord.jac_deproject_rad">
<code class="sig-name descname">jac_deproject_rad</code><span class="sig-paren">(</span><em class="sig-param">u</em>, <em class="sig-param">v</em>, <em class="sig-param">projection=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/coord/celestial.html#CelestialCoord.jac_deproject_rad"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.CelestialCoord.jac_deproject_rad" title="Permalink to this definition">¶</a></dt>
<dd><p>Equivalent to <code class="docutils literal notranslate"><span class="pre">jac_deproject</span></code>, but the inputs are in radians and may be numpy
arrays.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>u</strong> – The u position (in radians) on the tangent plane</p></li>
<li><p><strong>v</strong> – The v position (in radians) on the tangent plane</p></li>
<li><p><strong>projection</strong> – The name of the projection to be used. [default: gnomonic, see <a class="reference internal" href="#galsim.CelestialCoord.project" title="galsim.CelestialCoord.project"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">project</span></code></a>
docstring for other options]</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the Jacobian as a 2x2 numpy array [[J00, J01], [J10, J11]]</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.CelestialCoord.normal">
<code class="sig-name descname">normal</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/coord/celestial.html#CelestialCoord.normal"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.CelestialCoord.normal" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the coordinate in the “normal” convention of having 0 &lt;= ra &lt; 24 hours.</p>
<p>This convention is not enforced on construction, so this function exists to make it
easy to convert if desired.</p>
<p>Functions such as <a class="reference internal" href="#galsim.CelestialCoord.from_galactic" title="galsim.CelestialCoord.from_galactic"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">from_galactic</span></code></a> and <a class="reference internal" href="#galsim.CelestialCoord.from_xyz" title="galsim.CelestialCoord.from_xyz"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">from_xyz</span></code></a> will return normal coordinates.</p>
</dd></dl>

<dl class="method">
<dt id="galsim.CelestialCoord.precess">
<code class="sig-name descname">precess</code><span class="sig-paren">(</span><em class="sig-param">from_epoch</em>, <em class="sig-param">to_epoch</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/coord/celestial.html#CelestialCoord.precess"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.CelestialCoord.precess" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>This function precesses equatorial ra and dec from one epoch to another.</dt><dd><p>It is adapted from a set of fortran subroutines based on (a) pages 30-34 of
the Explanatory Supplement to the AE, (b) Lieske, et al. (1977) A&amp;A 58, 1-16,
and (c) Lieske (1979) A&amp;A 73, 282-284.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>from_epoch</strong> – The epoch of the current coordinate</p></li>
<li><p><strong>to_epoch</strong> – The epoch of the returned precessed coordinate</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a CelestialCoord object corresponding to the precessed position.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.CelestialCoord.project">
<code class="sig-name descname">project</code><span class="sig-paren">(</span><em class="sig-param">coord2</em>, <em class="sig-param">projection=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/coord/celestial.html#CelestialCoord.project"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.CelestialCoord.project" title="Permalink to this definition">¶</a></dt>
<dd><p>Use the currect coord as the center point of a tangent plane projection to project
the <code class="docutils literal notranslate"><span class="pre">coord2</span></code> coordinate onto that plane.</p>
<p>This function return a tuple (u,v) in the Euclidean coordinate system defined by
a tangent plane projection around the current coordinate, with +v pointing north and
+u pointing west. (i.e. to the right on the sky if +v is up.)</p>
<p>There are currently four options for the projection, which you can specify with the
optional <code class="docutils literal notranslate"><span class="pre">projection</span></code> keyword argument:</p>
<blockquote>
<div><dl class="field-list simple">
<dt class="field-odd">gnomonic</dt>
<dd class="field-odd"><p>[default] uses a gnomonic projection (i.e. a projection from the center of
the sphere, which has the property that all great circles become straight
lines.  For more information, see
<a class="reference external" href="http://mathworld.wolfram.com/GnomonicProjection.html">http://mathworld.wolfram.com/GnomonicProjection.html</a>
This is the usual TAN projection used by most FITS images.</p>
</dd>
<dt class="field-even">stereographic</dt>
<dd class="field-even"><p>uses a stereographic proejection, which preserves angles, but
not area.  For more information, see
<a class="reference external" href="http://mathworld.wolfram.com/StereographicProjection.html">http://mathworld.wolfram.com/StereographicProjection.html</a></p>
</dd>
<dt class="field-odd">lambert</dt>
<dd class="field-odd"><p>uses a Lambert azimuthal projection, which preserves area, but not angles.
For more information, see
<a class="reference external" href="http://mathworld.wolfram.com/LambertAzimuthalEqual-AreaProjection.html">http://mathworld.wolfram.com/LambertAzimuthalEqual-AreaProjection.html</a></p>
</dd>
<dt class="field-even">postel</dt>
<dd class="field-even"><p>uses a Postel equidistant proejection, which preserves distances from
the projection point, but not area or angles.  For more information, see
<a class="reference external" href="http://mathworld.wolfram.com/AzimuthalEquidistantProjection.html">http://mathworld.wolfram.com/AzimuthalEquidistantProjection.html</a></p>
</dd>
</dl>
</div></blockquote>
<p>The distance or angle errors increase with distance from the projection point of course.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>coord2</strong> – The coordinate to project onto the tangent plane.</p></li>
<li><p><strong>projection</strong> – The name of the projection to be used. [default: gnomonic, see above
for other options]</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>(u,v) as Angle instances</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.CelestialCoord.project_rad">
<code class="sig-name descname">project_rad</code><span class="sig-paren">(</span><em class="sig-param">ra</em>, <em class="sig-param">dec</em>, <em class="sig-param">projection=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/coord/celestial.html#CelestialCoord.project_rad"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.CelestialCoord.project_rad" title="Permalink to this definition">¶</a></dt>
<dd><p>This is basically identical to the project() function except that the input <code class="docutils literal notranslate"><span class="pre">ra</span></code>, <code class="docutils literal notranslate"><span class="pre">dec</span></code>
are given in radians rather than packaged as a CelestialCoord object and the returned
u,v are given in radians.</p>
<p>The main advantage to this is that it will work if <code class="docutils literal notranslate"><span class="pre">ra</span></code> and <code class="docutils literal notranslate"><span class="pre">dec</span></code> are NumPy arrays, in which
case the output <code class="docutils literal notranslate"><span class="pre">u</span></code>, <code class="docutils literal notranslate"><span class="pre">v</span></code> will also be NumPy arrays.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ra</strong> – The right ascension in radians to project onto the tangent plane.</p></li>
<li><p><strong>dec</strong> – The declination in radians to project onto the tangent plane.</p></li>
<li><p><strong>projection</strong> – The name of the projection to be used. [default: gnomonic, see <code class="docutils literal notranslate"><span class="pre">project</span></code>
docstring for other options]</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>(u,v) in radians</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.CelestialCoord.ra">
<em class="property">property </em><code class="sig-name descname">ra</code><a class="headerlink" href="#galsim.CelestialCoord.ra" title="Permalink to this definition">¶</a></dt>
<dd><p>A read-only attribute, giving the Right Ascension as an Angle</p>
</dd></dl>

<dl class="method">
<dt id="galsim.CelestialCoord.rad">
<em class="property">property </em><code class="sig-name descname">rad</code><a class="headerlink" href="#galsim.CelestialCoord.rad" title="Permalink to this definition">¶</a></dt>
<dd><p>A convenience property, giving a tuple (ra.rad, dec.rad)</p>
</dd></dl>

<dl class="method">
<dt id="galsim.CelestialCoord.radec_to_xyz">
<em class="property">static </em><code class="sig-name descname">radec_to_xyz</code><span class="sig-paren">(</span><em class="sig-param">ra</em>, <em class="sig-param">dec</em>, <em class="sig-param">r=1.0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/coord/celestial.html#CelestialCoord.radec_to_xyz"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.CelestialCoord.radec_to_xyz" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert ra, dec (in radians) to 3D x,y,z coordinates on the unit sphere.</p>
<p>The connection between (ra,dec) and (x,y,z) are given by the following formulae:
.. math:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">&amp;=</span> <span class="n">r</span> \<span class="n">cos</span><span class="p">(</span><span class="n">dec</span><span class="p">)</span> \<span class="n">cos</span><span class="p">(</span><span class="n">ra</span><span class="p">)</span>  \\
<span class="n">y</span> <span class="o">&amp;=</span> <span class="n">r</span> \<span class="n">cos</span><span class="p">(</span><span class="n">dec</span><span class="p">)</span> \<span class="n">sin</span><span class="p">(</span><span class="n">ra</span><span class="p">)</span>  \\
<span class="n">z</span> <span class="o">&amp;=</span> <span class="n">r</span> \<span class="n">sin</span><span class="p">(</span><span class="n">dec</span><span class="p">)</span>
</pre></div>
</div>
<p>For a single ra,dec pair, the following are essentially equivalent:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ra</span> <span class="o">=</span> <span class="mi">12</span><span class="o">*</span><span class="n">hours</span><span class="o">/</span><span class="n">radians</span>       <span class="c1"># May be any angle measured</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dec</span> <span class="o">=</span> <span class="mi">31</span><span class="o">*</span><span class="n">degrees</span><span class="o">/</span><span class="n">radians</span>    <span class="c1"># in radians</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">CelestialCoord</span><span class="o">.</span><span class="n">radec_to_xyz</span><span class="p">(</span><span class="n">ra</span><span class="p">,</span> <span class="n">dec</span><span class="p">)</span>
<span class="go">(-0.8571673007021123, 1.0497271911386187e-16, 0.5150380749100542)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">CelestialCoord</span><span class="p">(</span><span class="n">ra</span> <span class="o">*</span> <span class="n">radians</span><span class="p">,</span> <span class="n">dec</span> <span class="o">*</span> <span class="n">radians</span><span class="p">)</span><span class="o">.</span><span class="n">get_xyz</span><span class="p">()</span>
<span class="go">(-0.8571673007021123, 1.0497271911386187e-16, 0.5150380749100542)</span>
</pre></div>
</div>
<p>However, the advantage of this function is that the input values may be numpy
arrays, in which case, the return values will also be numpy arrays.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ra</strong> – The right ascension(s) in radians. May be a numpy array.</p></li>
<li><p><strong>dec</strong> – The declination(s) in radians. May be a numpy array.</p></li>
<li><p><strong>r</strong> – The distance(s) from Earth (default 1.). May be a numpy array.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>x, y, z as a tuple.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.CelestialCoord.xyz_to_radec">
<em class="property">static </em><code class="sig-name descname">xyz_to_radec</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">y</em>, <em class="sig-param">z</em>, <em class="sig-param">return_r=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/coord/celestial.html#CelestialCoord.xyz_to_radec"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.CelestialCoord.xyz_to_radec" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert 3D x,y,z coordinates to ra, dec (in radians).</p>
<p>The connection between (ra,dec) and (x,y,z) are given by the following formulae:
.. math:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">&amp;=</span> <span class="n">r</span> \<span class="n">cos</span><span class="p">(</span><span class="n">dec</span><span class="p">)</span> \<span class="n">cos</span><span class="p">(</span><span class="n">ra</span><span class="p">)</span>  \\
<span class="n">y</span> <span class="o">&amp;=</span> <span class="n">r</span> \<span class="n">cos</span><span class="p">(</span><span class="n">dec</span><span class="p">)</span> \<span class="n">sin</span><span class="p">(</span><span class="n">ra</span><span class="p">)</span>  \\
<span class="n">z</span> <span class="o">&amp;=</span> <span class="n">r</span> \<span class="n">sin</span><span class="p">(</span><span class="n">dec</span><span class="p">)</span>
</pre></div>
</div>
<p>For a single (x,y,z) position, the following are essentially equivalent:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="mf">0.839</span>       <span class="c1"># May be any any 3D location</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="mf">0.123</span>       <span class="c1"># Not necessarily on unit sphere</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span> <span class="o">=</span> <span class="mf">0.530</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">CelestialCoord</span><span class="o">.</span><span class="n">xyz_to_radec</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
<span class="go">(0.14556615088111796, 0.558616191048523)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">CelestialCoord</span><span class="o">.</span><span class="n">from_xyz</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">ra</span><span class="o">.</span><span class="n">rad</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">dec</span><span class="o">.</span><span class="n">rad</span>
<span class="go">(0.145566150881118, 0.558616191048523)</span>
</pre></div>
</div>
<p>However, the advantage of this function is that the input values may be numpy
arrays, in which case, the return values will also be numpy arrays.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> – The x position(s) in 3 dimensions. May be a numpy array.</p></li>
<li><p><strong>y</strong> – The y position(s) in 3 dimensions. May be a numpy array.</p></li>
<li><p><strong>z</strong> – The z position(s) in 3 dimensions. May be a numpy array.</p></li>
<li><p><strong>return_r</strong> – Whether to return r as well as ra, dec. (default: False)</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>ra, dec as a tuple.  Or if return_r is True, (ra, dec, r).</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="wcs-utilities">
<h2>WCS Utilities<a class="headerlink" href="#wcs-utilities" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="galsim.wcs.readFromFitsHeader">
<code class="sig-prename descclassname">galsim.wcs.</code><code class="sig-name descname">readFromFitsHeader</code><span class="sig-paren">(</span><em class="sig-param">header</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/wcs.html#readFromFitsHeader"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.wcs.readFromFitsHeader" title="Permalink to this definition">¶</a></dt>
<dd><p>Read a WCS function from a FITS header.</p>
<p>This is normally called automatically from within the <a class="reference internal" href="fits.html#galsim.fits.read" title="galsim.fits.read"><code class="xref any py py-func docutils literal notranslate"><span class="pre">galsim.fits.read</span></code></a> function, but
you can also call it directly as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">wcs</span><span class="p">,</span> <span class="n">origin</span> <span class="o">=</span> <span class="n">galsim</span><span class="o">.</span><span class="n">wcs</span><span class="o">.</span><span class="n">readFromFitsHeader</span><span class="p">(</span><span class="n">header</span><span class="p">)</span>
</pre></div>
</div>
<p>If the file was originally written by GalSim using one of the galsim.fits.write() functions,
then this should always succeed in reading back in the original WCS.  It may not end up
as exactly the same class as the original, but the underlying world coordinate system
transformation should be preserved.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For <a class="reference internal" href="#galsim.UVFunction" title="galsim.UVFunction"><code class="xref any py py-class docutils literal notranslate"><span class="pre">UVFunction</span></code></a> and <a class="reference internal" href="#galsim.RaDecFunction" title="galsim.RaDecFunction"><code class="xref any py py-class docutils literal notranslate"><span class="pre">RaDecFunction</span></code></a>, if the functions that were written to the FITS
header were real python functions (rather than a string that is converted to a function),
then the mechanism we use to write to the header and read it back in has some limitations:</p>
<ol class="arabic simple">
<li><p>It apparently only works for cpython implementations.</p></li>
<li><p>It probably won’t work to write from one version of python and read from another.
(At least for major version differences.)</p></li>
<li><p>If the function uses globals, you’ll need to make sure the globals are present
when you read it back in as well, or it probably won’t work.</p></li>
<li><p>It looks really ugly in the header.</p></li>
<li><p>We haven’t thought much about the security implications of this, so beware using
GalSim to open FITS files from untrusted sources.</p></li>
</ol>
</div>
<p>If the file was not written by GalSim, then this code will do its best to read the
WCS information in the FITS header.  Depending on what kind of WCS is encoded in the
header, this may or may not be successful.</p>
<p>If there is no WCS information in the header, then this will default to a pixel scale
of 1.</p>
<p>In addition to the wcs, this function will also return the image origin that the WCS
is assuming for the image.  If the file was originally written by GalSim, this should
correspond to the original image origin.  If not, it will default to (1,1).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>header</strong> – The fits header to write the data to.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a tuple (wcs, origin) of the wcs from the header and the image origin.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="galsim.wcs.compatible">
<code class="sig-prename descclassname">galsim.wcs.</code><code class="sig-name descname">compatible</code><span class="sig-paren">(</span><em class="sig-param">wcs1</em>, <em class="sig-param">wcs2</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/wcs.html#compatible"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.wcs.compatible" title="Permalink to this definition">¶</a></dt>
<dd><p>A utility to check the compatibility of two WCS.  In particular, if two WCS are consistent with
each other modulo a shifted origin, we consider them to be compatible, even though they are not
equal.</p>
</dd></dl>

</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="random.html" class="btn btn-neutral float-right" title="Noise and Random Values" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="units.html" class="btn btn-neutral float-left" title="Units" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, GalSim-developers

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>