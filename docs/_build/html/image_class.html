

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>The Image class &mdash; GalSim 2.2.1 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script type="text/javascript" src="_static/jquery.js"></script>
        <script type="text/javascript" src="_static/underscore.js"></script>
        <script type="text/javascript" src="_static/doctools.js"></script>
        <script type="text/javascript" src="_static/language_data.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Bounding boxes" href="bounds.html" />
    <link rel="prev" title="Images and Related Concepts" href="image.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> GalSim
          

          
          </a>

          
            
            
              <div class="version">
                2.2
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="overview.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="install.html">Installation Instructions</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorials.html">Tutorials</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="image.html">Images and Related Concepts</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#">The Image class</a></li>
<li class="toctree-l2"><a class="reference internal" href="bounds.html">Bounding boxes</a></li>
<li class="toctree-l2"><a class="reference internal" href="pos.html">Positions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="sb.html">Surface Brightness Profiles</a></li>
<li class="toctree-l1"><a class="reference internal" href="chromatic.html">Wavelength-dependent Profiles</a></li>
<li class="toctree-l1"><a class="reference internal" href="units.html">Units</a></li>
<li class="toctree-l1"><a class="reference internal" href="wcs.html">World Coordinate Systems</a></li>
<li class="toctree-l1"><a class="reference internal" href="random.html">Noise and Random Values</a></li>
<li class="toctree-l1"><a class="reference internal" href="wl.html">Weak Lensing</a></li>
<li class="toctree-l1"><a class="reference internal" href="photon.html">Photon Shooting</a></li>
<li class="toctree-l1"><a class="reference internal" href="utilities.html">Helper Functions and Classes</a></li>
<li class="toctree-l1"><a class="reference internal" href="errors.html">Errors and Warnings</a></li>
<li class="toctree-l1"><a class="reference internal" href="config.html">The Config Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="hsm.html">The HSM Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="des.html">The DES Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="wfirst.html">The WFIRST Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="shared.html">Shared Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="history.html">Revision History</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">GalSim</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
          <li><a href="image.html">Images and Related Concepts</a> &raquo;</li>
        
      <li>The Image class</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/image_class.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="the-image-class">
<h1>The Image class<a class="headerlink" href="#the-image-class" title="Permalink to this headline">¶</a></h1>
<dl class="class">
<dt id="galsim.Image">
<em class="property">class </em><code class="sig-prename descclassname">galsim.</code><code class="sig-name descname">Image</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/image.html#Image"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.Image" title="Permalink to this definition">¶</a></dt>
<dd><p>A class for storing image data along with the pixel scale or WCS information</p>
<p>The Image class encapsulates all the relevant information about an image including a NumPy array
for the pixel values, a bounding box, and some kind of WCS that converts between pixel
coordinates and world coordinates.  The NumPy array may be constructed by the Image class
itself, or an existing array can be provided by the user.</p>
<p>This class creates shallow copies unless a deep copy is explicitly requested using the <a class="reference internal" href="#galsim.Image.copy" title="galsim.Image.copy"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">copy</span></code></a>
method.  The main reason for this is that it allows users to work directly with and modify
subimages of larger images (for example, to successively draw many galaxies into one large
image).  For other implications of this convention, see the description of initialization
instructions below.</p>
<p>In most applications with images, we will use (x,y) to refer to the coordinates.  We adopt
the same meaning for these coordinates as most astronomy applications do: ds9, SAOImage,
SExtractor, etc. all treat x as the column number and y as the row number.  However, this
is different from the default convention used by numpy.  In numpy, the access is by
[row_num,col_num], which means this is really [y,x] in terms of the normal x,y values.
Users are typically insulated from this concern by the Image API, but if you access the
numpy array directly via the <code class="docutils literal notranslate"><span class="pre">array</span></code> attribute, you will need to be careful about this
difference.</p>
<p>There are 6 data types that the Image can use for the data values.  These are <code class="docutils literal notranslate"><span class="pre">numpy.uint16</span></code>,
<code class="docutils literal notranslate"><span class="pre">numpy.uint32</span></code>, <code class="docutils literal notranslate"><span class="pre">numpy.int16</span></code>, <code class="docutils literal notranslate"><span class="pre">numpy.int32</span></code>, <code class="docutils literal notranslate"><span class="pre">numpy.float32</span></code>, and <code class="docutils literal notranslate"><span class="pre">numpy.float64</span></code>.
If you are constructing a new Image from scratch, the default is <code class="docutils literal notranslate"><span class="pre">numpy.float32</span></code>, but you
can specify one of the other data types.</p>
<p>There are several ways to construct an Image:
(Optional arguments are shown with their default values after the = sign.)</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">Image(ncol,</span> <span class="pre">nrow,</span> <span class="pre">dtype=numpy.float32,</span> <span class="pre">init_value=0,</span> <span class="pre">xmin=1,</span> <span class="pre">ymin=1,</span> <span class="pre">...)</span></code></p>
<blockquote>
<div><p>This constructs a new image, allocating memory for the pixel values according to
the number of columns and rows.  You can specify the data type as <code class="docutils literal notranslate"><span class="pre">dtype</span></code> if you
want.  The default is <code class="docutils literal notranslate"><span class="pre">numpy.float32</span></code> if you don’t specify it.  You can also
optionally provide an initial value for the pixels, which defaults to 0.
The optional <code class="docutils literal notranslate"><span class="pre">xmin,ymin</span></code> allow you to specify the location of the lower-left
pixel, which defaults to (1,1).  Reminder, with our convention for x,y coordinates
described above, ncol is the number of pixels in the x direction, and nrow is the
number of pixels in the y direction.</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">Image(bounds,</span> <span class="pre">dtype=numpy.float32,</span> <span class="pre">init_value=0,</span> <span class="pre">...)</span></code></p>
<blockquote>
<div><p>This constructs a new image, allocating memory for the pixel values according to a
given <a class="reference internal" href="bounds.html#galsim.Bounds" title="galsim.Bounds"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Bounds</span></code></a> object.  Particularly, the bounds should be a <a class="reference internal" href="bounds.html#galsim.BoundsI" title="galsim.BoundsI"><code class="xref any py py-class docutils literal notranslate"><span class="pre">BoundsI</span></code></a> instance.
You can specify the data type as <code class="docutils literal notranslate"><span class="pre">dtype</span></code> if you want.  The default is
<code class="docutils literal notranslate"><span class="pre">numpy.float32</span></code> if you don’t specify it.  You can also optionally provide an
initial value for the pixels, which defaults to 0.</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">Image(array,</span> <span class="pre">xmin=1,</span> <span class="pre">ymin=1,</span> <span class="pre">make_const=False,</span> <span class="pre">copy=False</span> <span class="pre">...)</span></code></p>
<blockquote>
<div><p>This views an existing NumPy array as an Image, where updates to either the image
or the original array will affect the other one.  The data type is taken from
<code class="docutils literal notranslate"><span class="pre">array.dtype</span></code>, which must be one of the allowed types listed above.  You can also
optionally set the origin <code class="docutils literal notranslate"><span class="pre">xmin,</span> <span class="pre">ymin</span></code> if you want it to be something other than
(1,1).</p>
<p>You can also optionally force the Image to be read-only with <code class="docutils literal notranslate"><span class="pre">make_const=True</span></code>,
though if the original NumPy array is modified then the contents of <code class="docutils literal notranslate"><span class="pre">Image.array</span></code>
will change.</p>
<p>If you want to make a copy of the input array, rather than just view the existing
array, you can force a copy with:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">galsim</span><span class="o">.</span><span class="n">Image</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">Image(image,</span> <span class="pre">dtype=image.dtype,</span> <span class="pre">copy=True)</span></code></p>
<blockquote>
<div><p>This creates a copy of an Image, possibly changing the type.  e.g.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">image_float</span> <span class="o">=</span> <span class="n">galsim</span><span class="o">.</span><span class="n">Image</span><span class="p">(</span><span class="mi">64</span><span class="p">,</span> <span class="mi">64</span><span class="p">)</span> <span class="c1"># default dtype=numpy.float32</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image_double</span> <span class="o">=</span> <span class="n">galsim</span><span class="o">.</span><span class="n">Image</span><span class="p">(</span><span class="n">image_float</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
</pre></div>
</div>
<p>You can see a list of valid values for dtype in <code class="docutils literal notranslate"><span class="pre">galsim.Image.valid_dtypes</span></code>.
Without the <code class="docutils literal notranslate"><span class="pre">dtype</span></code> argument, this is equivalent to <code class="docutils literal notranslate"><span class="pre">image.copy()</span></code>, which makes
a deep copy.  If you want a copy that shares data with the original, see
the <a class="reference internal" href="#galsim.Image.view" title="galsim.Image.view"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">view</span></code></a> method.</p>
<p>If you only want to enforce the image to have a given type and not make a copy
if the array is already the correct type, you can use, e.g.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">image_double</span> <span class="o">=</span> <span class="n">galsim</span><span class="o">.</span><span class="n">Image</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
</div></blockquote>
</div></blockquote>
<p>You can specify the <code class="docutils literal notranslate"><span class="pre">ncol</span></code>, <code class="docutils literal notranslate"><span class="pre">nrow</span></code>, <code class="docutils literal notranslate"><span class="pre">bounds</span></code>, <code class="docutils literal notranslate"><span class="pre">array</span></code>, or <code class="docutils literal notranslate"><span class="pre">image</span></code>  parameters by
keyword argument if you want, or you can pass them as simple arg as shown aboves, and the
constructor will figure out what they are.</p>
<p>The other keyword arguments (shown as … above) relate to the conversion between sky
coordinates, which is how all the GalSim objects are defined, and the pixel coordinates.
There are three options for this:</p>
<blockquote>
<div><dl class="simple">
<dt>scale</dt><dd><p>You can optionally specify a pixel scale to use.  This would normally have
units arcsec/pixel, but it doesn’t have to be arcsec.  If you want to
use different units for the physical scale of your galsim objects, then
the same unit would be used here.</p>
</dd>
<dt>wcs</dt><dd><p>A WCS object that provides a non-trivial mapping between sky units and
pixel units.  The <code class="docutils literal notranslate"><span class="pre">scale</span></code> parameter is equivalent to
<code class="docutils literal notranslate"><span class="pre">wcs=PixelScale(scale)</span></code>.  But there are a number of more complicated options.
See the WCS class for more details.</p>
</dd>
<dt>None</dt><dd><p>If you do not provide either of the above, then the conversion is undefined.
When drawing onto such an image, a suitable pixel scale will be automatically
set according to the Nyquist scale of the object being drawn.</p>
</dd>
</dl>
</div></blockquote>
<p>After construction, you can set or change the scale or wcs with:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">image</span><span class="o">.</span><span class="n">scale</span> <span class="o">=</span> <span class="n">new_scale</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span><span class="o">.</span><span class="n">wcs</span> <span class="o">=</span> <span class="n">new_wcs</span>
</pre></div>
</div>
<p>Note that <code class="docutils literal notranslate"><span class="pre">image.scale</span></code> will only work if the WCS is a <a class="reference internal" href="wcs.html#galsim.PixelScale" title="galsim.PixelScale"><code class="xref any py py-class docutils literal notranslate"><span class="pre">PixelScale</span></code></a>.  Once you set the
wcs to be something non-trivial, then you must interact with it via the <code class="docutils literal notranslate"><span class="pre">wcs</span></code> attribute.
The <code class="docutils literal notranslate"><span class="pre">image.scale</span></code> syntax will raise an exception.</p>
<p>There are also two read-only attributes:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">image</span><span class="o">.</span><span class="n">bounds</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span><span class="o">.</span><span class="n">array</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">array</span></code> attribute is a NumPy array of the Image’s pixels.  The individual elements in the
array attribute are accessed as <code class="docutils literal notranslate"><span class="pre">image.array[y,x]</span></code>, matching the standard NumPy convention,
while the Image class’s own accessor uses either <code class="docutils literal notranslate"><span class="pre">(x,y)</span></code> or <code class="docutils literal notranslate"><span class="pre">[x,y]</span></code>.</p>
<p>That is, the following are equivalent:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ixy</span> <span class="o">=</span> <span class="n">image</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ixy</span> <span class="o">=</span> <span class="n">image</span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ixy</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">array</span><span class="p">[</span><span class="n">y</span><span class="p">,</span><span class="n">x</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ixy</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">getValue</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>
</pre></div>
</div>
<p>Similarly, for setting individual pixel values, the following are equivalent:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">image</span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_ixy</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span><span class="o">.</span><span class="n">array</span><span class="p">[</span><span class="n">y</span><span class="p">,</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_ixy</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span><span class="o">.</span><span class="n">setValue</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">new_ixy</span><span class="p">)</span>
</pre></div>
</div>
<dl class="method">
<dt id="galsim.Image.__getitem__">
<code class="sig-name descname">__getitem__</code><span class="sig-paren">(</span><em class="sig-param">*args</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/image.html#Image.__getitem__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.Image.__getitem__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return either a subimage or a single pixel value.</p>
<p>For example,:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">subimage</span> <span class="o">=</span> <span class="n">im</span><span class="p">[</span><span class="n">galsim</span><span class="o">.</span><span class="n">BoundsI</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">7</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">value</span> <span class="o">=</span> <span class="n">im</span><span class="p">[</span><span class="n">galsim</span><span class="o">.</span><span class="n">PositionI</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">value</span> <span class="o">=</span> <span class="n">im</span><span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="galsim.Image.__setitem__">
<code class="sig-name descname">__setitem__</code><span class="sig-paren">(</span><em class="sig-param">*args</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/image.html#Image.__setitem__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.Image.__setitem__" title="Permalink to this definition">¶</a></dt>
<dd><p>Set either a subimage or a single pixel to new values.</p>
<p>For example,:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">im</span><span class="p">[</span><span class="n">galsim</span><span class="o">.</span><span class="n">BoundsI</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">7</span><span class="p">)]</span> <span class="o">=</span> <span class="n">im2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">im</span><span class="p">[</span><span class="n">galsim</span><span class="o">.</span><span class="n">PositionI</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">)]</span> <span class="o">=</span> <span class="mf">17.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">im</span><span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="mf">17.</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="galsim.Image._wrap">
<code class="sig-name descname">_wrap</code><span class="sig-paren">(</span><em class="sig-param">bounds</em>, <em class="sig-param">hermx</em>, <em class="sig-param">hermy</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/image.html#Image._wrap"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.Image._wrap" title="Permalink to this definition">¶</a></dt>
<dd><p>A version of <a class="reference internal" href="#galsim.Image.wrap" title="galsim.Image.wrap"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">wrap</span></code></a> without the sanity checks.</p>
<p>Equivalent to <code class="docutils literal notranslate"><span class="pre">image.wrap(bounds,</span> <span class="pre">hermitian=='x',</span> <span class="pre">hermitian=='y')</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="galsim.Image._view">
<code class="sig-name descname">_view</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/image.html#Image._view"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.Image._view" title="Permalink to this definition">¶</a></dt>
<dd><p>Equivalent to <a class="reference internal" href="#galsim.Image.view" title="galsim.Image.view"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">view</span></code></a>, but without some of the sanity checks and extra options.</p>
</dd></dl>

<dl class="method">
<dt id="galsim.Image._shift">
<code class="sig-name descname">_shift</code><span class="sig-paren">(</span><em class="sig-param">delta</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/image.html#Image._shift"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.Image._shift" title="Permalink to this definition">¶</a></dt>
<dd><p>Equivalent to <a class="reference internal" href="#galsim.Image.shift" title="galsim.Image.shift"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">shift</span></code></a>, but without some of the sanity checks and <code class="docutils literal notranslate"><span class="pre">delta</span></code> must
be a <a class="reference internal" href="pos.html#galsim.PositionI" title="galsim.PositionI"><code class="xref any py py-class docutils literal notranslate"><span class="pre">PositionI</span></code></a> instance.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>delta</strong> – The amount to shift as a <a class="reference internal" href="pos.html#galsim.PositionI" title="galsim.PositionI"><code class="xref any py py-class docutils literal notranslate"><span class="pre">PositionI</span></code></a>.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.Image.__call__">
<code class="sig-name descname">__call__</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/image.html#Image.__call__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.Image.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the pixel value at given position</p>
<p>The arguments here may be either (x, y) or a PositionI instance.
Or you can provide x, y as named kwargs.</p>
</dd></dl>

<dl class="method">
<dt id="galsim.Image._getValue">
<code class="sig-name descname">_getValue</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">y</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/image.html#Image._getValue"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.Image._getValue" title="Permalink to this definition">¶</a></dt>
<dd><p>Equivalent to <a class="reference internal" href="#galsim.Image.getValue" title="galsim.Image.getValue"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">getValue</span></code></a>, except there are no checks that the values fall
within the bounds of the image.</p>
</dd></dl>

<dl class="method">
<dt id="galsim.Image._setValue">
<code class="sig-name descname">_setValue</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">y</em>, <em class="sig-param">value</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/image.html#Image._setValue"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.Image._setValue" title="Permalink to this definition">¶</a></dt>
<dd><p>Equivalent to <a class="reference internal" href="#galsim.Image.setValue" title="galsim.Image.setValue"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">setValue</span></code></a> except that there are no checks that the values
fall within the bounds of the image, and the coordinates must be given as <code class="docutils literal notranslate"><span class="pre">x</span></code>, <code class="docutils literal notranslate"><span class="pre">y</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> – The x coordinate of the pixel to set.</p></li>
<li><p><strong>y</strong> – The y coordinate of the pixel to set.</p></li>
<li><p><strong>value</strong> – The value to set the pixel to.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.Image._addValue">
<code class="sig-name descname">_addValue</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">y</em>, <em class="sig-param">value</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/image.html#Image._addValue"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.Image._addValue" title="Permalink to this definition">¶</a></dt>
<dd><p>Equivalent to <a class="reference internal" href="#galsim.Image.addValue" title="galsim.Image.addValue"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">addValue</span></code></a> except that there are no checks that the values
fall within the bounds of the image, and the coordinates must be given as <code class="docutils literal notranslate"><span class="pre">x</span></code>, <code class="docutils literal notranslate"><span class="pre">y</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> – The x coordinate of the pixel to add to.</p></li>
<li><p><strong>y</strong> – The y coordinate of the pixel to add to.</p></li>
<li><p><strong>value</strong> – The value to add to this pixel.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.Image._fill">
<code class="sig-name descname">_fill</code><span class="sig-paren">(</span><em class="sig-param">value</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/image.html#Image._fill"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.Image._fill" title="Permalink to this definition">¶</a></dt>
<dd><p>Equivalent to <a class="reference internal" href="#galsim.Image.fill" title="galsim.Image.fill"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">fill</span></code></a>, except that there are no checks that the bounds are defined.</p>
</dd></dl>

<dl class="method">
<dt id="galsim.Image._invertSelf">
<code class="sig-name descname">_invertSelf</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/image.html#Image._invertSelf"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.Image._invertSelf" title="Permalink to this definition">¶</a></dt>
<dd><p>Equivalent to <a class="reference internal" href="#galsim.Image.invertSelf" title="galsim.Image.invertSelf"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">invertSelf</span></code></a>, except that there are no checks that the bounds are defined.</p>
</dd></dl>

<dl class="method">
<dt id="galsim.Image.FindAdaptiveMom">
<code class="sig-name descname">FindAdaptiveMom</code><span class="sig-paren">(</span><em class="sig-param">weight=None</em>, <em class="sig-param">badpix=None</em>, <em class="sig-param">guess_sig=5.0</em>, <em class="sig-param">precision=1e-06</em>, <em class="sig-param">guess_centroid=None</em>, <em class="sig-param">strict=True</em>, <em class="sig-param">round_moments=False</em>, <em class="sig-param">hsmparams=None</em><span class="sig-paren">)</span><a class="headerlink" href="#galsim.Image.FindAdaptiveMom" title="Permalink to this definition">¶</a></dt>
<dd><p>Measure adaptive moments of an object.</p>
<p>This method estimates the best-fit elliptical Gaussian to the object (see Hirata &amp; Seljak 2003
for more discussion of adaptive moments).  This elliptical Gaussian is computed iteratively
by initially guessing a circular Gaussian that is used as a weight function, computing the
weighted moments, recomputing the moments using the result of the previous step as the weight
function, and so on until the moments that are measured are the same as those used for the
weight function.  <a class="reference internal" href="#galsim.Image.FindAdaptiveMom" title="galsim.Image.FindAdaptiveMom"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">FindAdaptiveMom</span></code></a> can be used either as a free function, or as a method of the
<a class="reference internal" href="#galsim.Image" title="galsim.Image"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Image</span></code></a> class.</p>
<p>This routine assumes that (at least locally) the WCS can be approximated as a <a class="reference internal" href="wcs.html#galsim.PixelScale" title="galsim.PixelScale"><code class="xref any py py-class docutils literal notranslate"><span class="pre">PixelScale</span></code></a>, with
no distortion or non-trivial remapping. Any non-trivial WCS gets completely ignored.</p>
<p>Like <a class="reference internal" href="hsm.html#galsim.hsm.EstimateShear" title="galsim.hsm.EstimateShear"><code class="xref any py py-func docutils literal notranslate"><span class="pre">EstimateShear</span></code></a>, <a class="reference internal" href="#galsim.Image.FindAdaptiveMom" title="galsim.Image.FindAdaptiveMom"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">FindAdaptiveMom</span></code></a> works on <a class="reference internal" href="#galsim.Image" title="galsim.Image"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Image</span></code></a> inputs, and fails if the object is
small compared to the pixel scale.  For more details, see <a class="reference internal" href="hsm.html#galsim.hsm.EstimateShear" title="galsim.hsm.EstimateShear"><code class="xref any py py-func docutils literal notranslate"><span class="pre">EstimateShear</span></code></a>.</p>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">my_gaussian</span> <span class="o">=</span> <span class="n">galsim</span><span class="o">.</span><span class="n">Gaussian</span><span class="p">(</span><span class="n">flux</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mf">1.0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">my_gaussian_image</span> <span class="o">=</span> <span class="n">my_gaussian</span><span class="o">.</span><span class="n">drawImage</span><span class="p">(</span><span class="n">scale</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;no_pixel&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">my_moments</span> <span class="o">=</span> <span class="n">galsim</span><span class="o">.</span><span class="n">hsm</span><span class="o">.</span><span class="n">FindAdaptiveMom</span><span class="p">(</span><span class="n">my_gaussian_image</span><span class="p">)</span>
</pre></div>
</div>
<p>or:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">my_moments</span> <span class="o">=</span> <span class="n">my_gaussian_image</span><span class="o">.</span><span class="n">FindAdaptiveMom</span><span class="p">()</span>
</pre></div>
</div>
<p>Assuming a successful measurement, the most relevant pieces of information are
<code class="docutils literal notranslate"><span class="pre">my_moments.moments_sigma</span></code>, which is <code class="docutils literal notranslate"><span class="pre">|det(M)|^(1/4)</span></code> (= <code class="docutils literal notranslate"><span class="pre">sigma</span></code> for a circular Gaussian)
and <code class="docutils literal notranslate"><span class="pre">my_moments.observed_shape</span></code>, which is a <a class="reference internal" href="shear.html#galsim.Shear" title="galsim.Shear"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Shear</span></code></a>.  In this case,
<code class="docutils literal notranslate"><span class="pre">my_moments.moments_sigma</span></code> is precisely 5.0 (in units of pixels), and
<code class="docutils literal notranslate"><span class="pre">my_moments.observed_shape</span></code> is consistent with zero.</p>
<p>Methods of the <a class="reference internal" href="shear.html#galsim.Shear" title="galsim.Shear"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Shear</span></code></a> class can be used to get the distortion <code class="docutils literal notranslate"><span class="pre">e</span></code>, the shear <code class="docutils literal notranslate"><span class="pre">g</span></code>, the
conformal shear <code class="docutils literal notranslate"><span class="pre">eta</span></code>, and so on.</p>
<p>As an example of how to use the optional <code class="docutils literal notranslate"><span class="pre">hsmparams</span></code> argument, consider cases where the input
images have unusual properties, such as being very large.  This could occur when measuring the
properties of a very over-sampled image such as that generated using:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">my_gaussian</span> <span class="o">=</span> <span class="n">galsim</span><span class="o">.</span><span class="n">Gaussian</span><span class="p">(</span><span class="n">sigma</span><span class="o">=</span><span class="mf">5.0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">my_gaussian_image</span> <span class="o">=</span> <span class="n">my_gaussian</span><span class="o">.</span><span class="n">drawImage</span><span class="p">(</span><span class="n">scale</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;no_pixel&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>If the user attempts to measure the moments of this very large image using the standard syntax,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">my_moments</span> <span class="o">=</span> <span class="n">my_gaussian_image</span><span class="o">.</span><span class="n">FindAdaptiveMom</span><span class="p">()</span>
</pre></div>
</div>
<p>then the result will be a <code class="docutils literal notranslate"><span class="pre">GalSimHSMError</span></code> due to moment measurement failing because the
object is so large.  While the list of all possible settings that can be changed is accessible
in the docstring of the <a class="reference internal" href="hsm.html#galsim.hsm.HSMParams" title="galsim.hsm.HSMParams"><code class="xref any py py-class docutils literal notranslate"><span class="pre">HSMParams</span></code></a> class, in this case we need to modify <code class="docutils literal notranslate"><span class="pre">max_amoment</span></code> which
is the maximum value of the moments in units of pixel^2.  The following measurement, using the
default values for every parameter except for <code class="docutils literal notranslate"><span class="pre">max_amoment</span></code>, will be
successful:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">new_params</span> <span class="o">=</span> <span class="n">galsim</span><span class="o">.</span><span class="n">hsm</span><span class="o">.</span><span class="n">HSMParams</span><span class="p">(</span><span class="n">max_amoment</span><span class="o">=</span><span class="mf">5.0e5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">my_moments</span> <span class="o">=</span> <span class="n">my_gaussian_image</span><span class="o">.</span><span class="n">FindAdaptiveMom</span><span class="p">(</span><span class="n">hsmparams</span><span class="o">=</span><span class="n">new_params</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>object_image</strong> – The <a class="reference internal" href="#galsim.Image" title="galsim.Image"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Image</span></code></a> for the object being measured.</p></li>
<li><p><strong>weight</strong> – The optional weight image for the object being measured.  Can be an int
or a float array.  Currently, GalSim does not account for the variation
in non-zero weights, i.e., a weight map is converted to an image with 0
and 1 for pixels that are not and are used.  Full use of spatial
variation in non-zero weights will be included in a future version of
the code. [default: None]</p></li>
<li><p><strong>badpix</strong> – The optional bad pixel mask for the image being used.  Zero should be
used for pixels that are good, and any nonzero value indicates a bad
pixel. [default: None]</p></li>
<li><p><strong>guess_sig</strong> – Optional argument with an initial guess for the Gaussian sigma of the
object (in pixels). [default: 5.0]</p></li>
<li><p><strong>precision</strong> – The convergence criterion for the moments. [default: 1e-6]</p></li>
<li><p><strong>guess_centroid</strong> – An initial guess for the object centroid (useful in case it is not
located at the center, which is used if this keyword is not set).  The
convention for centroids is such that the center of the lower-left pixel
is (image.xmin, image.ymin).
[default: object_image.true_center]</p></li>
<li><p><strong>strict</strong> – Whether to require success. If <code class="docutils literal notranslate"><span class="pre">strict=True</span></code>, then there will be a
<code class="docutils literal notranslate"><span class="pre">GalSimHSMError</span></code> exception if shear estimation fails.  If set to
<code class="docutils literal notranslate"><span class="pre">False</span></code>, then information about failures will be silently stored in
the output ShapeData object. [default: True]</p></li>
<li><p><strong>round_moments</strong> – Use a circular weight function instead of elliptical.
[default: False]</p></li>
<li><p><strong>hsmparams</strong> – The hsmparams keyword can be used to change the settings used by
FindAdaptiveMom when estimating moments; see <a class="reference internal" href="hsm.html#galsim.hsm.HSMParams" title="galsim.hsm.HSMParams"><code class="xref any py py-class docutils literal notranslate"><span class="pre">HSMParams</span></code></a> documentation
for more information. [default: None]</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a <a class="reference internal" href="hsm.html#galsim.hsm.ShapeData" title="galsim.hsm.ShapeData"><code class="xref any py py-class docutils literal notranslate"><span class="pre">ShapeData</span></code></a> object containing the results of moment measurement.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.Image.addNoise">
<code class="sig-name descname">addNoise</code><span class="sig-paren">(</span><em class="sig-param">noise</em><span class="sig-paren">)</span><a class="headerlink" href="#galsim.Image.addNoise" title="Permalink to this definition">¶</a></dt>
<dd><p>Add noise to the image according to a supplied noise model.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>noise</strong> – The noise (<a class="reference internal" href="noise.html#galsim.BaseNoise" title="galsim.BaseNoise"><code class="xref any py py-class docutils literal notranslate"><span class="pre">BaseNoise</span></code></a>) model to use.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.Image.addNoiseSNR">
<code class="sig-name descname">addNoiseSNR</code><span class="sig-paren">(</span><em class="sig-param">noise</em>, <em class="sig-param">snr</em>, <em class="sig-param">preserve_flux=False</em><span class="sig-paren">)</span><a class="headerlink" href="#galsim.Image.addNoiseSNR" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds noise to the image in a way that achieves the specified signal-to-noise ratio.</p>
<p>The specified <code class="docutils literal notranslate"><span class="pre">snr</span></code> (signal-to-noise ratio, or <span class="math notranslate nohighlight">\(S/N\)</span>) can be achieved either by scaling
the flux of the object while keeping the noise level fixed, or the flux can be preserved and
the noise variance changed.  This choice is specified using the parameter <code class="docutils literal notranslate"><span class="pre">preserve_flux</span></code>,
where False means the former and True means the latter.</p>
<p>The definition of <span class="math notranslate nohighlight">\(S/N\)</span> is equivalent to the one used by Great08.  We take the signal to
be a weighted sum of the pixel values:</p>
<div class="math notranslate nohighlight">
\[\begin{split}S &amp;= \frac{\sum W(x,y) I(x,y)}{\sum W(x,y)} \\
N^2 = Var(S) &amp;= \frac{\sum W(x,y)^2 Var(I(x,y))}{(\sum W(x,y))^2}\end{split}\]</div>
<p>and assume that <span class="math notranslate nohighlight">\(Var(I(x,y))\)</span> is constant, <span class="math notranslate nohighlight">\(V \equiv Var(I(x,y))\)</span>.
We then assume that we are using a matched filter for <span class="math notranslate nohighlight">\(W\)</span>, so <span class="math notranslate nohighlight">\(W(x,y) = I(x,y)\)</span>.
Then a few things cancel and we find that</p>
<div class="math notranslate nohighlight">
\[(S/N)^2 = \frac{\sum I(x,y)^2}{V}\]</div>
<p>and therefore, for a given <span class="math notranslate nohighlight">\(I(x,y)\)</span> and <span class="math notranslate nohighlight">\(S/N\)</span> (aka <code class="docutils literal notranslate"><span class="pre">snr</span></code>)</p>
<div class="math notranslate nohighlight">
\[V = \frac{\sum I(x,y)^2}{(S/N)^2}\]</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For noise models such as <a class="reference internal" href="noise.html#galsim.PoissonNoise" title="galsim.PoissonNoise"><code class="xref any py py-class docutils literal notranslate"><span class="pre">PoissonNoise</span></code></a> and <a class="reference internal" href="noise.html#galsim.CCDNoise" title="galsim.CCDNoise"><code class="xref any py py-class docutils literal notranslate"><span class="pre">CCDNoise</span></code></a>, the assumption of constant
<span class="math notranslate nohighlight">\(Var(I(x,y))\)</span> is only approximate, since the flux of the object adds to the Poisson
noise in those pixels.  Thus, the real <span class="math notranslate nohighlight">\(S/N\)</span> on the final image will be slightly
lower than the target <code class="docutils literal notranslate"><span class="pre">snr</span></code> value, and this effect will be larger for brighter objects.</p>
</div>
<p>This function relies on <a class="reference internal" href="noise.html#galsim.BaseNoise.getVariance" title="galsim.BaseNoise.getVariance"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">BaseNoise.getVariance</span></code></a> to determine how much variance the noise model
will add.  Thus, it will not work for noise models that do not have a well-defined variance,
such as <a class="reference internal" href="noise.html#galsim.VariableGaussianNoise" title="galsim.VariableGaussianNoise"><code class="xref any py py-class docutils literal notranslate"><span class="pre">VariableGaussianNoise</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>noise</strong> – The noise (<a class="reference internal" href="noise.html#galsim.BaseNoise" title="galsim.BaseNoise"><code class="xref any py py-class docutils literal notranslate"><span class="pre">BaseNoise</span></code></a>) model to use.</p></li>
<li><p><strong>snr</strong> – The desired signal-to-noise after the noise is applied.</p></li>
<li><p><strong>preserve_flux</strong> – Whether to preserve the flux of the object (<code class="docutils literal notranslate"><span class="pre">True</span></code>) or the variance of
the noise model (<code class="docutils literal notranslate"><span class="pre">False</span></code>) to achieve the desired snr. [default: False]</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the variance of the noise that was applied to the image.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.Image.addReciprocityFailure">
<code class="sig-name descname">addReciprocityFailure</code><span class="sig-paren">(</span><em class="sig-param">exp_time</em>, <em class="sig-param">alpha</em>, <em class="sig-param">base_flux</em><span class="sig-paren">)</span><a class="headerlink" href="#galsim.Image.addReciprocityFailure" title="Permalink to this definition">¶</a></dt>
<dd><p>Accounts for the reciprocity failure and includes it in the original <a class="reference internal" href="#galsim.Image" title="galsim.Image"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Image</span></code></a> directly.</p>
<p>Reciprocity, in the context of photography, is the inverse relationship between the incident
flux (I) of a source object and the exposure time (t) required to produce a given response (p)
in the detector, i.e., p = I*t. At very low (also at high) levels of incident flux, deviation
from this relation is observed, leading to reduced sensitivity at low flux levels. The pixel
response to a high flux is larger than its response to a low flux. This flux-dependent non-
linearity is known as ‘Reciprocity Failure’ and is known to happen in photographic films since
1893. Interested users can refer to <a class="reference external" href="http://en.wikipedia.org/wiki/Reciprocity_(photography">http://en.wikipedia.org/wiki/Reciprocity_(photography</a>)</p>
<p>CCDs are not known to suffer from this effect. HgCdTe detectors that are used for near infrared
astrometry, although to an extent much lesser than the photographic films, are found to
exhibit reciprocity failure at low flux levels. The exact mechanism of this effect is unknown
and hence we lack a good theoretical model. Many models that fit the empirical data exist and
a common relation is</p>
<div class="math notranslate nohighlight">
\[\frac{p_R}{p} = \left(1 + \alpha \log_{10}\left(\frac{p}{t}\right)
                   - \alpha \log_{10}\left(\frac{p^\prime}{t^\prime}\right)\right)\]</div>
<p>where <span class="math notranslate nohighlight">\(t\)</span> is the exposure time (in units of seconds), <span class="math notranslate nohighlight">\(p\)</span> is the pixel response
(in units of electrons) and <span class="math notranslate nohighlight">\(p_R\)</span> is the response if the reciprocity relation fails to
hold. <span class="math notranslate nohighlight">\(p^\prime/t^\prime\)</span> is the count rate (in electrons/second) corresponding to the
photon flux (base flux) at which the detector is calibrated to have its nominal gain.
alpha is the parameter in the model, measured in units of per decade and varies with detectors
and the operating temperature. The functional form for the reciprocity failure is motivated
empirically from the tests carried out on H2RG detectors.</p>
<p>See for reference Fig. 1 and Fig. 2 of <a class="reference external" href="http://arxiv.org/abs/1106.1090">http://arxiv.org/abs/1106.1090</a>. Since <span class="math notranslate nohighlight">\(p_R/p\)</span>
remains close to unity over a wide range of flux, we convert this relation to a power law by
approximating <span class="math notranslate nohighlight">\(p_R/p \approx 1 + \log(p_R/p)\)</span>. This gives a relation that is better
behaved than the logarithmic relation at low flux levels.</p>
<div class="math notranslate nohighlight">
\[\frac{p_R}{p} = \left(\frac{p/t}{p^\prime/t^\prime}\right)^\frac{\alpha}{\log(10)}.\]</div>
<p>Because of how this function is defined, the input image must have non-negative pixel
values for the resulting image to be well-defined. Negative pixel values result in ‘nan’s.
The image should be in units of electrons, or if it is in ADU, then the value passed to
exp_time should be the exposure time divided by the nominal gain. The image should include
both the signal from the astronomical objects as well as the background level.  The addition of
nonlinearity should occur after including the effect of reciprocity failure.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>exp_time</strong> – The exposure time (t) in seconds, which goes into the expression for
reciprocity failure given in the docstring.</p></li>
<li><p><strong>alpha</strong> – The alpha parameter in the expression for reciprocity failure, in
units of ‘per decade’.</p></li>
<li><p><strong>base_flux</strong> – The flux (<span class="math notranslate nohighlight">\(p^\prime/t^\prime\)</span>) at which the gain is calibrated to have
its nominal value.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.Image.addValue">
<code class="sig-name descname">addValue</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/image.html#Image.addValue"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.Image.addValue" title="Permalink to this definition">¶</a></dt>
<dd><p>Add some amount to the pixel value at given (x,y) position</p>
<p>The arguments here may be either (x, y, value) or (pos, value) where pos is a PositionI.
Or you can provide x, y, value as named kwargs.</p>
<p>This is equivalent to self[x,y] += rhs</p>
</dd></dl>

<dl class="method">
<dt id="galsim.Image.applyIPC">
<code class="sig-name descname">applyIPC</code><span class="sig-paren">(</span><em class="sig-param">IPC_kernel</em>, <em class="sig-param">edge_treatment='extend'</em>, <em class="sig-param">fill_value=None</em>, <em class="sig-param">kernel_nonnegativity=True</em>, <em class="sig-param">kernel_normalization=True</em><span class="sig-paren">)</span><a class="headerlink" href="#galsim.Image.applyIPC" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies the effect of interpixel capacitance to the <a class="reference internal" href="#galsim.Image" title="galsim.Image"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Image</span></code></a> instance.</p>
<p>In NIR detectors, the quantity that is sensed is not the charge as in CCDs, but a voltage that
relates to the charge present within each pixel. The voltage read at a given pixel location is
influenced by the charges present in the neighboring pixel locations due to capacitive
coupling of sense nodes.</p>
<p>This interpixel capacitance is approximated as a linear effect that can be described by a 3x3
kernel that is convolved with the image. The kernel must be an <a class="reference internal" href="#galsim.Image" title="galsim.Image"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Image</span></code></a> instance and could be
intrinsically anisotropic. A sensible kernel must have non-negative entries and must be
normalized such that the sum of the elements is 1, in order to conserve the total charge.
The (1,1) element of the kernel is the contribution to the voltage read at a pixel from the
electrons in the pixel to its bottom-left, the (1,2) element of the kernel is the contribution
from the charges to its left and so on.</p>
<p>The argument ‘edge_treatment’ specifies how the edges of the image should be treated, which
could be in one of the three ways:</p>
<ol class="arabic simple">
<li><p>‘extend’: The kernel is convolved with the zero-padded image, leading to a larger
intermediate image. The central portion of this image is returned.  [default]</p></li>
<li><p>‘crop’: The kernel is convolved with the image, with the kernel inside the image completely.
Pixels at the edges, where the center of the kernel could not be placed, are set to the
value specified by ‘fill_value’. If ‘fill_value’ is not specified or set to ‘None’, then
the pixel values in the original image are retained. The user can make the edges invalid
by setting fill_value to numpy.nan.</p></li>
<li><p>‘wrap’: The kernel is convolved with the image, assuming periodic boundary conditions.</p></li>
</ol>
<p>The size of the image array remains unchanged in all three cases.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>IPC_kernel</strong> – A 3x3 <a class="reference internal" href="#galsim.Image" title="galsim.Image"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Image</span></code></a> instance that is convolved with the <a class="reference internal" href="#galsim.Image" title="galsim.Image"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Image</span></code></a> instance</p></li>
<li><p><strong>edge_treatment</strong> – Specifies the method of handling edges and should be one of
‘crop’, ‘extend’ or ‘wrap’. See above for details.
[default: ‘extend’]</p></li>
<li><p><strong>fill_value</strong> – Specifies the value (including nan) to fill the edges with when
edge_treatment is ‘crop’. If unspecified or set to ‘None’, the
original pixel values are retained at the edges. If
edge_treatment is not ‘crop’, then this is ignored.</p></li>
<li><p><strong>kernel_nonnegativity</strong> – Specify whether the kernel should have only non-negative
entries.  [default: True]</p></li>
<li><p><strong>kernel_normalization</strong> – Specify whether to check and enforce correct normalization for
the kernel.  [default: True]</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.Image.applyNonlinearity">
<code class="sig-name descname">applyNonlinearity</code><span class="sig-paren">(</span><em class="sig-param">NLfunc</em>, <em class="sig-param">*args</em><span class="sig-paren">)</span><a class="headerlink" href="#galsim.Image.applyNonlinearity" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies the given non-linearity function (<code class="docutils literal notranslate"><span class="pre">NLfunc</span></code>) on the <a class="reference internal" href="#galsim.Image" title="galsim.Image"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Image</span></code></a> instance directly.</p>
<p>This routine can transform the image in a non-linear manner specified by the user. However,
the typical kind of non-linearity one sees in astronomical images is voltage non-linearity,
also sometimes known as ‘classical non-linearity’, refers to the non-linearity in
charge-to-voltage conversion process. This arises as charge gets integrated at the junction
capacitance of the pixel node. Voltage non-linearity decreases signals at higher signal
levels, causing the attenuation of brighter pixels. The image should include both the
signal from the astronomical objects as well as the background level. Other detectors effects
such as dark current and persistence (not currently included in GalSim) would also occur
before the inclusion of nonlinearity.</p>
<p>The argument <code class="docutils literal notranslate"><span class="pre">NLfunc</span></code> is a callable function (for example a lambda function, a
<a class="reference internal" href="table.html#galsim.LookupTable" title="galsim.LookupTable"><code class="xref any py py-class docutils literal notranslate"><span class="pre">galsim.LookupTable</span></code></a>, or a user-defined function), possibly with arguments that need to be given
as subsequent arguments to the <code class="docutils literal notranslate"><span class="pre">applyNonlinearity</span></code> function (after the <code class="docutils literal notranslate"><span class="pre">NLfunc</span></code> argument).
<code class="docutils literal notranslate"><span class="pre">NLfunc</span></code> should be able to take a 2d NumPy array as input, and return a NumPy array of the
same shape.  It should be defined such that it outputs the final image with nonlinearity
included (i.e., in the limit that there is no nonlinearity, the function should return the
original image, NOT zero). The image should be in units of electrons when this routine is being
used to generate classical non-linearity. When used for other purposes, the units can be in
electrons or in ADU, as found appropriate by the user.</p>
<p>Examples:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">+</span> <span class="p">(</span><span class="mf">1.e-7</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span><span class="o">.</span><span class="n">applyNonlinearity</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">beta1</span><span class="p">,</span> <span class="n">beta2</span><span class="p">:</span> <span class="n">x</span> <span class="o">-</span> <span class="n">beta1</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">beta2</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span><span class="o">.</span><span class="n">applyNonlinearity</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="mf">1.e-7</span><span class="p">,</span> <span class="mf">1.e-10</span><span class="p">)</span>
</pre></div>
</div>
<p>On calling the method, the <a class="reference internal" href="#galsim.Image" title="galsim.Image"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Image</span></code></a> instance <code class="docutils literal notranslate"><span class="pre">img</span></code> is transformed by the user-defined function
<code class="docutils literal notranslate"><span class="pre">f</span></code> with <code class="docutils literal notranslate"><span class="pre">beta1</span></code> = 1.e-7 and <code class="docutils literal notranslate"><span class="pre">beta2</span></code> = 1.e-10.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>NLfunc</strong> – The function that maps the input image pixel values to the output image pixel
values.</p></li>
<li><p><strong>*args</strong> – Any subsequent arguments are passed along to the NLfunc function.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.Image.applyPersistence">
<code class="sig-name descname">applyPersistence</code><span class="sig-paren">(</span><em class="sig-param">imgs</em>, <em class="sig-param">coeffs</em><span class="sig-paren">)</span><a class="headerlink" href="#galsim.Image.applyPersistence" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies the effects of persistence to the <a class="reference internal" href="#galsim.Image" title="galsim.Image"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Image</span></code></a> instance.</p>
<p>Persistence refers to the retention of a small fraction of the signal after resetting the
imager pixel elements. The persistence signal of a previous exposure is left in the pixel even
after several detector resets. This effect is most likely due to charge traps in the material.
Laboratory tests on the WFIRST CMOS detectors show that if exposures and readouts are taken in
a fixed cadence, the persistence signal can be given as a linear combination of prior pixel
values that can be added to the current image.</p>
<p>This routine takes in a list of <a class="reference internal" href="#galsim.Image" title="galsim.Image"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Image</span></code></a> instances and adds them to <a class="reference internal" href="#galsim.Image" title="galsim.Image"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Image</span></code></a> weighted by the
values passed on to ‘coeffs’. The pixel values of the <a class="reference internal" href="#galsim.Image" title="galsim.Image"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Image</span></code></a> instances in the list must
correspond to the electron counts before the readout. This routine does NOT keep track of
realistic dither patterns. During the image simulation process, the user has to queue a list of
previous <a class="reference internal" href="#galsim.Image" title="galsim.Image"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Image</span></code></a> instances (imgs) outside the routine by inserting the latest image in the
beginning of the list and deleting the oldest image. The values in ‘coeffs’ tell how much of
each <a class="reference internal" href="#galsim.Image" title="galsim.Image"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Image</span></code></a> is to be added. This usually remains constant in the image generation process.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>imgs</strong> – A list of previous <a class="reference internal" href="#galsim.Image" title="galsim.Image"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Image</span></code></a> instances that still persist.</p></li>
<li><p><strong>coeffs</strong> – A list of floats that specifies the retention factors for the corresponding
<a class="reference internal" href="#galsim.Image" title="galsim.Image"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Image</span></code></a> instances listed in ‘imgs’.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.Image.array">
<em class="property">property </em><code class="sig-name descname">array</code><a class="headerlink" href="#galsim.Image.array" title="Permalink to this definition">¶</a></dt>
<dd><p>The underlying numpy array.</p>
</dd></dl>

<dl class="method">
<dt id="galsim.Image.bin">
<code class="sig-name descname">bin</code><span class="sig-paren">(</span><em class="sig-param">nx</em>, <em class="sig-param">ny</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/image.html#Image.bin"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.Image.bin" title="Permalink to this definition">¶</a></dt>
<dd><p>Bin the image pixels in blocks of nx x ny pixels.</p>
<p>This returns a new image that is a binned version of the current image.
Adjacent pixel values in nx x ny blocks are added together to produce the flux in each
output pixel.</p>
<p>If the current number of pixels in each direction is not a multiple of nx, ny, then the
last pixel in each direction will be the sum of fewer than nx or ny pixels as needed.</p>
<p>See also subsample, which is the opposite of this.</p>
<p>If the wcs is a Jacobian (or simpler), the output image will have its wcs set properly.
But if the wcs is more complicated, the output wcs would be fairly complicated to figure
out properly, so we leave it as None.  The user should set it themselves if required.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>nx</strong> – The number of adjacent pixels in the x direction to add together into each
output pixel.</p></li>
<li><p><strong>ny</strong> – The number of adjacent pixels in the y direction to add together into each
output pixel.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a new <a class="reference internal" href="#galsim.Image" title="galsim.Image"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Image</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.Image.bounds">
<em class="property">property </em><code class="sig-name descname">bounds</code><a class="headerlink" href="#galsim.Image.bounds" title="Permalink to this definition">¶</a></dt>
<dd><p>The bounds of the <a class="reference internal" href="#galsim.Image" title="galsim.Image"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Image</span></code></a>.</p>
</dd></dl>

<dl class="method">
<dt id="galsim.Image.calculateFWHM">
<code class="sig-name descname">calculateFWHM</code><span class="sig-paren">(</span><em class="sig-param">center=None</em>, <em class="sig-param">Imax=0.0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/image.html#Image.calculateFWHM"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.Image.calculateFWHM" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the full-width half-maximum (FWHM) of a drawn object.</p>
<p>This method is equivalent to <a class="reference internal" href="gsobject.html#galsim.GSObject.calculateFWHM" title="galsim.GSObject.calculateFWHM"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">GSObject.calculateFWHM</span></code></a> when the object has already
been drawn onto an image.  Note that the profile should be drawn using a method that
does not integrate over pixels, so either ‘sb’ or ‘no_pixel’.  Also, if there is a
significant amount of noise in the image, this method may not work well.</p>
<p>If the image has a wcs other than a <a class="reference internal" href="wcs.html#galsim.PixelScale" title="galsim.PixelScale"><code class="xref any py py-class docutils literal notranslate"><span class="pre">PixelScale</span></code></a>, an AttributeError will be raised.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>center</strong> – The position in pixels to use for the center, r=0.
[default: self.true_center]</p></li>
<li><p><strong>Imax</strong> – The maximum surface brightness.  [default: max(self.array)]
Note: If Imax is provided, and the maximum pixel value is larger than
this value, Imax will be updated to use the larger value.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>an estimate of the full-width half-maximum in physical units defined by the pixel scale.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.Image.calculateHLR">
<code class="sig-name descname">calculateHLR</code><span class="sig-paren">(</span><em class="sig-param">center=None</em>, <em class="sig-param">flux=None</em>, <em class="sig-param">flux_frac=0.5</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/image.html#Image.calculateHLR"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.Image.calculateHLR" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the half-light radius of a drawn object.</p>
<p>This method is equivalent to <a class="reference internal" href="gsobject.html#galsim.GSObject.calculateHLR" title="galsim.GSObject.calculateHLR"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">GSObject.calculateHLR</span></code></a> when the object has already been
been drawn onto an image.  Note that the profile should be drawn using a method that
integrates over pixels and does not add noise. (The default method=’auto’ is acceptable.)</p>
<p>If the image has a wcs other than a <a class="reference internal" href="wcs.html#galsim.PixelScale" title="galsim.PixelScale"><code class="xref any py py-class docutils literal notranslate"><span class="pre">PixelScale</span></code></a>, an AttributeError will be raised.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>center</strong> – The position in pixels to use for the center, r=0.
[default: self.true_center]</p></li>
<li><p><strong>flux</strong> – The total flux.  [default: sum(self.array)]</p></li>
<li><p><strong>flux_frac</strong> – The fraction of light to be enclosed by the returned radius.
[default: 0.5]</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>an estimate of the half-light radius in physical units defined by the pixel scale.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.Image.calculateMomentRadius">
<code class="sig-name descname">calculateMomentRadius</code><span class="sig-paren">(</span><em class="sig-param">center=None</em>, <em class="sig-param">flux=None</em>, <em class="sig-param">rtype='det'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/image.html#Image.calculateMomentRadius"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.Image.calculateMomentRadius" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an estimate of the radius based on unweighted second moments of a drawn object.</p>
<p>This method is equivalent to <a class="reference internal" href="gsobject.html#galsim.GSObject.calculateMomentRadius" title="galsim.GSObject.calculateMomentRadius"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">GSObject.calculateMomentRadius</span></code></a> when the object has already
been drawn onto an image.  Note that the profile should be drawn using a method that
integrates over pixels and does not add noise. (The default method=’auto’ is acceptable.)</p>
<p>If the image has a wcs other than a <a class="reference internal" href="wcs.html#galsim.PixelScale" title="galsim.PixelScale"><code class="xref any py py-class docutils literal notranslate"><span class="pre">PixelScale</span></code></a>, an AttributeError will be raised.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>center</strong> – The position in pixels to use for the center, r=0.
[default: self.true_center]</p></li>
<li><p><strong>flux</strong> – The total flux.  [default: sum(self.array)]</p></li>
<li><p><strong>rtype</strong> – <p>There are three options for this parameter:</p>
<ul>
<li><p>’trace’ means return sqrt(T/2)</p></li>
<li><p>’det’ means return det(Q)^1/4</p></li>
<li><p>’both’ means return both: (sqrt(T/2), det(Q)^1/4)</p></li>
</ul>
<p>[default: ‘det’]</p>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>an estimate of the radius in physical units defined by the pixel scale
(or both estimates if rtype == ‘both’).</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.Image.calculate_fft">
<code class="sig-name descname">calculate_fft</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/image.html#Image.calculate_fft"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.Image.calculate_fft" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs an FFT of an <a class="reference internal" href="#galsim.Image" title="galsim.Image"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Image</span></code></a> in real space to produce a k-space <a class="reference internal" href="#galsim.Image" title="galsim.Image"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Image</span></code></a>.</p>
<p>Note: the image will be padded with zeros as needed to make an image with bounds that
look like <code class="docutils literal notranslate"><span class="pre">BoundsI(-N/2,</span> <span class="pre">N/2-1,</span> <span class="pre">-N/2,</span> <span class="pre">N/2-1)</span></code>.</p>
<p>The input image must have a <a class="reference internal" href="wcs.html#galsim.PixelScale" title="galsim.PixelScale"><code class="xref any py py-class docutils literal notranslate"><span class="pre">PixelScale</span></code></a> wcs.  The output image will be complex (an
<a class="reference internal" href="#galsim.ImageCF" title="galsim.ImageCF"><code class="xref any py py-func docutils literal notranslate"><span class="pre">ImageCF</span></code></a> or <a class="reference internal" href="#galsim.ImageCD" title="galsim.ImageCD"><code class="xref any py py-func docutils literal notranslate"><span class="pre">ImageCD</span></code></a> instance) and its scale will be 2pi / (N dx), where dx is the scale
of the input image.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>an <a class="reference internal" href="#galsim.Image" title="galsim.Image"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Image</span></code></a> instance with the k-space image.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.Image.calculate_inverse_fft">
<code class="sig-name descname">calculate_inverse_fft</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/image.html#Image.calculate_inverse_fft"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.Image.calculate_inverse_fft" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs an inverse FFT of an <a class="reference internal" href="#galsim.Image" title="galsim.Image"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Image</span></code></a> in k-space to produce a real-space <a class="reference internal" href="#galsim.Image" title="galsim.Image"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Image</span></code></a>.</p>
<p>The starting image is typically an <a class="reference internal" href="#galsim.ImageCD" title="galsim.ImageCD"><code class="xref any py py-func docutils literal notranslate"><span class="pre">ImageCD</span></code></a>, although if the Fourier function is real
valued, then you could get away with using an <a class="reference internal" href="#galsim.ImageD" title="galsim.ImageD"><code class="xref any py py-func docutils literal notranslate"><span class="pre">ImageD</span></code></a> or <a class="reference internal" href="#galsim.ImageF" title="galsim.ImageF"><code class="xref any py py-func docutils literal notranslate"><span class="pre">ImageF</span></code></a>.</p>
<p>The image is assumed to be Hermitian.  In fact, only the portion with x &gt;= 0 needs to
be defined, with f(-x,-y) taken to be conj(f(x,y)).</p>
<p>Note: the k-space image will be padded with zeros and/or wrapped as needed to make an
image with bounds that look like <code class="docutils literal notranslate"><span class="pre">BoundsI(0,</span> <span class="pre">N/2,</span> <span class="pre">-N/2,</span> <span class="pre">N/2-1)</span></code>.  If you are building a
larger k-space image and then wrapping, you should wrap directly into an image of
this shape.</p>
<p>The input image must have a <a class="reference internal" href="wcs.html#galsim.PixelScale" title="galsim.PixelScale"><code class="xref any py py-class docutils literal notranslate"><span class="pre">PixelScale</span></code></a> wcs.  The output image will be real (an <a class="reference internal" href="#galsim.ImageD" title="galsim.ImageD"><code class="xref any py py-func docutils literal notranslate"><span class="pre">ImageD</span></code></a>
instance) and its scale will be 2pi / (N dk), where dk is the scale of the input image.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>an <a class="reference internal" href="#galsim.Image" title="galsim.Image"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Image</span></code></a> instance with the real-space image.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.Image.center">
<em class="property">property </em><code class="sig-name descname">center</code><a class="headerlink" href="#galsim.Image.center" title="Permalink to this definition">¶</a></dt>
<dd><p>The current nominal center (xcen,ycen) of the image as a PositionI instance.</p>
<p>In terms of the rows and columns, xcen is the x value for the central column, and ycen
is the y value of the central row.  For even-sized arrays, there is no central column
or row, so the convention we adopt in this case is to round up.  For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">im</span> <span class="o">=</span> <span class="n">galsim</span><span class="o">.</span><span class="n">Image</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">16</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">im</span><span class="o">.</span><span class="n">center</span>
<span class="go">galsim.PositionI(x=3, y=3)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">im</span><span class="p">(</span><span class="n">im</span><span class="o">.</span><span class="n">center</span><span class="p">)</span>
<span class="go">10.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">im</span><span class="o">.</span><span class="n">setCenter</span><span class="p">(</span><span class="mi">56</span><span class="p">,</span><span class="mi">72</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">im</span><span class="o">.</span><span class="n">center</span>
<span class="go">galsim.PositionI(x=56, y=72)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">im</span><span class="p">(</span><span class="n">im</span><span class="o">.</span><span class="n">center</span><span class="p">)</span>
<span class="go">10.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="galsim.Image.conjugate">
<em class="property">property </em><code class="sig-name descname">conjugate</code><a class="headerlink" href="#galsim.Image.conjugate" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the complex conjugate of an image.</p>
<p>This works for real or complex.  For real images, it acts the same as <a class="reference internal" href="#galsim.Image.view" title="galsim.Image.view"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">view</span></code></a>.</p>
<p>Note that for complex images, this is not a conjugate view into the original image.
So changing the original image does not change the conjugate (or vice versa).</p>
</dd></dl>

<dl class="method">
<dt id="galsim.Image.copy">
<code class="sig-name descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/image.html#Image.copy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.Image.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Make a copy of the <a class="reference internal" href="#galsim.Image" title="galsim.Image"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Image</span></code></a></p>
</dd></dl>

<dl class="method">
<dt id="galsim.Image.copyFrom">
<code class="sig-name descname">copyFrom</code><span class="sig-paren">(</span><em class="sig-param">rhs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/image.html#Image.copyFrom"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.Image.copyFrom" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy the contents of another image</p>
</dd></dl>

<dl class="method">
<dt id="galsim.Image.dtype">
<em class="property">property </em><code class="sig-name descname">dtype</code><a class="headerlink" href="#galsim.Image.dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>The dtype of the underlying numpy array.</p>
</dd></dl>

<dl class="method">
<dt id="galsim.Image.fill">
<code class="sig-name descname">fill</code><span class="sig-paren">(</span><em class="sig-param">value</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/image.html#Image.fill"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.Image.fill" title="Permalink to this definition">¶</a></dt>
<dd><p>Set all pixel values to the given <code class="docutils literal notranslate"><span class="pre">value</span></code></p>
<dl class="simple">
<dt>Parameter:</dt><dd><p>value:  The value to set all the pixels to.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.Image.getValue">
<code class="sig-name descname">getValue</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">y</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/image.html#Image.getValue"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.Image.getValue" title="Permalink to this definition">¶</a></dt>
<dd><p>This method is a synonym for im(x,y).  It is a bit faster than im(x,y), since GalSim
does not have to parse the different options available for __call__.  (i.e. im(x,y) or
im(pos) or im(x=x,y=y))</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> – The x coordinate of the pixel to get.</p></li>
<li><p><strong>y</strong> – The y coordinate of the pixel to get.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.Image.get_pixel_centers">
<code class="sig-name descname">get_pixel_centers</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/image.html#Image.get_pixel_centers"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.Image.get_pixel_centers" title="Permalink to this definition">¶</a></dt>
<dd><p>A convenience function to get the x and y values at the centers of the image pixels.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>(x, y), each of which is a numpy array the same shape as <code class="docutils literal notranslate"><span class="pre">self.array</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.Image.good_fft_size">
<em class="property">classmethod </em><code class="sig-name descname">good_fft_size</code><span class="sig-paren">(</span><em class="sig-param">input_size</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/image.html#Image.good_fft_size"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.Image.good_fft_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Round the given input size up to the next higher power of 2 or 3 times a power of 2.</p>
<p>This rounds up to the next higher value that is either 2^k or 3*2^k.  If you are
going to be performing FFTs on an image, these will tend to be faster at performing
the FFT.</p>
</dd></dl>

<dl class="method">
<dt id="galsim.Image.imag">
<em class="property">property </em><code class="sig-name descname">imag</code><a class="headerlink" href="#galsim.Image.imag" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the imaginary part of an image.</p>
<p>This is a property, not a function.  So write <code class="docutils literal notranslate"><span class="pre">im.imag</span></code>, not <code class="docutils literal notranslate"><span class="pre">im.imag()</span></code>.</p>
<p>This works for real or complex.  For real images, the returned array is read-only and
all elements are 0.</p>
</dd></dl>

<dl class="method">
<dt id="galsim.Image.invertSelf">
<code class="sig-name descname">invertSelf</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/image.html#Image.invertSelf"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.Image.invertSelf" title="Permalink to this definition">¶</a></dt>
<dd><p>Set all pixel values to their inverse: x -&gt; 1/x.</p>
<p>Note: any pixels whose value is 0 originally are ignored.  They remain equal to 0
on the output, rather than turning into inf.</p>
</dd></dl>

<dl class="method">
<dt id="galsim.Image.iscomplex">
<em class="property">property </em><code class="sig-name descname">iscomplex</code><a class="headerlink" href="#galsim.Image.iscomplex" title="Permalink to this definition">¶</a></dt>
<dd><p>Whether the <a class="reference internal" href="#galsim.Image" title="galsim.Image"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Image</span></code></a> values are complex.</p>
</dd></dl>

<dl class="method">
<dt id="galsim.Image.isconst">
<em class="property">property </em><code class="sig-name descname">isconst</code><a class="headerlink" href="#galsim.Image.isconst" title="Permalink to this definition">¶</a></dt>
<dd><p>Whether the <a class="reference internal" href="#galsim.Image" title="galsim.Image"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Image</span></code></a> is constant.  I.e. modifying its values is an error.</p>
</dd></dl>

<dl class="method">
<dt id="galsim.Image.iscontiguous">
<em class="property">property </em><code class="sig-name descname">iscontiguous</code><a class="headerlink" href="#galsim.Image.iscontiguous" title="Permalink to this definition">¶</a></dt>
<dd><p>Indicates whether each row of the image is contiguous in memory.</p>
<p>Note: it is ok for the end of one row to not be contiguous with the start of the
next row.  This just checks that each individual row has a stride of 1.</p>
</dd></dl>

<dl class="method">
<dt id="galsim.Image.isinteger">
<em class="property">property </em><code class="sig-name descname">isinteger</code><a class="headerlink" href="#galsim.Image.isinteger" title="Permalink to this definition">¶</a></dt>
<dd><p>Whether the <a class="reference internal" href="#galsim.Image" title="galsim.Image"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Image</span></code></a> values are integral.</p>
</dd></dl>

<dl class="method">
<dt id="galsim.Image.origin">
<em class="property">property </em><code class="sig-name descname">origin</code><a class="headerlink" href="#galsim.Image.origin" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the origin of the image.  i.e. the (x,y) position of the lower-left pixel.</p>
<p>In terms of the rows and columns, this is the (x,y) coordinate of the first column, and
first row of the array.  For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">im</span> <span class="o">=</span> <span class="n">galsim</span><span class="o">.</span><span class="n">Image</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">16</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">im</span><span class="o">.</span><span class="n">origin</span>
<span class="go">galsim.PositionI(x=1, y=1)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">im</span><span class="p">(</span><span class="n">im</span><span class="o">.</span><span class="n">origin</span><span class="p">)</span>
<span class="go">0.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">im</span><span class="o">.</span><span class="n">setOrigin</span><span class="p">(</span><span class="mi">23</span><span class="p">,</span><span class="mi">45</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">im</span><span class="o">.</span><span class="n">origin</span>
<span class="go">galsim.PositionI(x=23, y=45)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">im</span><span class="p">(</span><span class="n">im</span><span class="o">.</span><span class="n">origin</span><span class="p">)</span>
<span class="go">0.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">im</span><span class="p">(</span><span class="mi">23</span><span class="p">,</span><span class="mi">45</span><span class="p">)</span>
<span class="go">0.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">im</span><span class="o">.</span><span class="n">bounds</span>
<span class="go">galsim.BoundsI(xmin=23, xmax=26, ymin=45, ymax=48)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="galsim.Image.outer_bounds">
<em class="property">property </em><code class="sig-name descname">outer_bounds</code><a class="headerlink" href="#galsim.Image.outer_bounds" title="Permalink to this definition">¶</a></dt>
<dd><p>The bounds of the outer edge of the pixels.</p>
<p>Equivalent to galsim.BoundsD(im.xmin-0.5, im.xmax+0.5, im.ymin-0.5, im.ymax+0.5)</p>
</dd></dl>

<dl class="method">
<dt id="galsim.Image.quantize">
<code class="sig-name descname">quantize</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#galsim.Image.quantize" title="Permalink to this definition">¶</a></dt>
<dd><p>Rounds the pixel values in an image to integer values, while preserving the type of the data.</p>
<p>At certain stages in the astronomical image generation process, detectors effectively round to
the nearest integer.  The exact stage at which this happens depends on the type of device (CCD
vs. NIR detector).  For example, for H2RG detectors, quantization happens in two stages: first,
when detecting a certain number of photons, corresponding to the sum of background and signal
multiplied by the QE and including reciprocity failure.  After this, a number of other processes
occur (e.g., nonlinearity, IPC, read noise) that could result in non-integer pixel values, only
rounding to an integer at the stage of analog-to-digital conversion.</p>
<p>Because we cannot guarantee that quantization will always be the last step in the process, the
quantize() routine does not actually modify the type of the image to ‘int’.  However, users can
easily do so by doing:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">image</span><span class="o">.</span><span class="n">quantize</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">int_image</span> <span class="o">=</span> <span class="n">galsim</span><span class="o">.</span><span class="n">Image</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="galsim.Image.real">
<em class="property">property </em><code class="sig-name descname">real</code><a class="headerlink" href="#galsim.Image.real" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the real part of an image.</p>
<p>This is a property, not a function.  So write <code class="docutils literal notranslate"><span class="pre">im.real</span></code>, not <code class="docutils literal notranslate"><span class="pre">im.real()</span></code>.</p>
<p>This works for real or complex.  For real images, it acts the same as <a class="reference internal" href="#galsim.Image.view" title="galsim.Image.view"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">view</span></code></a>.</p>
</dd></dl>

<dl class="method">
<dt id="galsim.Image.replaceNegative">
<code class="sig-name descname">replaceNegative</code><span class="sig-paren">(</span><em class="sig-param">replace_value=0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/image.html#Image.replaceNegative"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.Image.replaceNegative" title="Permalink to this definition">¶</a></dt>
<dd><p>Replace any negative values currently in the image with 0 (or some other value).</p>
<p>Sometimes FFT drawing can result in tiny negative values, which may be undesirable for
some purposes.  This method replaces those values with 0 or some other value if desired.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>replace_value</strong> – The value with which to replace any negative pixels. [default: 0]</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.Image.resize">
<code class="sig-name descname">resize</code><span class="sig-paren">(</span><em class="sig-param">bounds</em>, <em class="sig-param">wcs=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/image.html#Image.resize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.Image.resize" title="Permalink to this definition">¶</a></dt>
<dd><p>Resize the image to have a new bounds (must be a <a class="reference internal" href="bounds.html#galsim.BoundsI" title="galsim.BoundsI"><code class="xref any py py-class docutils literal notranslate"><span class="pre">BoundsI</span></code></a> instance)</p>
<p>Note that the resized image will have uninitialized data.  If you want to preserve
the existing data values, you should either use <a class="reference internal" href="#galsim.Image.subImage" title="galsim.Image.subImage"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">subImage</span></code></a> (if you want a smaller
portion of the current <a class="reference internal" href="#galsim.Image" title="galsim.Image"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Image</span></code></a>) or make a new <a class="reference internal" href="#galsim.Image" title="galsim.Image"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Image</span></code></a> and copy over the current values
into a portion of the new image (if you are resizing to a larger <a class="reference internal" href="#galsim.Image" title="galsim.Image"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Image</span></code></a>).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>bounds</strong> – The new bounds to resize to.</p></li>
<li><p><strong>wcs</strong> – If provided, also update the wcs to the given value. [default: None,
which means keep the existing wcs]</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.Image.scale">
<em class="property">property </em><code class="sig-name descname">scale</code><a class="headerlink" href="#galsim.Image.scale" title="Permalink to this definition">¶</a></dt>
<dd><p>The pixel scale of the <a class="reference internal" href="#galsim.Image" title="galsim.Image"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Image</span></code></a>.  Only valid if the wcs is a <a class="reference internal" href="wcs.html#galsim.PixelScale" title="galsim.PixelScale"><code class="xref any py py-class docutils literal notranslate"><span class="pre">PixelScale</span></code></a>.</p>
<p>If the WCS is either not set (i.e. it is <code class="docutils literal notranslate"><span class="pre">None</span></code>) or it is a <a class="reference internal" href="wcs.html#galsim.PixelScale" title="galsim.PixelScale"><code class="xref any py py-class docutils literal notranslate"><span class="pre">PixelScale</span></code></a>, then
it is permissible to change the scale with:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">image</span><span class="o">.</span><span class="n">scale</span> <span class="o">=</span> <span class="n">new_pixel_scale</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="galsim.Image.setCenter">
<code class="sig-name descname">setCenter</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/image.html#Image.setCenter"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.Image.setCenter" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the center of the image to the given (integral) (xcen, ycen)</p>
<p>The arguments here may be either (xcen, ycen) or a PositionI instance.
Or you can provide xcen, ycen as named kwargs.</p>
<p>In terms of the rows and columns, xcen is the new x value for the central column, and ycen
is the new y value of the central row.  For even-sized arrays, there is no central column
or row, so the convention we adopt in this case is to round up.  For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">im</span> <span class="o">=</span> <span class="n">galsim</span><span class="o">.</span><span class="n">Image</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">16</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">im</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="go">0.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">im</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="go">3.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">im</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>
<span class="go">15.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">im</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="go">10.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">im</span><span class="o">.</span><span class="n">setCenter</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">im</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
<span class="go">10.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">im</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>
<span class="go">0.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">im</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>
<span class="go">3.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">im</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="go">15.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">im</span><span class="o">.</span><span class="n">setCenter</span><span class="p">(</span><span class="mi">234</span><span class="p">,</span><span class="mi">456</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">im</span><span class="p">(</span><span class="mi">234</span><span class="p">,</span><span class="mi">456</span><span class="p">)</span>
<span class="go">10.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">im</span><span class="o">.</span><span class="n">bounds</span>
<span class="go">galsim.BoundsI(xmin=232, xmax=235, ymin=454, ymax=457)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="galsim.Image.setOrigin">
<code class="sig-name descname">setOrigin</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/image.html#Image.setOrigin"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.Image.setOrigin" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the origin of the image to the given (integral) (x0, y0)</p>
<p>The arguments here may be either (x0, y0) or a PositionI instance.
Or you can provide x0, y0 as named kwargs.</p>
<p>In terms of the rows and columns, x0 is the new x value for the first column,
and y0 is the new y value of the first row.  For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">im</span> <span class="o">=</span> <span class="n">galsim</span><span class="o">.</span><span class="n">Image</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">16</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">im</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="go">0.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">im</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="go">3.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">im</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>
<span class="go">12.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">im</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>
<span class="go">15.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">im</span><span class="o">.</span><span class="n">setOrigin</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">im</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
<span class="go">0.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">im</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
<span class="go">3.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">im</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="go">12.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">im</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="go">15.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">im</span><span class="o">.</span><span class="n">setOrigin</span><span class="p">(</span><span class="mi">234</span><span class="p">,</span><span class="mi">456</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">im</span><span class="p">(</span><span class="mi">234</span><span class="p">,</span><span class="mi">456</span><span class="p">)</span>
<span class="go">0.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">im</span><span class="o">.</span><span class="n">bounds</span>
<span class="go">galsim.BoundsI(xmin=234, xmax=237, ymin=456, ymax=459)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="galsim.Image.setSubImage">
<code class="sig-name descname">setSubImage</code><span class="sig-paren">(</span><em class="sig-param">bounds</em>, <em class="sig-param">rhs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/image.html#Image.setSubImage"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.Image.setSubImage" title="Permalink to this definition">¶</a></dt>
<dd><p>Set a portion of the full image to the values in another image</p>
<p>This is equivalent to self[bounds] = rhs</p>
</dd></dl>

<dl class="method">
<dt id="galsim.Image.setValue">
<code class="sig-name descname">setValue</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/image.html#Image.setValue"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.Image.setValue" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the pixel value at given (x,y) position</p>
<p>The arguments here may be either (x, y, value) or (pos, value) where pos is a PositionI.
Or you can provide x, y, value as named kwargs.</p>
<p>This is equivalent to self[x,y] = rhs</p>
</dd></dl>

<dl class="method">
<dt id="galsim.Image.setZero">
<code class="sig-name descname">setZero</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/image.html#Image.setZero"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.Image.setZero" title="Permalink to this definition">¶</a></dt>
<dd><p>Set all pixel values to zero.</p>
</dd></dl>

<dl class="method">
<dt id="galsim.Image.shift">
<code class="sig-name descname">shift</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/image.html#Image.shift"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.Image.shift" title="Permalink to this definition">¶</a></dt>
<dd><p>Shift the pixel coordinates by some (integral) dx,dy.</p>
<p>The arguments here may be either (dx, dy) or a PositionI instance.
Or you can provide dx, dy as named kwargs.</p>
<p>In terms of columns and rows, dx means a shift in the x value of each column in the
array, and dy means a shift in the y value of each row.  In other words, the following
will return the same value for ixy.  The shift function just changes the coordinates (x,y)
used for that pixel:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ixy</span> <span class="o">=</span> <span class="n">im</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">im</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">9</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ixy</span> <span class="o">=</span> <span class="n">im</span><span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="mi">3</span><span class="p">,</span> <span class="n">y</span><span class="o">+</span><span class="mi">9</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="galsim.Image.subImage">
<code class="sig-name descname">subImage</code><span class="sig-paren">(</span><em class="sig-param">bounds</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/image.html#Image.subImage"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.Image.subImage" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a view of a portion of the full image</p>
<p>This is equivalent to self[bounds]</p>
</dd></dl>

<dl class="method">
<dt id="galsim.Image.subsample">
<code class="sig-name descname">subsample</code><span class="sig-paren">(</span><em class="sig-param">nx</em>, <em class="sig-param">ny</em>, <em class="sig-param">dtype=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/image.html#Image.subsample"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.Image.subsample" title="Permalink to this definition">¶</a></dt>
<dd><p>Subdivide the image pixels into nx x ny sub-pixels.</p>
<p>This returns a new image that is a subsampled version of the current image.
Each pixel’s flux is split (uniformly) into nx x ny smaller pixels.</p>
<p>See also bin, which is the opposite of this.  Note that subsample(nx,ny) followed by
bin(nx,ny) is essentially a no op.</p>
<p>If the wcs is a Jacobian (or simpler), the output image will have its wcs set properly.
But if the wcs is more complicated, the output wcs would be fairly complicated to figure
out properly, so we leave it as None.  The user should set it themselves if required.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>nx</strong> – The number of sub-pixels in the x direction for each original pixel.</p></li>
<li><p><strong>ny</strong> – The number of sub-pixels in the y direction for each original pixel.</p></li>
<li><p><strong>dtype</strong> – Optionally provide a dtype for the return image. [default: None, which
means to use the same dtype as the original image]</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a new <a class="reference internal" href="#galsim.Image" title="galsim.Image"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Image</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.Image.symmetrizeNoise">
<code class="sig-name descname">symmetrizeNoise</code><span class="sig-paren">(</span><em class="sig-param">noise</em>, <em class="sig-param">order=4</em><span class="sig-paren">)</span><a class="headerlink" href="#galsim.Image.symmetrizeNoise" title="Permalink to this definition">¶</a></dt>
<dd><p>Impose N-fold symmetry (where N=``order`` is an even integer &gt;=4) on the noise in a square
image assuming that the noise currently in the image can be described by the
<a class="reference internal" href="corr_noise.html#galsim.BaseCorrelatedNoise" title="galsim.BaseCorrelatedNoise"><code class="xref any py py-class docutils literal notranslate"><span class="pre">BaseCorrelatedNoise</span></code></a> object <code class="docutils literal notranslate"><span class="pre">noise</span></code>.  See <a class="reference internal" href="corr_noise.html#galsim.BaseCorrelatedNoise.symmetrizeImage" title="galsim.BaseCorrelatedNoise.symmetrizeImage"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">BaseCorrelatedNoise.symmetrizeImage</span></code></a> for more
details of how this method works.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>noise</strong> – The <a class="reference internal" href="corr_noise.html#galsim.BaseCorrelatedNoise" title="galsim.BaseCorrelatedNoise"><code class="xref any py py-class docutils literal notranslate"><span class="pre">BaseCorrelatedNoise</span></code></a> model to use when figuring out how much noise to add
to make the final noise have symmetry at the desired order.</p></li>
<li><p><strong>order</strong> – Desired symmetry order.  Must be an even integer larger than 2.
[default: 4]</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the theoretically calculated variance of the combined noise fields in the updated image.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.Image.true_center">
<em class="property">property </em><code class="sig-name descname">true_center</code><a class="headerlink" href="#galsim.Image.true_center" title="Permalink to this definition">¶</a></dt>
<dd><p>The current true center of the image as a PositionD instance.</p>
<p>Unline the nominal center returned by im.center, this value may be half-way between
two pixels if the image has an even number of rows or columns.  It gives the position
(x,y) at the exact center of the image, regardless of whether this is at the center of
a pixel (integer value) or halfway between two (half-integer).  For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">im</span> <span class="o">=</span> <span class="n">galsim</span><span class="o">.</span><span class="n">Image</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">16</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">im</span><span class="o">.</span><span class="n">center</span>
<span class="go">galsim.PositionI(x=3, y=3)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">im</span><span class="o">.</span><span class="n">true_center</span>
<span class="go">galsim.PositionI(x=2.5, y=2.5)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">im</span><span class="o">.</span><span class="n">setCenter</span><span class="p">(</span><span class="mi">56</span><span class="p">,</span><span class="mi">72</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">im</span><span class="o">.</span><span class="n">center</span>
<span class="go">galsim.PositionI(x=56, y=72)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">im</span><span class="o">.</span><span class="n">true_center</span>
<span class="go">galsim.PositionD(x=55.5, y=71.5)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">im</span><span class="o">.</span><span class="n">setOrigin</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">im</span><span class="o">.</span><span class="n">true_center</span>
<span class="go">galsim.PositionD(x=1.5, y=1.5)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="galsim.Image.view">
<code class="sig-name descname">view</code><span class="sig-paren">(</span><em class="sig-param">scale=None</em>, <em class="sig-param">wcs=None</em>, <em class="sig-param">origin=None</em>, <em class="sig-param">center=None</em>, <em class="sig-param">make_const=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/image.html#Image.view"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.Image.view" title="Permalink to this definition">¶</a></dt>
<dd><p>Make a view of this image, which lets you change the scale, wcs, origin, etc.
but view the same underlying data as the original image.</p>
<p>If you do not provide either <code class="docutils literal notranslate"><span class="pre">scale</span></code> or <code class="docutils literal notranslate"><span class="pre">wcs</span></code>, the view will keep the same wcs
as the current <a class="reference internal" href="#galsim.Image" title="galsim.Image"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Image</span></code></a> object.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>scale</strong> – If provided, use this as the pixel scale for the image. [default: None]</p></li>
<li><p><strong>wcs</strong> – If provided, use this as the wcs for the image. [default: None]</p></li>
<li><p><strong>origin</strong> – If profided, use this as the origin position of the view.
[default: None]</p></li>
<li><p><strong>center</strong> – If profided, use this as the center position of the view.
[default: None]</p></li>
<li><p><strong>make_const</strong> – Make the view’s data array immutable. [default: False]</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.Image.whitenNoise">
<code class="sig-name descname">whitenNoise</code><span class="sig-paren">(</span><em class="sig-param">noise</em><span class="sig-paren">)</span><a class="headerlink" href="#galsim.Image.whitenNoise" title="Permalink to this definition">¶</a></dt>
<dd><p>Whiten the noise in the image assuming that the noise currently in the image can be described
by the <a class="reference internal" href="corr_noise.html#galsim.BaseCorrelatedNoise" title="galsim.BaseCorrelatedNoise"><code class="xref any py py-class docutils literal notranslate"><span class="pre">BaseCorrelatedNoise</span></code></a> object <code class="docutils literal notranslate"><span class="pre">noise</span></code>.  See <a class="reference internal" href="corr_noise.html#galsim.BaseCorrelatedNoise.whitenImage" title="galsim.BaseCorrelatedNoise.whitenImage"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">BaseCorrelatedNoise.whitenImage</span></code></a> for more
details of how this method works.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>noise</strong> – The <a class="reference internal" href="corr_noise.html#galsim.BaseCorrelatedNoise" title="galsim.BaseCorrelatedNoise"><code class="xref any py py-class docutils literal notranslate"><span class="pre">BaseCorrelatedNoise</span></code></a> model to use when figuring out how much noise to add
to make the final noise white.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the theoretically calculated variance of the combined noise fields in the updated image.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.Image.wrap">
<code class="sig-name descname">wrap</code><span class="sig-paren">(</span><em class="sig-param">bounds</em>, <em class="sig-param">hermitian=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/image.html#Image.wrap"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.Image.wrap" title="Permalink to this definition">¶</a></dt>
<dd><p>Wrap the values in a image onto a given subimage and return the subimage.</p>
<p>This would typically be used on a k-space image where you initially draw a larger image
than you want for the FFT and then wrap it onto a smaller subset.  This will cause
aliasing of course, but this is often preferable to just using the smaller image
without wrapping.</p>
<p>For complex images of FFTs, one often only stores half the image plane with the
implicit understanding that the function is Hermitian, so im(-x,-y) == im(x,y).conjugate().
In this case, the wrapping needs to work slightly differently, so you can specify
that your image is implicitly Hermitian with the <code class="docutils literal notranslate"><span class="pre">hermitian</span></code> argument.  Options are:</p>
<dl class="simple">
<dt>hermitian=False</dt><dd><p>(default) Normal non-Hermitian image.</p>
</dd>
<dt>hermitian=’x’</dt><dd><p>Only x&gt;=0 values are stored with x&lt;0 values being implicitly Hermitian.
In this case im.bounds.xmin and bounds.xmin must be 0.</p>
</dd>
<dt>hermitian=’y’</dt><dd><p>Only y&gt;=0 values are stored with y&lt;0 values being implicitly Hermitian.
In this case im.bounds.ymin and bounds.ymin must be 0.</p>
</dd>
</dl>
<p>Also, in the two Hermitian cases, the direction that is not implicitly Hermitian must be
symmetric in the image’s bounds.  The wrap bounds must be almost symmetric, but missing
the most negative value.  For example,:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">N</span> <span class="o">=</span> <span class="mi">100</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">im_full</span> <span class="o">=</span> <span class="n">galsim</span><span class="o">.</span><span class="n">ImageCD</span><span class="p">(</span><span class="n">bounds</span><span class="o">=</span><span class="n">galsim</span><span class="o">.</span><span class="n">BoundsI</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">N</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="n">N</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="n">N</span><span class="o">/</span><span class="mi">2</span><span class="p">),</span> <span class="n">scale</span><span class="o">=</span><span class="n">dk</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># ... fill with im[i,j] = FT(kx=i*dk, ky=j*dk)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">N2</span> <span class="o">=</span> <span class="mi">64</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">im_wrap</span> <span class="o">=</span> <span class="n">im_full</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="n">galsim</span><span class="o">.</span><span class="n">BoundsI</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">N</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="n">N2</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="n">N2</span><span class="o">/</span><span class="mi">2</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">hermitian</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>This sets up im_wrap to be the properly Hermitian version of the data appropriate for
passing to an FFT.</p>
<p>Note that this routine modifies the original image (and not just the subimage onto which
it is wrapped), so if you want to keep the original pristine, you should call
<code class="docutils literal notranslate"><span class="pre">wrapped_image</span> <span class="pre">=</span> <span class="pre">image.copy().wrap(bounds)</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>bounds</strong> – The bounds of the subimage onto which to wrap the full image.</p></li>
<li><p><strong>hermitian</strong> – Whether the image is implicitly Hermitian and if so, whether it is the
x or y values that are not stored.  [default: False]</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the subimage, image[bounds], after doing the wrapping.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.Image.write">
<code class="sig-name descname">write</code><span class="sig-paren">(</span><em class="sig-param">file_name=None</em>, <em class="sig-param">dir=None</em>, <em class="sig-param">hdu_list=None</em>, <em class="sig-param">clobber=True</em>, <em class="sig-param">compression='auto'</em><span class="sig-paren">)</span><a class="headerlink" href="#galsim.Image.write" title="Permalink to this definition">¶</a></dt>
<dd><p>Write a single image to a FITS file.</p>
<p>Write the <a class="reference internal" href="#galsim.Image" title="galsim.Image"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Image</span></code></a> instance <code class="docutils literal notranslate"><span class="pre">image</span></code> to a FITS file, with details depending on the arguments.
This function can be called directly as <code class="docutils literal notranslate"><span class="pre">galsim.fits.write(image,</span> <span class="pre">...)</span></code>, with the image as the
first argument, or as an <a class="reference internal" href="#galsim.Image" title="galsim.Image"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Image</span></code></a> method: <code class="docutils literal notranslate"><span class="pre">image.write(...)</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>image</strong> – The <a class="reference internal" href="#galsim.Image" title="galsim.Image"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Image</span></code></a> to write to file.  Per the description of this method, it may be
given explicitly via <code class="docutils literal notranslate"><span class="pre">galsim.fits.write(image,</span> <span class="pre">...)</span></code> or the method may be
called directly as an image method, <code class="docutils literal notranslate"><span class="pre">image.write(...)</span></code>.  Note that if the
image has a ‘header’ attribute containing a <a class="reference internal" href="fits.html#galsim.fits.FitsHeader" title="galsim.fits.FitsHeader"><code class="xref any py py-class docutils literal notranslate"><span class="pre">FitsHeader</span></code></a>, then the
<a class="reference internal" href="fits.html#galsim.fits.FitsHeader" title="galsim.fits.FitsHeader"><code class="xref any py py-class docutils literal notranslate"><span class="pre">FitsHeader</span></code></a> is written to the header in the PrimaryHDU, followed by the
WCS as usual.</p></li>
<li><p><strong>file_name</strong> – The name of the file to write to.  [Either <code class="docutils literal notranslate"><span class="pre">file_name</span></code> or <code class="docutils literal notranslate"><span class="pre">hdu_list</span></code> is
required.]</p></li>
<li><p><strong>dir</strong> – Optionally a directory name can be provided if <code class="docutils literal notranslate"><span class="pre">file_name</span></code> does not
already include it. [default: None]</p></li>
<li><p><strong>hdu_list</strong> – An astropy.io.fits.HDUList.  If this is provided instead of <code class="docutils literal notranslate"><span class="pre">file_name</span></code>,
then the <a class="reference internal" href="#galsim.Image" title="galsim.Image"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Image</span></code></a> is appended to the end of the HDUList as a new HDU. In
that case, the user is responsible for calling either
<code class="docutils literal notranslate"><span class="pre">hdu_list.writeto(...)</span></code> or <code class="docutils literal notranslate"><span class="pre">galsim.fits.writeFile(...)</span></code> afterwards.
[Either <code class="docutils literal notranslate"><span class="pre">file_name</span></code> or <code class="docutils literal notranslate"><span class="pre">hdu_list</span></code> is required.]</p></li>
<li><p><strong>clobber</strong> – Setting <code class="docutils literal notranslate"><span class="pre">clobber=True</span></code> will silently overwrite existing files.
[default: True]</p></li>
<li><p><strong>compression</strong> – <p>Which compression scheme to use (if any).  Options are:</p>
<ul>
<li><p>None or ‘none’ = no compression</p></li>
<li><p>’rice’ = use rice compression in tiles (preserves header readability)</p></li>
<li><p>’gzip’ = use gzip to compress the full file</p></li>
<li><p>’bzip2’ = use bzip2 to compress the full file</p></li>
<li><p>’gzip_tile’ = use gzip in tiles (preserves header readability)</p></li>
<li><p>’hcompress’ = use hcompress in tiles (only valid for 2-d images)</p></li>
<li><p>’plio’ = use plio compression in tiles (only valid for pos integer data)</p></li>
<li><p>’auto’ = determine the compression from the extension of the file name
(requires <code class="docutils literal notranslate"><span class="pre">file_name</span></code> to be given):</p>
<ul>
<li><p>’.fz’ =&gt; ‘rice’</p></li>
<li><p>’.gz’ =&gt; ‘gzip’</p></li>
<li><p>’.bz2’ =&gt; ‘bzip2’</p></li>
<li><p>otherwise None</p></li>
</ul>
</li>
</ul>
<p>[default: ‘auto’]</p>
</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.Image.xmax">
<em class="property">property </em><code class="sig-name descname">xmax</code><a class="headerlink" href="#galsim.Image.xmax" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for self.bounds.xmax.</p>
</dd></dl>

<dl class="method">
<dt id="galsim.Image.xmin">
<em class="property">property </em><code class="sig-name descname">xmin</code><a class="headerlink" href="#galsim.Image.xmin" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for self.bounds.xmin.</p>
</dd></dl>

<dl class="method">
<dt id="galsim.Image.ymax">
<em class="property">property </em><code class="sig-name descname">ymax</code><a class="headerlink" href="#galsim.Image.ymax" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for self.bounds.ymax.</p>
</dd></dl>

<dl class="method">
<dt id="galsim.Image.ymin">
<em class="property">property </em><code class="sig-name descname">ymin</code><a class="headerlink" href="#galsim.Image.ymin" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for self.bounds.ymin.</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="galsim._Image">
<code class="sig-prename descclassname">galsim.</code><code class="sig-name descname">_Image</code><span class="sig-paren">(</span><em class="sig-param">array</em>, <em class="sig-param">bounds</em>, <em class="sig-param">wcs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/image.html#_Image"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim._Image" title="Permalink to this definition">¶</a></dt>
<dd><p>Equivalent to <code class="docutils literal notranslate"><span class="pre">Image(array,</span> <span class="pre">bounds,</span> <span class="pre">wcs)</span></code>, but without the overhead of sanity checks,
and the other options for how to provide the arguments.</p>
</dd></dl>

<dl class="function">
<dt id="galsim.ImageF">
<code class="sig-prename descclassname">galsim.</code><code class="sig-name descname">ImageF</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/image.html#ImageF"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.ImageF" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for galsim.Image(…, dtype=numpy.float32)</p>
</dd></dl>

<dl class="function">
<dt id="galsim.ImageD">
<code class="sig-prename descclassname">galsim.</code><code class="sig-name descname">ImageD</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/image.html#ImageD"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.ImageD" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for galsim.Image(…, dtype=numpy.float64)</p>
</dd></dl>

<dl class="function">
<dt id="galsim.ImageI">
<code class="sig-prename descclassname">galsim.</code><code class="sig-name descname">ImageI</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/image.html#ImageI"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.ImageI" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for galsim.Image(…, dtype=numpy.int32)</p>
</dd></dl>

<dl class="function">
<dt id="galsim.ImageS">
<code class="sig-prename descclassname">galsim.</code><code class="sig-name descname">ImageS</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/image.html#ImageS"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.ImageS" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for galsim.Image(…, dtype=numpy.int16)</p>
</dd></dl>

<dl class="function">
<dt id="galsim.ImageUI">
<code class="sig-prename descclassname">galsim.</code><code class="sig-name descname">ImageUI</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/image.html#ImageUI"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.ImageUI" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for galsim.Image(…, dtype=numpy.uint32)</p>
</dd></dl>

<dl class="function">
<dt id="galsim.ImageUS">
<code class="sig-prename descclassname">galsim.</code><code class="sig-name descname">ImageUS</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/image.html#ImageUS"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.ImageUS" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for galsim.Image(…, dtype=numpy.uint16)</p>
</dd></dl>

<dl class="function">
<dt id="galsim.ImageCF">
<code class="sig-prename descclassname">galsim.</code><code class="sig-name descname">ImageCF</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/image.html#ImageCF"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.ImageCF" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for galsim.Image(…, dtype=numpy.complex64)</p>
</dd></dl>

<dl class="function">
<dt id="galsim.ImageCD">
<code class="sig-prename descclassname">galsim.</code><code class="sig-name descname">ImageCD</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/image.html#ImageCD"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.ImageCD" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for galsim.Image(…, dtype=numpy.complex128)</p>
</dd></dl>

</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="bounds.html" class="btn btn-neutral float-right" title="Bounding boxes" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="image.html" class="btn btn-neutral float-left" title="Images and Related Concepts" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, GalSim-developers

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>