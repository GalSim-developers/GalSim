

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>The GSObject base class &mdash; GalSim 2.2.0 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script type="text/javascript" src="_static/jquery.js"></script>
        <script type="text/javascript" src="_static/underscore.js"></script>
        <script type="text/javascript" src="_static/doctools.js"></script>
        <script type="text/javascript" src="_static/language_data.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Simple Profiles" href="simple.html" />
    <link rel="prev" title="Surface Brightness Profiles" href="sb.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> GalSim
          

          
          </a>

          
            
            
              <div class="version">
                2.2
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="overview.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="install.html">Installation Instructions</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorials.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="image.html">Images and Related Concepts</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="sb.html">Surface Brightness Profiles</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#">The GSObject base class</a></li>
<li class="toctree-l2"><a class="reference internal" href="simple.html">Simple Profiles</a></li>
<li class="toctree-l2"><a class="reference internal" href="psf.html">Point-spread functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="gal.html">Galaxies</a></li>
<li class="toctree-l2"><a class="reference internal" href="arbitrary.html">Aribtrary Profiles</a></li>
<li class="toctree-l2"><a class="reference internal" href="phase_psf.html">Phase-screen PSFs</a></li>
<li class="toctree-l2"><a class="reference internal" href="real_gal.html">“Real” Galaxies</a></li>
<li class="toctree-l2"><a class="reference internal" href="composite.html">Composite Profiles</a></li>
<li class="toctree-l2"><a class="reference internal" href="transform.html">Transformed Profiles</a></li>
<li class="toctree-l2"><a class="reference internal" href="gsparams.html">The GSParams class</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="chromatic.html">Wavelength-dependent Profiles</a></li>
<li class="toctree-l1"><a class="reference internal" href="units.html">Units</a></li>
<li class="toctree-l1"><a class="reference internal" href="wcs.html">World Coordinate Systems</a></li>
<li class="toctree-l1"><a class="reference internal" href="random.html">Noise and Random Values</a></li>
<li class="toctree-l1"><a class="reference internal" href="wl.html">Weak Lensing</a></li>
<li class="toctree-l1"><a class="reference internal" href="photon.html">Photon Shooting</a></li>
<li class="toctree-l1"><a class="reference internal" href="utilities.html">Helper Functions and Classes</a></li>
<li class="toctree-l1"><a class="reference internal" href="errors.html">Errors and Warnings</a></li>
<li class="toctree-l1"><a class="reference internal" href="config.html">The Config Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="hsm.html">The HSM Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="des.html">The DES Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="wfirst.html">The WFIRST Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="shared.html">Shared Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="history.html">Revision History</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">GalSim</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
          <li><a href="sb.html">Surface Brightness Profiles</a> &raquo;</li>
        
      <li>The GSObject base class</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/gsobject.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="the-gsobject-base-class">
<h1>The GSObject base class<a class="headerlink" href="#the-gsobject-base-class" title="Permalink to this headline">¶</a></h1>
<p>This class defines most of the public API methods for how to use one of the various
surface brightness profiles like transforming it, drawing it, etc.</p>
<p>Note that not all methods are allowed to be called for all subclasses.  For instance,
some classes only define the profile in Fourier space, so methods which need to access
the profile in real space may not be implemented.  In such cases, a NotImplementedError
will be raised.</p>
<dl class="class">
<dt id="galsim.GSObject">
<em class="property">class </em><code class="sig-prename descclassname">galsim.</code><code class="sig-name descname">GSObject</code><a class="reference internal" href="_modules/galsim/gsobject.html#GSObject"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.GSObject" title="Permalink to this definition">¶</a></dt>
<dd><p>Base class for all GalSim classes that represent some kind of surface brightness profile.</p>
<p>A GSObject is not intended to be constructed directly.  Normally, you would use whatever
derived class is appropriate for the surface brightness profile you want:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gal</span> <span class="o">=</span> <span class="n">galsim</span><span class="o">.</span><span class="n">Sersic</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">half_light_radius</span><span class="o">=</span><span class="mf">4.3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">psf</span> <span class="o">=</span> <span class="n">galsim</span><span class="o">.</span><span class="n">Moffat</span><span class="p">(</span><span class="n">beta</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">fwhm</span><span class="o">=</span><span class="mf">2.85</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">conv</span> <span class="o">=</span> <span class="n">galsim</span><span class="o">.</span><span class="n">Convolve</span><span class="p">([</span><span class="n">gal</span><span class="p">,</span><span class="n">psf</span><span class="p">])</span>
</pre></div>
</div>
<p>All of these classes are subclasses of GSObject, so you should see those docstrings for
more details about how to construct the various profiles.  Here we discuss attributes and
methods that are common to all GSObjects.</p>
<p>GSObjects are always defined in sky coordinates.  So all sizes and other linear dimensions
should be in terms of some kind of units on the sky, arcsec for instance.  Only later (when
they are drawn) is the connection to pixel coordinates established via a pixel scale or WCS.
(See the documentation for galsim.BaseWCS for more details about how to specify various kinds
of world coordinate systems more complicated than a simple pixel scale.)</p>
<p>For instance, if you eventually draw onto an image that has a pixel scale of 0.2 arcsec/pixel,
then the normal thing to do would be to define your surface brightness profiles in terms of
arcsec and then draw with <code class="docutils literal notranslate"><span class="pre">pixel_scale=0.2</span></code>.  However, while arcsec are the usual choice of
units for the sky coordinates, if you wanted, you could instead define the sizes of all your
galaxies and PSFs in terms of radians and then use <code class="docutils literal notranslate"><span class="pre">pixel_scale=0.2/206265</span></code> when you draw
them.</p>
<p><strong>Transforming methods</strong>:</p>
<p>The GSObject class uses an “immutable” design[1], so all methods that would potentially modify
the object actually return a new object instead.  This uses pointers and such behind the
scenes, so it all happens efficiently, but it makes using the objects a bit simpler, since
you don’t need to worry about some function changing your object behind your back.</p>
<p>In all cases below, we just give an example usage.  See the docstrings for the methods for
more details about how to use them.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">obj</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">shear</span><span class="p">(</span><span class="n">shear</span><span class="p">)</span>      <span class="c1"># Apply a shear to the object.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">obj</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">dilate</span><span class="p">(</span><span class="n">scale</span><span class="p">)</span>     <span class="c1"># Apply a flux-preserving dilation.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">obj</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">magnify</span><span class="p">(</span><span class="n">mu</span><span class="p">)</span>       <span class="c1"># Apply a surface-brightness-preserving magnification.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">obj</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>     <span class="c1"># Apply a rotation.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">obj</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span><span class="n">dx</span><span class="p">,</span><span class="n">dy</span><span class="p">)</span>      <span class="c1"># Shft the object in real space.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">obj</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">dudx</span><span class="p">,</span><span class="n">dudy</span><span class="p">,</span><span class="n">dvdx</span><span class="p">,</span><span class="n">dvdy</span><span class="p">)</span>    <span class="c1"># Apply a general jacobian transformation.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">obj</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">lens</span><span class="p">(</span><span class="n">g1</span><span class="p">,</span><span class="n">g2</span><span class="p">,</span><span class="n">mu</span><span class="p">)</span>    <span class="c1"># Apply both a lensing shear and magnification.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">obj</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">withFlux</span><span class="p">(</span><span class="n">flux</span><span class="p">)</span>    <span class="c1"># Set a new flux value.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">obj</span> <span class="o">=</span> <span class="n">obj</span> <span class="o">*</span> <span class="n">ratio</span>           <span class="c1"># Scale the surface brightness profile by some factor.</span>
</pre></div>
</div>
<p><strong>Access Methods</strong>:</p>
<p>There are some access methods and properties that are available for all GSObjects.
Again, see the docstrings for each method for more details.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">obj</span><span class="o">.</span><span class="n">flux</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">obj</span><span class="o">.</span><span class="n">centroid</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">obj</span><span class="o">.</span><span class="n">nyquist_scale</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">obj</span><span class="o">.</span><span class="n">stepk</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">obj</span><span class="o">.</span><span class="n">maxk</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">obj</span><span class="o">.</span><span class="n">has_hard_edges</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">obj</span><span class="o">.</span><span class="n">is_axisymmetric</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">obj</span><span class="o">.</span><span class="n">is_analytic_x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">obj</span><span class="o">.</span><span class="n">is_analytic_k</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">obj</span><span class="o">.</span><span class="n">xValue</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="ow">or</span> <span class="n">obj</span><span class="o">.</span><span class="n">xValue</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">obj</span><span class="o">.</span><span class="n">kValue</span><span class="p">(</span><span class="n">kx</span><span class="p">,</span><span class="n">ky</span><span class="p">)</span> <span class="n">os</span> <span class="n">obj</span><span class="o">.</span><span class="n">kValue</span><span class="p">(</span><span class="n">kpos</span><span class="p">)</span>
</pre></div>
</div>
<p>Most subclasses have additional methods that are available for values that are particular to
that specific surface brightness profile.  e.g. <code class="docutils literal notranslate"><span class="pre">sigma</span> <span class="pre">=</span> <span class="pre">gauss.sigma</span></code>.  However, note
that class-specific methods are not available after performing one of the above transforming
operations.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gal</span> <span class="o">=</span> <span class="n">galsim</span><span class="o">.</span><span class="n">Gaussian</span><span class="p">(</span><span class="n">sigma</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gal</span> <span class="o">=</span> <span class="n">gal</span><span class="o">.</span><span class="n">shear</span><span class="p">(</span><span class="n">g1</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">g2</span><span class="o">=</span><span class="mf">0.05</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sigma</span> <span class="o">=</span> <span class="n">gal</span><span class="o">.</span><span class="n">sigma</span>               <span class="c1"># This will raise an exception.</span>
</pre></div>
</div>
<p>It is however possible to access the original object that was transformed via the
<code class="docutils literal notranslate"><span class="pre">original</span></code> attribute.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sigma</span> <span class="o">=</span> <span class="n">gal</span><span class="o">.</span><span class="n">original</span><span class="o">.</span><span class="n">sigma</span>      <span class="c1"># This works.</span>
</pre></div>
</div>
<p>No matter how many transformations are performed, the <code class="docutils literal notranslate"><span class="pre">original</span></code> attribute will contain the
_original_ object (not necessarily the most recent ancestor).</p>
<p><strong>Drawing Methods</strong>:</p>
<p>The main thing to do with a GSObject once you have built it is to draw it onto an image.
There are two methods that do this.  In both cases, there are lots of optional parameters.
See the docstrings for these methods for more details.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">drawImage</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">kimage</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">drawKImage</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
</pre></div>
</div>
<p>There two attributes that may be available for a GSObject.</p>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>original</strong> – This was mentioned above as a way to access the original object that has
been transformed by one of the transforming methods.</p></li>
<li><p><strong>noise</strong> – Some types, like <a class="reference internal" href="real_gal.html#galsim.RealGalaxy" title="galsim.RealGalaxy"><code class="xref any py py-class docutils literal notranslate"><span class="pre">RealGalaxy</span></code></a>, set this attribute to be the intrinsic noise that
is already inherent in the profile and will thus be present when you draw the
object.  The noise is propagated correctly through the various transforming
methods, as well as convolutions and flux rescalings.  Note that the <code class="docutils literal notranslate"><span class="pre">noise</span></code>
attribute can be set directly by users even for GSObjects that do not naturally
have one. The typical use for this attribute is to use it to whiten the noise in
the image after drawing.  See <a class="reference internal" href="corr_noise.html#galsim.BaseCorrelatedNoise" title="galsim.BaseCorrelatedNoise"><code class="xref any py py-class docutils literal notranslate"><span class="pre">BaseCorrelatedNoise</span></code></a> for more details.</p></li>
</ul>
</dd>
</dl>
<p><strong>GSParams</strong>:</p>
<p>All GSObject classes take an optional <code class="docutils literal notranslate"><span class="pre">gsparams</span></code> argument, so we document that feature here.
For all documentation about the specific derived classes, please see the docstring for each
one individually.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">gsparams</span></code> argument can be used to specify various numbers that govern the tradeoff
between accuracy and speed for the calculations made in drawing a GSObject.  The numbers are
encapsulated in a class called <a class="reference internal" href="gsparams.html#galsim.GSParams" title="galsim.GSParams"><code class="xref any py py-class docutils literal notranslate"><span class="pre">GSParams</span></code></a>, and the user should make careful choices whenever
they opt to deviate from the defaults.  For more details about the parameters and their default
values, please see the docstring of the <a class="reference internal" href="gsparams.html#galsim.GSParams" title="galsim.GSParams"><code class="xref any py py-class docutils literal notranslate"><span class="pre">GSParams</span></code></a> class.</p>
<p>For example, let’s say you want to do something that requires an FFT larger than 4096 x 4096
(and you have enough memory to handle it!).  Then you can create a new <a class="reference internal" href="gsparams.html#galsim.GSParams" title="galsim.GSParams"><code class="xref any py py-class docutils literal notranslate"><span class="pre">GSParams</span></code></a> object with a
larger <code class="docutils literal notranslate"><span class="pre">maximum_fft_size</span></code> and pass that to your GSObject on construction:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gal</span> <span class="o">=</span> <span class="n">galsim</span><span class="o">.</span><span class="n">Sersic</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">half_light_radius</span><span class="o">=</span><span class="mf">4.3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">psf</span> <span class="o">=</span> <span class="n">galsim</span><span class="o">.</span><span class="n">Moffat</span><span class="p">(</span><span class="n">beta</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">fwhm</span><span class="o">=</span><span class="mf">2.85</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">conv</span> <span class="o">=</span> <span class="n">galsim</span><span class="o">.</span><span class="n">Convolve</span><span class="p">([</span><span class="n">gal</span><span class="p">,</span><span class="n">psf</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">im</span> <span class="o">=</span> <span class="n">galsim</span><span class="o">.</span><span class="n">Image</span><span class="p">(</span><span class="mi">1000</span><span class="p">,</span><span class="mi">1000</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mf">0.02</span><span class="p">)</span>        <span class="c1"># Note the very small pixel scale!</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">im</span> <span class="o">=</span> <span class="n">conv</span><span class="o">.</span><span class="n">drawImage</span><span class="p">(</span><span class="n">image</span><span class="o">=</span><span class="n">im</span><span class="p">)</span>                   <span class="c1"># This uses the default GSParams.</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
  File <span class="nb">&quot;galsim/gsobject.py&quot;</span>, line <span class="m">1666</span>, in <span class="n">drawImage</span>
    <span class="n">added_photons</span> <span class="o">=</span> <span class="n">prof</span><span class="o">.</span><span class="n">drawFFT</span><span class="p">(</span><span class="n">draw_image</span><span class="p">,</span> <span class="n">add</span><span class="p">)</span>
  File <span class="nb">&quot;galsim/gsobject.py&quot;</span>, line <span class="m">1877</span>, in <span class="n">drawFFT</span>
    <span class="n">kimage</span><span class="p">,</span> <span class="n">wrap_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">drawFFT_makeKImage</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
  File <span class="nb">&quot;galsim/gsobject.py&quot;</span>, line <span class="m">1802</span>, in <span class="n">drawFFT_makeKImage</span>
    <span class="k">raise</span> <span class="n">GalSimFFTSizeError</span><span class="p">(</span><span class="s2">&quot;drawFFT requires an FFT that is too large.&quot;</span><span class="p">,</span> <span class="n">Nk</span><span class="p">)</span>
<span class="gr">galsim.errors.GalSimFFTSizeError</span>: <span class="n">drawFFT requires an FFT that is too large.</span>
<span class="go">The required FFT size would be 12288 x 12288, which requires 3.38 GB of memory.</span>
<span class="go">If you can handle the large FFT, you may update gsparams.maximum_fft_size.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">big_fft_params</span> <span class="o">=</span> <span class="n">galsim</span><span class="o">.</span><span class="n">GSParams</span><span class="p">(</span><span class="n">maximum_fft_size</span><span class="o">=</span><span class="mi">12300</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">conv</span> <span class="o">=</span> <span class="n">galsim</span><span class="o">.</span><span class="n">Convolve</span><span class="p">([</span><span class="n">gal</span><span class="p">,</span><span class="n">psf</span><span class="p">],</span><span class="n">gsparams</span><span class="o">=</span><span class="n">big_fft_params</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">im</span> <span class="o">=</span> <span class="n">conv</span><span class="o">.</span><span class="n">drawImage</span><span class="p">(</span><span class="n">image</span><span class="o">=</span><span class="n">im</span><span class="p">)</span>                   <span class="c1"># Now it works (but is slow!)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">im</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;high_res_sersic.fits&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Note that for compound objects such as <a class="reference internal" href="composite.html#galsim.Convolution" title="galsim.Convolution"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Convolution</span></code></a> or <a class="reference internal" href="composite.html#galsim.Sum" title="galsim.Sum"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Sum</span></code></a>, not all <a class="reference internal" href="gsparams.html#galsim.GSParams" title="galsim.GSParams"><code class="xref any py py-class docutils literal notranslate"><span class="pre">GSParams</span></code></a> can be
changed when the compound object is created.  In the example given here, it is possible to
change parameters related to the drawing, but not the Fourier space parameters for the
components that go into the <a class="reference internal" href="composite.html#galsim.Convolution" title="galsim.Convolution"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Convolution</span></code></a>.  To get better sampling in Fourier space,
for example, the <code class="docutils literal notranslate"><span class="pre">gal</span></code> and/or <code class="docutils literal notranslate"><span class="pre">psf</span></code> should be created with <code class="docutils literal notranslate"><span class="pre">gsparams</span></code> that have a
non-default value of <code class="docutils literal notranslate"><span class="pre">folding_threshold</span></code>.  This statement applies to the threshold and
accuracy parameters.</p>
<dl class="method">
<dt id="galsim.GSObject.__add__">
<code class="sig-name descname">__add__</code><span class="sig-paren">(</span><em class="sig-param">other</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/gsobject.html#GSObject.__add__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.GSObject.__add__" title="Permalink to this definition">¶</a></dt>
<dd><p>Add two GSObjects.</p>
<p>Equivalent to Add(self, other)</p>
</dd></dl>

<dl class="method">
<dt id="galsim.GSObject.__sub__">
<code class="sig-name descname">__sub__</code><span class="sig-paren">(</span><em class="sig-param">other</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/gsobject.html#GSObject.__sub__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.GSObject.__sub__" title="Permalink to this definition">¶</a></dt>
<dd><p>Subtract two GSObjects.</p>
<p>Equivalent to Add(self, -1 * other)</p>
</dd></dl>

<dl class="method">
<dt id="galsim.GSObject.__mul__">
<code class="sig-name descname">__mul__</code><span class="sig-paren">(</span><em class="sig-param">other</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/gsobject.html#GSObject.__mul__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.GSObject.__mul__" title="Permalink to this definition">¶</a></dt>
<dd><p>Scale the flux of the object by the given factor.</p>
<p>obj * flux_ratio is equivalent to obj.withScaledFlux(flux_ratio)</p>
<p>It creates a new object that has the same profile as the original, but with the
surface brightness at every location scaled by the given amount.</p>
<p>You can also multiply by an <a class="reference internal" href="sed.html#galsim.SED" title="galsim.SED"><code class="xref any py py-class docutils literal notranslate"><span class="pre">SED</span></code></a>, which will create a <a class="reference internal" href="chromaticobject.html#galsim.ChromaticObject" title="galsim.ChromaticObject"><code class="xref any py py-class docutils literal notranslate"><span class="pre">ChromaticObject</span></code></a> where the <a class="reference internal" href="sed.html#galsim.SED" title="galsim.SED"><code class="xref any py py-class docutils literal notranslate"><span class="pre">SED</span></code></a>
acts like a wavelength-dependent <code class="docutils literal notranslate"><span class="pre">flux_ratio</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="galsim.GSObject.__rmul__">
<code class="sig-name descname">__rmul__</code><span class="sig-paren">(</span><em class="sig-param">other</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/gsobject.html#GSObject.__rmul__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.GSObject.__rmul__" title="Permalink to this definition">¶</a></dt>
<dd><p>Equivalent to obj * other.  See <a class="reference internal" href="#galsim.GSObject.__mul__" title="galsim.GSObject.__mul__"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">__mul__</span></code></a> for details.</p>
</dd></dl>

<dl class="method">
<dt id="galsim.GSObject.__div__">
<code class="sig-name descname">__div__</code><span class="sig-paren">(</span><em class="sig-param">other</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/gsobject.html#GSObject.__div__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.GSObject.__div__" title="Permalink to this definition">¶</a></dt>
<dd><p>Equivalent to obj * (1/other).  See <a class="reference internal" href="#galsim.GSObject.__mul__" title="galsim.GSObject.__mul__"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">__mul__</span></code></a> for details.</p>
</dd></dl>

<dl class="method">
<dt id="galsim.GSObject._xValue">
<code class="sig-name descname">_xValue</code><span class="sig-paren">(</span><em class="sig-param">pos</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/gsobject.html#GSObject._xValue"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.GSObject._xValue" title="Permalink to this definition">¶</a></dt>
<dd><p>Equivalent to <a class="reference internal" href="#galsim.GSObject.xValue" title="galsim.GSObject.xValue"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">xValue</span></code></a>, but <code class="docutils literal notranslate"><span class="pre">pos</span></code> must be a <a class="reference internal" href="pos.html#galsim.PositionD" title="galsim.PositionD"><code class="xref any py py-class docutils literal notranslate"><span class="pre">galsim.PositionD</span></code></a> instance</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>pos</strong> – The position at which you want the surface brightness of the object.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the surface brightness at that position.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.GSObject._kValue">
<code class="sig-name descname">_kValue</code><span class="sig-paren">(</span><em class="sig-param">kpos</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/gsobject.html#GSObject._kValue"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.GSObject._kValue" title="Permalink to this definition">¶</a></dt>
<dd><p>Equivalent to <a class="reference internal" href="#galsim.GSObject.kValue" title="galsim.GSObject.kValue"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">kValue</span></code></a>, but <code class="docutils literal notranslate"><span class="pre">kpos</span></code> must be a <a class="reference internal" href="pos.html#galsim.PositionD" title="galsim.PositionD"><code class="xref any py py-class docutils literal notranslate"><span class="pre">galsim.PositionD</span></code></a> instance.</p>
</dd></dl>

<dl class="method">
<dt id="galsim.GSObject._shear">
<code class="sig-name descname">_shear</code><span class="sig-paren">(</span><em class="sig-param">shear</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/gsobject.html#GSObject._shear"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.GSObject._shear" title="Permalink to this definition">¶</a></dt>
<dd><p>Equivalent to <a class="reference internal" href="#galsim.GSObject.shear" title="galsim.GSObject.shear"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">GSObject.shear</span></code></a>, but without the overhead of sanity checks or other
ways to input the <code class="docutils literal notranslate"><span class="pre">shear</span></code> value.</p>
<p>This is only valid for <a class="reference internal" href="#galsim.GSObject" title="galsim.GSObject"><code class="xref any py py-class docutils literal notranslate"><span class="pre">GSObject</span></code></a>.  For a <a class="reference internal" href="chromaticobject.html#galsim.ChromaticObject" title="galsim.ChromaticObject"><code class="xref any py py-class docutils literal notranslate"><span class="pre">ChromaticObject</span></code></a>, you must use the regular
<a class="reference internal" href="#galsim.GSObject.shear" title="galsim.GSObject.shear"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">GSObject.shear</span></code></a> method.</p>
<p>Also, it won’t propagate any noise attribute.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>shear</strong> – The <a class="reference internal" href="shear.html#galsim.Shear" title="galsim.Shear"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Shear</span></code></a> to be applied.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the sheared object.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.GSObject._shift">
<code class="sig-name descname">_shift</code><span class="sig-paren">(</span><em class="sig-param">offset</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/gsobject.html#GSObject._shift"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.GSObject._shift" title="Permalink to this definition">¶</a></dt>
<dd><p>Equivalent to <a class="reference internal" href="#galsim.GSObject.shift" title="galsim.GSObject.shift"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">shift</span></code></a>, but without the overhead of sanity checks or option
to give the shift as (dx,dy).</p>
<p>This is only valid for <a class="reference internal" href="#galsim.GSObject" title="galsim.GSObject"><code class="xref any py py-class docutils literal notranslate"><span class="pre">GSObject</span></code></a>.  For a <a class="reference internal" href="chromaticobject.html#galsim.ChromaticObject" title="galsim.ChromaticObject"><code class="xref any py py-class docutils literal notranslate"><span class="pre">ChromaticObject</span></code></a>, you must use the regular
<a class="reference internal" href="#galsim.GSObject.shift" title="galsim.GSObject.shift"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">shift</span></code></a> method.</p>
<p>Also, it won’t propagate any noise attribute.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>offset</strong> – The shift to apply, given as a <a class="reference internal" href="pos.html#galsim.PositionD" title="galsim.PositionD"><code class="xref any py py-class docutils literal notranslate"><span class="pre">PositionD</span></code></a></p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the shifted object.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.GSObject._drawReal">
<code class="sig-name descname">_drawReal</code><span class="sig-paren">(</span><em class="sig-param">image</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/gsobject.html#GSObject._drawReal"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.GSObject._drawReal" title="Permalink to this definition">¶</a></dt>
<dd><p>A version of <a class="reference internal" href="#galsim.GSObject.drawReal" title="galsim.GSObject.drawReal"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">drawReal</span></code></a> without the sanity checks or some options.</p>
<p>This is nearly equivalent to the regular <code class="docutils literal notranslate"><span class="pre">drawReal(image,</span> <span class="pre">add_to_image=False)</span></code>, but
the image’s dtype must be either float32 or float64, and it must have a c_contiguous array
(<code class="docutils literal notranslate"><span class="pre">image.iscontiguous</span></code> must be True).</p>
</dd></dl>

<dl class="method">
<dt id="galsim.GSObject._calculate_nphotons">
<code class="sig-name descname">_calculate_nphotons</code><span class="sig-paren">(</span><em class="sig-param">n_photons</em>, <em class="sig-param">poisson_flux</em>, <em class="sig-param">max_extra_noise</em>, <em class="sig-param">rng</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/gsobject.html#GSObject._calculate_nphotons"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.GSObject._calculate_nphotons" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate how many photons to shoot and what flux_ratio (called g) each one should
have in order to produce an image with the right S/N and total flux.</p>
<p>This routine is normally called by <a class="reference internal" href="#galsim.GSObject.drawPhot" title="galsim.GSObject.drawPhot"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">drawPhot</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>n_photons, g</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.GSObject._shoot">
<code class="sig-name descname">_shoot</code><span class="sig-paren">(</span><em class="sig-param">photons</em>, <em class="sig-param">rng</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/gsobject.html#GSObject._shoot"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.GSObject._shoot" title="Permalink to this definition">¶</a></dt>
<dd><p>Shoot photons into the given <a class="reference internal" href="photon_array.html#galsim.PhotonArray" title="galsim.PhotonArray"><code class="xref any py py-class docutils literal notranslate"><span class="pre">PhotonArray</span></code></a>.</p>
<p>This is the backend implementation of <a class="reference internal" href="#galsim.GSObject.shoot" title="galsim.GSObject.shoot"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">shoot</span></code></a> once the <a class="reference internal" href="photon_array.html#galsim.PhotonArray" title="galsim.PhotonArray"><code class="xref any py py-class docutils literal notranslate"><span class="pre">PhotonArray</span></code></a> has been constructed.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>photons</strong> – A <a class="reference internal" href="photon_array.html#galsim.PhotonArray" title="galsim.PhotonArray"><code class="xref any py py-class docutils literal notranslate"><span class="pre">PhotonArray</span></code></a> instance into which the photons should be placed.</p></li>
<li><p><strong>rng</strong> – A <a class="reference internal" href="deviate.html#galsim.BaseDeviate" title="galsim.BaseDeviate"><code class="xref any py py-class docutils literal notranslate"><span class="pre">BaseDeviate</span></code></a> instance to use for the photon shooting,</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.GSObject._drawKImage">
<code class="sig-name descname">_drawKImage</code><span class="sig-paren">(</span><em class="sig-param">image</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/gsobject.html#GSObject._drawKImage"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.GSObject._drawKImage" title="Permalink to this definition">¶</a></dt>
<dd><p>A version of <a class="reference internal" href="#galsim.GSObject.drawKImage" title="galsim.GSObject.drawKImage"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">drawKImage</span></code></a> without the sanity checks or some options.</p>
<p>Equivalent to <code class="docutils literal notranslate"><span class="pre">drawKImage(image,</span> <span class="pre">add_to_image=False,</span> <span class="pre">recenter=False,</span> <span class="pre">add_to_image=False)</span></code>,
but without the option to create the image automatically.</p>
<p>The input image must be provided as a complex <a class="reference internal" href="image_class.html#galsim.Image" title="galsim.Image"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Image</span></code></a> instance (dtype=complex64 or
complex128), and the bounds should be set up appropriately (e.g. with 0,0 in the center if
so desired).  This corresponds to recenter=False for the normal <a class="reference internal" href="#galsim.GSObject.drawKImage" title="galsim.GSObject.drawKImage"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">drawKImage</span></code></a>.  And, it must
have a c_contiguous array (image.iscontiguous must be True).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>image</strong> – The <a class="reference internal" href="image_class.html#galsim.Image" title="galsim.Image"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Image</span></code></a> onto which to draw the k-space image. [required]</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.GSObject.calculateFWHM">
<code class="sig-name descname">calculateFWHM</code><span class="sig-paren">(</span><em class="sig-param">size=None</em>, <em class="sig-param">scale=None</em>, <em class="sig-param">centroid=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/gsobject.html#GSObject.calculateFWHM"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.GSObject.calculateFWHM" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the full-width half-maximum (FWHM) of the object.</p>
<p>If the profile has a fwhm attribute, it will just return that, but in the general case,
we draw the profile and estimate the FWHM directly.</p>
<p>As with <a class="reference internal" href="#galsim.GSObject.calculateHLR" title="galsim.GSObject.calculateHLR"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">calculateHLR</span></code></a> and <a class="reference internal" href="#galsim.GSObject.calculateMomentRadius" title="galsim.GSObject.calculateMomentRadius"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">calculateMomentRadius</span></code></a>, this function optionally takes size and
scale values to use for the image drawing.  The default is to use the the Nyquist scale
for the pixel scale and let <a class="reference internal" href="#galsim.GSObject.drawImage" title="galsim.GSObject.drawImage"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">drawImage</span></code></a> choose a size for the stamp that will enclose at
least 99.5% of the flux.  These were found to produce results accurate to well below
one percent on our internal tests, so it is unlikely that you will want to adjust
them for accuracy.  However, using a smaller size than default could help speed up
the calculation, since the default is usually much larger than is needed.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>size</strong> – If given, the stamp size to use for the drawn image. [default: None,
which will let <a class="reference internal" href="#galsim.GSObject.drawImage" title="galsim.GSObject.drawImage"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">drawImage</span></code></a> choose the size automatically]</p></li>
<li><p><strong>scale</strong> – If given, the pixel scale to use for the drawn image. [default:
self.nyquist_scale]</p></li>
<li><p><strong>centroid</strong> – The position to use for the centroid. [default: self.centroid]</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>an estimate of the full-width half-maximum in physical units</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.GSObject.calculateHLR">
<code class="sig-name descname">calculateHLR</code><span class="sig-paren">(</span><em class="sig-param">size=None</em>, <em class="sig-param">scale=None</em>, <em class="sig-param">centroid=None</em>, <em class="sig-param">flux_frac=0.5</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/gsobject.html#GSObject.calculateHLR"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.GSObject.calculateHLR" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the half-light radius of the object.</p>
<p>If the profile has a half_light_radius attribute, it will just return that, but in the
general case, we draw the profile and estimate the half-light radius directly.</p>
<p>This function (by default at least) is only accurate to a few percent, typically.
Possibly worse depending on the profile being measured.  If you care about a high
precision estimate of the half-light radius, the accuracy can be improved using the
optional parameter scale to change the pixel scale used to draw the profile.</p>
<p>The default scale is half the Nyquist scale, which were found to produce results accurate
to a few percent on our internal tests.  Using a smaller scale will be more accurate at
the expense of speed.</p>
<p>In addition, you can optionally specify the size of the image to draw. The default size is
None, which means <a class="reference internal" href="#galsim.GSObject.drawImage" title="galsim.GSObject.drawImage"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">drawImage</span></code></a> will choose a size designed to contain around 99.5% of the
flux.  This is overkill for this calculation, so choosing a smaller size than this may
speed up this calculation somewhat.</p>
<p>Also, while the name of this function refers to the half-light radius, in fact it can also
calculate radii that enclose other fractions of the light, according to the parameter
<code class="docutils literal notranslate"><span class="pre">flux_frac</span></code>.  E.g. for r90, you would set flux_frac=0.90.</p>
<p>The default scale should usually be acceptable for things like testing that a galaxy
has a reasonable resolution, but they should not be trusted for very fine grain
discriminations.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>size</strong> – If given, the stamp size to use for the drawn image. [default: None,
which will let <a class="reference internal" href="#galsim.GSObject.drawImage" title="galsim.GSObject.drawImage"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">drawImage</span></code></a> choose the size automatically]</p></li>
<li><p><strong>scale</strong> – If given, the pixel scale to use for the drawn image. [default:
0.5 * self.nyquist_scale]</p></li>
<li><p><strong>centroid</strong> – The position to use for the centroid. [default: self.centroid]</p></li>
<li><p><strong>flux_frac</strong> – The fraction of light to be enclosed by the returned radius.
[default: 0.5]</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>an estimate of the half-light radius in physical units</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.GSObject.calculateMomentRadius">
<code class="sig-name descname">calculateMomentRadius</code><span class="sig-paren">(</span><em class="sig-param">size=None</em>, <em class="sig-param">scale=None</em>, <em class="sig-param">centroid=None</em>, <em class="sig-param">rtype='det'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/gsobject.html#GSObject.calculateMomentRadius"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.GSObject.calculateMomentRadius" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an estimate of the radius based on unweighted second moments.</p>
<p>The second moments are defined as:</p>
<p>Q_ij = int( I(x,y) i j dx dy ) / int( I(x,y) dx dy )
where i,j may be either x or y.</p>
<p>If I(x,y) is a Gaussian, then T = Tr(Q) = Qxx + Qyy = 2 sigma^2.  Thus, one reasonable
choice for a “radius” for an arbitrary profile is sqrt(T/2).</p>
<p>In addition, det(Q) = sigma^4.  So another choice for an arbitrary profile is det(Q)^1/4.</p>
<p>This routine can return either of these measures according to the value of the <code class="docutils literal notranslate"><span class="pre">rtype</span></code>
parameter.  <code class="docutils literal notranslate"><span class="pre">rtype='trace'</span></code> will cause it to return sqrt(T/2).  <code class="docutils literal notranslate"><span class="pre">rtype='det'</span></code> will cause
it to return det(Q)^1/4.  And <code class="docutils literal notranslate"><span class="pre">rtype='both'</span></code> will return a tuple with both values.</p>
<p>Note that for the special case of a Gaussian profile, no calculation is necessary, and
the <code class="docutils literal notranslate"><span class="pre">sigma</span></code> attribute will be used in both cases.  In the limit as scale-&gt;0, this
function will return the same value, but because finite pixels are drawn, the results
will not be precisely equal for real use cases.  The approximation being made is that
the integral of I(x,y) i j dx dy over each pixel can be approximated as
int(I(x,y) dx dy) * i_center * j_center.</p>
<p>This function (by default at least) is only accurate to a few percent, typically.
Possibly worse depending on the profile being measured.  If you care about a high
precision estimate of the radius, the accuracy can be improved using the optional
parameters size and scale to change the size and pixel scale used to draw the profile.</p>
<p>The default is to use the the Nyquist scale for the pixel scale and let <a class="reference internal" href="#galsim.GSObject.drawImage" title="galsim.GSObject.drawImage"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">drawImage</span></code></a>
choose a size for the stamp that will enclose at least 99.5% of the flux.  These
were found to produce results accurate to a few percent on our internal tests.
Using a smaller scale and larger size will be more accurate at the expense of speed.</p>
<p>The default parameters should usually be acceptable for things like testing that a galaxy
has a reasonable resolution, but they should not be trusted for very fine grain
discriminations.  For a more accurate estimate, see galsim.hsm.FindAdaptiveMom.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>size</strong> – If given, the stamp size to use for the drawn image. [default: None,
which will let <a class="reference internal" href="#galsim.GSObject.drawImage" title="galsim.GSObject.drawImage"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">drawImage</span></code></a> choose the size automatically]</p></li>
<li><p><strong>scale</strong> – If given, the pixel scale to use for the drawn image. [default:
self.nyquist_scale]</p></li>
<li><p><strong>centroid</strong> – The position to use for the centroid. [default: self.centroid]</p></li>
<li><p><strong>rtype</strong> – There are three options for this parameter:
- ‘trace’ means return sqrt(T/2)
- ‘det’ means return det(Q)^1/4
- ‘both’ means return both: (sqrt(T/2), det(Q)^1/4)
[default: ‘det’]</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>an estimate of the radius in physical units (or both estimates if rtype == ‘both’)</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.GSObject.centroid">
<em class="property">property </em><code class="sig-name descname">centroid</code><a class="headerlink" href="#galsim.GSObject.centroid" title="Permalink to this definition">¶</a></dt>
<dd><p>The (x, y) centroid of an object as a <a class="reference internal" href="pos.html#galsim.PositionD" title="galsim.PositionD"><code class="xref any py py-class docutils literal notranslate"><span class="pre">PositionD</span></code></a>.</p>
</dd></dl>

<dl class="method">
<dt id="galsim.GSObject.dilate">
<code class="sig-name descname">dilate</code><span class="sig-paren">(</span><em class="sig-param">scale</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/gsobject.html#GSObject.dilate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.GSObject.dilate" title="Permalink to this definition">¶</a></dt>
<dd><p>Dilate the linear size of the profile by the given <code class="docutils literal notranslate"><span class="pre">scale</span></code> factor, while preserving
flux.</p>
<p>e.g. <code class="docutils literal notranslate"><span class="pre">half_light_radius</span></code> &lt;– <code class="docutils literal notranslate"><span class="pre">half_light_radius</span> <span class="pre">*</span> <span class="pre">scale</span></code></p>
<p>See expand() and magnify() for versions that preserve surface brightness, and thus
changes the flux.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>scale</strong> – The linear rescaling factor to apply.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the dilated object.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.GSObject.drawFFT">
<code class="sig-name descname">drawFFT</code><span class="sig-paren">(</span><em class="sig-param">image</em>, <em class="sig-param">add_to_image=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/gsobject.html#GSObject.drawFFT"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.GSObject.drawFFT" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw this profile into an <a class="reference internal" href="image_class.html#galsim.Image" title="galsim.Image"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Image</span></code></a> by computing the k-space image and performing an FFT.</p>
<p>This is usually called from the <a class="reference internal" href="#galsim.GSObject.drawImage" title="galsim.GSObject.drawImage"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">drawImage</span></code></a> function, rather than called directly by the
user.  In particular, the input image must be already set up with defined bounds.  The
profile will be drawn centered on whatever pixel corresponds to (0,0) with the given
bounds, not the image center (unlike <a class="reference internal" href="#galsim.GSObject.drawImage" title="galsim.GSObject.drawImage"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">drawImage</span></code></a>).  The image also must have a <a class="reference internal" href="wcs.html#galsim.PixelScale" title="galsim.PixelScale"><code class="xref any py py-class docutils literal notranslate"><span class="pre">PixelScale</span></code></a>
wcs.  The profile being drawn should have already been converted to image coordinates via:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">image_profile</span> <span class="o">=</span> <span class="n">original_wcs</span><span class="o">.</span><span class="n">toImage</span><span class="p">(</span><span class="n">original_profile</span><span class="p">)</span>
</pre></div>
</div>
<p>Note that the <a class="reference internal" href="image_class.html#galsim.Image" title="galsim.Image"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Image</span></code></a> produced by drawFFT represents the profile sampled at the center
of each pixel and then multiplied by the pixel area.  That is, the profile is NOT
integrated over the area of the pixel.  This is equivalent to method=’no_pixel’ in
<a class="reference internal" href="#galsim.GSObject.drawImage" title="galsim.GSObject.drawImage"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">drawImage</span></code></a>.  If you want to render a profile integrated over the pixel, you can convolve
with a <a class="reference internal" href="simple.html#galsim.Pixel" title="galsim.Pixel"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Pixel</span></code></a> first and draw that.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>image</strong> – The <a class="reference internal" href="image_class.html#galsim.Image" title="galsim.Image"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Image</span></code></a> onto which to place the flux. [required]</p></li>
<li><p><strong>add_to_image</strong> – Whether to add flux to the existing image rather than clear out
anything in the image before drawing. [default: False]</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The total flux drawn inside the image bounds.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.GSObject.drawFFT_finish">
<code class="sig-name descname">drawFFT_finish</code><span class="sig-paren">(</span><em class="sig-param">image</em>, <em class="sig-param">kimage</em>, <em class="sig-param">wrap_size</em>, <em class="sig-param">add_to_image</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/gsobject.html#GSObject.drawFFT_finish"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.GSObject.drawFFT_finish" title="Permalink to this definition">¶</a></dt>
<dd><p>This is a helper routine for drawFFT that finishes the calculation, based on the
drawn k-space image.</p>
<p>It applies the Fourier transform to <code class="docutils literal notranslate"><span class="pre">kimage</span></code> and adds the result to <code class="docutils literal notranslate"><span class="pre">image</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>image</strong> – The <a class="reference internal" href="image_class.html#galsim.Image" title="galsim.Image"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Image</span></code></a> onto which to place the flux.</p></li>
<li><p><strong>kimage</strong> – The k-space <a class="reference internal" href="image_class.html#galsim.Image" title="galsim.Image"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Image</span></code></a> where the object was drawn.</p></li>
<li><p><strong>wrap_size</strong> – The size of the region to wrap kimage, which must be either the same
size as kimage or smaller.</p></li>
<li><p><strong>add_to_image</strong> – Whether to add flux to the existing image rather than clear out
anything in the image before drawing.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The total flux drawn inside the image bounds.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.GSObject.drawFFT_makeKImage">
<code class="sig-name descname">drawFFT_makeKImage</code><span class="sig-paren">(</span><em class="sig-param">image</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/gsobject.html#GSObject.drawFFT_makeKImage"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.GSObject.drawFFT_makeKImage" title="Permalink to this definition">¶</a></dt>
<dd><p>This is a helper routine for drawFFT that just makes the (blank) k-space image
onto which the profile will be drawn.  This can be useful if you want to break
up the calculation into parts for extra efficiency.  E.g. save the k-space image of
the PSF so drawing many models of the galaxy with the given PSF profile can avoid
drawing the PSF each time.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>image</strong> – The <a class="reference internal" href="image_class.html#galsim.Image" title="galsim.Image"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Image</span></code></a> onto which to place the flux.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>(kimage, wrap_size), where wrap_size is either the size of kimage or smaller if
the result should be wrapped before doing the inverse fft.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.GSObject.drawImage">
<code class="sig-name descname">drawImage</code><span class="sig-paren">(</span><em class="sig-param">image=None</em>, <em class="sig-param">nx=None</em>, <em class="sig-param">ny=None</em>, <em class="sig-param">bounds=None</em>, <em class="sig-param">scale=None</em>, <em class="sig-param">wcs=None</em>, <em class="sig-param">dtype=None</em>, <em class="sig-param">method='auto'</em>, <em class="sig-param">area=1.0</em>, <em class="sig-param">exptime=1.0</em>, <em class="sig-param">gain=1.0</em>, <em class="sig-param">add_to_image=False</em>, <em class="sig-param">center=None</em>, <em class="sig-param">use_true_center=True</em>, <em class="sig-param">offset=None</em>, <em class="sig-param">n_photons=0.0</em>, <em class="sig-param">rng=None</em>, <em class="sig-param">max_extra_noise=0.0</em>, <em class="sig-param">poisson_flux=None</em>, <em class="sig-param">sensor=None</em>, <em class="sig-param">surface_ops=()</em>, <em class="sig-param">n_subsample=3</em>, <em class="sig-param">maxN=None</em>, <em class="sig-param">save_photons=False</em>, <em class="sig-param">setup_only=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/gsobject.html#GSObject.drawImage"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.GSObject.drawImage" title="Permalink to this definition">¶</a></dt>
<dd><p>Draws an <a class="reference internal" href="image_class.html#galsim.Image" title="galsim.Image"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Image</span></code></a> of the object.</p>
<p>The drawImage() method is used to draw an <a class="reference internal" href="image_class.html#galsim.Image" title="galsim.Image"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Image</span></code></a> of the current object using one of several
possible rendering methods (see below).  It can create a new <a class="reference internal" href="image_class.html#galsim.Image" title="galsim.Image"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Image</span></code></a> or can draw onto an
existing one if provided by the <code class="docutils literal notranslate"><span class="pre">image</span></code> parameter.  If the <code class="docutils literal notranslate"><span class="pre">image</span></code> is given, you can
also optionally add to the given <a class="reference internal" href="image_class.html#galsim.Image" title="galsim.Image"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Image</span></code></a> if <code class="docutils literal notranslate"><span class="pre">add_to_image</span> <span class="pre">=</span> <span class="pre">True</span></code>, but the default is to
replace the current contents with new values.</p>
<p><strong>Providing an input image</strong>:</p>
<p>Note that if you provide an <code class="docutils literal notranslate"><span class="pre">image</span></code> parameter, it is the image onto which the profile
will be drawn.  The provided image <em>will be modified</em>.  A reference to the same image
is also returned to provide a parallel return behavior to when <code class="docutils literal notranslate"><span class="pre">image</span></code> is <code class="docutils literal notranslate"><span class="pre">None</span></code>
(described above).</p>
<p>This option is useful in practice because you may want to construct the image first and
then draw onto it, perhaps multiple times. For example, you might be drawing onto a
subimage of a larger image. Or you may want to draw different components of a complex
profile separately.  In this case, the returned value is typically ignored.  For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">im1</span> <span class="o">=</span> <span class="n">bulge</span><span class="o">.</span><span class="n">drawImage</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">im2</span> <span class="o">=</span> <span class="n">disk</span><span class="o">.</span><span class="n">drawImage</span><span class="p">(</span><span class="n">image</span><span class="o">=</span><span class="n">im1</span><span class="p">,</span> <span class="n">add_to_image</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">im1</span> <span class="ow">is</span> <span class="n">im2</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">full_image</span> <span class="o">=</span> <span class="n">galsim</span><span class="o">.</span><span class="n">Image</span><span class="p">(</span><span class="mi">2048</span><span class="p">,</span> <span class="mi">2048</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">pixel_scale</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">galsim</span><span class="o">.</span><span class="n">BoundsI</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">32</span><span class="p">,</span> <span class="n">x</span><span class="o">+</span><span class="mi">32</span><span class="p">,</span> <span class="n">y</span><span class="o">-</span><span class="mi">32</span><span class="p">,</span> <span class="n">y</span><span class="o">+</span><span class="mi">32</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stamp</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">drawImage</span><span class="p">(</span><span class="n">image</span> <span class="o">=</span> <span class="n">full_image</span><span class="p">[</span><span class="n">b</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="p">(</span><span class="n">stamp</span><span class="o">.</span><span class="n">array</span> <span class="o">==</span> <span class="n">full_image</span><span class="p">[</span><span class="n">b</span><span class="p">]</span><span class="o">.</span><span class="n">array</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
</pre></div>
</div>
<p><strong>Letting drawImage create the image for you</strong>:</p>
<p>If drawImage() will be creating the image from scratch for you, then there are several ways
to control the size of the new image.  If the <code class="docutils literal notranslate"><span class="pre">nx</span></code> and <code class="docutils literal notranslate"><span class="pre">ny</span></code> keywords are present, then
an image with these numbers of pixels on a side will be created.  Similarly, if the <code class="docutils literal notranslate"><span class="pre">bounds</span></code>
keyword is present, then an image with the specified bounds will be created.  Note that it
is an error to provide an existing <a class="reference internal" href="image_class.html#galsim.Image" title="galsim.Image"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Image</span></code></a> when also specifying <code class="docutils literal notranslate"><span class="pre">nx</span></code>, <code class="docutils literal notranslate"><span class="pre">ny</span></code>, or
<code class="docutils literal notranslate"><span class="pre">bounds</span></code>.  In the absence of <code class="docutils literal notranslate"><span class="pre">nx</span></code>, <code class="docutils literal notranslate"><span class="pre">ny</span></code>, and <code class="docutils literal notranslate"><span class="pre">bounds</span></code>, drawImage will decide a good
size to use based on the size of the object being drawn.  Basically, it will try to use an
area large enough to include at least 99.5% of the flux.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This value 0.995 is really <code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">-</span> <span class="pre">folding_threshold</span></code>.  You can change the value of
<code class="docutils literal notranslate"><span class="pre">folding_threshold</span></code> for any object via <a class="reference internal" href="gsparams.html#galsim.GSParams" title="galsim.GSParams"><code class="xref any py py-class docutils literal notranslate"><span class="pre">GSParams</span></code></a>.</p>
</div>
<p>You can set the pixel scale of the constructed image with the <code class="docutils literal notranslate"><span class="pre">scale</span></code> parameter, or set
a WCS function with <code class="docutils literal notranslate"><span class="pre">wcs</span></code>.  If you do not provide either <code class="docutils literal notranslate"><span class="pre">scale</span></code> or <code class="docutils literal notranslate"><span class="pre">wcs</span></code>, then
drawImage() will default to using the Nyquist scale for the current object.</p>
<p>You can also set the data type used in the new <a class="reference internal" href="image_class.html#galsim.Image" title="galsim.Image"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Image</span></code></a> with the <code class="docutils literal notranslate"><span class="pre">dtype</span></code> parameter that has
the same options as for the <a class="reference internal" href="image_class.html#galsim.Image" title="galsim.Image"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Image</span></code></a> constructor.</p>
<p><strong>The drawing “method”</strong>:</p>
<p>There are several different possible methods drawImage() can use for rendering the image.
This is set by the <code class="docutils literal notranslate"><span class="pre">method</span></code> parameter.  The options are:</p>
<dl class="simple">
<dt>auto</dt><dd><p>This is the default, which will normally be equivalent to ‘fft’.  However,
if the object being rendered is simple (no convolution) and has hard edges
(e.g. a Box or a truncated Moffat or Sersic), then it will switch to
‘real_space’, since that is often both faster and more accurate in these
cases (due to ringing in Fourier space).</p>
</dd>
<dt>fft</dt><dd><p>The integration of the light within each pixel is mathematically equivalent
to convolving by the pixel profile (a <a class="reference internal" href="simple.html#galsim.Pixel" title="galsim.Pixel"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Pixel</span></code></a> object) and sampling the result
at the centers of the pixels.  This method will do that convolution using
a discrete Fourier transform.  Furthermore, if the object (or any component
of it) has been transformed via shear(), dilate(), etc., then these
transformations are done in Fourier space as well.</p>
</dd>
<dt>real_space</dt><dd><p>This uses direct integrals (using the Gauss-Kronrod-Patterson algorithm)
in real space for the integration over the pixel response.  It is usually
slower than the ‘fft’ method, but if the profile has hard edges that cause
ringing in Fourier space, it can be faster and/or more accurate.  If you
use ‘real_space’ with something that is already a Convolution, then this
will revert to ‘fft’, since the double convolution that is required to also
handle the pixel response is far too slow to be practical using real-space
integrals.</p>
</dd>
<dt>phot</dt><dd><p>This uses a technique called photon shooting to render the image.
Essentially, the object profile is taken as a probability distribution
from which a finite number of photons are “shot” onto the image.  Each
photon’s flux gets added to whichever pixel the photon hits.  This process
automatically accounts for the integration of the light over the pixel
area, since all photons that hit any part of the pixel are counted.
Convolutions and transformations are simple geometric processes in this
framework.  However, there are two caveats with this method: (1) the
resulting image will have Poisson noise from the finite number of photons,
and (2) it is not available for all object types (notably anything that
includes a Deconvolution).</p>
</dd>
<dt>no_pixel</dt><dd><p>Instead of integrating over the pixels, this method will sample the profile
at the centers of the pixels and multiply by the pixel area.  If there is
a convolution involved, the choice of whether this will use an FFT or
real-space calculation is governed by the <code class="docutils literal notranslate"><span class="pre">real_space</span></code> parameter of the
Convolution class.  This method is the appropriate choice if you are using
a PSF that already includes a convolution by the pixel response.  For
example, if you are using a PSF from an observed image of a star, then it
has already been convolved by the pixel, so you would not want to do so
again.  Note: The multiplication by the pixel area gets the flux
normalization right for the above use case.  cf. <code class="docutils literal notranslate"><span class="pre">method</span> <span class="pre">=</span> <span class="pre">'sb'</span></code>.</p>
</dd>
<dt>sb</dt><dd><p>This is a lot like ‘no_pixel’, except that the image values will simply be
the sampled object profile’s surface brightness, not multiplied by the
pixel area.  This does not correspond to any real observing scenario, but
it could be useful if you want to view the surface brightness profile of an
object directly, without including the pixel integration.</p>
</dd>
</dl>
<p>The ‘phot’ method has a few extra parameters that adjust how it functions.  The total
number of photons to shoot is normally calculated from the object’s flux.  This flux is
taken to be given in photons/cm^2/s, so for most simple profiles, this times area * exptime
will equal the number of photons shot.  (See the discussion in Rowe et al, 2015, for why
this might be modified for <a class="reference internal" href="arbitrary.html#galsim.InterpolatedImage" title="galsim.InterpolatedImage"><code class="xref any py py-class docutils literal notranslate"><span class="pre">InterpolatedImage</span></code></a> and related profiles.)  However, you can
manually set a different number of photons with <code class="docutils literal notranslate"><span class="pre">n_photons</span></code>.  You can also set
<code class="docutils literal notranslate"><span class="pre">max_extra_noise</span></code> to tell drawImage() to use fewer photons than normal (and so is faster)
such that no more than that much extra noise is added to any pixel.  This is particularly
useful if you will be subsequently adding sky noise, and you can thus tolerate more noise
than the normal number of photons would give you, since using fewer photons is of course
faster.  Finally, the default behavior is to have the total flux vary as a Poisson random
variate, which is normally appropriate with photon shooting.  But you can turn this off with
<code class="docutils literal notranslate"><span class="pre">poisson_flux=False</span></code>.  It also defaults to False if you set an explicit value for
<code class="docutils literal notranslate"><span class="pre">n_photons</span></code>.</p>
<p>Given the periodicity implicit in the use of FFTs, there can occasionally be artifacts due
to wrapping at the edges, particularly for objects that are quite extended (e.g., due to
the nature of the radial profile). See <a class="reference internal" href="gsparams.html#galsim.GSParams" title="galsim.GSParams"><code class="xref any py py-class docutils literal notranslate"><span class="pre">GSParams</span></code></a> for parameters that you can use to reduce
the level of these artifacts, in particular <code class="docutils literal notranslate"><span class="pre">folding_threshold</span></code> may be helpful if you see
such artifacts in your images.</p>
<p>Setting the offset:</p>
<p>The object will by default be drawn with its nominal center at the center location of the
image.  There is thus a qualitative difference in the appearance of the rendered profile
when drawn on even- and odd-sized images.  For a profile with a maximum at (0,0), this
maximum will fall in the central pixel of an odd-sized image, but in the corner of the four
central pixels of an even-sized image.  There are three parameters that can affect this
behavior.  First, you can specify any arbitrary pixel position to center the object using
the <code class="docutils literal notranslate"><span class="pre">center</span></code> parameter.  If this is None, then it will pick one of the two potential
“centers” of the image, either <code class="docutils literal notranslate"><span class="pre">image.true_center</span></code> or <code class="docutils literal notranslate"><span class="pre">image.center</span></code>.  The latter is
an integer position, which always corresponds to the center of some pixel, which for even
sized images won’t (cannot) be the actual “true” center of the image.  You can choose which
of these two centers you want to use with the <code class="docutils literal notranslate"><span class="pre">use_true_center</span></code> parameters, which
defaults to False.  You can also arbitrarily offset the profile from the image center with
the <code class="docutils literal notranslate"><span class="pre">offset</span></code> parameter to handle any aribtrary offset you want from the chosen center.
(Typically, one would use only one of <code class="docutils literal notranslate"><span class="pre">center</span></code> or <code class="docutils literal notranslate"><span class="pre">offset</span></code> but it is permissible to use
both.)</p>
<p>Setting the overall normalization:</p>
<p>Normally, the flux of the object should be equal to the sum of all the pixel values in the
image, less some small amount of flux that may fall off the edge of the image (assuming you
don’t use <code class="docutils literal notranslate"><span class="pre">method='sb'</span></code>).  However, you may optionally set a <code class="docutils literal notranslate"><span class="pre">gain</span></code> value, which
converts between photons and ADU (so-called analog-to-digital units), the units of the
pixel values in real images.  Normally, the gain of a CCD is in electrons/ADU, but in
GalSim, we fold the quantum efficiency into the gain as well, so the units are photons/ADU.</p>
<p>Another caveat is that, technically, flux is really in units of photons/cm^2/s, not photons.
So if you want, you can keep track of this properly and provide an <code class="docutils literal notranslate"><span class="pre">area</span></code> and <code class="docutils literal notranslate"><span class="pre">exptime</span></code>
here. This detail is more important with chromatic objects where the <a class="reference internal" href="sed.html#galsim.SED" title="galsim.SED"><code class="xref any py py-class docutils literal notranslate"><span class="pre">SED</span></code></a> is typically
given in erg/cm^2/s/nm, so the exposure time and area are important details. With achromatic
objects however, it is often more convenient to ignore these details and just consider the
flux to be the total number of photons for this exposure, in which case, you would leave the
area and exptime parameters at their default value of 1.</p>
<p>On return, the image will have an attribute <code class="docutils literal notranslate"><span class="pre">added_flux</span></code>, which will be set to the total
flux added to the image.  This may be useful as a sanity check that you have provided a
large enough image to catch most of the flux.  For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">obj</span><span class="o">.</span><span class="n">drawImage</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">image</span><span class="o">.</span><span class="n">added_flux</span> <span class="o">&gt;</span> <span class="mf">0.99</span> <span class="o">*</span> <span class="n">obj</span><span class="o">.</span><span class="n">flux</span>
</pre></div>
</div>
<p>The appropriate threshold will depend on your particular application, including what kind
of profile the object has, how big your image is relative to the size of your object,
whether you are keeping <code class="docutils literal notranslate"><span class="pre">poisson_flux=True</span></code>, etc.</p>
<p>The following code snippet illustrates how <code class="docutils literal notranslate"><span class="pre">gain</span></code>, <code class="docutils literal notranslate"><span class="pre">exptime</span></code>, <code class="docutils literal notranslate"><span class="pre">area</span></code>, and <code class="docutils literal notranslate"><span class="pre">method</span></code>
can all influence the relationship between the <code class="docutils literal notranslate"><span class="pre">flux</span></code> attribute of a <a class="reference internal" href="#galsim.GSObject" title="galsim.GSObject"><code class="xref any py py-class docutils literal notranslate"><span class="pre">GSObject</span></code></a> and
both the pixel values and <code class="docutils literal notranslate"><span class="pre">.added_flux</span></code> attribute of an <a class="reference internal" href="image_class.html#galsim.Image" title="galsim.Image"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Image</span></code></a> drawn with
<code class="docutils literal notranslate"><span class="pre">drawImage()</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">obj</span> <span class="o">=</span> <span class="n">galsim</span><span class="o">.</span><span class="n">Gaussian</span><span class="p">(</span><span class="n">fwhm</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">obj</span><span class="o">.</span><span class="n">flux</span>
<span class="go">1.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">im</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">drawImage</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">im</span><span class="o">.</span><span class="n">added_flux</span>
<span class="go">0.9999630988657515</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">im</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
<span class="go">0.99996305</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">im</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">drawImage</span><span class="p">(</span><span class="n">exptime</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">area</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">im</span><span class="o">.</span><span class="n">added_flux</span>
<span class="go">0.9999630988657525</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">im</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
<span class="go">99.996315</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">im</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">drawImage</span><span class="p">(</span><span class="n">exptime</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">area</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;sb&#39;</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">nx</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">ny</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">im</span><span class="o">.</span><span class="n">added_flux</span>
<span class="go">0.9999973790505298</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">im</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
<span class="go">399.9989</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">im</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">drawImage</span><span class="p">(</span><span class="n">exptime</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">area</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">gain</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">im</span><span class="o">.</span><span class="n">added_flux</span>
<span class="go">0.9999630988657525</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">im</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
<span class="go">49.998158</span>
</pre></div>
</div>
<p>Using a non-trivial sensor:</p>
<p>Normally the sensor is modeled as an array of pixels where any photon that hits a given
pixel is accumulated into that pixel.  The final pixel value then just reflects the total
number of pixels that hit each sensor.  However, real sensors do not (quite) work this way.</p>
<p>In real CCDs, the photons travel some distance into the silicon before converting to
electrons.  Then the electrons diffuse laterally some amount as they are pulled by the
electric field toward the substrate.  Finally, previous electrons that have already been
deposited will repel subsequent electrons, both slowing down their descent, leading to
more diffusion, and pushing them laterally toward neighboring pixels, which is called
the brighter-fatter effect.</p>
<p>Users interested in modeling this kind of effect can supply a <code class="docutils literal notranslate"><span class="pre">sensor</span></code> object to use
for the accumulation step.  See <a class="reference internal" href="sensor.html#galsim.SiliconSensor" title="galsim.SiliconSensor"><code class="xref any py py-class docutils literal notranslate"><span class="pre">SiliconSensor</span></code></a> for a class that models silicon-based CCD
sensors.</p>
<p>Some related effects may need to be done to the photons at the surface layer before being
passed into the sensor object.  For instance, the photons may need to be given appropriate
incidence angles according to the optics of the telescope (since this matters for where the
photons are converted to electrons).  You may also need to give the photons wavelengths
according to the <a class="reference internal" href="sed.html#galsim.SED" title="galsim.SED"><code class="xref any py py-class docutils literal notranslate"><span class="pre">SED</span></code></a> of the object.  Such steps are specified in a <code class="docutils literal notranslate"><span class="pre">surface_ops</span></code>
parameter, which should be a list of any such operations you wish to perform on the photon
array before passing them to the sensor.  See <a class="reference internal" href="surface.html#galsim.FRatioAngles" title="galsim.FRatioAngles"><code class="xref any py py-class docutils literal notranslate"><span class="pre">FRatioAngles</span></code></a> and <a class="reference internal" href="surface.html#galsim.WavelengthSampler" title="galsim.WavelengthSampler"><code class="xref any py py-class docutils literal notranslate"><span class="pre">WavelengthSampler</span></code></a> for
two examples of such surface operators.</p>
<p>Since the sensor deals with photons, it is most natural to use this feature in conjunction
with photon shooting (<code class="docutils literal notranslate"><span class="pre">method='phot'</span></code>).  However, it is allowed with FFT methods too.
But there is a caveat one should be aware of in this case.  The FFT drawing is used to
produce an intermediate image, which is then converted to a <a class="reference internal" href="photon_array.html#galsim.PhotonArray" title="galsim.PhotonArray"><code class="xref any py py-class docutils literal notranslate"><span class="pre">PhotonArray</span></code></a> using the
factory function <a class="reference internal" href="photon_array.html#galsim.PhotonArray.makeFromImage" title="galsim.PhotonArray.makeFromImage"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">PhotonArray.makeFromImage</span></code></a>.  This assigns photon positions randomly
within each pixel where they were drawn, which isn’t always a particularly good
approximation.</p>
<p>To improve this behavior, the intermediate image is drawn with smaller pixels than the
target image, so the photons are given positions closer to their true locations.  The
amount of subsampling is controlled by the <code class="docutils literal notranslate"><span class="pre">n_subsample</span></code> parameter, which defaults to 3.
Larger values will be more accurate at the expense of larger FFTs (i.e. slower and using
more memory).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>image</strong> – If provided, this will be the image on which to draw the profile.
If <code class="docutils literal notranslate"><span class="pre">image</span></code> is None, then an automatically-sized <a class="reference internal" href="image_class.html#galsim.Image" title="galsim.Image"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Image</span></code></a> will be
created.  If <code class="docutils literal notranslate"><span class="pre">image</span></code> is given, but its bounds are undefined (e.g. if
it was constructed with <code class="docutils literal notranslate"><span class="pre">image</span> <span class="pre">=</span> <span class="pre">galsim.Image()</span></code>), then it will be
resized appropriately based on the profile’s size [default: None].</p></li>
<li><p><strong>nx</strong> – If provided and <code class="docutils literal notranslate"><span class="pre">image</span></code> is None, use to set the x-direction size of
the image.  Must be accompanied by <code class="docutils literal notranslate"><span class="pre">ny</span></code>.</p></li>
<li><p><strong>ny</strong> – If provided and <code class="docutils literal notranslate"><span class="pre">image</span></code> is None, use to set the y-direction size of
the image.  Must be accompanied by <code class="docutils literal notranslate"><span class="pre">nx</span></code>.</p></li>
<li><p><strong>bounds</strong> – If provided and <code class="docutils literal notranslate"><span class="pre">image</span></code> is None, use to set the bounds of the image.</p></li>
<li><p><strong>scale</strong> – If provided, use this as the pixel scale for the image.
If <code class="docutils literal notranslate"><span class="pre">scale</span></code> is None and <code class="docutils literal notranslate"><span class="pre">image</span></code> is given, then take the provided
image’s pixel scale.
If <code class="docutils literal notranslate"><span class="pre">scale</span></code> is None and <code class="docutils literal notranslate"><span class="pre">image</span></code> is None, then use the Nyquist scale.
If <code class="docutils literal notranslate"><span class="pre">scale</span> <span class="pre">&lt;=</span> <span class="pre">0</span></code> (regardless of <code class="docutils literal notranslate"><span class="pre">image</span></code>), then use the Nyquist scale.
If <code class="docutils literal notranslate"><span class="pre">scale</span> <span class="pre">&gt;</span> <span class="pre">0</span></code> and <code class="docutils literal notranslate"><span class="pre">image</span></code> is given, then override <code class="docutils literal notranslate"><span class="pre">image.scale</span></code>
with the value given as a keyword.  [default: None]</p></li>
<li><p><strong>wcs</strong> – If provided, use this as the wcs for the image (possibly overriding any
existing <code class="docutils literal notranslate"><span class="pre">image.wcs</span></code>).  At most one of <code class="docutils literal notranslate"><span class="pre">scale</span></code> or <code class="docutils literal notranslate"><span class="pre">wcs</span></code> may be
provided.  [default: None]</p></li>
<li><p><strong>dtype</strong> – The data type to use for an automatically constructed image.  Only
valid if <code class="docutils literal notranslate"><span class="pre">image</span></code> is None. [default: None, which means to use
numpy.float32]</p></li>
<li><p><strong>method</strong> – Which method to use for rendering the image.  See discussion above
for the various options and what they do. [default: ‘auto’]</p></li>
<li><p><strong>area</strong> – Collecting area of telescope in cm^2.  [default: 1.]</p></li>
<li><p><strong>exptime</strong> – Exposure time in s.  [default: 1.]</p></li>
<li><p><strong>gain</strong> – The number of photons per ADU (“analog to digital units”, the units of
the numbers output from a CCD).  [default: 1]</p></li>
<li><p><strong>add_to_image</strong> – Whether to add flux to the existing image rather than clear out
anything in the image before drawing.
Note: This requires that <code class="docutils literal notranslate"><span class="pre">image</span></code> be provided and that it have defined
bounds. [default: False]</p></li>
<li><p><strong>center</strong> – The position on the image at which to place the nominal center of the
object (usually the centroid, but not necessarily).  [default: None]</p></li>
<li><p><strong>use_true_center</strong> – If <code class="docutils literal notranslate"><span class="pre">center</span></code> is None, then the object is normally centered at the
true center of the image (using the property image.true_center).
If you would rather use the integer center (given by image.center),
set this to <code class="docutils literal notranslate"><span class="pre">False</span></code>.  [default: True]</p></li>
<li><p><strong>offset</strong> – The offset in pixel coordinates at which to center the profile being
drawn relative to either <code class="docutils literal notranslate"><span class="pre">center</span></code> (if given) or the center of the
image (either the true center or integer center according to the
<code class="docutils literal notranslate"><span class="pre">use_true_center</span></code> parameter). [default: None]</p></li>
<li><p><strong>n_photons</strong> – If provided, the number of photons to use for photon shooting.
If not provided (i.e. <code class="docutils literal notranslate"><span class="pre">n_photons</span> <span class="pre">=</span> <span class="pre">0</span></code>), use as many photons as
necessary to result in an image with the correct Poisson shot
noise for the object’s flux.  For positive definite profiles, this
is equivalent to <code class="docutils literal notranslate"><span class="pre">n_photons</span> <span class="pre">=</span> <span class="pre">flux</span></code>.  However, some profiles need
more than this because some of the shot photons are negative
(usually due to interpolants).
[default: 0]</p></li>
<li><p><strong>rng</strong> – If provided, a random number generator to use for photon shooting,
which may be any kind of <a class="reference internal" href="deviate.html#galsim.BaseDeviate" title="galsim.BaseDeviate"><code class="xref any py py-class docutils literal notranslate"><span class="pre">BaseDeviate</span></code></a> object.  If <code class="docutils literal notranslate"><span class="pre">rng</span></code> is None, one
will be automatically created.  [default: None]</p></li>
<li><p><strong>max_extra_noise</strong> – If provided, the allowed extra noise in each pixel when photon
shooting.  This is only relevant if <code class="docutils literal notranslate"><span class="pre">n_photons=0</span></code>, so the number of
photons is being automatically calculated.  In that case, if the image
noise is dominated by the sky background, then you can get away with
using fewer shot photons than the full <code class="docutils literal notranslate"><span class="pre">n_photons</span> <span class="pre">=</span> <span class="pre">flux</span></code>.
Essentially each shot photon can have a <code class="docutils literal notranslate"><span class="pre">flux</span> <span class="pre">&gt;</span> <span class="pre">1</span></code>, which increases
the noise in each pixel.  The <code class="docutils literal notranslate"><span class="pre">max_extra_noise</span></code> parameter specifies
how much extra noise per pixel is allowed because of this approximation.
A typical value for this might be <code class="docutils literal notranslate"><span class="pre">max_extra_noise</span> <span class="pre">=</span> <span class="pre">sky_level</span> <span class="pre">/</span> <span class="pre">100</span></code>
where <code class="docutils literal notranslate"><span class="pre">sky_level</span></code> is the flux per pixel due to the sky.  Note that
this uses a “variance” definition of noise, not a “sigma” definition.
[default: 0.]</p></li>
<li><p><strong>poisson_flux</strong> – Whether to allow total object flux scaling to vary according to
Poisson statistics for <code class="docutils literal notranslate"><span class="pre">n_photons</span></code> samples when photon shooting.
[default: True, unless <code class="docutils literal notranslate"><span class="pre">n_photons</span></code> is given, in which case the default
is False]</p></li>
<li><p><strong>sensor</strong> – An optional <a class="reference internal" href="sensor.html#galsim.Sensor" title="galsim.Sensor"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Sensor</span></code></a> instance, which will be used to accumulate the
photons onto the image. [default: None]</p></li>
<li><p><strong>surface_ops</strong> – A list of operators that can modify the photon array that will be
applied in order before accumulating the photons on the sensor.
[default: ()]</p></li>
<li><p><strong>n_subsample</strong> – The number of sub-pixels per final pixel to use for fft drawing when
using a sensor.  The sensor step needs to know the sub-pixel positions
of the photons, which is lost in the fft method.  So using smaller
pixels for the fft step keeps some of that information, making the
assumption of uniform flux per pixel less bad of an approximation.
[default: 3]</p></li>
<li><p><strong>maxN</strong> – Sets the maximum number of photons that will be added to the image
at a time.  (Memory requirements are proportional to this number.)
[default: None, which means no limit]</p></li>
<li><p><strong>save_photons</strong> – If True, save the <a class="reference internal" href="photon_array.html#galsim.PhotonArray" title="galsim.PhotonArray"><code class="xref any py py-class docutils literal notranslate"><span class="pre">PhotonArray</span></code></a> as <code class="docutils literal notranslate"><span class="pre">image.photons</span></code>. Only valid if
method is ‘phot’ or sensor is not None.  [default: False]</p></li>
<li><p><strong>setup_only</strong> – Don’t actually draw anything on the image.  Just make sure the image
is set up correctly.  This is used internally by GalSim, but there
may be cases where the user will want the same functionality.
[default: False]</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the drawn <a class="reference internal" href="image_class.html#galsim.Image" title="galsim.Image"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Image</span></code></a>.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.GSObject.drawKImage">
<code class="sig-name descname">drawKImage</code><span class="sig-paren">(</span><em class="sig-param">image=None</em>, <em class="sig-param">nx=None</em>, <em class="sig-param">ny=None</em>, <em class="sig-param">bounds=None</em>, <em class="sig-param">scale=None</em>, <em class="sig-param">add_to_image=False</em>, <em class="sig-param">recenter=True</em>, <em class="sig-param">setup_only=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/gsobject.html#GSObject.drawKImage"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.GSObject.drawKImage" title="Permalink to this definition">¶</a></dt>
<dd><p>Draws the k-space (complex) <a class="reference internal" href="image_class.html#galsim.Image" title="galsim.Image"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Image</span></code></a> of the object, with bounds optionally set by input
<a class="reference internal" href="image_class.html#galsim.Image" title="galsim.Image"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Image</span></code></a> instance.</p>
<p>Normalization is always such that image(0,0) = flux.  Unlike the real-space <a class="reference internal" href="#galsim.GSObject.drawImage" title="galsim.GSObject.drawImage"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">drawImage</span></code></a>
function, the (0,0) point will always be one of the actual pixel values.  For even-sized
images, it will be 1/2 pixel above and to the right of the true center of the image.</p>
<p>Another difference from  <a class="reference internal" href="#galsim.GSObject.drawImage" title="galsim.GSObject.drawImage"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">drawImage</span></code></a> is that a wcs other than a simple pixel scale is not
allowed.  There is no <code class="docutils literal notranslate"><span class="pre">wcs</span></code> parameter here, and if the images have a non-trivial wcs (and
you don’t override it with the <code class="docutils literal notranslate"><span class="pre">scale</span></code> parameter), a TypeError will be raised.</p>
<p>Also, there is no convolution by a pixel.  This is just a direct image of the Fourier
transform of the surface brightness profile.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>image</strong> – If provided, this will be the <a class="reference internal" href="image_class.html#galsim.Image" title="galsim.Image"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Image</span></code></a> onto which to draw the k-space
image.  If <code class="docutils literal notranslate"><span class="pre">image</span></code> is None, then an automatically-sized image will be
created.  If <code class="docutils literal notranslate"><span class="pre">image</span></code> is given, but its bounds are undefined, then it
will be resized appropriately based on the profile’s size.
[default: None]</p></li>
<li><p><strong>nx</strong> – If provided and <code class="docutils literal notranslate"><span class="pre">image</span></code> is None, use to set the x-direction size of
the image.  Must be accompanied by <code class="docutils literal notranslate"><span class="pre">ny</span></code>.</p></li>
<li><p><strong>ny</strong> – If provided and <code class="docutils literal notranslate"><span class="pre">image</span></code> is None, use to set the y-direction size of
the image.  Must be accompanied by <code class="docutils literal notranslate"><span class="pre">nx</span></code>.</p></li>
<li><p><strong>bounds</strong> – If provided and <code class="docutils literal notranslate"><span class="pre">image</span></code> is None, use to set the bounds of the image.</p></li>
<li><p><strong>scale</strong> – If provided, use this as the pixel scale, dk, for the images.
If <code class="docutils literal notranslate"><span class="pre">scale</span></code> is None and <code class="docutils literal notranslate"><span class="pre">image</span></code> is given, then take the provided
images’ pixel scale (which must be equal).
If <code class="docutils literal notranslate"><span class="pre">scale</span></code> is None and <code class="docutils literal notranslate"><span class="pre">image</span></code> is None, then use the Nyquist scale.
If <code class="docutils literal notranslate"><span class="pre">scale</span> <span class="pre">&lt;=</span> <span class="pre">0</span></code> (regardless of <code class="docutils literal notranslate"><span class="pre">image</span></code>), then use the Nyquist scale.
[default: None]</p></li>
<li><p><strong>add_to_image</strong> – Whether to add to the existing images rather than clear out
anything in the image before drawing.
Note: This requires that <code class="docutils literal notranslate"><span class="pre">image</span></code> be provided and that it has defined
bounds. [default: False]</p></li>
<li><p><strong>recenter</strong> – Whether to recenter the image to put k = 0 at the center (True) or to
trust the provided bounds (False).  [default: True]</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>an <a class="reference internal" href="image_class.html#galsim.Image" title="galsim.Image"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Image</span></code></a> instance (created if necessary)</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.GSObject.drawPhot">
<code class="sig-name descname">drawPhot</code><span class="sig-paren">(</span><em class="sig-param">image</em>, <em class="sig-param">gain=1.0</em>, <em class="sig-param">add_to_image=False</em>, <em class="sig-param">n_photons=0</em>, <em class="sig-param">rng=None</em>, <em class="sig-param">max_extra_noise=0.0</em>, <em class="sig-param">poisson_flux=None</em>, <em class="sig-param">sensor=None</em>, <em class="sig-param">surface_ops=()</em>, <em class="sig-param">maxN=None</em>, <em class="sig-param">orig_center=galsim.PositionI(x=0</em>, <em class="sig-param">y=0)</em>, <em class="sig-param">local_wcs=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/gsobject.html#GSObject.drawPhot"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.GSObject.drawPhot" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw this profile into an <a class="reference internal" href="image_class.html#galsim.Image" title="galsim.Image"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Image</span></code></a> by shooting photons.</p>
<p>This is usually called from the <a class="reference internal" href="#galsim.GSObject.drawImage" title="galsim.GSObject.drawImage"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">drawImage</span></code></a> function, rather than called directly by the
user.  In particular, the input image must be already set up with defined bounds.  The
profile will be drawn centered on whatever pixel corresponds to (0,0) with the given
bounds, not the image center (unlike <a class="reference internal" href="#galsim.GSObject.drawImage" title="galsim.GSObject.drawImage"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">drawImage</span></code></a>).  The image also must have a <a class="reference internal" href="wcs.html#galsim.PixelScale" title="galsim.PixelScale"><code class="xref any py py-class docutils literal notranslate"><span class="pre">PixelScale</span></code></a>
wcs.  The profile being drawn should have already been converted to image coordinates via:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">image_profile</span> <span class="o">=</span> <span class="n">original_wcs</span><span class="o">.</span><span class="n">toImage</span><span class="p">(</span><span class="n">original_profile</span><span class="p">)</span>
</pre></div>
</div>
<p>Note that the image produced by <a class="reference internal" href="#galsim.GSObject.drawPhot" title="galsim.GSObject.drawPhot"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">drawPhot</span></code></a> represents the profile integrated over the
area of each pixel.  This is equivalent to convolving the profile by a square <a class="reference internal" href="simple.html#galsim.Pixel" title="galsim.Pixel"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Pixel</span></code></a>
profile and sampling the value at the center of each pixel, although this happens
automatically by the shooting algorithm, so you do not need to manually convolve by
a <a class="reference internal" href="simple.html#galsim.Pixel" title="galsim.Pixel"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Pixel</span></code></a> as you would for <a class="reference internal" href="#galsim.GSObject.drawReal" title="galsim.GSObject.drawReal"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">drawReal</span></code></a> or <a class="reference internal" href="#galsim.GSObject.drawFFT" title="galsim.GSObject.drawFFT"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">drawFFT</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>image</strong> – The <a class="reference internal" href="image_class.html#galsim.Image" title="galsim.Image"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Image</span></code></a> onto which to place the flux. [required]</p></li>
<li><p><strong>gain</strong> – The number of photons per ADU (“analog to digital units”, the units of
the numbers output from a CCD). [default: 1.]</p></li>
<li><p><strong>add_to_image</strong> – Whether to add to the existing images rather than clear out
anything in the image before drawing.  [default: False]</p></li>
<li><p><strong>n_photons</strong> – If provided, the number of photons to use for photon shooting.
If not provided (i.e. <code class="docutils literal notranslate"><span class="pre">n_photons</span> <span class="pre">=</span> <span class="pre">0</span></code>), use as many photons as
necessary to result in an image with the correct Poisson shot
noise for the object’s flux.  For positive definite profiles, this
is equivalent to <code class="docutils literal notranslate"><span class="pre">n_photons</span> <span class="pre">=</span> <span class="pre">flux</span></code>.  However, some profiles need
more than this because some of the shot photons are negative
(usually due to interpolants).  [default: 0]</p></li>
<li><p><strong>rng</strong> – If provided, a random number generator to use for photon shooting,
which may be any kind of <a class="reference internal" href="deviate.html#galsim.BaseDeviate" title="galsim.BaseDeviate"><code class="xref any py py-class docutils literal notranslate"><span class="pre">BaseDeviate</span></code></a> object.  If <code class="docutils literal notranslate"><span class="pre">rng</span></code> is None, one
will be automatically created, using the time as a seed.
[default: None]</p></li>
<li><p><strong>max_extra_noise</strong> – If provided, the allowed extra noise in each pixel when photon
shooting.  This is only relevant if <code class="docutils literal notranslate"><span class="pre">n_photons=0</span></code>, so the number of
photons is being automatically calculated.  In that case, if the image
noise is dominated by the sky background, then you can get away with
using fewer shot photons than the full <code class="docutils literal notranslate"><span class="pre">n_photons</span> <span class="pre">=</span> <span class="pre">flux</span></code>.
Essentially each shot photon can have a <code class="docutils literal notranslate"><span class="pre">flux</span> <span class="pre">&gt;</span> <span class="pre">1</span></code>, which increases
the noise in each pixel.  The <code class="docutils literal notranslate"><span class="pre">max_extra_noise</span></code> parameter specifies
how much extra noise per pixel is allowed because of this approximation.
A typical value for this might be <code class="docutils literal notranslate"><span class="pre">max_extra_noise</span> <span class="pre">=</span> <span class="pre">sky_level</span> <span class="pre">/</span> <span class="pre">100</span></code>
where <code class="docutils literal notranslate"><span class="pre">sky_level</span></code> is the flux per pixel due to the sky.  Note that
this uses a “variance” definition of noise, not a “sigma” definition.
[default: 0.]</p></li>
<li><p><strong>poisson_flux</strong> – Whether to allow total object flux scaling to vary according to
Poisson statistics for <code class="docutils literal notranslate"><span class="pre">n_photons</span></code> samples when photon shooting.
[default: True, unless <code class="docutils literal notranslate"><span class="pre">n_photons</span></code> is given, in which case the default
is False]</p></li>
<li><p><strong>sensor</strong> – An optional <a class="reference internal" href="sensor.html#galsim.Sensor" title="galsim.Sensor"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Sensor</span></code></a> instance, which will be used to accumulate the
photons onto the image. [default: None]</p></li>
<li><p><strong>surface_ops</strong> – A list of operators that can modify the photon array that will be
applied in order before accumulating the photons on the sensor.
[default: ()]</p></li>
<li><p><strong>maxN</strong> – Sets the maximum number of photons that will be added to the image
at a time.  (Memory requirements are proportional to this number.)
[default: None, which means no limit]</p></li>
<li><p><strong>orig_center</strong> – The position of the image center in the original image coordinates.
[default: (0,0)]</p></li>
<li><p><strong>local_wcs</strong> – The local wcs in the original image. [default: None]</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p>added_flux is the total flux of photons that landed inside the image bounds, and</p></li>
<li><p>photons is the <a class="reference internal" href="photon_array.html#galsim.PhotonArray" title="galsim.PhotonArray"><code class="xref any py py-class docutils literal notranslate"><span class="pre">PhotonArray</span></code></a> that was applied to the image.</p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>(added_flux, photons) where</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.GSObject.drawReal">
<code class="sig-name descname">drawReal</code><span class="sig-paren">(</span><em class="sig-param">image</em>, <em class="sig-param">add_to_image=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/gsobject.html#GSObject.drawReal"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.GSObject.drawReal" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw this profile into an <a class="reference internal" href="image_class.html#galsim.Image" title="galsim.Image"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Image</span></code></a> by direct evaluation at the location of each pixel.</p>
<p>This is usually called from the <a class="reference internal" href="#galsim.GSObject.drawImage" title="galsim.GSObject.drawImage"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">drawImage</span></code></a> function, rather than called directly by the
user.  In particular, the input image must be already set up with defined bounds.  The
profile will be drawn centered on whatever pixel corresponds to (0,0) with the given
bounds, not the image center (unlike <a class="reference internal" href="#galsim.GSObject.drawImage" title="galsim.GSObject.drawImage"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">drawImage</span></code></a>).  The image also must have a <a class="reference internal" href="wcs.html#galsim.PixelScale" title="galsim.PixelScale"><code class="xref any py py-class docutils literal notranslate"><span class="pre">PixelScale</span></code></a>
wcs.  The profile being drawn should have already been converted to image coordinates via:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">image_profile</span> <span class="o">=</span> <span class="n">original_wcs</span><span class="o">.</span><span class="n">toImage</span><span class="p">(</span><span class="n">original_profile</span><span class="p">)</span>
</pre></div>
</div>
<p>Note that the image produced by <code class="docutils literal notranslate"><span class="pre">drawReal</span></code> represents the profile sampled at the center
of each pixel and then multiplied by the pixel area.  That is, the profile is NOT
integrated over the area of the pixel.  This is equivalent to method=’no_pixel’ in
<a class="reference internal" href="#galsim.GSObject.drawImage" title="galsim.GSObject.drawImage"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">drawImage</span></code></a>.  If you want to render a profile integrated over the pixel, you can convolve
with a <a class="reference internal" href="simple.html#galsim.Pixel" title="galsim.Pixel"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Pixel</span></code></a> first and draw that.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>image</strong> – The <a class="reference internal" href="image_class.html#galsim.Image" title="galsim.Image"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Image</span></code></a> onto which to place the flux. [required]</p></li>
<li><p><strong>add_to_image</strong> – Whether to add flux to the existing image rather than clear out
anything in the image before drawing. [default: False]</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The total flux drawn inside the image bounds.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.GSObject.expand">
<code class="sig-name descname">expand</code><span class="sig-paren">(</span><em class="sig-param">scale</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/gsobject.html#GSObject.expand"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.GSObject.expand" title="Permalink to this definition">¶</a></dt>
<dd><p>Expand the linear size of the profile by the given <code class="docutils literal notranslate"><span class="pre">scale</span></code> factor, while preserving
surface brightness.</p>
<p>e.g. <code class="docutils literal notranslate"><span class="pre">half_light_radius</span></code> &lt;– <code class="docutils literal notranslate"><span class="pre">half_light_radius</span> <span class="pre">*</span> <span class="pre">scale</span></code></p>
<p>This doesn’t correspond to either of the normal operations one would typically want to do to
a galaxy.  The functions dilate() and magnify() are the more typical usage.  But this
function is conceptually simple.  It rescales the linear dimension of the profile, while
preserving surface brightness.  As a result, the flux will necessarily change as well.</p>
<p>See dilate() for a version that applies a linear scale factor while preserving flux.</p>
<p>See magnify() for a version that applies a scale factor to the area while preserving surface
brightness.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>scale</strong> – The factor by which to scale the linear dimension of the object.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the expanded object.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.GSObject.flux">
<em class="property">property </em><code class="sig-name descname">flux</code><a class="headerlink" href="#galsim.GSObject.flux" title="Permalink to this definition">¶</a></dt>
<dd><p>The flux of the profile.</p>
</dd></dl>

<dl class="method">
<dt id="galsim.GSObject.getGoodImageSize">
<code class="sig-name descname">getGoodImageSize</code><span class="sig-paren">(</span><em class="sig-param">pixel_scale</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/gsobject.html#GSObject.getGoodImageSize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.GSObject.getGoodImageSize" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a good size to use for drawing this profile.</p>
<p>The size will be large enough to cover most of the flux of the object.  Specifically,
at least (1-gsparams.folding_threshold) (i.e. 99.5% by default) of the flux should fall
in the image.</p>
<p>Also, the returned size is always an even number, which is usually desired in practice.
Of course, if you prefer an odd-sized image, you can add 1 to the result.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>pixel_scale</strong> – The desired pixel scale of the image to be built.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>N, a good (linear) size of an image on which to draw this object.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.GSObject.gsparams">
<em class="property">property </em><code class="sig-name descname">gsparams</code><a class="headerlink" href="#galsim.GSObject.gsparams" title="Permalink to this definition">¶</a></dt>
<dd><p>A <a class="reference internal" href="gsparams.html#galsim.GSParams" title="galsim.GSParams"><code class="xref any py py-class docutils literal notranslate"><span class="pre">GSParams</span></code></a> object that sets various parameters relevant for speed/accuracy trade-offs.</p>
</dd></dl>

<dl class="method">
<dt id="galsim.GSObject.has_hard_edges">
<em class="property">property </em><code class="sig-name descname">has_hard_edges</code><a class="headerlink" href="#galsim.GSObject.has_hard_edges" title="Permalink to this definition">¶</a></dt>
<dd><p>Whether there are any hard edges in the profile, which would require very small k
spacing when working in the Fourier domain.</p>
</dd></dl>

<dl class="method">
<dt id="galsim.GSObject.is_analytic_k">
<em class="property">property </em><code class="sig-name descname">is_analytic_k</code><a class="headerlink" href="#galsim.GSObject.is_analytic_k" title="Permalink to this definition">¶</a></dt>
<dd><p>Whether the k-space values can be determined immediately at any position without
requiring a Discrete Fourier Transform.</p>
</dd></dl>

<dl class="method">
<dt id="galsim.GSObject.is_analytic_x">
<em class="property">property </em><code class="sig-name descname">is_analytic_x</code><a class="headerlink" href="#galsim.GSObject.is_analytic_x" title="Permalink to this definition">¶</a></dt>
<dd><p>Whether the real-space values can be determined immediately at any position without
requiring a Discrete Fourier Transform.</p>
</dd></dl>

<dl class="method">
<dt id="galsim.GSObject.is_axisymmetric">
<em class="property">property </em><code class="sig-name descname">is_axisymmetric</code><a class="headerlink" href="#galsim.GSObject.is_axisymmetric" title="Permalink to this definition">¶</a></dt>
<dd><p>Whether the profile is axially symmetric; affects efficiency of evaluation.</p>
</dd></dl>

<dl class="method">
<dt id="galsim.GSObject.kValue">
<code class="sig-name descname">kValue</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/gsobject.html#GSObject.kValue"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.GSObject.kValue" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the value of the object at a chosen 2D position in k space.</p>
<p>This function returns the amplitude of the fourier transform of the surface brightness
profile at a given position in k space.  The position argument may be provided as a
<a class="reference internal" href="pos.html#galsim.Position" title="galsim.Position"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Position</span></code></a> argument, or it may be given as kx,ky (either as a tuple or as two arguments).</p>
<p>Technically, kValue() is available if and only if the given obj has <code class="docutils literal notranslate"><span class="pre">obj.is_analytic_k</span>
<span class="pre">==</span> <span class="pre">True</span></code>, but this is the case for all <a class="reference internal" href="#galsim.GSObject" title="galsim.GSObject"><code class="xref any py py-class docutils literal notranslate"><span class="pre">GSObject</span></code></a> classes currently, so that should never
be an issue (unlike for <a class="reference internal" href="#galsim.GSObject.xValue" title="galsim.GSObject.xValue"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">xValue</span></code></a>).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>position</strong> – The position in k space at which you want the fourier amplitude.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the amplitude of the fourier transform at that position.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.GSObject.lens">
<code class="sig-name descname">lens</code><span class="sig-paren">(</span><em class="sig-param">g1</em>, <em class="sig-param">g2</em>, <em class="sig-param">mu</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/gsobject.html#GSObject.lens"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.GSObject.lens" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a version of the current object with both a lensing shear and magnification
applied to it.</p>
<p>This <a class="reference internal" href="#galsim.GSObject" title="galsim.GSObject"><code class="xref any py py-class docutils literal notranslate"><span class="pre">GSObject</span></code></a> method applies a lensing (reduced) shear and magnification.  The shear must
be specified using the g1, g2 definition of shear (see <a class="reference internal" href="shear.html#galsim.Shear" title="galsim.Shear"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Shear</span></code></a> for more details).
This is the same definition as the outputs of the PowerSpectrum and NFWHalo classes, which
compute shears according to some lensing power spectrum or lensing by an NFW dark matter
halo.  The magnification determines the rescaling factor for the object area and flux,
preserving surface brightness.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>g1</strong> – First component of lensing (reduced) shear to apply to the object.</p></li>
<li><p><strong>g2</strong> – Second component of lensing (reduced) shear to apply to the object.</p></li>
<li><p><strong>mu</strong> – Lensing magnification to apply to the object.  This is the factor by which
the solid angle subtended by the object is magnified, preserving surface
brightness.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the lensed object.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.GSObject.magnify">
<code class="sig-name descname">magnify</code><span class="sig-paren">(</span><em class="sig-param">mu</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/gsobject.html#GSObject.magnify"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.GSObject.magnify" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a version of the current object with a lensing magnification applied to it,
scaling the area and flux by <code class="docutils literal notranslate"><span class="pre">mu</span></code> at fixed surface brightness.</p>
<p>This process applies a lensing magnification mu, which scales the linear dimensions of the
image by the factor sqrt(mu), i.e., <code class="docutils literal notranslate"><span class="pre">half_light_radius</span></code> &lt;–
<code class="docutils literal notranslate"><span class="pre">half_light_radius</span> <span class="pre">*</span> <span class="pre">sqrt(mu)</span></code> while increasing the flux by a factor of mu.  Thus,
magnify() preserves surface brightness.</p>
<p>See dilate() for a version that applies a linear scale factor while preserving flux.</p>
<p>See expand() for a version that applies a linear scale factor while preserving surface
brightness.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>mu</strong> – The lensing magnification to apply.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the magnified object.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.GSObject.max_sb">
<em class="property">property </em><code class="sig-name descname">max_sb</code><a class="headerlink" href="#galsim.GSObject.max_sb" title="Permalink to this definition">¶</a></dt>
<dd><p>An estimate of the maximum surface brightness of the object.</p>
<p>Some profiles will return the exact peak SB, typically equal to the value of
obj.xValue(obj.centroid).  However, not all profiles (e.g. Convolution) know how to
calculate this value without just drawing the image and checking what the maximum value is.
Clearly, this would be inefficient, so in these cases, some kind of estimate is returned,
which will generally be conservative on the high side.</p>
<p>This routine is mainly used by the photon shooting process, where an overestimate of
the maximum surface brightness is acceptable.</p>
<p>Note, for negative-flux profiles, this will return the absolute value of the most negative
surface brightness.  Technically, it is an estimate of the maximum deviation from zero,
rather than the maximum value.  For most profiles, these are the same thing.</p>
</dd></dl>

<dl class="method">
<dt id="galsim.GSObject.maxk">
<em class="property">property </em><code class="sig-name descname">maxk</code><a class="headerlink" href="#galsim.GSObject.maxk" title="Permalink to this definition">¶</a></dt>
<dd><p>The value of k beyond which aliasing can be neglected.</p>
</dd></dl>

<dl class="method">
<dt id="galsim.GSObject.negative_flux">
<em class="property">property </em><code class="sig-name descname">negative_flux</code><a class="headerlink" href="#galsim.GSObject.negative_flux" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the expectation value of flux in negative photons.</p>
<p>Some profiles, when rendered with photon shooting, need to shoot both positive- and
negative-flux photons.  For such profiles, this method returns the total absolute flux
of the negative-valued photons (i.e. as a positive value).</p>
<p>For profiles that don’t have this complication, this returns 0.</p>
<p>It should be generally true that <code class="docutils literal notranslate"><span class="pre">obj.positive_flux</span> <span class="pre">-</span> <span class="pre">obj.negative_flux</span></code> returns the same
thing as <code class="docutils literal notranslate"><span class="pre">obj.flux</span></code>.  Small difference may accrue from finite numerical accuracy in
cases involving lookup tables, etc.</p>
</dd></dl>

<dl class="method">
<dt id="galsim.GSObject.noise">
<em class="property">property </em><code class="sig-name descname">noise</code><a class="headerlink" href="#galsim.GSObject.noise" title="Permalink to this definition">¶</a></dt>
<dd><p>An estimate of the noise already in the profile.</p>
<p>Some profiles have some noise already in their definition.  E.g. those that come from
observations of galaxies in real data.  In GalSim, <a class="reference internal" href="real_gal.html#galsim.RealGalaxy" title="galsim.RealGalaxy"><code class="xref any py py-class docutils literal notranslate"><span class="pre">RealGalaxy</span></code></a> objects are an example of
this.  In these cases, the noise attribute gives an estimate of the Noise object that
would generate noise consistent with that already in the profile.</p>
<p>It is permissible to attach a noise estimate to an existing object with:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">obj</span><span class="o">.</span><span class="n">noise</span> <span class="o">=</span> <span class="n">noise</span>    <span class="c1"># Some BaseNoise instance</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="galsim.GSObject.nyquist_scale">
<em class="property">property </em><code class="sig-name descname">nyquist_scale</code><a class="headerlink" href="#galsim.GSObject.nyquist_scale" title="Permalink to this definition">¶</a></dt>
<dd><p>The pixel spacing that does not alias maxk.</p>
</dd></dl>

<dl class="method">
<dt id="galsim.GSObject.positive_flux">
<em class="property">property </em><code class="sig-name descname">positive_flux</code><a class="headerlink" href="#galsim.GSObject.positive_flux" title="Permalink to this definition">¶</a></dt>
<dd><p>The expectation value of flux in positive photons.</p>
<p>Some profiles, when rendered with photon shooting, need to shoot both positive- and
negative-flux photons.  For such profiles, this method returns the total flux
of the positive-valued photons.</p>
<p>For profiles that don’t have this complication, this is equivalent to getFlux().</p>
<p>It should be generally true that <code class="docutils literal notranslate"><span class="pre">obj.positive_flux</span> <span class="pre">-</span> <span class="pre">obj.negative_flux</span></code> returns the same
thing as <code class="docutils literal notranslate"><span class="pre">obj.flux</span></code>.  Small difference may accrue from finite numerical accuracy in
cases involving lookup tables, etc.</p>
</dd></dl>

<dl class="method">
<dt id="galsim.GSObject.rotate">
<code class="sig-name descname">rotate</code><span class="sig-paren">(</span><em class="sig-param">theta</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/gsobject.html#GSObject.rotate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.GSObject.rotate" title="Permalink to this definition">¶</a></dt>
<dd><p>Rotate this object by an <a class="reference internal" href="units.html#galsim.Angle" title="galsim.Angle"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Angle</span></code></a> <code class="docutils literal notranslate"><span class="pre">theta</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>theta</strong> – Rotation angle (<a class="reference internal" href="units.html#galsim.Angle" title="galsim.Angle"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Angle</span></code></a> object, positive means anticlockwise).</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the rotated object.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.GSObject.shear">
<code class="sig-name descname">shear</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/gsobject.html#GSObject.shear"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.GSObject.shear" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a version of the current object with an area-preserving shear applied to it.</p>
<p>The arguments may be either a <a class="reference internal" href="shear.html#galsim.Shear" title="galsim.Shear"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Shear</span></code></a> instance or arguments to be used to initialize one.</p>
<p>For more details about the allowed keyword arguments, see the <a class="reference internal" href="shear.html#galsim.Shear" title="galsim.Shear"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Shear</span></code></a> docstring.</p>
<p>The shear() method precisely preserves the area.  To include a lensing distortion with
the appropriate change in area, either use shear() with magnify(), or use lens(), which
combines both operations.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>shear</strong> – The <a class="reference internal" href="shear.html#galsim.Shear" title="galsim.Shear"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Shear</span></code></a> to be applied. Or, as described above, you may instead supply
parameters do construct a shear directly.  eg. <code class="docutils literal notranslate"><span class="pre">obj.shear(g1=g1,g2=g2)</span></code>.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the sheared object.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.GSObject.shift">
<code class="sig-name descname">shift</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/gsobject.html#GSObject.shift"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.GSObject.shift" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a version of the current object shifted by some amount in real space.</p>
<p>After this call, the caller’s type will be a <a class="reference internal" href="#galsim.GSObject" title="galsim.GSObject"><code class="xref any py py-class docutils literal notranslate"><span class="pre">GSObject</span></code></a>.
This means that if the caller was a derived type that had extra methods or properties
beyond those defined in <a class="reference internal" href="#galsim.GSObject" title="galsim.GSObject"><code class="xref any py py-class docutils literal notranslate"><span class="pre">GSObject</span></code></a> (e.g. <a class="reference internal" href="simple.html#galsim.Gaussian.sigma" title="galsim.Gaussian.sigma"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">Gaussian.sigma</span></code></a>), then these methods are no
longer available.</p>
<p>Note: in addition to the dx,dy parameter names, you may also supply dx,dy as a tuple,
or as a <a class="reference internal" href="pos.html#galsim.Position" title="galsim.Position"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Position</span></code></a> object.</p>
<p>The shift coordinates here are sky coordinates.  <a class="reference internal" href="#galsim.GSObject" title="galsim.GSObject"><code class="xref any py py-class docutils literal notranslate"><span class="pre">GSObject</span></code></a> profiles are always defined in
sky coordinates and only later (when they are drawn) is the connection to pixel coordinates
established (via a pixel_scale or WCS).  So a shift of dx moves the object horizontally
in the sky (e.g. west in the local tangent plane of the observation), and dy moves the
object vertically (north in the local tangent plane).</p>
<p>The units are typically arcsec, but we don’t enforce that anywhere.  The units here just
need to be consistent with the units used for any size values used by the <a class="reference internal" href="#galsim.GSObject" title="galsim.GSObject"><code class="xref any py py-class docutils literal notranslate"><span class="pre">GSObject</span></code></a>.
The connection of these units to the eventual image pixels is defined by either the
<code class="docutils literal notranslate"><span class="pre">pixel_scale</span></code> or the <code class="docutils literal notranslate"><span class="pre">wcs</span></code> parameter of <a class="reference internal" href="#galsim.GSObject.drawImage" title="galsim.GSObject.drawImage"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">GSObject.drawImage</span></code></a>.</p>
<p>Note: if you want to shift the object by a set number (or fraction) of pixels in the
drawn image, you probably want to use the <code class="docutils literal notranslate"><span class="pre">offset</span></code> parameter of <a class="reference internal" href="#galsim.GSObject.drawImage" title="galsim.GSObject.drawImage"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">GSObject.drawImage</span></code></a>
rather than this method.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dx</strong> – Horizontal shift to apply.</p></li>
<li><p><strong>dy</strong> – Vertical shift to apply.</p></li>
</ul>
</dd>
</dl>
<p>Alternatively, you may supply a single parameter as a <a class="reference internal" href="pos.html#galsim.Position" title="galsim.Position"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Position</span></code></a> instance, rather than
the two components separately if that is more convenient.</p>
<dl class="simple">
<dt>Parameter:</dt><dd><p>offset:     The shift to apply, given as PositionD(dx,dy) or PositionI(dx,dy)</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the shifted object.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.GSObject.shoot">
<code class="sig-name descname">shoot</code><span class="sig-paren">(</span><em class="sig-param">n_photons</em>, <em class="sig-param">rng=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/gsobject.html#GSObject.shoot"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.GSObject.shoot" title="Permalink to this definition">¶</a></dt>
<dd><p>Shoot photons into a <a class="reference internal" href="photon_array.html#galsim.PhotonArray" title="galsim.PhotonArray"><code class="xref any py py-class docutils literal notranslate"><span class="pre">PhotonArray</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n_photons</strong> – The number of photons to use for photon shooting.</p></li>
<li><p><strong>rng</strong> – If provided, a random number generator to use for photon shooting,
which may be any kind of <a class="reference internal" href="deviate.html#galsim.BaseDeviate" title="galsim.BaseDeviate"><code class="xref any py py-class docutils literal notranslate"><span class="pre">BaseDeviate</span></code></a> object.  If <code class="docutils literal notranslate"><span class="pre">rng</span></code> is None, one
will be automatically created, using the time as a seed.
[default: None]</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A <a class="reference internal" href="photon_array.html#galsim.PhotonArray" title="galsim.PhotonArray"><code class="xref any py py-class docutils literal notranslate"><span class="pre">PhotonArray</span></code></a>.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.GSObject.stepk">
<em class="property">property </em><code class="sig-name descname">stepk</code><a class="headerlink" href="#galsim.GSObject.stepk" title="Permalink to this definition">¶</a></dt>
<dd><p>The sampling in k space necessary to avoid folding of image in x space.</p>
</dd></dl>

<dl class="method">
<dt id="galsim.GSObject.transform">
<code class="sig-name descname">transform</code><span class="sig-paren">(</span><em class="sig-param">dudx</em>, <em class="sig-param">dudy</em>, <em class="sig-param">dvdx</em>, <em class="sig-param">dvdy</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/gsobject.html#GSObject.transform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.GSObject.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a version of the current object with an arbitrary Jacobian matrix transformation
applied to it.</p>
<p>This applies a Jacobian matrix to the coordinate system in which this object
is defined.  It changes a profile defined in terms of (x,y) to one defined in
terms of (u,v) where:</p>
<blockquote>
<div><p>u = dudx x + dudy y
v = dvdx x + dvdy y</p>
</div></blockquote>
<p>That is, an arbitrary affine transform, but without the translation (which is
easily effected via the <a class="reference internal" href="#galsim.GSObject.shift" title="galsim.GSObject.shift"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">shift</span></code></a> method).</p>
<p>Note that this function is similar to expand in that it preserves surface brightness,
not flux.  If you want to preserve flux, you should also do:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">prof</span> <span class="o">*=</span> <span class="mf">1.</span><span class="o">/</span><span class="nb">abs</span><span class="p">(</span><span class="n">dudx</span><span class="o">*</span><span class="n">dvdy</span> <span class="o">-</span> <span class="n">dudy</span><span class="o">*</span><span class="n">dvdx</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dudx</strong> – du/dx, where (x,y) are the current coords, and (u,v) are the new coords.</p></li>
<li><p><strong>dudy</strong> – du/dy, where (x,y) are the current coords, and (u,v) are the new coords.</p></li>
<li><p><strong>dvdx</strong> – dv/dx, where (x,y) are the current coords, and (u,v) are the new coords.</p></li>
<li><p><strong>dvdy</strong> – dv/dy, where (x,y) are the current coords, and (u,v) are the new coords.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the transformed object</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.GSObject.withFlux">
<code class="sig-name descname">withFlux</code><span class="sig-paren">(</span><em class="sig-param">flux</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/gsobject.html#GSObject.withFlux"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.GSObject.withFlux" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a version of the current object with a different flux.</p>
<p>This function is equivalent to <code class="docutils literal notranslate"><span class="pre">obj.withScaledFlux(flux</span> <span class="pre">/</span> <span class="pre">obj.flux)</span></code>.</p>
<p>It creates a new object that has the same profile as the original, but with the
surface brightness at every location rescaled such that the total flux will be
the given value.  Note that if <code class="docutils literal notranslate"><span class="pre">flux</span></code> is an <a class="reference internal" href="sed.html#galsim.SED" title="galsim.SED"><code class="xref any py py-class docutils literal notranslate"><span class="pre">SED</span></code></a>, the return value will be a
<a class="reference internal" href="chromaticobject.html#galsim.ChromaticObject" title="galsim.ChromaticObject"><code class="xref any py py-class docutils literal notranslate"><span class="pre">ChromaticObject</span></code></a> with specified <a class="reference internal" href="sed.html#galsim.SED" title="galsim.SED"><code class="xref any py py-class docutils literal notranslate"><span class="pre">SED</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>flux</strong> – The new flux for the object.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the object with the new flux</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.GSObject.withGSParams">
<code class="sig-name descname">withGSParams</code><span class="sig-paren">(</span><em class="sig-param">gsparams</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/gsobject.html#GSObject.withGSParams"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.GSObject.withGSParams" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a version of the current object with the given <a class="reference internal" href="gsparams.html#galsim.GSParams" title="galsim.GSParams"><code class="xref any py py-class docutils literal notranslate"><span class="pre">GSParams</span></code></a>.</p>
</dd></dl>

<dl class="method">
<dt id="galsim.GSObject.withScaledFlux">
<code class="sig-name descname">withScaledFlux</code><span class="sig-paren">(</span><em class="sig-param">flux_ratio</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/gsobject.html#GSObject.withScaledFlux"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.GSObject.withScaledFlux" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a version of the current object with the flux scaled by the given <code class="docutils literal notranslate"><span class="pre">flux_ratio</span></code>.</p>
<p>This function is equivalent to <code class="docutils literal notranslate"><span class="pre">obj.withFlux(flux_ratio</span> <span class="pre">*</span> <span class="pre">obj.flux)</span></code>.  Indeed, withFlux()
is implemented in terms of this one.</p>
<p>It creates a new object that has the same profile as the original, but with the
surface brightness at every location scaled by the given amount.  If <code class="docutils literal notranslate"><span class="pre">flux_ratio</span></code> is an
<a class="reference internal" href="sed.html#galsim.SED" title="galsim.SED"><code class="xref any py py-class docutils literal notranslate"><span class="pre">SED</span></code></a>, then the returned object is a <a class="reference internal" href="chromaticobject.html#galsim.ChromaticObject" title="galsim.ChromaticObject"><code class="xref any py py-class docutils literal notranslate"><span class="pre">ChromaticObject</span></code></a> with the <a class="reference internal" href="sed.html#galsim.SED" title="galsim.SED"><code class="xref any py py-class docutils literal notranslate"><span class="pre">SED</span></code></a> multiplied by
its current <code class="docutils literal notranslate"><span class="pre">flux</span></code>.</p>
<p>Note that in this case the <code class="docutils literal notranslate"><span class="pre">flux</span></code> attribute of the <a class="reference internal" href="#galsim.GSObject" title="galsim.GSObject"><code class="xref any py py-class docutils literal notranslate"><span class="pre">GSObject</span></code></a> being scaled gets
interpreted as being dimensionless, instead of having its normal units of [photons/s/cm^2].
The photons/s/cm^2 units are (optionally) carried by the <a class="reference internal" href="sed.html#galsim.SED" title="galsim.SED"><code class="xref any py py-class docutils literal notranslate"><span class="pre">SED</span></code></a> instead, or even left out
entirely if the <a class="reference internal" href="sed.html#galsim.SED" title="galsim.SED"><code class="xref any py py-class docutils literal notranslate"><span class="pre">SED</span></code></a> is dimensionless itself (see discussion in the <a class="reference internal" href="chromaticobject.html#galsim.ChromaticObject" title="galsim.ChromaticObject"><code class="xref any py py-class docutils literal notranslate"><span class="pre">ChromaticObject</span></code></a>
docstring).  The <a class="reference internal" href="#galsim.GSObject" title="galsim.GSObject"><code class="xref any py py-class docutils literal notranslate"><span class="pre">GSObject</span></code></a> <code class="docutils literal notranslate"><span class="pre">flux</span></code> attribute <em>does</em> still contribute to the
<a class="reference internal" href="chromaticobject.html#galsim.ChromaticObject" title="galsim.ChromaticObject"><code class="xref any py py-class docutils literal notranslate"><span class="pre">ChromaticObject</span></code></a> normalization, though.  For example, the following are equivalent:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">chrom_obj</span> <span class="o">=</span> <span class="n">gsobj</span><span class="o">.</span><span class="n">withScaledFlux</span><span class="p">(</span><span class="n">sed</span> <span class="o">*</span> <span class="mf">3.0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">chrom_obj2</span> <span class="o">=</span> <span class="p">(</span><span class="n">gsobj</span> <span class="o">*</span> <span class="mf">3.0</span><span class="p">)</span><span class="o">.</span><span class="n">withScaledFlux</span><span class="p">(</span><span class="n">sed</span><span class="p">)</span>
</pre></div>
</div>
<p>An equivalent, and usually simpler, way to effect this scaling is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">obj</span> <span class="o">=</span> <span class="n">obj</span> <span class="o">*</span> <span class="n">flux_ratio</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>flux_ratio</strong> – The ratio by which to rescale the flux of the object when creating a new
one.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the object with the new flux.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.GSObject.xValue">
<code class="sig-name descname">xValue</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/gsobject.html#GSObject.xValue"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.GSObject.xValue" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the value of the object at a chosen 2D position in real space.</p>
<p>This function returns the surface brightness of the object at a particular position
in real space.  The position argument may be provided as a <a class="reference internal" href="pos.html#galsim.PositionD" title="galsim.PositionD"><code class="xref any py py-class docutils literal notranslate"><span class="pre">PositionD</span></code></a> or <a class="reference internal" href="pos.html#galsim.PositionI" title="galsim.PositionI"><code class="xref any py py-class docutils literal notranslate"><span class="pre">PositionI</span></code></a>
argument, or it may be given as x,y (either as a tuple or as two arguments).</p>
<p>The object surface brightness profiles are typically defined in world coordinates, so
the position here should be in world coordinates as well.</p>
<p>Not all <a class="reference internal" href="#galsim.GSObject" title="galsim.GSObject"><code class="xref any py py-class docutils literal notranslate"><span class="pre">GSObject</span></code></a> classes can use this method.  Classes like Convolution that require a
Discrete Fourier Transform to determine the real space values will not do so for a single
position.  Instead a GalSimError will be raised.  The xValue() method is available if and
only if <code class="docutils literal notranslate"><span class="pre">obj.is_analytic_x</span> <span class="pre">==</span> <span class="pre">True</span></code>.</p>
<p>Users who wish to use the xValue() method for an object that is the convolution of other
profiles can do so by drawing the convolved profile into an image, using the image to
initialize a new <a class="reference internal" href="arbitrary.html#galsim.InterpolatedImage" title="galsim.InterpolatedImage"><code class="xref any py py-class docutils literal notranslate"><span class="pre">InterpolatedImage</span></code></a>, and then using the xValue() method for that new
object.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>position</strong> – The position at which you want the surface brightness of the object.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the surface brightness at that position.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="simple.html" class="btn btn-neutral float-right" title="Simple Profiles" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="sb.html" class="btn btn-neutral float-left" title="Surface Brightness Profiles" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, GalSim-developers

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>