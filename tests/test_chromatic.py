# Copyright (c) 2012-2018 by the GalSim developers team on GitHub
# https://github.com/GalSim-developers
#
# This file is part of GalSim: The modular galaxy image simulation toolkit.
# https://github.com/GalSim-developers/GalSim
#
# GalSim is free software: redistribution and use in source and binary forms,
# with or without modification, are permitted provided that the following
# conditions are met:
#
# 1. Redistributions of source code must retain the above copyright notice, this
#    list of conditions, and the disclaimer given in the accompanying LICENSE
#    file.
# 2. Redistributions in binary form must reproduce the above copyright notice,
#    this list of conditions, and the disclaimer given in the documentation
#    and/or other materials provided with the distribution.
#

from __future__ import print_function
import os
import numpy as np

import galsim
from galsim_test_helpers import *

bppath = os.path.join(galsim.meta_data.share_dir, "bandpasses")
sedpath = os.path.join(galsim.meta_data.share_dir, "SEDs")

# from pylab import *
# def plotme(image):
#     imshow(image.array)
#     show()

# liberal use of globals here...
zenith_angle = 20 * galsim.degrees
R500 = galsim.dcr.get_refraction(500.0, zenith_angle) # normalize refraction to 500nm

# some profile parameters to test with
bulge_n = 4.0
bulge_hlr = 0.5
bulge_e1 = 0.2
bulge_e2 = 0.2

disk_n = 1.0
disk_hlr = 1.0
disk_e1 = 0.4
disk_e2 = 0.2

PSF_hlr = 0.3
PSF_beta = 3.0
PSF_e1 = 0.01
PSF_e2 = 0.06

shear_g1 = 0.01
shear_g2 = 0.02

# load a filter
bandpass = (galsim.Bandpass(os.path.join(bppath, 'LSST_r.dat'), 'nm'))
bandpass_g = (galsim.Bandpass(os.path.join(bppath, 'LSST_g.dat'), 'nm'))
bandpass_z = (galsim.Bandpass(os.path.join(bppath, 'LSST_z.dat'), 'nm'))

# load some spectra
bulge_SED = (galsim.SED(os.path.join(sedpath, 'CWW_E_ext.sed'), wave_type='ang',
                        flux_type='flambda')
             .thin(rel_err=1e-3)
             .withFluxDensity(target_flux_density=0.3, wavelength=500.0))

disk_SED = (galsim.SED(os.path.join(sedpath, 'CWW_Sbc_ext.sed'), wave_type='ang',
                       flux_type='flambda')
            .thin(rel_err=1e-3)
            .withFluxDensity(target_flux_density=0.3, wavelength=500.0))

# define the directory containing some reference images
refdir = os.path.join(".", "chromatic_reference_images") # Directory containing the reference


@timer
def test_draw_add_commutativity():
    """Compare two chromatic images, one generated by adding up GSObject profiles before drawing,
    and one generated (via galsim.chromatic) by drawing image summands wavelength-by-wavelength
    while updating the profile and adding as you go.
    """
    import time

    stamp_size = 32
    pixel_scale = 0.2

    #------------------------------------------------------------------------------
    # Use galsim.base functions to generate chromaticity by creating an effective
    # PSF by adding together weighted monochromatic PSFs.
    # Profiles are added together before drawing.
    #------------------------------------------------------------------------------

    # make galaxy
    GS_gal = galsim.Sersic(n=bulge_n, half_light_radius=bulge_hlr)
    GS_gal = GS_gal.shear(e1=bulge_e1, e2=bulge_e2)
    GS_gal = GS_gal.shear(g1=shear_g1, g2=shear_g2)

    # make effective PSF with Riemann sum midpoint rule
    mPSFs = [] # list of flux-scaled monochromatic PSFs
    N = 50
    h = (bandpass.red_limit * 1.0 - bandpass.blue_limit) / N
    ws = [bandpass.blue_limit + h*(i+0.5) for i in range(N)]
    shift_fn = lambda w:(0, ((galsim.dcr.get_refraction(w, zenith_angle) - R500)
                             * (galsim.radians / galsim.arcsec)))
    dilate_fn = lambda w:(w/500.0)**(-0.2)
    for w in ws:
        flux = bulge_SED(w) * bandpass(w) * h
        mPSF = galsim.Moffat(flux=flux, beta=PSF_beta, half_light_radius=PSF_hlr*dilate_fn(w))
        mPSF = mPSF.shear(e1=PSF_e1, e2=PSF_e2)
        mPSF = mPSF.shift(shift_fn(w))
        mPSFs.append(mPSF)
    PSF = galsim.Add(mPSFs)

    # final profile
    final = galsim.Convolve([GS_gal, PSF])
    GS_image = galsim.ImageD(stamp_size, stamp_size, scale=pixel_scale)
    GS_kimage = galsim.ImageCD(stamp_size, stamp_size, scale=pixel_scale)
    t2 = time.time()
    GS_image = final.drawImage(image=GS_image)
    GS_kimage = final.drawKImage(image=GS_kimage)
    t3 = time.time()
    print('GS_object drawImage, drawKImage took {0} seconds.'.format(t3-t2))
    # plotme(GS_image)

    #------------------------------------------------------------------------------
    # Use galsim.chromatic to generate chromaticity.  Internally, this module draws
    # the result at each wavelength and adds the results together.  I.e., drawing
    # and adding happen in the reverse order of the above.
    #------------------------------------------------------------------------------

    # make galaxy
    mono_gal = galsim.Sersic(n=bulge_n, half_light_radius=bulge_hlr)
    chromatic_gal = mono_gal * bulge_SED
    do_pickle(bulge_SED)
    do_pickle(chromatic_gal, lambda x: x.drawImage(bandpass, method='no_pixel',
                                                   nx=10, ny=10, scale=1))
    do_pickle(chromatic_gal)

    # Shear object
    chromatic_gal = chromatic_gal.shear(e1=bulge_e1, e2=bulge_e2)
    chromatic_gal = chromatic_gal.shear(g1=shear_g1, g2=shear_g2)
    do_pickle(chromatic_gal, lambda x: x.drawImage(bandpass, method='no_pixel',
                                                   nx=10, ny=10, scale=1))
    do_pickle(chromatic_gal)

    # make chromatic PSF
    mono_PSF = galsim.Moffat(beta=PSF_beta, half_light_radius=PSF_hlr)
    mono_PSF = mono_PSF.shear(e1=PSF_e1, e2=PSF_e2)
    chromatic_PSF = galsim.ChromaticTransformation(mono_PSF, flux_ratio=1.0)
    do_pickle(chromatic_PSF, lambda x: (x.evaluateAtWavelength(bandpass.effective_wavelength)
                                         .drawImage(method='no_pixel', nx=10, ny=10, scale=1)))
    do_pickle(chromatic_PSF)
    chromatic_PSF = chromatic_PSF.dilate(dilate_fn)
    chromatic_PSF = chromatic_PSF.shift(shift_fn)

    # final profile
    chromatic_final = galsim.Convolve([chromatic_gal, chromatic_PSF])
    chromatic_image = galsim.ImageD(stamp_size, stamp_size, scale=pixel_scale)
    chromatic_kimage = galsim.ImageCD(stamp_size, stamp_size, scale=pixel_scale)
    # use chromatic parent class to draw without ChromaticConvolution acceleration...
    t4 = time.time()
    integrator = galsim.integ.ContinuousIntegrator(galsim.integ.midptRule, N=N, use_endpoints=False)
    # NB. You cannot use ChromaticObject.drawImage() here, since it will automatically farm out to
    #     the ChromaticConvolution version of drawImage rather than respecting the
    #     ChromaticObject specification.  Using super() doesn't seem to work either.  So I just
    #     went ahead and converted this statement to the new format.  There are a couple other
    #     similar times in the test suite where we want to force it to use the base class
    #     implementation, so those had to be switched as well.
    galsim.ChromaticObject.drawImage(chromatic_final, bandpass, image=chromatic_image,
                                     integrator=integrator, add_to_image=True)
    galsim.ChromaticObject.drawKImage(chromatic_final, bandpass, image=chromatic_kimage,
                                      integrator=integrator)
    t5 = time.time()
    print('ChromaticObject drawImage, drawKImage took {0} seconds.'.format(t5-t4))
    # plotme(chromatic_image)

    peak = chromatic_image.array.max()
    printval(GS_image, chromatic_image)
    np.testing.assert_array_almost_equal(
        chromatic_image.array/peak, GS_image.array/peak, 6,
        err_msg="Directly computed chromatic image disagrees with image created using "
                +"galsim.chromatic")

    kpeak = chromatic_kimage.array.real.max()
    np.testing.assert_array_almost_equal(
        chromatic_kimage.array/kpeak, GS_kimage.array/kpeak, 6,
        err_msg="Directly computed chromatic kimage disagrees with kimage created using "
                +"galsim.chromatic")

    # Repeat with multiple inseparable profiles.
    delta = galsim.ChromaticObject(galsim.DeltaFunction()).rotate(lambda wave: wave*galsim.degrees)
    chromatic_final2 = galsim.Convolve(chromatic_gal, chromatic_PSF, delta)
    chromatic_final2.drawImage(bandpass, image=chromatic_image, integrator=integrator)
    chromatic_final2.drawKImage(bandpass, image=chromatic_kimage, integrator=integrator)
    # Note: fft vs real space differences now, so only accurate to 1.e-3
    np.testing.assert_array_almost_equal(chromatic_image.array/peak, GS_image.array/peak, 3)
    np.testing.assert_array_almost_equal(chromatic_kimage.array/kpeak, GS_kimage.array/kpeak, 6)

    # Check error handling of too few sample points
    integrator = galsim.integ.ContinuousIntegrator(galsim.integ.midptRule, N=1, use_endpoints=False)
    with assert_raises(ValueError):
        chromatic_final.drawImage(bandpass, integrator=integrator)
    integrator = galsim.integ.ContinuousIntegrator(galsim.integ.trapzRule, N=1, use_endpoints=False)
    with assert_raises(ValueError):
        chromatic_final.drawImage(bandpass, integrator=integrator)

    # As an aside, check for appropriate tests of 'integrator' argument.
    assert_raises(ValueError, chromatic_final.drawImage, bandpass, method='no_pixel',
                  integrator='midp') # minor misspelling
    assert_raises(ValueError, chromatic_final.drawKImage, bandpass,
                  integrator='midp') # minor misspelling
    assert_raises(TypeError, chromatic_final.drawImage, bandpass, method='no_pixel',
                  integrator=galsim.integ.midpt)
    assert_raises(TypeError, chromatic_final.drawKImage, bandpass,
                  integrator=galsim.integ.midpt)

    # Can't use base class directly.
    assert_raises(NotImplementedError, galsim.integ.ImageIntegrator)


@timer
def test_ChromaticConvolution_InterpolatedImage():
    """Check that we can interchange the order of integrating over wavelength and convolving for
    separable ChromaticObjects.  This involves storing the results of integrating first in an
    InterpolatedImage.
    """
    pixel_scale = 0.2
    stamp_size = 32

    # stars are fundamentally delta-fns with an SED
    star = galsim.Gaussian(fwhm=1.e-8) * bulge_SED
    mono_PSF = galsim.Gaussian(half_light_radius=PSF_hlr)
    PSF = galsim.ChromaticAtmosphere(mono_PSF, base_wavelength=500.0,
                                     zenith_angle=zenith_angle)

    final = galsim.Convolve(star, PSF)
    image = galsim.ImageD(stamp_size, stamp_size, scale=pixel_scale)

    do_pickle(star)
    do_pickle(PSF)
    do_pickle(final)

    # draw image using speed tricks in ChromaticConvolution.draw
    # For this particular test, need to set iimult=4 in order to pass.
    II_image = final.drawImage(bandpass, image=image, iimult=4)
    II_flux = II_image.array.sum()

    image2 = image.copy()
    # draw image without any speed tricks using ChromaticObject.drawImage
    D_image = galsim.ChromaticObject.drawImage(final, bandpass, image=image2)
    D_flux = D_image.array.sum()

    #compare
    print('Flux when integrating first, convolving second: {0}'.format(II_flux))
    print('Flux when convolving first, integrating second: {0}'.format(D_flux))
    printval(II_image, D_image)
    # This used to work with decimal=5, but is apparently sensitive to the particular details of the
    # bandpass thinning used.  decimal=4 is still good though.
    np.testing.assert_array_almost_equal(
        II_image.array, D_image.array, 4,
        err_msg="ChromaticConvolution draw not equivalent to regular draw")

    # Check flux scaling
    II_image2 = (final * 2.).drawImage(bandpass, image=image, iimult=4)
    II_flux2 = II_image2.array.sum()
    np.testing.assert_array_almost_equal(
        II_flux2, 2.*II_flux, 5,
        err_msg="ChromaticConvolution * 2 resulted in wrong flux.")


@timer
def test_chromatic_add():
    """Test the `+` operator on ChromaticObjects"""
    stamp_size = 32
    pixel_scale = 0.2

    # create galaxy profiles
    mono_bulge = galsim.Sersic(n=bulge_n, half_light_radius=bulge_hlr)
    bulge = mono_bulge * bulge_SED
    bulge = bulge.shear(e1=bulge_e1, e2=bulge_e2)

    mono_disk = galsim.Sersic(n=disk_n, half_light_radius=disk_hlr)
    disk = mono_disk * disk_SED
    disk = disk.shear(e1=disk_e1, e2=disk_e2)

    # test `+` operator
    bdgal = bulge + disk
    bdgal = bdgal.shear(g1=shear_g1, g2=shear_g2)

    # now shear the indiv profiles
    bulge = bulge.shear(g1=shear_g1, g2=shear_g2)
    disk = disk.shear(g1=shear_g1, g2=shear_g2)

    # create PSF
    mono_PSF = galsim.Moffat(beta=PSF_beta, half_light_radius=PSF_hlr)
    mono_PSF = mono_PSF.shear(e1=PSF_e1, e2=PSF_e2)
    chromatic_PSF = galsim.ChromaticAtmosphere(mono_PSF, base_wavelength=500.0,
                                               zenith_angle=zenith_angle)

    # create final profile
    final = galsim.Convolve(bdgal, chromatic_PSF)
    image = galsim.ImageD(stamp_size, stamp_size, scale=pixel_scale)
    image = final.drawImage(bandpass, image=image)

    do_pickle(bulge)
    do_pickle(disk)
    do_pickle(bdgal)
    do_pickle(chromatic_PSF)
    do_pickle(final)

    bulge_image = galsim.ImageD(stamp_size, stamp_size, scale=pixel_scale)
    bulge_part = galsim.Convolve([bulge, chromatic_PSF])
    bulge_image = bulge_part.drawImage(bandpass, image=bulge_image)
    disk_image = galsim.ImageD(stamp_size, stamp_size, scale=pixel_scale)
    disk_part = galsim.Convolve([disk, chromatic_PSF])
    disk_image = disk_part.drawImage(bandpass, image=disk_image)

    piecewise_image = bulge_image + disk_image
    print('bulge image flux: {0}'.format(bulge_image.array.sum()))
    print('disk image flux: {0}'.format(disk_image.array.sum()))
    print('piecewise image flux: {0}'.format(piecewise_image.array.sum()))
    print('bdimage flux: {0}'.format(image.array.sum()))
    printval(image, piecewise_image)
    np.testing.assert_array_almost_equal(
            image.array, piecewise_image.array, 6,
            err_msg="`+` operator doesn't match manual image addition")

    # Check flux scaling
    flux = image.array.sum()
    image = (final * 2.).drawImage(bandpass, image=image)
    flux2 = image.array.sum()
    np.testing.assert_array_almost_equal(
        flux2, 2.*flux, 5,
        err_msg="ChromaticConvolution with sum * 2 resulted in wrong flux.")

    # apply flux scaling to ChromaticSum
    final2 = galsim.Convolve(bdgal*2, chromatic_PSF)
    image = final2.drawImage(bandpass, image=image)
    flux2 = image.array.sum()
    np.testing.assert_array_almost_equal(
        flux2, 2.*flux, 5,
        err_msg="ChromaticSum * 2 resulted in wrong flux.")

    # also check that a - b  ==  a + (-b)
    c = bulge_part - disk_part
    d = bulge_part + (-disk_part)
    assert c == d

    cimage = c.drawImage(bandpass, nx=stamp_size, ny=stamp_size, scale=pixel_scale)
    dimage = d.drawImage(bandpass, cimage.copy())
    np.testing.assert_equal(cimage, dimage, "chromatic a-b != a+(-b)")

@timer
def test_dcr_moments():
    """Check that zenith-direction surface brightness distribution first and second moments obey
    expected behavior for differential chromatic refraction when comparing objects drawn with
    different SEDs."""
    stamp_size = 256
    pixel_scale = 0.025

    # stars are fundamentally delta-fns with an SED
    star1 = galsim.Gaussian(fwhm=1.e-8) * bulge_SED
    star2 = galsim.Gaussian(fwhm=1.e-8) * disk_SED

    shift_fn = lambda w:(0, ((galsim.dcr.get_refraction(w, zenith_angle) - R500)
                             * (galsim.radians / galsim.arcsec)))
    mono_PSF = galsim.Moffat(beta=PSF_beta, half_light_radius=PSF_hlr)
    PSF = galsim.ChromaticObject(mono_PSF).shift(shift_fn)

    final1 = galsim.Convolve([star1, PSF])
    final2 = galsim.Convolve([star2, PSF])

    image1 = galsim.ImageD(stamp_size, stamp_size, scale=pixel_scale)
    image2 = galsim.ImageD(stamp_size, stamp_size, scale=pixel_scale)

    image1 = final1.drawImage(bandpass, image=image1)
    image2 = final2.drawImage(bandpass, image=image2)
    # plotme(image1)

    mom1 = galsim.utilities.unweighted_moments(image1)
    mom2 = galsim.utilities.unweighted_moments(image2)
    dR_image = (mom1['My'] - mom2['My']) * pixel_scale
    dV_image = (mom1['Myy'] - mom2['Myy']) * (pixel_scale)**2

    # analytic moment differences
    R_bulge, V_bulge = bulge_SED.calculateDCRMomentShifts(bandpass, zenith_angle=zenith_angle)
    R_disk, V_disk = disk_SED.calculateDCRMomentShifts(bandpass, zenith_angle=zenith_angle)
    dR_analytic = (R_bulge[1] - R_disk[1]) * 180.0/np.pi * 3600
    dV_analytic = (V_bulge[1,1] - V_disk[1,1]) * (180.0/np.pi * 3600)**2

    # also compute dR_analytic using ChromaticObject.calculateCentroid()
    centroid1 = final1.calculateCentroid(bandpass)
    centroid2 = final2.calculateCentroid(bandpass)
    dR_centroid = (centroid1 - centroid2).y

    print('image delta R:    {0}'.format(dR_image))
    print('analytic delta R: {0}'.format(dR_analytic))
    print('centroid delta R: {0}'.format(dR_centroid))
    print('image delta V:    {0}'.format(dV_image))
    print('analytic delta V: {0}'.format(dV_analytic))
    np.testing.assert_almost_equal(dR_image, dR_analytic, 5,
                                   err_msg="dRbar Shift from DCR doesn't match analytic formula")
    np.testing.assert_almost_equal(dR_analytic, dR_centroid, 10,
                                   err_msg="direct dRbar calculation doesn't match"
                                           +" ChromaticObject.calculateCentroid()")
    np.testing.assert_almost_equal(dV_image, dV_analytic, 5,
                                   err_msg="dV Shift from DCR doesn't match analytic formula")


@timer
def test_chromatic_seeing_moments():
    """Check that surface brightness distribution second moments obey expected behavior
    for chromatic seeing when comparing stars drawn with different SEDs."""
    pixel_scale = 0.0075
    stamp_size = 1024

    # stars are fundamentally delta-fns with an SED
    star1 = galsim.Gaussian(fwhm=1e-8) * bulge_SED
    star2 = galsim.Gaussian(fwhm=1e-8) * disk_SED

    indices = [-0.2, 0.6, 1.0]
    for index in indices:

        mono_PSF = galsim.Gaussian(half_light_radius=PSF_hlr)
        PSF = galsim.ChromaticObject(mono_PSF).dilate(lambda w:(w/500.0)**index)

        final1 = galsim.Convolve([star1, PSF])
        final2 = galsim.Convolve([star2, PSF])

        image1 = galsim.ImageD(stamp_size, stamp_size, scale=pixel_scale)
        image2 = galsim.ImageD(stamp_size, stamp_size, scale=pixel_scale)

        image1 = final1.drawImage(bandpass, image=image1)
        image2 = final2.drawImage(bandpass, image=image2)

        shape1 = galsim.utilities.unweighted_shape(image1)
        shape2 = galsim.utilities.unweighted_shape(image2)
        dr2byr2_image = (shape1['rsqr'] - shape2['rsqr']) / shape1['rsqr']

        # analytic moment differences
        r2_1 = bulge_SED.calculateSeeingMomentRatio(bandpass, alpha=index)
        r2_2 = disk_SED.calculateSeeingMomentRatio(bandpass, alpha=index)
        dr2byr2_analytic = (r2_1 - r2_2) / r2_1

        np.testing.assert_almost_equal(dr2byr2_image, dr2byr2_analytic, 5,
                                       err_msg="Moment Shift from chromatic seeing doesn't"+
                                               " match analytic formula")

        print('image delta(r^2) / r^2:    {0}'.format(dr2byr2_image))
        print('analytic delta(r^2) / r^2: {0}'.format(dr2byr2_analytic))


@timer
def test_monochromatic_filter():
    """Check that ChromaticObject drawn through a very narrow band filter matches analogous
    GSObject.
    """
    pixel_scale = 0.2
    stamp_size = 32

    chromatic_gal = galsim.Gaussian(fwhm=1.0) * bulge_SED
    GS_gal = galsim.Gaussian(fwhm=1.0)

    shift_fn = lambda w:(0, ((galsim.dcr.get_refraction(w, zenith_angle) - R500)
                             * (galsim.radians / galsim.arcsec)))
    dilate_fn = lambda wave: (wave/500.0)**(-0.2)
    mono_PSF = galsim.Gaussian(half_light_radius=PSF_hlr)
    mono_PSF = mono_PSF.shear(e1=PSF_e1, e2=PSF_e2)
    chromatic_PSF = galsim.ChromaticObject(mono_PSF).dilate(dilate_fn).shift(shift_fn)

    chromatic_final = galsim.Convolve([chromatic_gal, chromatic_PSF])

    fws = [350, 475, 625, 750, 875, 975] # approximate ugrizy filter central wavelengths
    for fw in fws:
        chromatic_image = galsim.ImageD(stamp_size, stamp_size, scale=pixel_scale)
        narrow_filter = galsim.Bandpass(galsim.LookupTable([fw-0.01, fw, fw+0.01],
                                                           [1.0, 1.0, 1.0],
                                                           interpolant='linear'), 'nm')
        chromatic_image = chromatic_final.drawImage(narrow_filter, image=chromatic_image)
        # take out normalization
        chromatic_image /= 0.02
        chromatic_image /= bulge_SED(fw)

        # now do non-chromatic version
        GS_PSF = galsim.Gaussian(half_light_radius=PSF_hlr)
        GS_PSF = GS_PSF.shear(e1=PSF_e1, e2=PSF_e2)
        GS_PSF = GS_PSF.dilate(dilate_fn(fw))
        GS_PSF = GS_PSF.shift(shift_fn(fw))
        GS_final = galsim.Convolve([GS_gal, GS_PSF])
        GS_image = galsim.ImageD(stamp_size, stamp_size, scale=pixel_scale)
        GS_final.drawImage(image=GS_image)
        # plotme(GS_image)

        printval(chromatic_image, GS_image)
        np.testing.assert_array_almost_equal(chromatic_image.array, GS_image.array, 5,
                err_msg="ChromaticObject.drawImage() with monochromatic filter doesn't match"+
                        "GSObject.drawImage()")


@timer
def test_chromatic_flux():
    """Test that the total drawn flux is equal to the integral of bandpass * sed over wavelength.
    """
    pixel_scale = 0.5
    stamp_size = 64

    # stars are fundamentally delta-fns with an SED
    star = galsim.Gaussian(fwhm=1e-8) * bulge_SED
    mono_PSF = galsim.Gaussian(half_light_radius=PSF_hlr)
    PSF = galsim.ChromaticAtmosphere(mono_PSF, base_wavelength=500,
                                     zenith_angle=zenith_angle)

    final = galsim.Convolve([star, PSF])
    image = galsim.ImageD(stamp_size, stamp_size, scale=pixel_scale)
    image2 = galsim.ImageD(stamp_size, stamp_size, scale=pixel_scale)

    final.drawImage(bandpass, image=image)
    ChromaticConvolve_flux = image.array.sum()

    galsim.ChromaticObject.drawImage(final, bandpass, image=image2)
    ChromaticObject_flux = image2.array.sum()

    # analytic integral...
    analytic_flux = bulge_SED.calculateFlux(bandpass)

    printval(image, image2)
    np.testing.assert_almost_equal(ChromaticObject_flux/analytic_flux, 1.0, 4,
                                   err_msg="Drawn ChromaticObject flux doesn't match " +
                                   "analytic prediction")
    np.testing.assert_almost_equal(ChromaticConvolve_flux/analytic_flux, 1.0, 4,
                                   err_msg="Drawn ChromaticConvolve flux doesn't match " +
                                   "analytic prediction")

    # Also check that the flux is okay and the image fairly consistent when using interpolation
    # for the ChromaticAtmosphere.
    PSF = PSF.interpolate(waves=np.linspace(bandpass.blue_limit, bandpass.red_limit, 30))
    final_int = galsim.Convolve([star, PSF])
    image3 = galsim.ImageD(stamp_size, stamp_size, scale=pixel_scale)
    final_int.drawImage(bandpass, image=image3)
    int_flux = image3.array.sum()
    # Be *slightly* less stringent in this test given that we did use interpolation.
    printval(image, image3)
    np.testing.assert_almost_equal(
        int_flux/analytic_flux, 1.0, 3,
        err_msg="Drawn ChromaticConvolve flux (interpolated) doesn't match analytic prediction")
    # As an aside, check for appropriate tests of 'integrator' argument.
    assert_raises(ValueError, final_int.drawImage, bandpass, integrator='midp') # minor misspelling
    assert_raises(TypeError, final_int.drawImage, bandpass, integrator=galsim.integ.midpt)
    do_pickle(PSF)

    # Check option to not use exact SED
    PSF = PSF.deinterpolated
    PSF = PSF * 1.0
    PSF = PSF.interpolate(waves=np.linspace(bandpass.blue_limit, bandpass.red_limit, 30),
                          use_exact_SED=False)
    final_int = galsim.Convolve([star, PSF])
    image3 = galsim.ImageD(stamp_size, stamp_size, scale=pixel_scale)
    final_int.drawImage(bandpass, image=image3)
    int_flux = image3.array.sum()
    # Be *slightly* less stringent in this test given that we did use interpolation.
    printval(image, image3)
    np.testing.assert_almost_equal(
        int_flux/analytic_flux, 1.0, 3,
        err_msg="Drawn ChromaticConvolve flux (interpolated) doesn't match analytic prediction")
    # As an aside, check for appropriate tests of 'integrator' argument.
    assert_raises(ValueError, final_int.drawImage, bandpass, integrator='midp') # minor misspelling
    assert_raises(TypeError, final_int.drawImage, bandpass, integrator=galsim.integ.midpt)
    do_pickle(PSF)

    # Go back to no interpolation (this will effect the PSFs that are used below).
    PSF = PSF.deinterpolated

    # Try adjusting flux to something else.
    target_flux = 2.63
    bulge_SED2 = bulge_SED.withFlux(target_flux, bandpass)
    star2 = galsim.Gaussian(fwhm=1e-8) * bulge_SED2
    final = galsim.Convolve([star2, PSF])
    final.drawImage(bandpass, image=image)
    np.testing.assert_almost_equal(image.array.sum()/target_flux, 1.0, 4,
                                   err_msg="Drawn ChromaticConvolve flux doesn't match " +
                                   "using SED.withFlux()")

    # Use flux_ratio instead.
    flux_ratio = target_flux / analytic_flux
    bulge_SED3 = bulge_SED * flux_ratio
    star3 = galsim.Gaussian(fwhm=1e-8) * bulge_SED3
    final = galsim.Convolve([star3, PSF])
    final.drawImage(bandpass, image=image)
    np.testing.assert_almost_equal(image.array.sum()/target_flux, 1.0, 4,
                                   err_msg="Drawn ChromaticConvolve flux doesn't match " +
                                   "using SED * flux_ratio")

    # This should be equivalent.
    bulge_SED3 = flux_ratio * bulge_SED
    star3 = galsim.Gaussian(fwhm=1e-8) * bulge_SED3
    final = galsim.Convolve([star3, PSF])
    final.drawImage(bandpass, image=image)
    np.testing.assert_almost_equal(image.array.sum()/target_flux, 1.0, 4,
                                   err_msg="Drawn ChromaticConvolve flux doesn't match " +
                                   "using flux_ratio * SED")

    # Use flux_ratio on the chromatic object instead.
    star4 = star * flux_ratio
    final = galsim.Convolve([star4, PSF])
    final.drawImage(bandpass, image=image)
    np.testing.assert_almost_equal(image.array.sum()/target_flux, 1.0, 4,
                                   err_msg="Drawn ChromaticConvolve flux doesn't match " +
                                   "using ChromaticObject * flux_ratio")

    # This should be equivalent.
    star4 = flux_ratio * star
    final = galsim.Convolve([star4, PSF])
    final.drawImage(bandpass, image=image)
    np.testing.assert_almost_equal(image.array.sum()/target_flux, 1.0, 4,
                                   err_msg="Drawn ChromaticConvolve flux doesn't match " +
                                   "using flux_ratio * ChromaticObject")

    # As should this.
    star4 = star.withScaledFlux(lambda wave: flux_ratio)
    final = galsim.Convolve([star4, PSF])
    final.drawImage(bandpass, image=image)
    np.testing.assert_almost_equal(image.array.sum()/target_flux, 1.0, 4,
                                   err_msg="Drawn ChromaticConvolve flux doesn't match " +
                                   "using ChromaticObject.withScaledFlux(flux_ratio)")
    # Can't scale GSObject by function (just SED)
    with assert_raises(TypeError):
        galsim.Gaussian(fwhm=1e-8).withScaledFlux(lambda wave: flux)
    with assert_raises(TypeError):
        galsim.Gaussian(fwhm=1e-8) * (lambda wave: flux)

    # Test ChromaticObject.withFlux
    star5 = star.withFlux(1.0, bandpass)
    final = galsim.Convolve([star5, PSF])
    final.drawImage(bandpass, image=image)
    np.testing.assert_almost_equal(image.array.sum(), 1.0, 4,
                                   err_msg="Drawn ChromaticConvolve flux doesn't match "
                                   "using ChromaticObject.withFlux(1.0)")

    # Test withMagnitude.  The zeropoint is the magnitude at which the object produces
    # 1 photon/sec/cm^2 in the given filter.  So drawing with mag == zeropoint should yield a flux
    # of 1.0
    bandpass2 = bandpass.withZeropoint(25.0)
    star6 = star.withMagnitude(25.0, bandpass2)
    final = galsim.Convolve([star6, PSF])
    final.drawImage(bandpass2, image=image)
    np.testing.assert_almost_equal(image.array.sum(), 1.0, 4,
                                   err_msg="Drawn ChromaticConvolve flux doesn't match "
                                   "using ChromaticObject.withMagnitude(0.0)")
    assert_raises(galsim.GalSimError, star.withMagnitude, 25.0, bandpass)

    # Some very simple tests of withFluxDensity.
    star7 = star.withFluxDensity(5.0, 500)
    final = galsim.Convolve([star7, PSF])
    final.evaluateAtWavelength(500).drawImage(image=image)
    np.testing.assert_almost_equal(image.array.sum(), 5.0, 4,
                                   err_msg="Drawn ChromaticConvolve flux density doesn't match "
                                   "using ChromaticObject.withFluxDensity(5.0, 500)")
    np.testing.assert_almost_equal(5.0, final.SED(500), 7,
                                   err_msg="ChromaticObject.SED(500) doesn't match "
                                   "withFluxDensity.")
    from astropy import units
    star8 = star.withFluxDensity(5.0, 5000*units.AA)
    assert star7 == star8
    star9 = star.withFluxDensity(0.5*units.astrophys.photon/(units.s*units.cm**2*units.AA), 500)
    assert star7 == star9


@timer
def test_double_ChromaticSum():
    ''' Test logic section of ChromaticConvolve that splits apart ChromaticSums for the case that
    more than one ChromaticSum's are convolved together.
    '''
    a = galsim.Gaussian(fwhm=1.0) * bulge_SED
    b = galsim.Gaussian(fwhm=2.0) * bulge_SED
    c = galsim.Gaussian(fwhm=3.0)
    d = galsim.Gaussian(fwhm=4.0)

    image = galsim.ImageD(16, 16, scale=0.2)
    obj = galsim.Convolve(a+b, c+d)
    obj.drawImage(bandpass, image=image, method='no_pixel')

    do_pickle(obj)

    image_a = galsim.ImageD(16, 16, scale=0.2)
    image_b = galsim.ImageD(16, 16, scale=0.2)
    obj_a = galsim.Convolve(a, c+d)
    obj_b = galsim.Convolve(b, c+d)
    obj_a.drawImage(bandpass, image = image_a, method='no_pixel')
    obj_b.drawImage(bandpass, image = image_b, method='no_pixel')
    printval(image, image_a+image_b)

    np.testing.assert_almost_equal(image.array, (image_a+image_b).array, 5,
                                   err_msg="Convolving two ChromaticSums failed")


@timer
def test_ChromaticConvolution_of_ChromaticConvolution():
    """Check that the __init__ of ChromaticConvolution properly expands arguments that are already
    ChromaticConvolutions.
    """
    a = galsim.Gaussian(fwhm=1.0) * bulge_SED
    b = galsim.Gaussian(fwhm=2.0)
    c = galsim.Gaussian(fwhm=3.0)
    d = galsim.Gaussian(fwhm=4.0)

    e = galsim.Convolve(a, b)
    f = galsim.Convolve(c, d)
    g = galsim.Convolve(e, f)
    if any(isinstance(h, galsim.ChromaticConvolution) for h in g.obj_list):
        raise AssertionError("ChromaticConvolution did not expand ChromaticConvolution argument")

    assert_raises(TypeError, galsim.ChromaticConvolution)
    assert_raises(TypeError, galsim.ChromaticConvolution, bulge_SED)
    assert_raises(TypeError, galsim.ChromaticConvolution, [a,b], invalid=True)
    assert_raises(NotImplementedError, galsim.ChromaticConvolution, [a,b], real_space=True)


@timer
def test_ChromaticAutoConvolution():
    a = galsim.Gaussian(fwhm=1.0)
    b = galsim.Gaussian(fwhm=2.0) * bulge_SED
    im1 = galsim.ImageD(32, 32, scale=0.2)
    im2 = galsim.ImageD(32, 32, scale=0.2)
    c = galsim.Convolve(a, a, b)
    c.drawImage(bandpass, image=im1, method='no_pixel')
    d = galsim.Convolve(galsim.AutoConvolve(a), b)
    d.drawImage(bandpass, image=im2, method='no_pixel')
    printval(im1, im2)
    np.testing.assert_array_almost_equal(im1.array, im2.array, 5,
                                         "ChromaticAutoConvolution(a) not equal to "
                                         "ChromaticConvolution(a,a)")

    # Check flux scaling
    flux = im2.array.sum()
    im2 = (d * 2.).drawImage(bandpass, image=im2, method='no_pixel')
    flux2 = im2.array.sum()
    np.testing.assert_array_almost_equal(
        flux2, 2.*flux, 5,
        err_msg="ChromaticAutoConvolution * 2 resulted in wrong flux.")


@timer
def test_ChromaticAutoCorrelation():
    a = galsim.Gaussian(fwhm=1.0)
    b = galsim.Gaussian(fwhm=2.0) * bulge_SED
    im1 = galsim.ImageD(32, 32, scale=0.2)
    im2 = galsim.ImageD(32, 32, scale=0.2)
    c = galsim.Convolve(a, a.rotate(180.0 * galsim.degrees), b)
    c.drawImage(bandpass, image=im1, method='no_pixel')
    d = galsim.Convolve(galsim.AutoCorrelate(a), b)
    d.drawImage(bandpass, image=im2, method='no_pixel')
    printval(im1, im2)
    np.testing.assert_array_almost_equal(im1.array, im2.array, 5,
                                         "ChromaticAutoCorrelate(a) not equal to "
                                         "ChromaticConvolution(a,a.rotate(180.0*galsim.degrees)")

    # Check flux scaling
    flux = im2.array.sum()
    im2 = (d * 2.).drawImage(bandpass, image=im2, method='no_pixel')
    flux2 = im2.array.sum()
    np.testing.assert_array_almost_equal(
        flux2/(2.*flux), 1.0, 5,
        err_msg="ChromaticAutoCorrelation * 2 resulted in wrong flux.")


@timer
def test_ChromaticObject_expand():
    im1 = galsim.ImageD(32, 32, scale=0.2)
    im2 = galsim.ImageD(32, 32, scale=0.2)
    a = galsim.Gaussian(fwhm=1.0).expand(1.1) * bulge_SED
    b = (galsim.Gaussian(fwhm=1.0) * bulge_SED).expand(1.1)

    a.drawImage(bandpass, image=im1, method='no_pixel')
    b.drawImage(bandpass, image=im2, method='no_pixel')
    printval(im1, im2)
    np.testing.assert_array_almost_equal(im1.array, im2.array, 5,
                                         "ChromaticObject.expand not equal to Chromatic.expand")

    do_pickle(a)
    do_pickle(b)

    # Check flux scaling
    flux = im2.array.sum()
    im2 = (b * 2.).drawImage(bandpass, image=im2, method='no_pixel')
    flux2 = im2.array.sum()
    np.testing.assert_array_almost_equal(
        flux2, 2.*flux, 5,
        err_msg="expanded ChromaticObject * 2 resulted in wrong flux.")

    # Test the wavelength-dependent expansion option
    pixel_scale = 0.3
    sigma = 1.7
    gal = galsim.Gaussian(sigma=sigma, flux=132)
    cgal = galsim.ChromaticObject(gal) * galsim.SED('1', 'nm', 'fphotons')
    im0 = gal.drawImage(scale=pixel_scale, dtype=float, method='no_pixel')
    # Initial mxx,myy should be sigma**2 in units of arcsec^2, so (sigma/pixel_scale)**2 in pix.
    mom = galsim.utilities.unweighted_moments(im0)
    np.testing.assert_almost_equal(mom['Mxx'] / (sigma/pixel_scale)**2, 1.0, decimal=4)
    np.testing.assert_almost_equal(mom['Myy'] / (sigma/pixel_scale)**2, 1.0, decimal=4)
    np.testing.assert_almost_equal(mom['Mxy'] / (sigma/pixel_scale)**2, 0, decimal=4)

    # First a very simple case with no actual wavelength dependence, but using the
    # functional syntax.
    gal1 = cgal.expand(lambda w: 1.2)
    # Use a simple bandpass so we can do the integral below analytically
    bp = galsim.Bandpass(lambda w: 1. - 0.12*(w-600)**2/100**2, 'nm', 500, 700)
    im1 = gal1.drawImage(bp, scale=pixel_scale, dtype=float, method='no_pixel')
    mom = galsim.utilities.unweighted_moments(im1)
    print('simple growth = ',mom['Mxx']/(sigma/pixel_scale)**2, 1.2**2)
    np.testing.assert_almost_equal(mom['Mxx'] / (sigma/pixel_scale)**2, 1.2**2, decimal=4)
    np.testing.assert_almost_equal(mom['Myy'] / (sigma/pixel_scale)**2, 1.2**2, decimal=4)
    np.testing.assert_almost_equal(mom['Mxy'] / (sigma/pixel_scale)**2, 0, decimal=4)

    # Use an expansion that varies quadratically within the range 500-700
    expansion = lambda w: 1.2 + 0.11*(w-600)/100 - 0.36*(w-600)**2/100**2
    gal2 = cgal.expand(expansion)
    im2 = gal2.drawImage(bp, scale=pixel_scale, dtype=float, method='no_pixel')
    # The test here relies on linearity to swap the order of the integrals.
    # The moments test is essentially int(dxdy x^2 int(dlambda I(x,y,lam) F(lam)))
    # But we can swap the order of the integrals to do int(dlambda int(dxdy x^2 I(x,y,lam) F(lam)))
    # and do the integral analytically.
    mom = galsim.utilities.unweighted_moments(im2)
    # Now the analytic integral:
    # mxx = int(dlam (sigma * expansion)**2 * expansion**2 * F(lam))
    #         / int(dlam expansion**2 * F(lam))
    # Note that two of the factors of expansion are the flux scaling.  The other two, only in the
    # numerator, are the size scaling.
    #     = sigma**2 * int(dt (1.2 + 0.11 t - 0.36 t**2)**4 (1 - 0.12 t**2), t=-1..1)
    #            / int(dt (1.2 + 0.11 t - 0.36 t**2)**2 (1 - 0.12 t**2), t=-1..1)
    #     = sigma**2 * 1.243224162 (according to Maple)
    growth_factor = galsim.integ.int1d(lambda w: expansion(w)**4 * bp(w),500,700)
    growth_factor /= galsim.integ.int1d(lambda w: expansion(w)**2 * bp(w),500,700)
    print('growth factor = ',mom['Mxx']/(sigma/pixel_scale)**2, growth_factor)
    np.testing.assert_almost_equal(mom['Mxx'] / (sigma/pixel_scale)**2, growth_factor, decimal=4)
    np.testing.assert_almost_equal(mom['Myy'] / (sigma/pixel_scale)**2, growth_factor, decimal=4)
    np.testing.assert_almost_equal(mom['Mxy'] / (sigma/pixel_scale)**2, 0, decimal=4)

    # Repeat using transform rather than expand
    gal3 = cgal.transform(expansion, 0.0, 0.0, expansion)
    im3 = gal3.drawImage(bp, scale=pixel_scale, dtype=float, method='no_pixel')
    mom = galsim.utilities.unweighted_moments(im3)
    np.testing.assert_almost_equal(mom['Mxx'] / (sigma/pixel_scale)**2, growth_factor, decimal=4)
    np.testing.assert_almost_equal(mom['Myy'] / (sigma/pixel_scale)**2, growth_factor, decimal=4)
    np.testing.assert_almost_equal(mom['Mxy'] / (sigma/pixel_scale)**2, 0, decimal=4)

    # Repeat using magnify
    gal4 = cgal.magnify(lambda w: expansion(w)**2)
    im4 = gal4.drawImage(bp, scale=pixel_scale, dtype=float, method='no_pixel')
    mom = galsim.utilities.unweighted_moments(im4)
    np.testing.assert_almost_equal(mom['Mxx'] / (sigma/pixel_scale)**2, growth_factor, decimal=4)
    np.testing.assert_almost_equal(mom['Myy'] / (sigma/pixel_scale)**2, growth_factor, decimal=4)
    np.testing.assert_almost_equal(mom['Mxy'] / (sigma/pixel_scale)**2, 0, decimal=4)

    # Repeat using lens
    gal5 = cgal.lens(0., 0., lambda w: expansion(w)**2)
    im5 = gal5.drawImage(bp, scale=pixel_scale, dtype=float, method='no_pixel')
    mom = galsim.utilities.unweighted_moments(im5)
    np.testing.assert_almost_equal(mom['Mxx'] / (sigma/pixel_scale)**2, growth_factor, decimal=4)
    np.testing.assert_almost_equal(mom['Myy'] / (sigma/pixel_scale)**2, growth_factor, decimal=4)
    np.testing.assert_almost_equal(mom['Mxy'] / (sigma/pixel_scale)**2, 0, decimal=4)

    # Dilate isn't quite the same, since it doesn't have the extra flux factor:
    gal5 = cgal.dilate(expansion)
    im5 = gal5.drawImage(bp, scale=pixel_scale, dtype=float, method='no_pixel')
    mom = galsim.utilities.unweighted_moments(im5)
    dilate_growth_factor = galsim.integ.int1d(lambda w: expansion(w)**2 * bp(w),500,700)
    dilate_growth_factor /= galsim.integ.int1d(lambda w: bp(w),500,700)
    print('dilate_growth factor = ',mom['Mxx']/(sigma/pixel_scale)**2, dilate_growth_factor)
    np.testing.assert_almost_equal(mom['Mxx'] / (sigma/pixel_scale)**2, dilate_growth_factor, decimal=4)
    np.testing.assert_almost_equal(mom['Myy'] / (sigma/pixel_scale)**2, dilate_growth_factor, decimal=4)
    np.testing.assert_almost_equal(mom['Mxy'] / (sigma/pixel_scale)**2, 0, decimal=4)


@timer
def test_ChromaticObject_rotate():
    im1 = galsim.ImageD(32, 32, scale=0.2)
    im2 = galsim.ImageD(32, 32, scale=0.2)
    a = (galsim.Gaussian(fwhm=1.0)
         .shear(eta=0.1, beta=0 * galsim.degrees)
         .rotate(1.1 * galsim.radians)) * bulge_SED
    b = (((galsim.Gaussian(fwhm=1.0)
           .shear(eta=0.1, beta=0 * galsim.degrees)) * bulge_SED)
           .rotate(1.1 * galsim.radians))

    a.drawImage(bandpass, image=im1, method='no_pixel')
    b.drawImage(bandpass, image=im2, method='no_pixel')
    printval(im1, im2)
    np.testing.assert_array_almost_equal(
            im1.array, im2.array, 5,
            "ChromaticObject.rotate not equal to ChromaticTransformation.rotate")

    do_pickle(a)
    do_pickle(b)

    # Check flux scaling
    flux = im2.array.sum()
    im2 = (b * 2.).drawImage(bandpass, image=im2, method='no_pixel')
    flux2 = im2.array.sum()
    np.testing.assert_array_almost_equal(
        flux2, 2.*flux, 5,
        err_msg="rotated ChromaticObject * 2 resulted in wrong flux.")

    # Test the wavelength-dependent rotation option
    pixel_scale = 0.3
    sigma = 1.7
    gal = galsim.Gaussian(sigma=sigma, flux=132).shear(e1=0.3)
    cgal = galsim.ChromaticObject(gal) * galsim.SED('1', 'nm', 'fphotons')
    im0 = gal.drawImage(scale=pixel_scale, dtype=float, method='no_pixel')
    # Initial distortion should be (e1,0).
    mom = galsim.utilities.unweighted_moments(im0)
    print('e1 = ',(mom['Mxx']-mom['Myy'])/(mom['Mxx']+mom['Myy']))
    print('e2 = ',(2*mom['Mxy'])/(mom['Mxx']+mom['Myy']))
    print('(mxx+myy)/sigma^2 = ',(mom['Mxx']+mom['Myy'])/(sigma/pixel_scale)**2)
    print('2/(mxx+myy)/sigma^2 = ',2./((mom['Mxx']+mom['Myy'])/(sigma/pixel_scale)**2))
    print('sqrt(1-0.3**2) = ',np.sqrt(1.-0.3**2))
    fact = np.sqrt(1.-0.3**2)
    np.testing.assert_almost_equal((mom['Mxx']-mom['Myy'])/(mom['Mxx']+mom['Myy']), 0.3, decimal=4)
    np.testing.assert_almost_equal((2*mom['Mxy'])/(mom['Mxx']+mom['Myy']), 0.0, decimal=4)
    np.testing.assert_almost_equal(mom['Mxx'] / (sigma/pixel_scale)**2, (1+0.3)/fact, decimal=4)
    np.testing.assert_almost_equal(mom['Myy'] / (sigma/pixel_scale)**2, (1-0.3)/fact, decimal=4)
    np.testing.assert_almost_equal(mom['Mxy'] / (sigma/pixel_scale)**2, 0, decimal=4)

    # First a very simple case with no actual wavelength dependence, but using the
    # functional syntax.
    gal1 = cgal.rotate(lambda w: 0.4 * galsim.radians)
    bp = galsim.Bandpass(lambda w: 1. - 0.12*(w-600)**2/100**2, 'nm', 500, 700)
    im1 = gal1.drawImage(bp, scale=pixel_scale, dtype=float, method='no_pixel')
    mom = galsim.utilities.unweighted_moments(im1)
    print('simple angle = ',(np.arctan2(2.*mom['Mxy'],mom['Mxx']-mom['Myy'])/2.), 0.4)
    np.testing.assert_almost_equal((mom['Mxx']-mom['Myy'])/(mom['Mxx']+mom['Myy']), 0.3*np.cos(2.*0.4), decimal=4)
    np.testing.assert_almost_equal((2*mom['Mxy'])/(mom['Mxx']+mom['Myy']), 0.3*np.sin(2.*0.4), decimal=4)
    rot_e1 = 0.3*np.cos(2.*0.4)
    rot_e2 = 0.3*np.sin(2.*0.4)
    np.testing.assert_almost_equal(mom['Mxx'] / (sigma/pixel_scale)**2, (1+rot_e1)/fact, decimal=4)
    np.testing.assert_almost_equal(mom['Myy'] / (sigma/pixel_scale)**2, (1-rot_e1)/fact, decimal=4)
    np.testing.assert_almost_equal(mom['Mxy'] / (sigma/pixel_scale)**2, rot_e2/fact, decimal=4)

    # Use a rotation that varies quadratically within the range 500-700
    rotation = lambda w: (0.4 + 0.11*(w-600)/100 - 0.36*(w-600)**2/100**2) * galsim.radians
    gal2 = cgal.rotate(rotation)
    im2 = gal2.drawImage(bp, scale=pixel_scale, dtype=float, method='no_pixel')
    mom = galsim.utilities.unweighted_moments(im2)
    # The analytic integrals:
    # mxx = int(dw (1 + 0.3 cos(2theta(w))) * F(w))  / int(dw F(w))
    # myy = int(dw (1 - 0.3 cos(2theta(w))) * F(w))  / int(dw F(w))
    # mxy = int(dw 0.3 sin(2theta(w)) * F(w))  / int(dw F(w))
    rot_mxx = galsim.integ.int1d(lambda w: (1.+0.3*np.cos(2*rotation(w))) * bp(w),500,700)
    rot_mxx /= galsim.integ.int1d(lambda w: bp(w),500,700)
    rot_myy = galsim.integ.int1d(lambda w: (1.-0.3*np.cos(2*rotation(w))) * bp(w),500,700)
    rot_myy /= galsim.integ.int1d(lambda w: bp(w),500,700)
    rot_mxy = galsim.integ.int1d(lambda w: (0.3*np.sin(2*rotation(w))) * bp(w),500,700)
    rot_mxy /= galsim.integ.int1d(lambda w: bp(w),500,700)
    rot_e1 = (rot_mxx-rot_myy)/(rot_mxx+rot_myy)
    rot_e2 = (2*rot_mxy)/(rot_mxx+rot_myy)
    print('rot e1 = ',(mom['Mxx']-mom['Myy'])/(mom['Mxx']+mom['Myy']), rot_e1)
    print('rot e2 = ',(2*mom['Mxy'])/(mom['Mxx']+mom['Myy']), rot_e2)
    print('rot e = ',np.sqrt(rot_e1**2+rot_e2**2))
    np.testing.assert_almost_equal((mom['Mxx']-mom['Myy'])/(mom['Mxx']+mom['Myy']), rot_e1, decimal=4)
    np.testing.assert_almost_equal((2*mom['Mxy'])/(mom['Mxx']+mom['Myy']), rot_e2, decimal=4)
    np.testing.assert_almost_equal(mom['Mxx'] / (sigma/pixel_scale)**2, (1+rot_e1)/fact, decimal=4)
    np.testing.assert_almost_equal(mom['Myy'] / (sigma/pixel_scale)**2, (1-rot_e1)/fact, decimal=4)
    np.testing.assert_almost_equal(mom['Mxy'] / (sigma/pixel_scale)**2, rot_e2/fact, decimal=4)

    # Repeat using transform rather than rotate
    gal3 = cgal.transform(
                lambda w: np.cos(rotation(w)),
                lambda w: -np.sin(rotation(w)),
                lambda w: np.sin(rotation(w)),
                lambda w: np.cos(rotation(w)) )
    im3 = gal3.drawImage(bp, scale=pixel_scale, dtype=float, method='no_pixel')
    mom = galsim.utilities.unweighted_moments(im3)
    np.testing.assert_almost_equal((mom['Mxx']-mom['Myy'])/(mom['Mxx']+mom['Myy']), rot_e1, decimal=4)
    np.testing.assert_almost_equal((2*mom['Mxy'])/(mom['Mxx']+mom['Myy']), rot_e2, decimal=4)
    np.testing.assert_almost_equal(mom['Mxx'] / (sigma/pixel_scale)**2, (1+rot_e1)/fact, decimal=4)
    np.testing.assert_almost_equal(mom['Myy'] / (sigma/pixel_scale)**2, (1-rot_e1)/fact, decimal=4)
    np.testing.assert_almost_equal(mom['Mxy'] / (sigma/pixel_scale)**2, rot_e2/fact, decimal=4)


@timer
def test_ChromaticObject_shear():
    im1 = galsim.ImageD(32, 32, scale=0.2)
    im2 = galsim.ImageD(32, 32, scale=0.2)
    shear = galsim.Shear(g1=0.1, g2=0.1)
    a = galsim.Gaussian(fwhm=1.0).shear(shear) * bulge_SED
    b = (galsim.Gaussian(fwhm=1.0) * bulge_SED).shear(shear)

    a.drawImage(bandpass, image=im1, method='no_pixel')
    b.drawImage(bandpass, image=im2, method='no_pixel')
    printval(im1, im2)
    np.testing.assert_array_almost_equal(
            im1.array, im2.array, 5,
            "ChromaticObject.shear not equal to ChromaticTransformation.shear")

    do_pickle(a)
    do_pickle(b)

    # Check flux scaling
    flux = im2.array.sum()
    im2 = (b * 2.).drawImage(bandpass, image=im2, method='no_pixel')
    flux2 = im2.array.sum()
    np.testing.assert_array_almost_equal(
        flux2, 2.*flux, 5,
        err_msg="rotated ChromaticObject * 2 resulted in wrong flux.")

    # Test the wavelength-dependent shear option
    pixel_scale = 0.3
    sigma = 1.7
    gal = galsim.Gaussian(sigma=sigma, flux=132)
    cgal = galsim.ChromaticObject(gal) * galsim.SED('1', 'nm', 'fphotons')
    im0 = gal.drawImage(scale=pixel_scale, dtype=float, method='no_pixel')
    # Initial distortion should be (0,0).
    mom = galsim.utilities.unweighted_moments(im0)
    print('mxx+myy = ',mom['Mxx']+mom['Myy'])
    print('e1 = ',(mom['Mxx']-mom['Myy'])/(mom['Mxx']+mom['Myy']))
    print('e2 = ',(2*mom['Mxy'])/(mom['Mxx']+mom['Myy']))
    np.testing.assert_almost_equal((mom['Mxx']-mom['Myy'])/(mom['Mxx']+mom['Myy']), 0.0, decimal=4)
    np.testing.assert_almost_equal((2*mom['Mxy'])/(mom['Mxx']+mom['Myy']), 0.0, decimal=4)
    np.testing.assert_almost_equal(mom['Mxx'] / (sigma/pixel_scale)**2, 1.0, decimal=4)
    np.testing.assert_almost_equal(mom['Myy'] / (sigma/pixel_scale)**2, 1.0, decimal=4)
    np.testing.assert_almost_equal(mom['Mxy'] / (sigma/pixel_scale)**2, 0.0, decimal=4)

    # First a very simple case with no actual wavelength dependence, but using the
    # functional syntax.
    gal1 = cgal.shear(lambda w: galsim.Shear(e1=0.23, e2=0.13))
    bp = galsim.Bandpass(lambda w: 1. - 0.12*(w-600)**2/100**2, 'nm', 500, 700)
    im1 = gal1.drawImage(bp, scale=pixel_scale, dtype=float, method='no_pixel')
    mom = galsim.utilities.unweighted_moments(im1)
    print('mxx+myy = ',mom['Mxx']+mom['Myy'])
    print('simple e1 = ',(mom['Mxx']-mom['Myy'])/(mom['Mxx']+mom['Myy']))
    print('simple e2 = ',(2.*mom['Mxy'])/(mom['Mxx']+mom['Myy']))
    np.testing.assert_almost_equal((mom['Mxx']-mom['Myy'])/(mom['Mxx']+mom['Myy']), 0.23, decimal=4)
    np.testing.assert_almost_equal((2*mom['Mxy'])/(mom['Mxx']+mom['Myy']), 0.13, decimal=4)
    fact = np.sqrt(1. - 0.23**2 - 0.13**2)
    np.testing.assert_almost_equal(mom['Mxx'] / (sigma/pixel_scale)**2, (1+0.23)/fact, decimal=4)
    np.testing.assert_almost_equal(mom['Myy'] / (sigma/pixel_scale)**2, (1-0.23)/fact, decimal=4)
    np.testing.assert_almost_equal(mom['Mxy'] / (sigma/pixel_scale)**2, 0.13/fact, decimal=4)

    # Use a shear that varies quadratically within the range 500-700
    shear = lambda w: galsim.Shear(e1=0.23 + 0.11*(w-600)/100 - 0.36*(w-600)**2/100**2,
                                   e2=0.13 + 0.19*(w-600)/100 - 0.09*(w-600)**2/100**2)
    gal2 = cgal.shear(shear)
    im2 = gal2.drawImage(bp, scale=pixel_scale, dtype=float, method='no_pixel')
    mom = galsim.utilities.unweighted_moments(im2)
    # The analytic integrals:
    # mxx = int(dw (1 + e1(w))/sqrt(1-e(w)^2) * F(w))  / int(dw F(w))
    # myy = int(dw (1 - e1(w))/sqrt(1-e(w)^2) * F(w))  / int(dw F(w))
    # mxy = int(dw e2(w)/sqrt(1-e(w)^2) * F(w))  / int(dw F(w))
    sh_mxx = galsim.integ.int1d(lambda w: (1.+shear(w).e1)/np.sqrt(1.-shear(w).e**2)*bp(w),500,700)
    sh_mxx /= galsim.integ.int1d(lambda w: bp(w),500,700)
    sh_myy = galsim.integ.int1d(lambda w: (1.-shear(w).e1)/np.sqrt(1.-shear(w).e**2)*bp(w),500,700)
    sh_myy /= galsim.integ.int1d(lambda w: bp(w),500,700)
    sh_mxy = galsim.integ.int1d(lambda w: shear(w).e2/np.sqrt(1.-shear(w).e**2)*bp(w),500,700)
    sh_mxy /= galsim.integ.int1d(lambda w: bp(w),500,700)
    print('mxx+myy = ',mom['Mxx']+mom['Myy'])
    print('shear e1 = ',(mom['Mxx']-mom['Myy'])/(mom['Mxx']+mom['Myy']), (sh_mxx-sh_myy)/(sh_mxx+sh_myy))
    print('shear e2 = ',(2*mom['Mxy'])/(mom['Mxx']+mom['Myy']), (2*sh_mxy)/(sh_mxx+sh_myy))
    np.testing.assert_almost_equal((mom['Mxx']-mom['Myy'])/(mom['Mxx']+mom['Myy']), (sh_mxx-sh_myy)/(sh_mxx+sh_myy), decimal=4)
    np.testing.assert_almost_equal((2*mom['Mxy'])/(mom['Mxx']+mom['Myy']), (2*sh_mxy)/(sh_mxx+sh_myy), decimal=4)
    np.testing.assert_almost_equal(mom['Mxx'] / (sigma/pixel_scale)**2, sh_mxx, decimal=4)
    np.testing.assert_almost_equal(mom['Myy'] / (sigma/pixel_scale)**2, sh_myy, decimal=4)
    np.testing.assert_almost_equal(mom['Mxy'] / (sigma/pixel_scale)**2, sh_mxy, decimal=4)

    # Repeat using transform rather than shear
    gal3 = cgal.transform(
                lambda w: (1.+shear(w).g1)/np.sqrt(1.-shear(w).g**2),
                lambda w: shear(w).g2/np.sqrt(1.-shear(w).g**2),
                lambda w: shear(w).g2/np.sqrt(1.-shear(w).g**2),
                lambda w: (1.-shear(w).g1)/np.sqrt(1.-shear(w).g**2) )
    im3 = gal3.drawImage(bp, scale=pixel_scale, dtype=float, method='no_pixel')
    mom = galsim.utilities.unweighted_moments(im3)
    np.testing.assert_almost_equal((mom['Mxx']-mom['Myy'])/(mom['Mxx']+mom['Myy']), (sh_mxx-sh_myy)/(sh_mxx+sh_myy), decimal=4)
    np.testing.assert_almost_equal((2*mom['Mxy'])/(mom['Mxx']+mom['Myy']), (2*sh_mxy)/(sh_mxx+sh_myy), decimal=4)
    np.testing.assert_almost_equal(mom['Mxx'] / (sigma/pixel_scale)**2, sh_mxx, decimal=4)
    np.testing.assert_almost_equal(mom['Myy'] / (sigma/pixel_scale)**2, sh_myy, decimal=4)
    np.testing.assert_almost_equal(mom['Mxy'] / (sigma/pixel_scale)**2, sh_mxy, decimal=4)

    # Repeat using lens
    gal4 = cgal.lens(lambda w: shear(w).g1, lambda w: shear(w).g2, 1.)
    im4 = gal4.drawImage(bp, scale=pixel_scale, dtype=float, method='no_pixel')
    mom = galsim.utilities.unweighted_moments(im4)
    np.testing.assert_almost_equal((mom['Mxx']-mom['Myy'])/(mom['Mxx']+mom['Myy']), (sh_mxx-sh_myy)/(sh_mxx+sh_myy), decimal=4)
    np.testing.assert_almost_equal((2*mom['Mxy'])/(mom['Mxx']+mom['Myy']), (2*sh_mxy)/(sh_mxx+sh_myy), decimal=4)
    np.testing.assert_almost_equal(mom['Mxx'] / (sigma/pixel_scale)**2, sh_mxx, decimal=4)
    np.testing.assert_almost_equal(mom['Myy'] / (sigma/pixel_scale)**2, sh_myy, decimal=4)
    np.testing.assert_almost_equal(mom['Mxy'] / (sigma/pixel_scale)**2, sh_mxy, decimal=4)

    assert_raises(TypeError, cgal.shear, 0.1, 0.3)
    assert_raises(TypeError, cgal.shear, 0.1)
    assert_raises(TypeError, cgal.shear, shear, g1=0.1, g2=0.2)
    assert_raises(TypeError, cgal.shear, shear=shear, g1=0.1, g2=0.2)


@timer
def test_ChromaticObject_shift():
    im1 = galsim.ImageD(32, 32, scale=0.2)
    im2 = galsim.ImageD(32, 32, scale=0.2)
    shift = (0.1, 0.3)
    a = galsim.Gaussian(fwhm=1.0).shift(shift) * bulge_SED
    b = (galsim.Gaussian(fwhm=1.0) * bulge_SED).shift(shift)

    a.drawImage(bandpass, image=im1, method='no_pixel')
    b.drawImage(bandpass, image=im2, method='no_pixel')
    printval(im1, im2)
    np.testing.assert_array_almost_equal(
            im1.array, im2.array, 5,
            "ChromaticObject.shift not equal to ChromaticTransformation.shift")

    do_pickle(a)
    do_pickle(b)

    # Check flux scaling
    flux = im2.array.sum()
    im2 = (b * 2.).drawImage(bandpass, image=im2, method='no_pixel')
    flux2 = im2.array.sum()
    np.testing.assert_array_almost_equal(
        flux2, 2.*flux, 5,
        err_msg="rotated ChromaticObject * 2 resulted in wrong flux.")

    cgal = galsim.Gaussian(fwhm=1.0) * bulge_SED
    assert_raises(TypeError, cgal.shift)
    assert_raises(TypeError, cgal.shift, 0.1)
    assert_raises(TypeError, cgal.shift, shift, 0.1, 0.2)
    assert_raises(TypeError, cgal.shift, shift, dx=0.1, dy=0.2)
    assert_raises(TypeError, cgal.shift, shift=shift)

@timer
def test_ChromaticObject_compound_affine_transformation():
    """ Check that making a (separable) object chromatic before a bunch of transformations is
    equivalent to making it chromatic after a bunch of transformations.
    """
    shear = galsim.Shear(eta=1.0, beta=0.3*galsim.radians)
    scale = 1.1
    theta = 0.1 * galsim.radians
    shift = (0.1, 0.3)
    sed = galsim.SED('wave**0.3', 'nm', 'fphotons')
    bandpass = galsim.Bandpass('1', 'nm', blue_limit=400, red_limit=550)

    a = galsim.Gaussian(fwhm=1.0)
    a = a.shear(shear).shift(shift).rotate(theta).dilate(scale)
    a = a.shear(shear).shift(shift).rotate(theta).expand(scale)
    a = a.lens(g1=0.1, g2=0.1, mu=1.1).shift(shift).rotate(theta).magnify(scale)
    a = a * sed

    b = galsim.Gaussian(fwhm=1.0) * sed
    b = b.shear(shear).shift(shift).rotate(theta).dilate(scale)
    b = b.shear(shear).shift(shift).rotate(theta).expand(scale)
    b = b.lens(g1=0.1, g2=0.1, mu=1.1).shift(shift).rotate(theta).magnify(scale)

    # Include a few gratuitous combinations of functional and static values.
    pshift = galsim.PositionD(*shift)
    c = galsim.Gaussian(fwhm=1.0) * sed
    c = c.shear(shear).shift(lambda w: shift).rotate(theta).dilate(lambda w: scale)
    c = c.shear(shear).shift(lambda w: pshift).rotate(theta).expand(scale)
    c = c.lens(g1=lambda w:0.1, g2=0.1, mu=lambda w:1.1).shift(shift).rotate(theta).magnify(scale)

    d = galsim.Gaussian(fwhm=1.0) * sed
    d = d.shear(lambda w: shear).shift(pshift).rotate(lambda w: theta).dilate(scale)
    d = d.shear(shear).shift(shift).rotate(theta).transform(scale, lambda w:0, lambda w:0, scale)
    d = d.lens(g1=0.1, g2=lambda w:0.1, mu=1.1).shift(shift).rotate(theta).magnify(scale)

    im1 = galsim.ImageD(32, 32, scale=0.2)
    im1 = a.drawImage(bandpass, image=im1.copy(), method='no_pixel')
    im2 = b.drawImage(bandpass, image=im1.copy(), method='no_pixel')
    im3 = c.drawImage(bandpass, image=im1.copy(), method='no_pixel')
    im4 = d.drawImage(bandpass, image=im1.copy(), method='no_pixel')
    printval(im1, im2)
    np.testing.assert_array_almost_equal(im2.array, im1.array, 5,
                                         "ChromaticObject affine transformation not equal to "
                                         "GSObject affine transformation")
    np.testing.assert_array_almost_equal(im3.array, im1.array, 5,
                                         "ChromaticObject affine transformation not equal to "
                                         "GSObject affine transformation")
    np.testing.assert_array_almost_equal(im4.array, im1.array, 5,
                                         "ChromaticObject affine transformation not equal to "
                                         "GSObject affine transformation")

    # Check flux scaling
    flux = im2.array.sum()
    im2 = (b * 2.).drawImage(bandpass, image=im2, method='no_pixel')
    flux2 = im2.array.sum()
    np.testing.assert_array_almost_equal(
        flux2, 2.*flux, 5,
        err_msg="transformed ChromaticObject * 2 resulted in wrong flux.")

    # Just check that the cache resizing routines are what the docs say they are.
    galsim.ChromaticObject.resize_multiplier_cache(100)
    galsim.ChromaticConvolution.resize_effective_prof_cache(100)

    # Check some branches in repr that we wouldn't hit otherwise.
    repr(a); repr(b); repr(c); repr(d)


@timer
def test_analytic_integrator():
    """Test that the analytic (i.e., not sampled) versions of SEDs and Bandpasses produce the
    same results as the sampled versions.
    """
    # Make sure to use something non-separable so the ImageIntegrators actually get triggered.
    psf = galsim.ChromaticObject(galsim.Moffat(fwhm=1.0, beta=2.7)).dilate(lambda w:(w/500)**1.1)

    # pure analytic
    band1 = galsim.Bandpass('1', 'nm', blue_limit=500, red_limit=750)
    sed1 = galsim.SED('wave**1.1', wave_type='nm', flux_type='fphotons').withFluxDensity(1.0, 500)
    gal1 = galsim.Gaussian(fwhm=1.0) * sed1
    final1 = galsim.Convolve(gal1, psf)
    image1 = galsim.ImageD(32, 32, scale=0.2)
    kimage1 = galsim.ImageCD(32, 32, scale=0.2)
    kimage1.setCenter(0,0)  # Necessary when adding to image
    assert len(band1.wave_list) == 0
    assert len(sed1.wave_list) == 0
    # Gratuitously use add_to_image=True so we test that branch.  Initial image is 0.
    final1.drawImage(band1, image=image1, add_to_image=True)
    final1.drawKImage(band1, image=kimage1, add_to_image=True)

    # try making the SED sampled
    band2 = band1
    N = 250 # default N for ContinuousIntegrator
    h = (band2.red_limit*1.0 - band2.blue_limit)/N
    x = [band2.blue_limit + h * i for i in range(N+1)]
    # make a sampled SED
    sed2 = galsim.SED(galsim.LookupTable(x, sed1(x), interpolant='linear'),
                      wave_type='nm', flux_type='fphotons')
    gal2 = galsim.Gaussian(fwhm=1.0) * sed2
    final2 = galsim.Convolve(gal2, psf)
    image2 = galsim.ImageD(32, 32, scale=0.2)
    kimage2 = galsim.ImageCD(32, 32, scale=0.2)
    assert len(band2.wave_list) == 0
    assert len(sed2.wave_list) != 0
    final2.drawImage(band1, image=image2)
    final2.drawKImage(band1, image=kimage2)

    # try making the Bandpass sampled
    sed3 = sed1
    band3 = galsim.Bandpass(galsim.LookupTable(x, band1(x), interpolant='linear'), 'nm')
    gal3 = galsim.Gaussian(fwhm=1.0) * sed3
    final3 = galsim.Convolve(gal3, psf)
    image3 = galsim.ImageD(32, 32, scale=0.2)
    kimage3 = galsim.ImageCD(32, 32, scale=0.2)
    assert len(band3.wave_list) != 0
    assert len(sed3.wave_list) == 0
    final3.drawImage(band3, image=image3)
    final3.drawKImage(band3, image=kimage3)

    printval(image1, image2)
    np.testing.assert_array_almost_equal(image1.array, image2.array, 5,
                                         "Analytic integrator doesn't match sample integrator")
    printval(image1, image3)
    np.testing.assert_array_almost_equal(image1.array, image3.array, 5,
                                         "Analytic integrator doesn't match sample integrator")

    np.testing.assert_array_almost_equal(kimage1.array, kimage2.array, 5,
                                         "Analytic integrator doesn't match sample integrator")
    np.testing.assert_array_almost_equal(kimage1.array, kimage3.array, 5,
                                         "Analytic integrator doesn't match sample integrator")

    # Test that attempting to use SampleIntegrator with analytic sed, bandpass raises an Error:
    with assert_raises(ValueError):
        final1.drawImage(band1,
                         integrator=galsim.integ.SampleIntegrator(rule=galsim.integ.trapzRule))


@timer
def test_gsparams():
    """Check that gsparams actually gets processed by ChromaticObjects.
    """
    # Setting maximum_fft_size this low causes an exception to be raised for GSObjects, so
    # make sure it does for ChromaticObjects too, thereby assuring that gsparams is really
    # getting properly forwarded through the internals of ChromaticObjects.
    gsparams = galsim.GSParams(maximum_fft_size=16)
    gal = galsim.Gaussian(fwhm=1, gsparams=gsparams) * bulge_SED
    with assert_raises(galsim.GalSimFFTSizeError):
        gal.drawImage(bandpass)
    assert (galsim.Gaussian(fwhm=1) * bulge_SED) != gal
    assert (galsim.Gaussian(fwhm=1) * bulge_SED).withGSParams(gsparams) == gal

    # Repeat, putting the gsparams argument in after the ChromaticObject constructor.
    gal = galsim.Gaussian(fwhm=1) * bulge_SED
    psf = galsim.Gaussian(sigma=0.4)
    final = galsim.Convolve([gal, psf], gsparams=gsparams)
    with assert_raises(galsim.GalSimFFTSizeError):
        final.drawImage(bandpass)

    # Use a restrictive one this time, so we test the "most restrictive gsparams" feature
    gsp2 = galsim.GSParams(folding_threshold=1.e-4, maxk_threshold=1.e-4, maximum_fft_size=1.e4)
    final = galsim.Convolve([gal, psf])
    final1 = galsim.Convolve([gal, psf], gsparams=gsp2)
    final2 = galsim.Convolve([gal, psf]).withGSParams(gsp2)
    final3 = galsim.Convolve([gal.withGSParams(gsp2), psf])
    final4 = galsim.Convolve([gal, psf.withGSParams(gsp2)])
    assert final1 != final
    assert final2 == final1
    assert final3 == final1
    assert final4 == final1
    assert final1.gsparams == gsp2
    assert final1.obj_list[0].gsparams == gsp2
    assert final1.obj_list[1].gsparams == gsp2

    final5 = galsim.Convolve(gal, psf, gsparams=gsp2, propagate_gsparams=False)
    assert final5 != final1
    assert final5.gsparams == gsp2
    assert final5.obj_list[0].gsparams == galsim.GSParams()
    assert final5.obj_list[1].gsparams == galsim.GSParams()

    final6 = final5.withGSParams(gsparams)
    assert final6 != final5
    assert final6.gsparams == gsparams
    assert final6.obj_list[0].gsparams == galsim.GSParams()
    assert final6.obj_list[1].gsparams == galsim.GSParams()

    do_pickle(final1)

    # Repeat similar tests for ChromaticSum
    bulge = galsim.Gaussian(half_light_radius=1) * bulge_SED
    disk = galsim.Exponential(half_light_radius=2) * disk_SED
    final = galsim.Add([bulge, disk])
    final1 = galsim.Add([bulge, disk], gsparams=gsp2)
    final2 = galsim.Add([bulge, disk]).withGSParams(gsp2)
    final3 = galsim.Add([bulge.withGSParams(gsp2), disk])
    final4 = galsim.Add([bulge, disk.withGSParams(gsp2)])
    assert final1 != final
    assert final2 == final1
    assert final3 == final1
    assert final4 == final1
    assert final1.gsparams == gsp2
    assert final1.obj_list[0].gsparams == gsp2
    assert final1.obj_list[1].gsparams == gsp2

    final5 = galsim.Add(bulge, disk, gsparams=gsp2, propagate_gsparams=False)
    assert final5 != final1
    assert final5.gsparams == gsp2
    assert final5.obj_list[0].gsparams == galsim.GSParams()
    assert final5.obj_list[1].gsparams == galsim.GSParams()

    final6 = final5.withGSParams(gsparams)
    assert final6 != final5
    assert final6.gsparams == gsparams
    assert final6.obj_list[0].gsparams == galsim.GSParams()
    assert final6.obj_list[1].gsparams == galsim.GSParams()


@timer
def test_separable_ChromaticSum():
    """ Test ChromaticSum separable profile grouping.
    """
    psf = galsim.Gaussian(fwhm=1)
    mono_gal1 = galsim.Gaussian(fwhm=1)
    mono_gal2 = galsim.Gaussian(fwhm=1.1)
    mono_gal3 = galsim.Gaussian(fwhm=1.2)

    # 1) check that 2 summands with same SED make a separable sum.
    cgal1 = mono_gal1 * bulge_SED + mono_gal2 * bulge_SED
    img1 = galsim.ImageD(32, 32, scale=0.2)
    kimg1 = galsim.ImageCD(32, 32, scale=0.5)
    if not cgal1.separable:
        raise AssertionError("failed to identify separable ChromaticSum")

    # check that drawing the profile works as expected
    final1 = galsim.Convolve(cgal1, psf)
    final1.drawImage(bandpass, image=img1)
    final1.drawKImage(bandpass, image=kimg1)

    img1b = img1.copy()
    kimg1b = kimg1.copy()
    component1 = galsim.Convolve(mono_gal1*bulge_SED, psf)
    component1.drawImage(bandpass, image=img1b)
    component1.drawKImage(bandpass, image=kimg1b)

    component2 = galsim.Convolve(mono_gal2*bulge_SED, psf)
    component2.drawImage(bandpass, image=img1b, add_to_image=True)
    component2.drawKImage(bandpass, image=kimg1b, add_to_image=True)

    np.testing.assert_array_almost_equal(img1.array, img1b.array, 5,
                                         "separable ChromaticSum not correctly drawn")
    np.testing.assert_array_almost_equal(kimg1.array, kimg1b.array, 5,
                                         "separable ChromaticSum not correctly k-drawn")
    do_pickle(final1)

    # 2) Check flux scaling
    img2 = img1.copy()
    flux1 = img1.array.sum()
    (final1 * 2).drawImage(bandpass, image=img2)
    flux2 = img2.array.sum()
    np.testing.assert_array_almost_equal(
        flux2, 2.*flux1, 5,
        err_msg="ChromaticConvolution containing separable ChromaticSum * 2 resulted in wrong flux.")

    final2 = galsim.Convolve(cgal1 * 2, psf)
    img2b = img1.copy()
    final2.drawImage(bandpass, image=img2b)
    flux2b = img2b.array.sum()
    np.testing.assert_array_almost_equal(
        flux2b, 2.*flux1, 5,
        err_msg="separable ChromaticSum * 2 resulted in wrong flux.")

    do_pickle(final2)

    # 3) check that 3 summands, 2 with the same SED, 1 with a different SED, make an
    # inseparable sum.
    cgal3 = galsim.Add(mono_gal1 * bulge_SED, mono_gal2 * bulge_SED, mono_gal3 * disk_SED)
    if cgal3.separable:
        raise AssertionError("failed to identify inseparable ChromaticSum")
    # check that its objlist contains a separable Chromatic and a separable ChromaticSum
    types = dict((o.__class__, o) for o in cgal3.obj_list)
    if galsim.ChromaticTransformation not in types or galsim.ChromaticSum not in types:
        raise AssertionError("failed to process list of objects with repeated SED")

    # check that drawing the profile works as expected
    final3 = galsim.Convolve(cgal3, psf)
    img3 = img1.copy()
    final3.drawImage(bandpass, image=img3)

    do_pickle(final3)


    component3 = galsim.Convolve(mono_gal3*disk_SED, psf)
    img3b = img1.copy()
    component1.drawImage(bandpass, image=img3b)
    component2.drawImage(bandpass, image=img3b, add_to_image=True)
    component3.drawImage(bandpass, image=img3b, add_to_image=True)

    np.testing.assert_array_almost_equal(img3.array, img3b.array, 5,
                                         "inseparable ChromaticSum not correctly drawn")

    do_pickle(component3)

    # 4) What about if we wrap mono_gal1 and mono_gal2 in a ChromaticObject?
    cgal4 = (galsim.ChromaticObject(mono_gal1) * bulge_SED
             + galsim.ChromaticObject(mono_gal2) * bulge_SED)
    img4 = img1.copy()
    if not cgal4.separable:
        raise AssertionError("failed to identify separable ChromaticSum")

    final4 = galsim.Convolve(cgal4, psf)
    final4.drawImage(bandpass, image=img4)
    np.testing.assert_array_almost_equal(img1.array, img4.array, 5,
                                         "separable ChromaticSum not correctly drawn")

    assert_raises(TypeError, galsim.ChromaticSum,
                  [mono_gal1 * bulge_SED, mono_gal2 * bulge_SED], invalid=3)
    assert_raises(TypeError, galsim.ChromaticSum)
    assert_raises(TypeError, galsim.ChromaticSum, bulge_SED)
    with assert_raises(galsim.GalSimIncompatibleValuesError):
        sum = mono_gal1 * bulge_SED + mono_gal2


@timer
def test_centroid():
    """Test the ChromaticObject.calculateCentroid function."""
    sed = galsim.SED('wave', wave_type='nm', flux_type='fphotons')
    bp = galsim.Bandpass('wave', 'nm', blue_limit=0, red_limit=1)
    shift_fn = lambda w: (w, 0)
    gal = sed * galsim.Gaussian(fwhm=1)
    gal = gal.shift(shift_fn)
    # The sed and bandpass each contribute a factor of wavelength to the flux integrand of the
    # galaxy.  The shift function contributes an additional factor of wavelength to the x-centroid
    # integrand.  The end result is that the x-centroid should be:
    # int(w^3, 0, 1) / int(w^2, 0, 1) = (1/4)/(1/3) = 3/4.
    cen = gal.calculateCentroid(bp)
    np.testing.assert_almost_equal(cen.x, 0.75, 5, "ChromaticObject.calculateCentroid() failed")
    np.testing.assert_almost_equal(cen.y, 0.0, 5, "ChromaticObject.calculateCentroid() failed")

    # Now check the centroid sampling integrator...
    gal.wave_list = np.linspace(0.0, 1.0, 500)
    cen = gal.calculateCentroid(bp)
    np.testing.assert_almost_equal(cen.x, 0.75, 5, "ChromaticObject.calculateCentroid() failed")
    np.testing.assert_almost_equal(cen.y, 0.0, 5, "ChromaticObject.calculateCentroid() failed")


@timer
def test_interpolated_ChromaticObject():
    """Test the ChromaticObject interpolation functionality."""
    # Define a ChromaticObject subclass for which interpolation could be helpful, but calculations
    # can be done quickly:
    # It's a Gaussian with a wavelength-dependent sigma [sigma = sigma_0 (wave / 500 nm)]
    # and shear g1 [g1 = 0.1 ((wave)/(500 nm) - 1)]
    class ChromaticGaussian(galsim.ChromaticObject):
        def __init__(self, sigma):
            # First, take the basic info.
            self.sigma = sigma
            self.separable = False
            self.interpolated = False
            self.deinterpolated = self
            self.SED = galsim.SED(1, 'nm', '1')
            self.wave_list = np.array([], dtype=float)

        def evaluateAtWavelength(self, wave):
            this_sigma = self.sigma * (wave / 500.)
            this_shear = 0.1 * ((wave/500.)-1.)
            ret = galsim.Gaussian(sigma = this_sigma)
            ret = ret.shear(g1 = this_shear)
            return ret

        @property
        def gsparams(self): return galsim.GSParams.default

        def withGSParams(self, gsp): return self

        def __eq__(self, other):
            return (isinstance(other, ChromaticGaussian) and
                    self.sigma == other.sigma)

        def __hash__(self):
            return hash(("ChromaticGaussian", self.sigma))

        def __repr__(self):
            return 'galsim.ChromaticGaussian(%r)'%self.sigma

    # For this test, we're going to use the ChromaticGaussian defined above.  This class is simple
    # enough that evaluation of both the interpolated and exact versions is very fast, so it won't
    # slow down the tests too much to do both ways.  Note that for initial tests (fair comparison
    # between exact and interpolated version) we're going to use a lot of images for the
    # interpolation, n_interp=100.  For more slowly-evaluated profiles, this is not going to be
    # feasible, and tests need to be done to check that a given n_interp is enough.  But that's an
    # accuracy test, not a unit test.
    sigma_0 = 0.06
    scale = 0.02
    n_interp = 100
    oversample_fac = 1.6
    blue_limit = min(bandpass.blue_limit, bandpass_g.blue_limit)
    red_limit = max(bandpass.red_limit, bandpass_g.red_limit)
    waves = np.linspace(blue_limit, red_limit, n_interp)
    # Make a version that tests the ability of the routine to handle non-sorted / non-array input.
    tricky_waves = list(waves[::-1])

    # Make a star.
    star = galsim.Gaussian(fwhm=1.e-8) * bulge_SED

    # First, compare images that are drawn with exact and interpolated ChromaticGaussian.
    exact_psf = ChromaticGaussian(sigma_0)
    interp_psf = exact_psf.interpolate(waves, oversample_fac=oversample_fac)
    exact_obj = galsim.Convolve(star, exact_psf)
    interp_obj = galsim.Convolve(star, interp_psf)
    im_exact = exact_obj.drawImage(bandpass, scale=scale, nx=40, ny=40)
    im_interp = im_exact.copy()
    im_interp = interp_obj.drawImage(bandpass, image=im_interp, scale=scale)
    # Note: peak value of array is around 0.3, so going to 4 decimal places is a reasonably
    # stringent test considering how different the exact vs. interpolated rendering process is.
    np.testing.assert_array_almost_equal(
        im_interp.array, im_exact.array, decimal=4,
        err_msg='Interpolated ChromaticObject results differ for exact vs. interpolated')

    # And test with midpoint rule (non-default).
    im_interp = interp_obj.drawImage(bandpass, image=im_interp, integrator='midpoint', scale=scale)
    np.testing.assert_array_almost_equal(
        im_interp.array, im_exact.array, decimal=4,
        err_msg='Interpolated ChromaticObject results differ for exact vs. interpolated (midpoint)')

    # Check kimage with midpoint rule too, also non-default.
    kscale = 2*np.pi/(scale*40)
    kim_exact = exact_obj.drawKImage(bandpass, scale=kscale, nx=40, ny=40)
    kim_interp = interp_obj.drawKImage(bandpass, scale=kscale, nx=40, ny=40, integrator='midpoint')
    np.testing.assert_allclose(
        kim_interp.array, kim_exact.array, rtol=0, atol=1e-4*kim_exact.array.real.max(),
        err_msg='Interpolated ChromaticObject results differ for exact vs. interpolated (midpoint)')

    # Check that we can turn interpolation off and on at will.
    other_psf = interp_psf.deinterpolated
    other_obj = galsim.Convolve(star, other_psf)
    im_other = im_exact.copy()
    im_other = other_obj.drawImage(bandpass, image=im_other, scale=scale)
    # Can test to very high accuracy.
    np.testing.assert_array_almost_equal(
        im_other.array, im_exact.array, decimal=8,
        err_msg='Failure to turn off interpolation in ChromaticObject')

    # Check that when an interpolated ChromaticObject is convolved with a ChromaticObject that has a
    # non-trivial surface brightness profile (i.e., a galaxy rather than a star), the image that we
    # get and the total flux normalization is correct. We are forcing it to go through the
    # evaluation of ChromaticConvolution.drawImage().
    gal = galsim.Exponential(half_light_radius = 2.*scale)
    gal = gal.shear(g2 = 0.3)
    gal = disk_SED*gal
    obj_exact = galsim.Convolve(exact_psf, gal)
    obj_interp = galsim.Convolve(interp_psf, gal)
    im_exact = obj_exact.drawImage(bandpass_g, scale=scale)
    im_interp = im_exact.copy()
    im_interp = obj_interp.drawImage(bandpass_g, image=im_interp, scale=scale)
    expected_flux = disk_SED.calculateFlux(bandpass_g)
    frac_diff_exact = abs(im_exact.array.sum()/expected_flux-1.0)
    frac_diff_interp = abs(im_interp.array.sum()/expected_flux-1.0)
    np.testing.assert_almost_equal(
        frac_diff_exact, 0.0, decimal=3,
        err_msg='ChromaticObject flux is wrong when convolved with ChromaticObject '
        ' (exact calculation)')
    np.testing.assert_almost_equal(
        frac_diff_interp, 0.0, decimal=3,
        err_msg='ChromaticObject (with interpolation) flux is wrong when convolved with '
        ' ChromaticObject')
    np.testing.assert_array_almost_equal(
        im_interp.array, im_exact.array, decimal=4,
        err_msg='ChromaticObject results differ for interpolated vs. exact'
        ' when convolving with ChromaticObject')

    # Check that when an ChromaticObject with interpolation is convolved with a ChromaticSum, the
    # image and flux normalization is correct.
    bulge = galsim.DeVaucouleurs(half_light_radius = 1.5*scale)
    bulge = bulge_SED*bulge
    tot_gal = gal + bulge
    obj_exact = galsim.Convolve(exact_psf, tot_gal)
    obj_interp = galsim.Convolve(interp_psf, tot_gal)
    im_exact = obj_exact.drawImage(bandpass, scale=scale)
    im_interp = im_exact.copy()
    im_interp = obj_interp.drawImage(bandpass, image=im_interp, scale=scale)
    expected_flux = disk_SED.calculateFlux(bandpass) + bulge_SED.calculateFlux(bandpass)
    frac_diff_exact = abs(im_exact.array.sum()/expected_flux-1.0)
    frac_diff_interp = abs(im_interp.array.sum()/expected_flux-1.0)
    # Check to 2%
    np.testing.assert_almost_equal(
        frac_diff_exact/2, 0.0, decimal=2,
        err_msg='ChromaticObject flux is wrong when convolved with ChromaticSum'
        ' (exact calculation)')
    np.testing.assert_almost_equal(
        frac_diff_interp/2, 0.0, decimal=2,
        err_msg='ChromaticObject flux is wrong when convolved with ChromaticSum'
        ' (interpolated calculation)')
    np.testing.assert_array_almost_equal(
        im_interp.array, im_exact.array, decimal=3,
        err_msg='ChromaticObject results differ for interpolated vs. exact'
        ' when convolving with ChromaticSum')

    # Check that InterpolatedChromaticObject.drawImage works.  Need an exact object with
    # an SED for this to work.
    exact_psf *= bulge_SED
    interp_psf = exact_psf.interpolate(waves, oversample_fac=oversample_fac)
    im_exact = exact_psf.drawImage(bandpass, scale=0.2, nx=32, ny=32)
    im_interp = interp_psf.drawImage(bandpass, scale=0.2, nx=32, ny=32)
    np.testing.assert_array_almost_equal(
        im_interp.array, im_exact.array, decimal=3,
        err_msg='Interpolated ChromaticObject results differ for exact vs. interpolated')

    # Check that we can render an image with chromatic transformations directly, and with
    # interpolation.  Use a ChromaticAtmosphere just because that's easily transformed.
    atm_fwhm = 0.7
    atm_scale = 0.2
    exact_psf = galsim.ChromaticAtmosphere(
        galsim.Kolmogorov(atm_fwhm), 500., zenith_angle=0.*galsim.degrees,
        parallactic_angle=0.*galsim.degrees)
    chrom_shear = lambda w: galsim.Shear(g1=0.2+0.2*(w-500.)/500.,g2=0.) if w<1000. else \
        galsim.Shear(g1=0.4, g2=0.)
    chrom_shift_y = lambda w: scale*(w-500.)
    chrom_dilate = lambda w: 1.0+0.1*(w-500.)/500.
    exact_psf = (exact_psf
                 .shear(shear=chrom_shear)
                 .shift(dx=0.,dy=chrom_shift_y)
                 .dilate(chrom_dilate))
    # Note here we are checking the use of more difficult input wavelengths.
    interp_psf = exact_psf.interpolate(tricky_waves, oversample_fac=oversample_fac)
    exact_obj = galsim.Convolve(star, exact_psf)
    interp_obj = galsim.Convolve(star, interp_psf)
    im_exact = exact_obj.drawImage(bandpass, scale=atm_scale)
    im_interp = im_exact.copy()
    im_interp = interp_obj.drawImage(bandpass, image=im_interp, scale=atm_scale)
    # Note: peak value of array is around 4, so going to 3 decimal places is a reasonably
    # stringent test considering how different the exact vs. interpolated rendering process is.
    np.testing.assert_array_almost_equal(
        im_interp.array, im_exact.array, decimal=3,
        err_msg='Interpolated ChromaticObject results differ for exact vs. interpolated'+
        ' when including chromatic transformations')

    # Check that we can render an image with achromatic transformations applied after
    # interpolation.
    exact_psf = galsim.ChromaticAtmosphere(
        galsim.Kolmogorov(atm_fwhm), 500., zenith_angle=0.*galsim.degrees,
        parallactic_angle=0.*galsim.degrees)
    interp_psf = exact_psf.interpolate(waves, oversample_fac=oversample_fac)

    achrom_shear = galsim.Shear(g1=0.05, g2=-0.1)
    exact_psf = exact_psf.shear(shear=achrom_shear)
    exact_obj = galsim.Convolve(star, exact_psf)
    interp_psf = interp_psf.shear(shear=achrom_shear)
    interp_obj = galsim.Convolve(star, interp_psf)

    im_exact = exact_obj.drawImage(bandpass, scale=atm_scale)
    im_interp = im_exact.copy()
    im_interp = interp_obj.drawImage(bandpass, image=im_interp, scale=atm_scale)
    # Note: peak value of array is around 4, so going to 3 decimal places is a reasonably
    # stringent test considering how different the exact vs. interpolated rendering process is.
    np.testing.assert_array_almost_equal(
        im_interp.array, im_exact.array, decimal=3,
        err_msg='Interpolated ChromaticObject results differ for exact vs. interpolated'+
        ' when including achromatic transformations after precomputation')

    # Check that the routine does not interpolate outside of its original bounds.
    with assert_raises(galsim.GalSimError):
        obj_interp.drawImage(bandpass_z)

    # Make sure it behaves appropriately when asked to apply chromatic transformations after
    # interpolating: it should do the job properly after un-setting the interpolation.
    # As a really strict test, we will apply chromatic transformations twice (before and after
    # setting up the interpolation).  This will make sure that it's really tracking and combining
    # all transformations.
    exact_psf = galsim.ChromaticAtmosphere(
        galsim.Kolmogorov(atm_fwhm), 500., zenith_angle=0.*galsim.degrees,
        parallactic_angle=0.*galsim.degrees)
    exact_psf = \
        exact_psf.shear(shear=chrom_shear).shift(dx=0.,dy=chrom_shift_y).dilate(chrom_dilate)
    interp_psf = exact_psf.interpolate(waves, oversample_fac=oversample_fac)
    trans_exact_psf = \
        exact_psf.shear(shear=chrom_shear).shift(dx=0.,dy=chrom_shift_y).dilate(chrom_dilate)

    with assert_warns(galsim.GalSimWarning):
        trans_interp_psf = interp_psf.shear(
            shear=chrom_shear).shift(dx=0.,dy=chrom_shift_y).dilate(chrom_dilate)
    exact_obj = galsim.Convolve(star, trans_exact_psf)
    interp_obj = galsim.Convolve(star, trans_interp_psf)
    im_exact = exact_obj.drawImage(bandpass, scale=atm_scale)
    im_interp = im_exact.copy()
    im_interp = interp_obj.drawImage(bandpass, image=im_interp, scale=atm_scale)
    # Note: since the image rendering should have been done in exactly the same way (it should
    # have trashed the interpolation entirely), test to high precision.
    np.testing.assert_array_almost_equal(
        im_interp.array, im_exact.array, decimal=9,
        err_msg='Did not do exact chromatic transformation by discarding interpolation')
    # Also make sure that it ditched the interpolation.
    assert not hasattr(trans_interp_psf, 'waves')


@timer
def test_ChromaticOpticalPSF():
    """Test the ChromaticOpticalPSF functionality."""
    import time

    # For ChromaticOpticalPSF, exact evaluation is too slow for routine unit tests.  So, for
    # this unit test, we use an interpolated version only.  The tests of
    # ChromaticObject in the previous unit test should be enough to ensure that exact
    # and interpolated evaluation match in general (given reasonable settings).

    # First, compare the interpolated result with saved, exact results.
    # Note that if the saved results file cannot be found, then this function will (slowly)
    # generate the exact image.  Note that this may need to be done outside of pytest to avoid
    # the default pytest time limit.

    # Note that exact results will have to be regenerated if any of the bandpasses or other
    # parameters defined here are changed.  Because of the parameters chosen here, there is a lot of
    # non-trivially complex structure in the PSFs, so this is a stringent test.
    aberrations = np.zeros(12)
    aberrations[4] = 40. # nm
    aberrations[7] = 20. # nm
    lam = 600. # nm
    aberrations /= lam
    diam = 2.4 # meters
    obscuration = 0.18
    nstruts = 4
    scale = 0.02
    n_interp = 15
    oversample_fac = 4.0
    waves = np.linspace(bandpass.blue_limit, bandpass.red_limit, n_interp)

    # from pylab import *
    # wexact = np.union1d(bandpass.wave_list, disk_SED.wave_list)
    # wexact = wexact[(wexact>bandpass.blue_limit) & (wexact<bandpass.red_limit)]
    # plot(wexact, bandpass(wexact)*disk_SED(wexact), marker='o', c='b')
    # plot(waves, bandpass(waves)*disk_SED(waves), ls=' ', marker='o', c='r', markersize=10)
    # show()

    star = galsim.Gaussian(fwhm=1.e-8) * disk_SED
    psf = galsim.ChromaticOpticalPSF(lam=lam, diam=diam, aberrations=aberrations,
                                     obscuration=obscuration, nstruts=nstruts)
    do_pickle(psf)

    with assert_raises(galsim.GalSimIncompatibleValuesError):
        galsim.ChromaticOpticalPSF(lam=lam, diam=diam, aberrations=aberrations, lam_over_diam=0.02)

    if not os.path.isfile(os.path.join(refdir, 'r_exact.fits')):
        import warnings
        warnings.warn("Could not find file r_exact.fits, so generating it from scratch.  This "
                      "should only happen if you intentionally deleted the file in order to "
                      "regenerate it!")

        # Generate exact results inside this if-block.
        # This block took ~30 seconds to run on a new-ish Macbook Pro, nearly all in the image
        # rendering process.  In contrast, the ChromaticOpticalPSF with interpolation that is used
        # for this unit test takes about ~9 seconds to initialize, and ~1s for the image rendering
        # process.  Obviously, if many images are to be rendered after incurring the overhead of
        # initializing this object, the interpolated calculation leads to a huge savings compared to
        # doing the exact calculation each time.
        t2 = time.time()
        obj = galsim.Convolve(star, psf)
        im_r_ref = obj.drawImage(bandpass, scale=scale)
        im_r_ref.write(os.path.join(refdir, 'r_exact.fits'))
        t3 = time.time()
        print("Time to draw ChromaticOpticalPSF: {0}s".format(t3-t2))

    t4 = time.time()
    psf = psf.interpolate(waves, oversample_fac=oversample_fac)
    t5 = time.time()
    print("Time to initialize InterpolatedChromaticObject: {0}s".format(t5-t4))
    obj = galsim.Convolve(star, psf)

    if __name__ == '__main__':
        # This is slow, but it is worth testing the pickling of InterpolatedChromaticObjects.
        do_pickle(psf)
    else:
        repr(psf)

    im_r_ref = galsim.fits.read(os.path.join(refdir, 'r_exact.fits'))
    im_r = im_r_ref.copy()
    t6 = time.time()
    obj.drawImage(bandpass, image=im_r, scale=scale)
    t7 = time.time()
    print("Time to draw InterpolatedChromaticObject: {0}s".format(t7-t6))
    printval(im_r, im_r_ref)
    # Check that arrays agree to within 1e-4 of integrated flux
    np.testing.assert_allclose(im_r.array, im_r_ref.array, atol=1e-4*im_r_ref.array.sum())
    # Check sums to 1e-3 of sum
    np.testing.assert_allclose(im_r.array.sum(), im_r_ref.array.sum(), atol=1e-3*im_r.array.sum())
    # Check peak to 1e-3 of peak
    np.testing.assert_allclose(im_r.array.max(), im_r_ref.array.max(), atol=1e-3*im_r.array.max())

    im_r_ref /= im_r_ref.array.max()
    im_r /= im_r.array.max()
    # Test nearly passes at decimal=4, but 0.08% of pixels disagree.  However, decimal=3 after
    # normalization with peak flux is still very good.
    np.testing.assert_array_almost_equal(
        im_r.array, im_r_ref.array, decimal=3,
        err_msg='Interpolated ChromaticOpticalPSF results disagree with reference in r band')

    # Finally, check that flux normalization is preserved when we convolve with a chromatic object.
    gal = galsim.Exponential(half_light_radius = 2.*scale)
    gal = gal.shear(g2 = 0.3)
    gal = disk_SED*gal
    obj_conv = galsim.Convolve(psf, gal)
    im = obj_conv.drawImage(bandpass, scale=scale)
    expected_flux = disk_SED.calculateFlux(bandpass)

    assert np.isclose(im.array.sum(), expected_flux, rtol=0.02), \
        "ChromaticObject flux is wrong when convolved with ChromaticOpticalPSF " \
        " (interpolated calculation)"


@timer
def test_ChromaticAiry():
    """Test the ChromaticAiry functionality."""
    # First, compare the interpolated result with saved, exact results.
    # Exact results were generated using the following code, sitting in this directory:
    #
    # import galsim
    # import os
    # import numpy as np
    #
    # path, filename = os.path.split(__file__)
    # datapath = os.path.abspath(os.path.join(path, "../examples/data/"))
    # bandpass = (galsim.Bandpass(os.path.join(datapath, 'LSST_r.dat'))
    #             .truncate(relative_throughput=1e-3)
    #             .thin(rel_err=1e-3))
    # disk_SED = (galsim.SED(os.path.join(datapath, 'CWW_Sbc_ext.sed'), wave_type='ang')
    #             .thin(rel_err=1e-3)
    #             .withFluxDensity(target_flux_density=0.3, wavelength=500.0))
    #
    # star = galsim.Gaussian(sigma=1.e-8)*disk_SED
    #
    # lam = 750. # nm
    # diam = 3.1 # meters
    # obscuration = 0.11
    # scale = 0.02
    #
    # psf = galsim.ChromaticAiry(lam=lam, diam=diam, obscuration=obscuration)
    # obj = galsim.Convolve(psf, star)
    # im_r = obj.drawImage(bandpass, scale=scale)
    # im_r.write('./chromatic_reference_images/r_exact_Airy.fits')
    #
    # Note that exact results will have to be regenerated if any of the bandpasses or other
    # parameters defined here are changed.  For example, had to regenerate on #590 because of new
    # version of r bandpass.

    # Define parameters:
    lam = 750. # nm
    diam = 3.1 # meters
    obscuration = 0.11
    scale = 0.02

    psf = galsim.ChromaticAiry(lam=lam, diam=diam, obscuration=obscuration)
    do_pickle(psf)

    # Generate a reference image
    star = galsim.Gaussian(fwhm=1.e-8) * disk_SED
    obj = galsim.Convolve(psf, star)
    im_r = obj.drawImage(bandpass, scale=scale)

    # Initialize object in different way, make sure results are identical:
    lam_over_diam = (1.e-9*lam/diam)*galsim.radians
    psf = galsim.ChromaticAiry(lam=lam, lam_over_diam=lam_over_diam/galsim.arcsec,
                               obscuration=obscuration)
    obj = galsim.Convolve(psf, star)
    im_r_2 = im_r.copy()
    obj.drawImage(bandpass, image=im_r_2, scale=scale)
    np.testing.assert_array_almost_equal(
        im_r_2.array, im_r.array, decimal=8,
        err_msg='Inconsistent ChromaticAiry image when initializing a different way')

    with assert_raises(galsim.GalSimIncompatibleValuesError):
        galsim.ChromaticAiry(lam=lam, diam=diam, lam_over_diam=lam_over_diam/galsim.arcsec)

    # Also check evaluation at a single wavelength.
    chromatic_psf_400 = psf.evaluateAtWavelength(400.)
    new_lam_over_diam = (1.e-9*400/diam)*galsim.radians
    exact_psf_400 = galsim.Airy(lam_over_diam=new_lam_over_diam/galsim.arcsec,
                                obscuration=obscuration)
    chr_im = chromatic_psf_400.drawImage(scale=scale)
    exact_im = chr_im.copy()
    exact_psf_400.drawImage(image=exact_im, scale=scale)
    np.testing.assert_array_almost_equal(
        chr_im.array, exact_im.array, decimal=8,
        err_msg='ChromaticAiry evaluated at a single wavelength is not as expected')

    # Finally, check that flux normalization is preserved when we convolve with a chromatic object.
    gal = galsim.Exponential(half_light_radius = 2.*scale)
    gal = gal.shear(g2 = 0.3)
    gal = disk_SED*gal
    obj_conv = galsim.Convolve(psf, gal)
    im = obj_conv.drawImage(bandpass, scale=scale)
    expected_flux = disk_SED.calculateFlux(bandpass)
    frac_diff_exact = abs(im.array.sum()/expected_flux-1.0)
    # Check to 1%
    np.testing.assert_almost_equal(
        frac_diff_exact, 0.0, decimal=2,
        err_msg='ChromaticObject flux is wrong when convolved with ChromaticAiry')


@timer
def test_chromatic_fiducial_wavelength():
    """ Check that chromatic code can handle profiles with flux(effective_wavelength) = 0.
    """
    waves = np.arange(500., 600.1, 10.)
    blue_flux = waves < 550.0
    red_flux = waves > 550.0
    bp = galsim.Bandpass(galsim.LookupTable(waves, waves**0, interpolant='linear'), 'nm')
    blue_sed = galsim.SED(galsim.LookupTable(waves, blue_flux, interpolant='linear'),
                          'nm', 'flambda')
    red_sed = galsim.SED(galsim.LookupTable(waves, red_flux, interpolant='linear'),
                         'nm', 'flambda')

    gal1 = galsim.Gaussian(fwhm=1) * blue_sed
    gal2 = galsim.Gaussian(fwhm=1) * red_sed
    img1 = gal1.drawImage(bp)
    img2 = gal2.drawImage(bp)
    # Didn't see an obvious np.testing method for checking finiteness, so just use assert.
    assert np.isfinite(img1.array.sum()), "drawImage failed to identify fiducial wavelength"
    assert np.isfinite(img2.array.sum()), "drawImage failed to identify fiducial wavelength"

    # Pathalogical sed that is zero across the band.
    bad_sed = galsim.SED(galsim.LookupTable([300,498,499,601,602,800],
                                            [  1,  1,  0,  0,  1,  1], 'linear'), 'nm', 'flambda')
    gal3 = galsim.Gaussian(fwhm=1) * bad_sed
    with assert_raises(galsim.GalSimError):
        gal3.drawImage(bp)


@timer
def test_chromatic_image_setup():
    """Test ability for chromatic drawImage to setup output image."""
    psf = galsim.ChromaticAiry(lam=550, diam=0.1)
    gal1 = galsim.Sersic(n=1, half_light_radius=1.0) * bulge_SED
    gal2 = galsim.Sersic(n=2, half_light_radius=0.5) * disk_SED

    # Just going to try drawing a few different combinations of profiles to make sure that
    # the automatic image construction logic doesn't crash.  Most possibilities effectively get
    # tested in other scripts above anyway, so just focus on possibilities related to known previous
    # failures here; specifically, drawing a convolution of two inseparable profiles while
    # specifying `nx`, `ny`, and `scale` as keywords.
    img = galsim.Convolve(gal1+gal2, psf).drawImage(bandpass, nx=32, ny=32, scale=0.2)
    bds = galsim.BoundsI(1, 32, 1, 32)
    img2 = galsim.Convolve(gal1+gal2, psf).drawImage(bandpass, bounds=bds, scale=0.2)
    np.testing.assert_array_equal(img.array.shape, (32, 32),
                                  "Got wrong size output image using nx=, ny= keywords.")
    np.testing.assert_array_equal(img2.array.shape, (32, 32),
                                  "Got wrong size output image using bounds= keyword.")
    np.testing.assert_almost_equal(img.scale, 0.2, 9,
                                   "Got wrong output image scale using nx=, ny= keywords.")
    np.testing.assert_almost_equal(img2.scale, 0.2, 9,
                                   "Got wrong output image scale using bounds= keyword.")


@timer
def test_convolution_of_spectral():
    """Test that convolution of >1 spectral ChromaticObjects raises a ValueError."""
    cgal1 = galsim.Gaussian(fwhm=1) * bulge_SED              # spectral
    cgal2 = galsim.Gaussian(fwhm=2)                          # dimensionless
    cgal3 = galsim.ChromaticObject(galsim.Gaussian(fwhm=3))  # dimensionless

    assert cgal1.spectral
    assert not cgal2.spectral
    assert not cgal3.spectral
    assert not cgal1.dimensionless
    assert cgal2.dimensionless
    assert cgal3.dimensionless

    # These should be okay
    galsim.Convolve(cgal1, cgal2)
    galsim.Convolve(cgal1, cgal3)
    galsim.Convolve(cgal1, cgal2, cgal3)

    # This should raise a ValueError
    assert_raises(ValueError, galsim.Convolve, cgal1, cgal1)
    assert_raises(ValueError, galsim.Convolve, cgal1, cgal1, cgal1)
    assert_raises(ValueError, galsim.Convolve, cgal1, cgal1, cgal2, cgal3)


def check_chromatic_invariant(obj, bps=None, waves=None):
    """ Helper function to check that ChromaticObjects satisfy intended invariants.
    """
    if bps is None:
        # load a filter
        bppath = os.path.join(galsim.meta_data.share_dir, 'bandpasses')
        bandpass = (galsim.Bandpass(os.path.join(bppath, 'LSST_r.dat'), 'nm')
                    .truncate(relative_throughput=1e-3)
                    .thin(rel_err=1e-3))
        bps = [bandpass]

    if waves is None:
        waves = [500.]

    assert isinstance(obj.wave_list, np.ndarray)
    assert isinstance(obj.separable, bool)
    assert isinstance(obj.interpolated, bool)
    assert isinstance(obj.deinterpolated, (galsim.ChromaticObject, galsim.GSObject))

    for wave in waves:
        desired = obj.SED(wave)
        # Since InterpolatedChromaticObject.evaluateAtWavelength involves actually drawing an
        # image, which implies flux can be lost off of the edges of the image, we don't expect
        # its accuracy to be nearly as good as for other objects.
        decimal = 2 if obj.interpolated else 7
        np.testing.assert_almost_equal(obj.evaluateAtWavelength(wave).flux, desired,
                                       decimal)
        # Don't bother trying to draw a deconvolution.
        if isinstance(obj, galsim.ChromaticDeconvolution):
            continue
        np.testing.assert_allclose(
                obj.evaluateAtWavelength(wave).drawImage().array.sum(dtype=float),
                desired,
                rtol=1e-2)

    if obj.SED.spectral:
        for bp in bps:
            calc_flux = obj.calculateFlux(bp)
            np.testing.assert_equal(obj.SED.calculateFlux(bp), calc_flux)
            np.testing.assert_allclose(calc_flux,
                                       obj.drawImage(bp).array.sum(dtype=float), rtol=1e-2)
            # Also try manipulating exptime and area.
            np.testing.assert_allclose(
                    calc_flux * 10,
                    obj.drawImage(bp, exptime=5, area=2).array.sum(dtype=float), rtol=1e-2)

            assert_raises(galsim.GalSimSEDError, galsim.Deconvolve, obj)
            assert_raises(galsim.GalSimSEDError, galsim.AutoConvolve, obj)
            assert_raises(galsim.GalSimSEDError, galsim.AutoCorrelate, obj)
            assert_raises(galsim.GalSimSEDError, galsim.FourierSqrt, obj)

        try:
            obj = copy.copy(obj)
            obj.SED = galsim.SED('1', 'nm', '1')
        except AttributeError:
            return
    if isinstance(obj, galsim.GSObject): return

    # When made with the same gsparams, it returns itself
    print('obj = ',obj)
    assert obj.withGSParams(obj.gsparams) is obj
    alt_gsp = galsim.GSParams(xvalue_accuracy=0.23, folding_threshold=7.3e-4)
    obj_alt = obj.withGSParams(alt_gsp)
    assert isinstance(obj_alt, obj.__class__)
    assert obj_alt.gsparams == alt_gsp
    print('obj_alt = ',obj_alt)
    print('obj.gsp = ',obj.gsparams)
    print('obj_alt.gsp = ',obj_alt.gsparams)
    print('gsp == ? ',obj.gsparams == obj_alt.gsparams)
    print('obj == ? ',obj == obj_alt)
    assert obj_alt != obj  # Assuming none of our tests use this exact gsparams choice.
    # Back to the original, ==, but not is
    assert obj_alt.withGSParams(obj.gsparams) is not obj
    assert obj_alt.withGSParams(obj.gsparams) == obj

    # Test errors for dimensionless SEDs.
    with assert_raises(galsim.GalSimSEDError):
        obj.drawImage(bps[0])
    with assert_raises(galsim.GalSimSEDError):
        obj.drawKImage(bps[0])
    with assert_raises(galsim.GalSimSEDError):
        obj.withFluxDensity(100., 500)
    with assert_raises(galsim.GalSimSEDError):
        obj.withFluxDensity(100., 500)
    with assert_raises(galsim.GalSimSEDError):
        obj.calculateFlux(bps[0])
    with assert_raises(galsim.GalSimSEDError):
        obj.calculateMagnitude(bps[0])


@timer
def test_chromatic_invariant():
    # Test atomic and non-transformed objects first.

    # GSObject
    gsobj = galsim.Kolmogorov(fwhm=0.6, flux=2.0)
    check_chromatic_invariant(gsobj)

    # ChromaticObject
    check_chromatic_invariant(galsim.ChromaticObject(gsobj))
    chrom1 = galsim.ChromaticObject(gsobj) * bulge_SED
    chrom2 = gsobj * bulge_SED
    chrom3 = galsim.ChromaticObject(gsobj * bulge_SED)
    do_pickle(chrom1)
    do_pickle(chrom2)
    do_pickle(chrom3)
    do_pickle(galsim.ChromaticObject(gsobj))

    with assert_raises(TypeError):
        galsim.ChromaticObject(bulge_SED)

    check_chromatic_invariant(chrom1)
    check_chromatic_invariant(chrom2)
    check_chromatic_invariant(chrom3)
    # also check that these end up with the same SED
    assert chrom1.SED == chrom2.SED == chrom3.SED

    # And that they make the same image through a given bandpass
    bp = galsim.Bandpass('0.8 + wave/800*0.1', 'nm', blue_limit=700, red_limit=900)
    img = galsim.ImageF(64, 64, scale=0.2)
    img1 = chrom1.drawImage(bp, img)
    img2 = chrom2.drawImage(bp, img)
    img3 = chrom3.drawImage(bp, img)
    print('im1.sum = ',img1.array.sum())
    print('im2.sum = ',img2.array.sum())
    print('im3.sum = ',img3.array.sum())
    np.testing.assert_almost_equal(img1.array, img2.array, decimal=5)
    np.testing.assert_almost_equal(img1.array, img3.array, decimal=5)

    # ChromaticAtmosphere
    chrom_atm = galsim.ChromaticAtmosphere(gsobj, 500.0, zenith_angle=20.0 * galsim.degrees,
                                           pressure=70., temperature=285., H2O_pressure=1.05)
    check_chromatic_invariant(chrom_atm)
    do_pickle(chrom_atm)

    assert_raises(TypeError, galsim.ChromaticAtmosphere, gsobj,
                  500.0, zenith_angle=20.0 * galsim.degrees, invalid=3)

    # ChromaticTransformation formed from __mul__
    chrom = gsobj * bulge_SED
    check_chromatic_invariant(chrom)
    do_pickle(chrom)

    with assert_raises(galsim.GalSimError):
        chrom.noise

    # ChromaticOpticalPSF
    chrom_opt = galsim.ChromaticOpticalPSF(lam=500.0, diam=2.0, tip=2.0, tilt=3.0, defocus=0.2,
                                           scale_unit='arcmin')
    check_chromatic_invariant(chrom_opt)
    do_pickle(chrom_opt)

    # ChromaticAiry
    chrom_airy = galsim.ChromaticAiry(lam=500.0, diam=3.0, scale_unit=galsim.arcmin)
    check_chromatic_invariant(chrom_airy)
    do_pickle(chrom_airy)

    # Now start testing compound objects...
    # ChromaticSum
    chrom_sum_noSED = chrom_airy + chrom_opt
    check_chromatic_invariant(chrom_sum_noSED)
    # TODO: Seems like this should be picklable. Probably anything that doesn't include
    #       unpicklable user input should be picklable.
    #       e.g. autoconv2 has no hope.  But there are a few do_pickle calls that are commented
    #       out that we should probably try to make work.  A job for another day, though...
    #do_pickle(chrom_sum_noSED)
    repr(chrom_sum_noSED)
    str(chrom_sum_noSED)

    chrom_sum_SED = chrom + chrom  # also separable
    check_chromatic_invariant(chrom_sum_SED)
    do_pickle(chrom_sum_SED)
    assert chrom_sum_SED.separable

    gsobj2 = galsim.Kolmogorov(fwhm=0.7)
    chrom2 = gsobj2 * disk_SED
    chrom_sum_SED2 = chrom + chrom2
    check_chromatic_invariant(chrom_sum_SED2)
    do_pickle(chrom_sum_SED2)
    assert not chrom_sum_SED2.separable

    # ChromaticConvolution
    conv1 = galsim.Convolve(chrom, chrom_airy)  # SEDed
    check_chromatic_invariant(conv1)
    do_pickle(conv1)

    with assert_raises(galsim.GalSimError):
        conv1.noise

    conv2 = galsim.Convolve(chrom_airy, chrom_opt)  # Non-SEDed
    check_chromatic_invariant(conv2)
    do_pickle(conv2)

    # ChromaticDeconvolution
    deconv = galsim.Deconvolve(chrom_airy)
    check_chromatic_invariant(deconv)
    #do_pickle(deconv)
    repr(deconv) # gratuitous coverage of repr until do_pickle works.
    str(deconv)

    # ChromaticAutoConvolution
    autoconv1 = galsim.AutoConvolve(chrom_airy)
    check_chromatic_invariant(autoconv1)
    autoconv2 = galsim.AutoConvolve(chrom_airy * (lambda w: (w/500.0)**0.1))
    check_chromatic_invariant(autoconv2)
    do_pickle(autoconv1)

    # ChromaticAutoCorrelation
    autocorr1 = galsim.AutoCorrelate(chrom_airy)
    check_chromatic_invariant(autocorr1)
    autocorr2 = galsim.AutoCorrelate(chrom_airy * (lambda w: (w/500.0)**0.1))
    check_chromatic_invariant(autocorr2)
    do_pickle(autocorr1)

    # ChromaticFourierSqrt
    four1 = galsim.FourierSqrt(chrom_airy)
    check_chromatic_invariant(four1)
    four2 = galsim.FourierSqrt(chrom_airy * (lambda w: (w/500.0)**0.1))
    check_chromatic_invariant(four2)
    #do_pickle(four1)
    repr(four1) # gratuitous coverage of repr until do_pickle works.
    str(four1)

    # And a few transforms too...
    # ChromaticTransformation
    sheared_chrom = chrom.shear(g1=0.1)
    check_chromatic_invariant(sheared_chrom)
    do_pickle(sheared_chrom)

    scaled_chrom = 2 * chrom
    check_chromatic_invariant(scaled_chrom)
    do_pickle(scaled_chrom)

    complex_scaled_chrom = chrom * (lambda w: (w/500.0)**0.1)
    check_chromatic_invariant(complex_scaled_chrom)

    chrom_added_SED = chrom_airy * bulge_SED
    check_chromatic_invariant(chrom_added_SED)
    do_pickle(chrom_added_SED)

    complex_expanded_chrom = chrom.expand(lambda w: (w/500.0)**0.1)
    check_chromatic_invariant(complex_expanded_chrom)

    complex_dilated_chrom = chrom.dilate(lambda w: (w/500.0)**0.1)
    check_chromatic_invariant(complex_dilated_chrom)

    complex_transformed_chrom = chrom.transform(
            lambda w: 1. + 0.2*(w/500)**0.1,
            lambda w: -0.2*(w/500)**0.2,
            lambda w: -0.3*(w/500)**0.3,
            lambda w: 1. + 0.1*(w/500)**0.2
    )
    check_chromatic_invariant(complex_transformed_chrom)

    # ChromaticInterpolatedObject
    chrom_interp = chrom_airy.interpolate(waves=[400.0, 500.0, 600.0])
    check_chromatic_invariant(chrom_interp)
    do_pickle(chrom_interp)


@timer
def test_ne():
    """Test chromatic.py objects for not-equals."""
    # Define some universal objects.
    gsp = galsim.GSParams(maxk_threshold=1.1e-3, folding_threshold=5.1e-3)
    gal1 = galsim.Gaussian(fwhm=1.0)
    gal2 = galsim.Gaussian(fwhm=1.1)
    cgal1 = galsim.ChromaticObject(gal1).dilate(lambda w:1)
    cgal2 = galsim.ChromaticObject(gal2).dilate(lambda w:1)
    cgal3 = cgal1.interpolate(np.arange(400, 550, 10))

    # ChromaticObject.  Only param is the GSObject to chromaticize.
    # The following should test unequal:
    gals = [cgal1, cgal2]
    all_obj_diff(gals)

    # # Check that setifying doesn't remove any duplicate items.
    # assert len(gals) == len(set(gals))
    # hashes = [hash(item) for item in gals]
    # assert len(hashes) == len(set(hashes))

    # InterpolatedChromaticObject.  Params include object to be chromaticized, waves, and
    # oversample_fac.
    # Also get a copy of cgal1 and make it interpolatable, but with a different waves argument.
    gals = [cgal1,
            cgal2,
            cgal3,
            galsim.InterpolatedChromaticObject(cgal1, np.arange(500, 700, 50)),
            galsim.InterpolatedChromaticObject(cgal2, np.arange(500, 700, 50)),
            galsim.InterpolatedChromaticObject(cgal1, np.arange(500, 700, 25)),
            galsim.InterpolatedChromaticObject(cgal1, np.arange(500, 700, 50), oversample_fac=1.1),
            cgal1.interpolate(np.arange(500, 700, 10)),
            cgal1.interpolate(np.arange(500, 700, 10), oversample_fac=1.2)]
    all_obj_diff(gals)

    # ChromaticAtmosphere.  Params include base_obj, base_wavelength, scale_unit, alpha,
    # zenith_angle, parallactic_angle, obj_coord, zenith_coord, HA, latitude, pressure, temperature,
    # and H2O_pressure.

    # Some params to test the celestial coords inputs.
    ra = galsim.Angle.from_hms("14:03:13") # hours : minutes : seconds
    dec = galsim.Angle.from_dms("54:20:57") # degrees : minutes : seconds
    m101 = galsim.CelestialCoord(ra, dec)
    latitude = 19.8207 * galsim.degrees # latitude of Mauna Kea
    HA = -1.0 * galsim.hours # Hour angle = one hour before transit
    zenith_coord = galsim.CelestialCoord(0.*galsim.degrees, 40*galsim.degrees) # Make something up
    # The following should test unequal.
    gals = [galsim.ChromaticAtmosphere(gal1, 500.0, zenith_angle=30*galsim.degrees),
            galsim.ChromaticAtmosphere(gal2, 500.0, zenith_angle=30*galsim.degrees),
            galsim.ChromaticAtmosphere(gal1, 600.0, zenith_angle=30*galsim.degrees),
            galsim.ChromaticAtmosphere(gal1, 600.0, zenith_angle=30*galsim.degrees,
                                       scale_unit=galsim.degrees),
            galsim.ChromaticAtmosphere(gal1, 600.0, zenith_angle=30*galsim.degrees,
                                       scale_unit='arcmin'),
            galsim.ChromaticAtmosphere(gal1, 500.0, zenith_angle=30*galsim.degrees, alpha=-0.1),
            galsim.ChromaticAtmosphere(gal1, 500.0, zenith_angle=30*galsim.degrees,
                                       parallactic_angle=45*galsim.degrees),
            galsim.ChromaticAtmosphere(gal1, 500.0, zenith_angle=30*galsim.degrees,
                                       temperature=290.0),
            galsim.ChromaticAtmosphere(gal1, 500.0, zenith_angle=30*galsim.degrees,
                                       pressure=75.0),
            galsim.ChromaticAtmosphere(gal1, 500.0, zenith_angle=30*galsim.degrees,
                                       H2O_pressure=2.0),
            galsim.ChromaticAtmosphere(gal1, 500.0, obj_coord=m101, HA=HA, latitude=latitude),
            galsim.ChromaticAtmosphere(gal1, 500.0, obj_coord=m101, zenith_coord=zenith_coord)]
    all_obj_diff(gals)

    # Chromatic.  Params are a gsobject and an SED.
    sed1 = galsim.SED(lambda w: w, 'nm', 'flambda')
    sed2 = galsim.SED(lambda w: 2*w, 'nm', 'flambda')
    # The following should test unequal.
    gals = [gal1 * sed1,
            gal1 * sed2,
            gal2 * sed1,
            gal2 * sed2]
    all_obj_diff(gals)

    # ChromaticTransformation.  Params are an object (possibly chromatic), a jacobian jac, an
    # offset, a flux_ratio, and gsparams.  For coverage, test jac, offset, and flux_ratio as
    # consts and functions.
    jac1 = lambda w: [[w, 0], [0, 1]]
    jac2 = lambda w: [[w, 0], [0, w]]
    offset1 = lambda w: (0, w)
    offset2 = lambda w: (w, 0)
    flux_ratio1 = lambda w: w
    flux_ratio2 = lambda w: w**2
    # The following should test unequal.
    with assert_warns(galsim.GalSimWarning):
        trans_cgal3 = galsim.ChromaticTransformation(
                cgal3, jac=jac1, offset=offset1, flux_ratio=flux_ratio1),
    gals = [galsim.ChromaticTransformation(cgal1),
            galsim.ChromaticTransformation(cgal3),
            galsim.ChromaticTransformation(gal1, jac=[[1, 1.1], [0.1, 1]]),
            galsim.ChromaticTransformation(gal1, jac=[[1, 0.1], [0.1, 1]]),
            galsim.ChromaticTransformation(gal1, jac=jac1),
            galsim.ChromaticTransformation(gal1, jac=jac2),
            galsim.ChromaticTransformation(gal1, offset=(0.1, 0.0)),
            galsim.ChromaticTransformation(gal1, offset=(0.0, 0.1)),
            galsim.ChromaticTransformation(gal1, offset=offset1),
            galsim.ChromaticTransformation(gal1, offset=offset2),
            galsim.ChromaticTransformation(gal1, flux_ratio=1.1),
            galsim.ChromaticTransformation(gal1, flux_ratio=1.4),
            galsim.ChromaticTransformation(gal1, flux_ratio=flux_ratio1),
            galsim.ChromaticTransformation(gal1, flux_ratio=flux_ratio2),
            galsim.ChromaticTransformation(cgal1, jac=jac1, offset=offset1, flux_ratio=flux_ratio1),
            trans_cgal3,
            galsim.ChromaticTransformation(cgal1, gsparams=gsp),
            galsim.ChromaticTransformation(cgal1, gsparams=gsp, propagate_gsparams=False),
            galsim.ChromaticTransformation(cgal3).withGSParams(gsp),
            galsim.ChromaticTransformation(cgal3, propagate_gsparams=False).withGSParams(gsp)]
    all_obj_diff(gals)

    # ChromaticSum.  Params are objs to add and potentially gsparams.
    # The following should test unequal.
    gals = [galsim.ChromaticSum(cgal1),
            galsim.ChromaticSum(cgal1, cgal2),
            galsim.ChromaticSum(cgal3, cgal2),
            galsim.ChromaticSum(cgal2, cgal1),  # Not! commutative.
            galsim.ChromaticSum(galsim.ChromaticSum(cgal1, cgal2), cgal2),
            galsim.ChromaticSum(cgal1, galsim.ChromaticSum(cgal2, cgal2)),  # Not! associative.
            galsim.ChromaticSum(cgal1, gsparams=gsp),
            galsim.ChromaticSum(cgal1, gsparams=gsp, propagate_gsparams=False),
            galsim.ChromaticSum(cgal3).withGSParams(gsp),
            galsim.ChromaticSum(cgal3, propagate_gsparams=False).withGSParams(gsp)]
    all_obj_diff(gals)

    # ChromaticConvolution.  Params are objs to convolve and potentially gsparams.
    # The following should test unequal
    with assert_warns(galsim.GalSimWarning):
        conv_32 = galsim.ChromaticConvolution(cgal3, cgal2),
    gals = [galsim.ChromaticConvolution(cgal1),
            galsim.ChromaticConvolution(cgal1, cgal2),
            conv_32,
            galsim.ChromaticConvolution(cgal2, cgal1),  # Not! commutative.
            galsim.ChromaticConvolution(galsim.ChromaticConvolution(cgal1, cgal2), cgal2),
            # ChromaticConvolution is associative! (unlike galsim.Convolution)
            # galsim.ChromaticConvolution(cgal1, galsim.ChromaticConvolution(cgal2, cgal2)),
            galsim.ChromaticConvolution(cgal1, gsparams=gsp),
            galsim.ChromaticConvolution(cgal1, gsparams=gsp, propagate_gsparams=False),
            galsim.ChromaticConvolution(cgal3).withGSParams(gsp),
            galsim.ChromaticConvolution(cgal3, propagate_gsparams=False).withGSParams(gsp)]
    all_obj_diff(gals)

    # ChromaticDeconvolution.  Only params here are obj to deconvolve and gsparams.
    gals = [galsim.ChromaticDeconvolution(cgal1),
            galsim.ChromaticDeconvolution(cgal2),
            galsim.ChromaticDeconvolution(cgal3),
            galsim.ChromaticDeconvolution(cgal1, gsparams=gsp),
            galsim.ChromaticDeconvolution(cgal1, gsparams=gsp, propagate_gsparams=False),
            galsim.ChromaticDeconvolution(cgal3).withGSParams(gsp),
            galsim.ChromaticDeconvolution(cgal3, propagate_gsparams=False).withGSParams(gsp)]
    all_obj_diff(gals)

    # ChromaticAutoConvolution.
    gals = [galsim.ChromaticAutoConvolution(cgal1),
            galsim.ChromaticAutoConvolution(cgal2),
            galsim.ChromaticAutoConvolution(cgal3),
            galsim.ChromaticAutoConvolution(cgal1, gsparams=gsp),
            galsim.ChromaticAutoConvolution(cgal1, gsparams=gsp, propagate_gsparams=False),
            galsim.ChromaticAutoConvolution(cgal3).withGSParams(gsp),
            galsim.ChromaticAutoConvolution(cgal3, propagate_gsparams=False).withGSParams(gsp)]
    all_obj_diff(gals)

    # ChromaticAutoCorrelation.
    gals = [galsim.ChromaticAutoCorrelation(cgal1),
            galsim.ChromaticAutoCorrelation(cgal2),
            galsim.ChromaticAutoCorrelation(cgal3),
            galsim.ChromaticAutoCorrelation(cgal1, gsparams=gsp),
            galsim.ChromaticAutoCorrelation(cgal1, gsparams=gsp, propagate_gsparams=False),
            galsim.ChromaticAutoCorrelation(cgal3).withGSParams(gsp),
            galsim.ChromaticAutoCorrelation(cgal3, propagate_gsparams=False).withGSParams(gsp)]
    all_obj_diff(gals)

    # ChromaticFourierSqrt.
    gals = [galsim.ChromaticFourierSqrtProfile(cgal1),
            galsim.ChromaticFourierSqrtProfile(cgal2),
            galsim.ChromaticFourierSqrtProfile(cgal3),
            galsim.ChromaticFourierSqrtProfile(cgal1, gsparams=gsp),
            galsim.ChromaticFourierSqrtProfile(cgal1, gsparams=gsp, propagate_gsparams=False),
            galsim.ChromaticFourierSqrtProfile(cgal3).withGSParams(gsp),
            galsim.ChromaticFourierSqrtProfile(cgal3, propagate_gsparams=False).withGSParams(gsp)]
    all_obj_diff(gals)

    # ChromaticOpticalPSF.  Params include: lam, (diam or lam_over_diam), aberrations, nstruts,
    # strut_thick, strut_angle, obscuration, oversampling, pad_factor, flux, gsparams, ...
    # Most of these get tested in the same way, (via a kwargs dict comparison), so only test a few
    # here.
    gals = [galsim.ChromaticOpticalPSF(lam=1.0, lam_over_diam=1.0),
            galsim.ChromaticOpticalPSF(lam=1.0, diam=1.1),
            galsim.ChromaticOpticalPSF(lam=1.0, diam=1.1, scale_unit=galsim.arcmin),
            galsim.ChromaticOpticalPSF(lam=1.0, diam=1.1, scale_unit='radians'),
            galsim.ChromaticOpticalPSF(lam=1.0, lam_over_diam=1.0, obscuration=0.5),
            galsim.ChromaticOpticalPSF(lam=1.0, lam_over_diam=1.0, aberrations=[0, 0, 0, 0, 0.1]),
            galsim.ChromaticOpticalPSF(lam=1.0, lam_over_diam=1.0, defocus=0.2),
            galsim.ChromaticOpticalPSF(lam=1.0, lam_over_diam=1.0, flux=0.2),
            galsim.ChromaticOpticalPSF(lam=1.0, lam_over_diam=1.0, gsparams=gsp),
            galsim.ChromaticOpticalPSF(lam=1.0, lam_over_diam=1.0, flux=0.2).withGSParams(gsp)]
    all_obj_diff(gals)

    # ChromaticAiry.  Params include: lam, diam, lam_over_diam, scale_unit, flux, obscuration,
    # gsparams.
    gals = [galsim.ChromaticAiry(lam=1.0, lam_over_diam=1.0),
            galsim.ChromaticAiry(lam=1.0, diam=1.0),
            galsim.ChromaticAiry(lam=1.0, diam=1.0, scale_unit=galsim.arcmin),
            galsim.ChromaticAiry(lam=1.0, diam=1.0, scale_unit='deg'),
            galsim.ChromaticAiry(lam=1.0, lam_over_diam=1.0, obscuration=0.5),
            galsim.ChromaticAiry(lam=1.0, lam_over_diam=1.0, flux=1.1),
            galsim.ChromaticAiry(lam=1.0, lam_over_diam=1.0, gsparams=gsp),
            galsim.ChromaticAiry(lam=1.0, lam_over_diam=1.0, flux=1.1).withGSParams(gsp)]
    all_obj_diff(gals)

    # Check that all the various combinations are properly unequal
    gals = [cgal1,
            galsim.ChromaticObject(gal1),
            galsim.InterpolatedChromaticObject(cgal1, np.arange(500, 700, 50)),
            galsim.ChromaticAtmosphere(gal1, 500.0, zenith_angle=30*galsim.degrees),
            gal1 * sed1,
            galsim.ChromaticTransformation(cgal1),
            galsim.ChromaticSum(cgal1),
            galsim.ChromaticConvolution(cgal1),
            galsim.ChromaticDeconvolution(cgal1),
            galsim.ChromaticAutoConvolution(cgal1),
            galsim.ChromaticAutoCorrelation(cgal1),
            galsim.ChromaticOpticalPSF(lam=1.0, lam_over_diam=1.0),
            galsim.ChromaticAiry(lam=1.0, lam_over_diam=1.0)]
    all_obj_diff(gals)


if __name__ == "__main__":
    test_draw_add_commutativity()
    test_ChromaticConvolution_InterpolatedImage()
    test_chromatic_add()
    test_dcr_moments()
    test_chromatic_seeing_moments()
    test_monochromatic_filter()
    test_chromatic_flux()
    test_double_ChromaticSum()
    test_ChromaticConvolution_of_ChromaticConvolution()
    test_ChromaticAutoConvolution()
    test_ChromaticAutoCorrelation()
    test_ChromaticObject_expand()
    test_ChromaticObject_rotate()
    test_ChromaticObject_shear()
    test_ChromaticObject_shift()
    test_ChromaticObject_compound_affine_transformation()
    test_analytic_integrator()
    test_gsparams()
    test_separable_ChromaticSum()
    test_centroid()
    test_interpolated_ChromaticObject()
    test_ChromaticOpticalPSF()
    test_ChromaticAiry()
    test_chromatic_fiducial_wavelength()
    test_chromatic_image_setup()
    test_convolution_of_spectral()
    test_chromatic_invariant()
    test_ne()
