# Copyright (c) 2012-2015 by the GalSim developers team on GitHub
# https://github.com/GalSim-developers
#
# This file is part of GalSim: The modular galaxy image simulation toolkit.
# https://github.com/GalSim-developers/GalSim
#
# GalSim is free software: redistribution and use in source and binary forms,
# with or without modification, are permitted provided that the following
# conditions are met:
#
# 1. Redistributions of source code must retain the above copyright notice, this
#    list of conditions, and the disclaimer given in the accompanying LICENSE
#    file.
# 2. Redistributions in binary form must reproduce the above copyright notice,
#    this list of conditions, and the disclaimer given in the documentation
#    and/or other materials provided with the distribution.
#
import os
import numpy as np
from galsim_test_helpers import *
path, filename = os.path.split(__file__)
datapath = os.path.abspath(os.path.join(path, "../examples/data/"))
try:
    import galsim
except ImportError:
    sys.path.append(os.path.abspath(os.path.join(path, "..")))
    import galsim

# from pylab import *
# def plotme(image):
#     imshow(image.array)
#     show()

# liberal use of globals here...
zenith_angle = 20 * galsim.degrees
R500 = galsim.dcr.get_refraction(500.0, zenith_angle) # normalize refraction to 500nm

# some profile parameters to test with
bulge_n = 4.0
bulge_hlr = 0.5
bulge_e1 = 0.2
bulge_e2 = 0.2

disk_n = 1.0
disk_hlr = 1.0
disk_e1 = 0.4
disk_e2 = 0.2

PSF_hlr = 0.3
PSF_beta = 3.0
PSF_e1 = 0.01
PSF_e2 = 0.06

shear_g1 = 0.01
shear_g2 = 0.02

# load a filter
bandpass = galsim.Bandpass(os.path.join(datapath, 'LSST_r.dat')).thin()
bandpass_g = galsim.Bandpass(os.path.join(datapath, 'LSST_g.dat')).thin()
bandpass_z = galsim.Bandpass(os.path.join(datapath, 'LSST_z.dat')).thin()

# load some spectra
bulge_SED = galsim.SED(os.path.join(datapath, 'CWW_E_ext.sed'), wave_type='ang')
bulge_SED = bulge_SED.withFluxDensity(target_flux_density=0.3, wavelength=500.0)

disk_SED = galsim.SED(os.path.join(datapath, 'CWW_Sbc_ext.sed'), wave_type='ang')
disk_SED = disk_SED.withFluxDensity(target_flux_density=0.3, wavelength=500.0)

# define the directory containing some reference images
refdir = os.path.join(".", "chromatic_reference_images") # Directory containing the reference

def test_draw_add_commutativity():
    """Compare two chromatic images, one generated by adding up GSObject profiles before drawing,
    and one generated (via galsim.chromatic) by drawing image summands wavelength-by-wavelength
    while updating the profile and adding as you go.
    """
    import time
    t1 = time.time()

    stamp_size = 32
    pixel_scale = 0.2

    #------------------------------------------------------------------------------
    # Use galsim.base functions to generate chromaticity by creating an effective
    # PSF by adding together weighted monochromatic PSFs.
    # Profiles are added together before drawing.
    #------------------------------------------------------------------------------

    # make galaxy
    GS_gal = galsim.Sersic(n=bulge_n, half_light_radius=bulge_hlr)
    GS_gal = GS_gal.shear(e1=bulge_e1, e2=bulge_e2)
    GS_gal = GS_gal.shear(g1=shear_g1, g2=shear_g2)

    # make effective PSF with Riemann sum midpoint rule
    mPSFs = [] # list of flux-scaled monochromatic PSFs
    N = 50
    h = (bandpass.red_limit * 1.0 - bandpass.blue_limit) / N
    ws = [bandpass.blue_limit + h*(i+0.5) for i in range(N)]
    shift_fn = lambda w:(0, ((galsim.dcr.get_refraction(w, zenith_angle) - R500)
                             * (galsim.radians / galsim.arcsec)))
    dilate_fn = lambda w:(w/500.0)**(-0.2)
    for w in ws:
        flux = bulge_SED(w) * bandpass(w) * h
        mPSF = galsim.Moffat(flux=flux, beta=PSF_beta, half_light_radius=PSF_hlr*dilate_fn(w))
        mPSF = mPSF.shear(e1=PSF_e1, e2=PSF_e2)
        mPSF = mPSF.shift(shift_fn(w))
        mPSFs.append(mPSF)
    PSF = galsim.Add(mPSFs)

    # final profile
    final = galsim.Convolve([GS_gal, PSF])
    GS_image = galsim.ImageD(stamp_size, stamp_size, scale=pixel_scale)
    t2 = time.time()
    GS_image = final.drawImage(image=GS_image)
    t3 = time.time()
    print 'GS_object.drawImage() took {0} seconds.'.format(t3-t2)
    # plotme(GS_image)

    # As an aside, check for appropriate tests of 'integrator' argument.
    try:
        np.testing.assert_raises(TypeError, final.drawImage, bandpass, method='no_pixel',
                                 integrator='midp') # minor misspelling
        np.testing.assert_raises(TypeError, final.drawImage, bandpass, method='no_pixel',
                                 integrator=galsim.integ.midpt)
    except ImportError:
        print 'The assert_raises tests require nose'

    #------------------------------------------------------------------------------
    # Use galsim.chromatic to generate chromaticity.  Internally, this module draws
    # the result at each wavelength and adds the results together.  I.e., drawing
    # and adding happen in the reverse order of the above.
    #------------------------------------------------------------------------------

    # make galaxy
    mono_gal = galsim.Sersic(n=bulge_n, half_light_radius=bulge_hlr)
    chromatic_gal = mono_gal * bulge_SED
    do_pickle(bulge_SED)
    do_pickle(chromatic_gal, lambda x: x.drawImage(bandpass, method='no_pixel',
                                                   nx=10, ny=10, scale=1))
    do_pickle(chromatic_gal)

    # Shear object
    chromatic_gal = chromatic_gal.shear(e1=bulge_e1, e2=bulge_e2)
    chromatic_gal = chromatic_gal.shear(g1=shear_g1, g2=shear_g2)
    do_pickle(chromatic_gal, lambda x: x.drawImage(bandpass, method='no_pixel',
                                                   nx=10, ny=10, scale=1))
    do_pickle(chromatic_gal)

    # make chromatic PSF
    mono_PSF = galsim.Moffat(beta=PSF_beta, half_light_radius=PSF_hlr)
    mono_PSF = mono_PSF.shear(e1=PSF_e1, e2=PSF_e2)
    chromatic_PSF = galsim.ChromaticObject(mono_PSF)
    do_pickle(chromatic_PSF, lambda x: x.drawImage(bandpass, method='no_pixel',
                                                   nx=10, ny=10, scale=1))
    do_pickle(chromatic_PSF)
    chromatic_PSF = chromatic_PSF.dilate(dilate_fn)
    chromatic_PSF = chromatic_PSF.shift(shift_fn)

    # final profile
    chromatic_final = galsim.Convolve([chromatic_gal, chromatic_PSF])
    chromatic_image = galsim.ImageD(stamp_size, stamp_size, scale=pixel_scale)
    # use chromatic parent class to draw without ChromaticConvolution acceleration...
    t4 = time.time()
    integrator = galsim.integ.ContinuousIntegrator(galsim.integ.midpt, N=N, use_endpoints=False)
    # NB. You cannot use ChromaticObject.drawImage() here, since it will automatically farm out to
    #     the ChromaticConvolution version of drawImage rather than respecting the
    #     ChromaticObject specification.  Using super() doesn't seem to work either.  So I just
    #     went ahead and converted this statement to the new format.  There are a couple other
    #     similar times in the test suite where we want to force it to use the base class
    #     implementation, so those had to be switched as well.
    galsim.ChromaticObject.drawImage(chromatic_final, bandpass, image=chromatic_image,
                                     integrator=integrator)
    t5 = time.time()
    print 'ChromaticObject.drawImage() took {0} seconds.'.format(t5-t4)
    # plotme(chromatic_image)

    peak1 = chromatic_image.array.max()

    printval(GS_image, chromatic_image)
    np.testing.assert_array_almost_equal(
        chromatic_image.array/peak1, GS_image.array/peak1, 6,
        err_msg="Directly computed chromatic image disagrees with image created using "
                +"galsim.chromatic")
    t6 = time.time()
    print 'time for %s = %.2f'%(funcname(),t6-t1)

def test_ChromaticConvolution_InterpolatedImage():
    """Check that we can interchange the order of integrating over wavelength and convolving for
    separable ChromaticObjects.  This involves storing the results of integrating first in an
    InterpolatedImage.
    """
    import time
    t1 = time.time()

    pixel_scale = 0.2
    stamp_size = 32

    # stars are fundamentally delta-fns with an SED
    star = galsim.Gaussian(fwhm=1.e-8) * bulge_SED
    mono_PSF = galsim.Gaussian(half_light_radius=PSF_hlr)
    PSF = galsim.ChromaticAtmosphere(mono_PSF, base_wavelength=500.0,
                                     zenith_angle=zenith_angle)

    final = galsim.Convolve([star, PSF])
    image = galsim.ImageD(stamp_size, stamp_size, scale=pixel_scale)

    do_pickle(star)
    do_pickle(PSF)
    do_pickle(final)

    # draw image using speed tricks in ChromaticConvolution.draw
    # For this particular test, need to set iimult=4 in order to pass.
    II_image = final.drawImage(bandpass, image=image, iimult=4)
    II_flux = II_image.array.sum()

    image2 = image.copy()
    # draw image without any speed tricks using ChromaticObject.drawImage
    D_image = galsim.ChromaticObject.drawImage(final, bandpass, image=image2)
    D_flux = D_image.array.sum()

    #compare
    print 'Flux when integrating first, convolving second: {0}'.format(II_flux)
    print 'Flux when convolving first, integrating second: {0}'.format(D_flux)
    printval(II_image, D_image)
    np.testing.assert_array_almost_equal(
        II_image.array, D_image.array, 5,
        err_msg="ChromaticConvolution draw not equivalent to regular draw")

    # Check flux scaling
    II_image2 = (final * 2.).drawImage(bandpass, image=image, iimult=4)
    II_flux2 = II_image2.array.sum()
    np.testing.assert_array_almost_equal(
        II_flux2, 2.*II_flux, 5,
        err_msg="ChromaticConvolution * 2 resulted in wrong flux.")

    t2 = time.time()
    print 'time for %s = %.2f'%(funcname(),t2-t1)

def test_chromatic_add():
    """Test the `+` operator on ChromaticObjects"""
    import time
    t1 = time.time()

    stamp_size = 32
    pixel_scale = 0.2

    # create galaxy profiles
    mono_bulge = galsim.Sersic(n=bulge_n, half_light_radius=bulge_hlr)
    bulge = mono_bulge * bulge_SED
    bulge = bulge.shear(e1=bulge_e1, e2=bulge_e2)

    mono_disk = galsim.Sersic(n=disk_n, half_light_radius=disk_hlr)
    disk = mono_disk * disk_SED
    disk = disk.shear(e1=disk_e1, e2=disk_e2)

    # test `+` operator
    bdgal = bulge + disk
    bdgal = bdgal.shear(g1=shear_g1, g2=shear_g2)

    # now shear the indiv profiles
    bulge = bulge.shear(g1=shear_g1, g2=shear_g2)
    disk = disk.shear(g1=shear_g1, g2=shear_g2)

    # create PSF
    mono_PSF = galsim.Moffat(beta=PSF_beta, half_light_radius=PSF_hlr)
    mono_PSF = mono_PSF.shear(e1=PSF_e1, e2=PSF_e2)
    chromatic_PSF = galsim.ChromaticAtmosphere(mono_PSF, base_wavelength=500.0,
                                               zenith_angle=zenith_angle)

    # create final profile
    final = galsim.Convolve([bdgal, chromatic_PSF])
    image = galsim.ImageD(stamp_size, stamp_size, scale=pixel_scale)
    image = final.drawImage(bandpass, image=image)

    do_pickle(bulge)
    do_pickle(disk)
    do_pickle(bdgal)
    do_pickle(chromatic_PSF)
    do_pickle(final)

    bulge_image = galsim.ImageD(stamp_size, stamp_size, scale=pixel_scale)
    bulge_part = galsim.Convolve([bulge, chromatic_PSF])
    bulge_image = bulge_part.drawImage(bandpass, image=bulge_image)
    disk_image = galsim.ImageD(stamp_size, stamp_size, scale=pixel_scale)
    disk_part = galsim.Convolve([disk, chromatic_PSF])
    disk_image = disk_part.drawImage(bandpass, image=disk_image)

    piecewise_image = bulge_image + disk_image
    print 'bulge image flux: {0}'.format(bulge_image.array.sum())
    print 'disk image flux: {0}'.format(disk_image.array.sum())
    print 'piecewise image flux: {0}'.format(piecewise_image.array.sum())
    print 'bdimage flux: {0}'.format(image.array.sum())
    printval(image, piecewise_image)
    np.testing.assert_array_almost_equal(
            image.array, piecewise_image.array, 6,
            err_msg="`+` operator doesn't match manual image addition")

    # Check flux scaling
    flux = image.array.sum()
    image = (final * 2.).drawImage(bandpass, image=image)
    flux2 = image.array.sum()
    np.testing.assert_array_almost_equal(
        flux2, 2.*flux, 5,
        err_msg="ChromaticConvolution with sum * 2 resulted in wrong flux.")

    # apply flux scaling to ChromaticSum
    final2 = galsim.Convolve(bdgal*2, chromatic_PSF)
    image = final2.drawImage(bandpass, image=image)
    flux2 = image.array.sum()
    np.testing.assert_array_almost_equal(
        flux2, 2.*flux, 5,
        err_msg="ChromaticSum * 2 resulted in wrong flux.")


    t2 = time.time()
    print 'time for %s = %.2f'%(funcname(),t2-t1)

def test_dcr_moments():
    """Check that zenith-direction surface brightness distribution first and second moments obey
    expected behavior for differential chromatic refraction when comparing objects drawn with
    different SEDs."""

    import time
    t1 = time.time()

    stamp_size = 256
    pixel_scale = 0.025

    # stars are fundamentally delta-fns with an SED
    star1 = galsim.Gaussian(fwhm=1.e-8) * bulge_SED
    star2 = galsim.Gaussian(fwhm=1.e-8) * disk_SED

    shift_fn = lambda w:(0, ((galsim.dcr.get_refraction(w, zenith_angle) - R500)
                             * (galsim.radians / galsim.arcsec)))
    mono_PSF = galsim.Moffat(beta=PSF_beta, half_light_radius=PSF_hlr)
    PSF = galsim.ChromaticObject(mono_PSF)
    PSF = PSF.shift(shift_fn)

    final1 = galsim.Convolve([star1, PSF])
    final2 = galsim.Convolve([star2, PSF])

    image1 = galsim.ImageD(stamp_size, stamp_size, scale=pixel_scale)
    image2 = galsim.ImageD(stamp_size, stamp_size, scale=pixel_scale)

    image1 = final1.drawImage(bandpass, image=image1)
    image2 = final2.drawImage(bandpass, image=image2)
    # plotme(image1)

    mom1 = getmoments(image1)
    mom2 = getmoments(image2)
    dR_image = (mom1[1] - mom2[1]) * pixel_scale
    dV_image = (mom1[3] - mom2[3]) * (pixel_scale)**2

    # analytic moment differences
    R_bulge, V_bulge = bulge_SED.calculateDCRMomentShifts(bandpass, zenith_angle=zenith_angle)
    R_disk, V_disk = disk_SED.calculateDCRMomentShifts(bandpass, zenith_angle=zenith_angle)
    dR_analytic = (R_bulge[1] - R_disk[1]) * 180.0/np.pi * 3600
    dV_analytic = (V_bulge[1,1] - V_disk[1,1]) * (180.0/np.pi * 3600)**2

    # also compute dR_analytic using ChromaticObject.centroid()
    centroid1 = final1.centroid(bandpass)
    centroid2 = final2.centroid(bandpass)
    dR_centroid = (centroid1 - centroid2).y

    print 'image delta R:    {0}'.format(dR_image)
    print 'analytic delta R: {0}'.format(dR_analytic)
    print 'centroid delta R: {0}'.format(dR_centroid)
    print 'image delta V:    {0}'.format(dV_image)
    print 'analytic delta V: {0}'.format(dV_analytic)
    np.testing.assert_almost_equal(dR_image, dR_analytic, 5,
                                   err_msg="dRbar Shift from DCR doesn't match analytic formula")
    np.testing.assert_almost_equal(dR_analytic, dR_centroid, 10,
                                   err_msg="direct dRbar calculation doesn't match"
                                           +" ChromaticObject.centroid()")
    np.testing.assert_almost_equal(dV_image, dV_analytic, 5,
                                   err_msg="dV Shift from DCR doesn't match analytic formula")


    t2 = time.time()
    print 'time for %s = %.2f'%(funcname(),t2-t1)

def test_chromatic_seeing_moments():
    """Check that surface brightness distribution second moments obey expected behavior
    for chromatic seeing when comparing stars drawn with different SEDs."""

    import time
    t1 = time.time()

    pixel_scale = 0.0075
    stamp_size = 1024

    # stars are fundamentally delta-fns with an SED
    star1 = galsim.Gaussian(fwhm=1e-8) * bulge_SED
    star2 = galsim.Gaussian(fwhm=1e-8) * disk_SED

    indices = [-0.2, 0.6, 1.0]
    for index in indices:

        mono_PSF = galsim.Gaussian(half_light_radius=PSF_hlr)
        PSF = galsim.ChromaticObject(mono_PSF)
        PSF = PSF.dilate(lambda w:(w/500.0)**index)

        final1 = galsim.Convolve([star1, PSF])
        final2 = galsim.Convolve([star2, PSF])

        image1 = galsim.ImageD(stamp_size, stamp_size, scale=pixel_scale)
        image2 = galsim.ImageD(stamp_size, stamp_size, scale=pixel_scale)

        image1 = final1.drawImage(bandpass, image=image1)
        image2 = final2.drawImage(bandpass, image=image2)

        mom1 = getmoments(image1)
        mom2 = getmoments(image2)
        dr2byr2_image = ((mom1[2]+mom1[3]) - (mom2[2]+mom2[3])) / (mom1[2]+mom1[3])

        # analytic moment differences
        r2_1 = bulge_SED.calculateSeeingMomentRatio(bandpass, alpha=index)
        r2_2 = disk_SED.calculateSeeingMomentRatio(bandpass, alpha=index)
        dr2byr2_analytic = (r2_1 - r2_2) / r2_1

        np.testing.assert_almost_equal(dr2byr2_image, dr2byr2_analytic, 5,
                                       err_msg="Moment Shift from chromatic seeing doesn't"+
                                               " match analytic formula")

        print 'image delta(r^2) / r^2:    {0}'.format(dr2byr2_image)
        print 'analytic delta(r^2) / r^2: {0}'.format(dr2byr2_analytic)

    t2 = time.time()
    print 'time for %s = %.2f'%(funcname(),t2-t1)

def test_monochromatic_filter():
    """Check that ChromaticObject drawn through a very narrow band filter matches analogous
    GSObject.
    """

    import time
    t1 = time.time()

    pixel_scale = 0.2
    stamp_size = 32

    chromatic_gal = galsim.Gaussian(fwhm=1.0) * bulge_SED
    GS_gal = galsim.Gaussian(fwhm=1.0)

    shift_fn = lambda w:(0, ((galsim.dcr.get_refraction(w, zenith_angle) - R500)
                             * (galsim.radians / galsim.arcsec)))
    dilate_fn = lambda wave: (wave/500.0)**(-0.2)
    mono_PSF = galsim.Gaussian(half_light_radius=PSF_hlr)
    mono_PSF = mono_PSF.shear(e1=PSF_e1, e2=PSF_e2)
    chromatic_PSF = galsim.ChromaticObject(mono_PSF)
    chromatic_PSF = chromatic_PSF.dilate(dilate_fn)
    chromatic_PSF = chromatic_PSF.shift(shift_fn)

    chromatic_final = galsim.Convolve([chromatic_gal, chromatic_PSF])

    fws = [350, 475, 625, 750, 875, 975] # approximate ugrizy filter central wavelengths
    for fw in fws:
        chromatic_image = galsim.ImageD(stamp_size, stamp_size, scale=pixel_scale)
        narrow_filter = galsim.Bandpass(galsim.LookupTable([fw-0.01, fw, fw+0.01],
                                                           [1.0, 1.0, 1.0],
                                                           interpolant='linear'))
        chromatic_image = chromatic_final.drawImage(narrow_filter, image=chromatic_image)
        # take out normalization
        chromatic_image /= 0.02
        chromatic_image /= bulge_SED(fw)

        # now do non-chromatic version
        GS_PSF = galsim.Gaussian(half_light_radius=PSF_hlr)
        GS_PSF = GS_PSF.shear(e1=PSF_e1, e2=PSF_e2)
        GS_PSF = GS_PSF.dilate(dilate_fn(fw))
        GS_PSF = GS_PSF.shift(shift_fn(fw))
        GS_final = galsim.Convolve([GS_gal, GS_PSF])
        GS_image = galsim.ImageD(stamp_size, stamp_size, scale=pixel_scale)
        GS_final.drawImage(image=GS_image)
        # plotme(GS_image)

        printval(chromatic_image, GS_image)
        np.testing.assert_array_almost_equal(chromatic_image.array, GS_image.array, 5,
                err_msg="ChromaticObject.drawImage() with monochromatic filter doesn't match"+
                        "GSObject.drawImage()")

        getmoments(GS_image)
    t2 = time.time()
    print 'time for %s = %.2f'%(funcname(),t2-t1)

def test_chromatic_flux():
    """Test that the total drawn flux is equal to the integral of bandpass * sed over wavelength.
    """
    import time
    t1 = time.time()

    pixel_scale = 0.5
    stamp_size = 64

    # stars are fundamentally delta-fns with an SED
    star = galsim.Gaussian(fwhm=1e-8) * bulge_SED
    mono_PSF = galsim.Gaussian(half_light_radius=PSF_hlr)
    PSF = galsim.ChromaticAtmosphere(mono_PSF, base_wavelength=500,
                                     zenith_angle=zenith_angle)

    final = galsim.Convolve([star, PSF])
    image = galsim.ImageD(stamp_size, stamp_size, scale=pixel_scale)
    image2 = galsim.ImageD(stamp_size, stamp_size, scale=pixel_scale)

    final.drawImage(bandpass, image=image)
    ChromaticConvolve_flux = image.array.sum()

    galsim.ChromaticObject.drawImage(final, bandpass, image=image2)
    ChromaticObject_flux = image2.array.sum()

    # analytic integral...
    analytic_flux = bulge_SED.calculateFlux(bandpass)

    printval(image, image2)
    np.testing.assert_almost_equal(ChromaticObject_flux/analytic_flux, 1.0, 4,
                                   err_msg="Drawn ChromaticObject flux doesn't match " +
                                   "analytic prediction")
    np.testing.assert_almost_equal(ChromaticConvolve_flux/analytic_flux, 1.0, 4,
                                   err_msg="Drawn ChromaticConvolve flux doesn't match " +
                                   "analytic prediction")

    # Also check that the flux is okay and the image fairly consistent when using interpolation
    # for the ChromaticAtmosphere.
    PSF = PSF.interpolate(waves=np.linspace(bandpass.blue_limit, bandpass.red_limit, 30))
    final_int = galsim.Convolve([star, PSF])
    image3 = galsim.ImageD(stamp_size, stamp_size, scale=pixel_scale)
    final_int.drawImage(bandpass, image=image3)
    int_flux = image3.array.sum()
    # Be *slight* less stringent in this test given that we did use interpolation.
    printval(image, image3)
    np.testing.assert_almost_equal(
        int_flux/analytic_flux, 1.0, 3,
        err_msg="Drawn ChromaticConvolve flux (interpolated) doesn't match analytic prediction")
    # As an aside, check for appropriate tests of 'integrator' argument.
    try:
        np.testing.assert_raises(TypeError, final_int.drawImage, bandpass,
                                 integrator='midp') # minor misspelling
        np.testing.assert_raises(TypeError, final_int.drawImage, bandpass,
                                 integrator=galsim.integ.midpt)
    except ImportError:
        print 'The assert_raises tests require nose'

    # Go back to no interpolation (this will effect the PSFs that are used below).
    PSF = PSF.original

    # Try adjusting flux to something else.
    target_flux = 2.63
    bulge_SED2 = bulge_SED.withFlux(target_flux, bandpass)
    star2 = galsim.Gaussian(fwhm=1e-8) * bulge_SED2
    final = galsim.Convolve([star2, PSF])
    final.drawImage(bandpass, image=image)
    np.testing.assert_almost_equal(image.array.sum()/target_flux, 1.0, 4,
                                   err_msg="Drawn ChromaticConvolve flux doesn't match " +
                                   "using SED.withFlux()")

    # Use flux_ratio instead.
    flux_ratio = target_flux / analytic_flux
    bulge_SED3 = bulge_SED * flux_ratio
    star3 = galsim.Gaussian(fwhm=1e-8) * bulge_SED3
    final = galsim.Convolve([star3, PSF])
    final.drawImage(bandpass, image=image)
    np.testing.assert_almost_equal(image.array.sum()/target_flux, 1.0, 4,
                                   err_msg="Drawn ChromaticConvolve flux doesn't match " +
                                   "using SED * flux_ratio")

    # This should be equivalent.
    bulge_SED3 = flux_ratio * bulge_SED
    star3 = galsim.Gaussian(fwhm=1e-8) * bulge_SED3
    final = galsim.Convolve([star3, PSF])
    final.drawImage(bandpass, image=image)
    np.testing.assert_almost_equal(image.array.sum()/target_flux, 1.0, 4,
                                   err_msg="Drawn ChromaticConvolve flux doesn't match " +
                                   "using flux_ratio * SED")

    # Use flux_ratio on the chromatic object instead.
    star4 = star * flux_ratio
    final = galsim.Convolve([star4, PSF])
    final.drawImage(bandpass, image=image)
    np.testing.assert_almost_equal(image.array.sum()/target_flux, 1.0, 4,
                                   err_msg="Drawn ChromaticConvolve flux doesn't match " +
                                   "using ChromaticObject * flux_ratio")

    # This should be equivalent.
    star4 = flux_ratio * star
    final = galsim.Convolve([star4, PSF])
    final.drawImage(bandpass, image=image)
    np.testing.assert_almost_equal(image.array.sum()/target_flux, 1.0, 4,
                                   err_msg="Drawn ChromaticConvolve flux doesn't match " +
                                   "using flux_ratio * ChromaticObject")

    # As should this.
    star4 = star.withScaledFlux(flux_ratio)
    final = galsim.Convolve([star4, PSF])
    final.drawImage(bandpass, image=image)
    np.testing.assert_almost_equal(image.array.sum()/target_flux, 1.0, 4,
                                   err_msg="Drawn ChromaticConvolve flux doesn't match " +
                                   "using ChromaticObject.withScaledFlux(flux_ratio)")

    t2 = time.time()
    print 'time for %s = %.2f'%(funcname(),t2-t1)

def test_double_ChromaticSum():
    ''' Test logic section of ChromaticConvolve that splits apart ChromaticSums for the case that
    more than one ChromaticSum's are convolved together.
    '''
    import time
    t1 = time.time()

    a = galsim.Gaussian(fwhm=1.0) * bulge_SED
    b = galsim.Gaussian(fwhm=2.0) * bulge_SED
    c = galsim.Gaussian(fwhm=3.0) * bulge_SED
    d = galsim.Gaussian(fwhm=4.0) * bulge_SED

    image = galsim.ImageD(16, 16, scale=0.2)
    obj = galsim.Convolve(a+b, c+d)
    obj.drawImage(bandpass, image=image, method='no_pixel')

    do_pickle(obj)

    image_a = galsim.ImageD(16, 16, scale=0.2)
    image_b = galsim.ImageD(16, 16, scale=0.2)
    obj_a = galsim.Convolve(a, c+d)
    obj_b = galsim.Convolve(b, c+d)
    obj_a.drawImage(bandpass, image = image_a, method='no_pixel')
    obj_b.drawImage(bandpass, image = image_b, method='no_pixel')
    printval(image, image_a+image_b)

    np.testing.assert_almost_equal(image.array, (image_a+image_b).array, 5,
                                   err_msg="Convolving two ChromaticSums failed")
    t2 = time.time()
    print 'time for %s = %.2f'%(funcname(),t2-t1)

def test_ChromaticConvolution_of_ChromaticConvolution():
    """Check that the __init__ of ChromaticConvolution properly expands arguments that are already
    ChromaticConvolutions.
    """
    import time
    t1 = time.time()

    a = galsim.Gaussian(fwhm=1.0) * bulge_SED
    b = galsim.Gaussian(fwhm=2.0) * bulge_SED
    c = galsim.Gaussian(fwhm=3.0) * bulge_SED
    d = galsim.Gaussian(fwhm=4.0) * bulge_SED

    e = galsim.Convolve(a, b)
    f = galsim.Convolve(c, d)
    g = galsim.Convolve(e, f)
    if any([not isinstance(h, galsim.Chromatic) for h in g.objlist]):
        raise AssertionError("ChromaticConvolution did not expand ChromaticConvolution argument")

    t2 = time.time()
    print 'time for %s = %.2f'%(funcname(),t2-t1)

def test_ChromaticAutoConvolution():
    import time
    t1 = time.time()

    a = galsim.Gaussian(fwhm=1.0) * bulge_SED
    im1 = galsim.ImageD(32, 32, scale=0.2)
    im2 = galsim.ImageD(32, 32, scale=0.2)
    b = galsim.Convolve(a, a)
    b.drawImage(bandpass, image=im1, method='no_pixel')
    c = galsim.AutoConvolve(a)
    c.drawImage(bandpass, image=im2, method='no_pixel')
    printval(im1, im2)
    np.testing.assert_array_almost_equal(im1.array, im2.array, 5,
                                         "ChromaticAutoConvolution(a) not equal to "
                                         "ChromaticConvolution(a,a)")

    # Check flux scaling
    flux = im2.array.sum()
    im2 = (c * 2.).drawImage(bandpass, image=im2, method='no_pixel')
    flux2 = im2.array.sum()
    np.testing.assert_array_almost_equal(
        flux2, 2.*flux, 5,
        err_msg="ChromaticAutoConvolution * 2 resulted in wrong flux.")

    t2 = time.time()
    print 'time for %s = %.2f'%(funcname(),t2-t1)

def test_ChromaticAutoCorrelation():
    import time
    t1 = time.time()

    a = galsim.Gaussian(fwhm=1.0) * bulge_SED
    im1 = galsim.ImageD(32, 32, scale=0.2)
    im2 = galsim.ImageD(32, 32, scale=0.2)
    b = galsim.Convolve(a, a.rotate(180.0 * galsim.degrees))
    b.drawImage(bandpass, image=im1, method='no_pixel')
    c = galsim.AutoCorrelate(a)
    c.drawImage(bandpass, image=im2, method='no_pixel')
    printval(im1, im2)
    np.testing.assert_array_almost_equal(im1.array, im2.array, 5,
                                         "ChromaticAutoCorrelate(a) not equal to "
                                         "ChromaticConvolution(a,a.rotate(180.0*galsim.degrees)")

    # Check flux scaling
    flux = im2.array.sum()
    im2 = (c * 2.).drawImage(bandpass, image=im2, method='no_pixel')
    flux2 = im2.array.sum()
    np.testing.assert_array_almost_equal(
        flux2, 2.*flux, 5,
        err_msg="ChromaticAutoCorrelation * 2 resulted in wrong flux.")

    t2 = time.time()
    print 'time for %s = %.2f'%(funcname(),t2-t1)

def test_ChromaticObject_expand():
    import time
    t1 = time.time()
    im1 = galsim.ImageD(32, 32, scale=0.2)
    im2 = galsim.ImageD(32, 32, scale=0.2)
    a = galsim.Gaussian(fwhm=1.0).expand(1.1) * bulge_SED
    b = (galsim.Gaussian(fwhm=1.0) * bulge_SED).expand(1.1)

    a.drawImage(bandpass, image=im1, method='no_pixel')
    b.drawImage(bandpass, image=im2, method='no_pixel')
    printval(im1, im2)
    np.testing.assert_array_almost_equal(im1.array, im2.array, 5,
                                         "ChromaticObject.expand not equal to Chromatic.expand")

    do_pickle(a)
    do_pickle(b)

    # Check flux scaling
    flux = im2.array.sum()
    im2 = (b * 2.).drawImage(bandpass, image=im2, method='no_pixel')
    flux2 = im2.array.sum()
    np.testing.assert_array_almost_equal(
        flux2, 2.*flux, 5,
        err_msg="expanded ChromaticObject * 2 resulted in wrong flux.")

    # Test the wavelength-dependent expansion option
    pixel_scale = 0.3
    sigma = 1.7
    gal = galsim.Gaussian(sigma=sigma, flux=132)
    im0 = gal.drawImage(scale=pixel_scale, dtype=float, method='no_pixel')
    # Initial mxx,myy should be sigma**2 in units of arcsec^2, so (sigma/pixel_scale)**2 in pix.
    mx, my, mxx, myy, mxy = getmoments(im0)
    np.testing.assert_almost_equal(mxx / (sigma/pixel_scale)**2, 1.0, decimal=4)
    np.testing.assert_almost_equal(myy / (sigma/pixel_scale)**2, 1.0, decimal=4)
    np.testing.assert_almost_equal(mxy / (sigma/pixel_scale)**2, 0, decimal=4)

    # First a very simple case with no actual wavelength dependence, but using the
    # functional syntax.
    gal1 = galsim.ChromaticObject(gal).expand(lambda w: 1.2)
    # Use a simple bandpass so we can do the integral below analytically
    bp = galsim.Bandpass(lambda w: 1. - 0.12*(w-600)**2/100**2, 500, 700)
    im1 = gal1.drawImage(bp, scale=pixel_scale, dtype=float, method='no_pixel')
    mx, my, mxx, myy, mxy = getmoments(im1)
    print 'simple growth = ',mxx/(sigma/pixel_scale)**2, 1.2**2
    np.testing.assert_almost_equal(mxx / (sigma/pixel_scale)**2, 1.2**2, decimal=4)
    np.testing.assert_almost_equal(myy / (sigma/pixel_scale)**2, 1.2**2, decimal=4)
    np.testing.assert_almost_equal(mxy / (sigma/pixel_scale)**2, 0, decimal=4)

    # Use an expansion that varies quadratically within the range 500-700
    expansion = lambda w: 1.2 + 0.11*(w-600)/100 - 0.36*(w-600)**2/100**2
    gal2 = galsim.ChromaticObject(gal).expand(expansion)
    im2 = gal2.drawImage(bp, scale=pixel_scale, dtype=float, method='no_pixel')
    # The test here relies on linearity to swap the order of the integrals.
    # The getmoments test is essentially int(dxdy x^2 int(dlambda I(x,y,lam) F(lam)))
    # But we can swap the order of the integrals to do int(dlambda int(dxdy x^2 I(x,y,lam) F(lam)))
    # and do the integral analytically.
    mx, my, mxx, myy, mxy = getmoments(im2)
    # Now the analytic integral:
    # mxx = int(dlam (sigma * expansion)**2 * expansion**2 * F(lam))
    #         / int(dlam expansion**2 * F(lam))
    # Note that two of the factors of expansion are the flux scaling.  The other two, only in the
    # numerator, are the size scaling.
    #     = sigma**2 * int(dt (1.2 + 0.11 t - 0.36 t**2)**4 (1 - 0.12 t**2), t=-1..1)
    #            / int(dt (1.2 + 0.11 t - 0.36 t**2)**2 (1 - 0.12 t**2), t=-1..1)
    #     = sigma**2 * 1.243224162 (according to Maple)
    growth_factor = galsim.integ.int1d(lambda w: expansion(w)**4 * bp(w),500,700)
    growth_factor /= galsim.integ.int1d(lambda w: expansion(w)**2 * bp(w),500,700)
    print 'growth factor = ',mxx/(sigma/pixel_scale)**2, growth_factor
    np.testing.assert_almost_equal(mxx / (sigma/pixel_scale)**2, growth_factor, decimal=4)
    np.testing.assert_almost_equal(myy / (sigma/pixel_scale)**2, growth_factor, decimal=4)
    np.testing.assert_almost_equal(mxy / (sigma/pixel_scale)**2, 0, decimal=4)

    # Repeat using transform rather than expand
    gal3 = galsim.ChromaticObject(gal).transform(expansion, 0.0, 0.0, expansion)
    im3 = gal3.drawImage(bp, scale=pixel_scale, dtype=float, method='no_pixel')
    mx, my, mxx, myy, mxy = getmoments(im3)
    np.testing.assert_almost_equal(mxx / (sigma/pixel_scale)**2, growth_factor, decimal=4)
    np.testing.assert_almost_equal(myy / (sigma/pixel_scale)**2, growth_factor, decimal=4)
    np.testing.assert_almost_equal(mxy / (sigma/pixel_scale)**2, 0, decimal=4)

    # Repeat using magnify
    gal4 = galsim.ChromaticObject(gal).magnify(lambda w: expansion(w)**2)
    im4 = gal4.drawImage(bp, scale=pixel_scale, dtype=float, method='no_pixel')
    mx, my, mxx, myy, mxy = getmoments(im4)
    np.testing.assert_almost_equal(mxx / (sigma/pixel_scale)**2, growth_factor, decimal=4)
    np.testing.assert_almost_equal(myy / (sigma/pixel_scale)**2, growth_factor, decimal=4)
    np.testing.assert_almost_equal(mxy / (sigma/pixel_scale)**2, 0, decimal=4)

    # Repeat using lens
    gal5 = galsim.ChromaticObject(gal).lens(0., 0., lambda w: expansion(w)**2)
    im5 = gal5.drawImage(bp, scale=pixel_scale, dtype=float, method='no_pixel')
    mx, my, mxx, myy, mxy = getmoments(im5)
    np.testing.assert_almost_equal(mxx / (sigma/pixel_scale)**2, growth_factor, decimal=4)
    np.testing.assert_almost_equal(myy / (sigma/pixel_scale)**2, growth_factor, decimal=4)
    np.testing.assert_almost_equal(mxy / (sigma/pixel_scale)**2, 0, decimal=4)

    # Dilate isn't quite the same, since it doesn't have the extra flux factor:
    gal5 = galsim.ChromaticObject(gal).dilate(expansion)
    im5 = gal5.drawImage(bp, scale=pixel_scale, dtype=float, method='no_pixel')
    mx, my, mxx, myy, mxy = getmoments(im5)
    dilate_growth_factor = galsim.integ.int1d(lambda w: expansion(w)**2 * bp(w),500,700)
    dilate_growth_factor /= galsim.integ.int1d(lambda w: bp(w),500,700)
    print 'dilate_growth factor = ',mxx/(sigma/pixel_scale)**2, dilate_growth_factor
    np.testing.assert_almost_equal(mxx / (sigma/pixel_scale)**2, dilate_growth_factor, decimal=4)
    np.testing.assert_almost_equal(myy / (sigma/pixel_scale)**2, dilate_growth_factor, decimal=4)
    np.testing.assert_almost_equal(mxy / (sigma/pixel_scale)**2, 0, decimal=4)

    t2 = time.time()
    print 'time for %s = %.2f'%(funcname(),t2-t1)

def test_ChromaticObject_rotate():
    import time
    t1 = time.time()
    im1 = galsim.ImageD(32, 32, scale=0.2)
    im2 = galsim.ImageD(32, 32, scale=0.2)
    a = (galsim.Gaussian(fwhm=1.0)
         .shear(eta=0.1, beta=0 * galsim.degrees)
         .rotate(1.1 * galsim.radians)) * bulge_SED
    b = (((galsim.Gaussian(fwhm=1.0)
           .shear(eta=0.1, beta=0 * galsim.degrees)) * bulge_SED)
           .rotate(1.1 * galsim.radians))

    a.drawImage(bandpass, image=im1, method='no_pixel')
    b.drawImage(bandpass, image=im2, method='no_pixel')
    printval(im1, im2)
    np.testing.assert_array_almost_equal(im1.array, im2.array, 5,
                                         "ChromaticObject.rotate not equal to Chromatic.rotate")

    do_pickle(a)
    do_pickle(b)

    # Check flux scaling
    flux = im2.array.sum()
    im2 = (b * 2.).drawImage(bandpass, image=im2, method='no_pixel')
    flux2 = im2.array.sum()
    np.testing.assert_array_almost_equal(
        flux2, 2.*flux, 5,
        err_msg="rotated ChromaticObject * 2 resulted in wrong flux.")

    # Test the wavelength-dependent rotation option
    pixel_scale = 0.3
    sigma = 1.7
    gal = galsim.Gaussian(sigma=sigma, flux=132).shear(e1=0.3)
    im0 = gal.drawImage(scale=pixel_scale, dtype=float, method='no_pixel')
    # Initial distortion should be (e1,0).
    mx, my, mxx, myy, mxy = getmoments(im0)
    print 'e1 = ',(mxx-myy)/(mxx+myy)
    print 'e2 = ',(2*mxy)/(mxx+myy)
    print '(mxx+myy)/sigma^2 = ',(mxx+myy)/(sigma/pixel_scale)**2
    print '2/(mxx+myy)/sigma^2 = ',2./((mxx+myy)/(sigma/pixel_scale)**2)
    print 'sqrt(1-0.3**2) = ',np.sqrt(1.-0.3**2)
    fact = np.sqrt(1.-0.3**2)
    np.testing.assert_almost_equal((mxx-myy)/(mxx+myy), 0.3, decimal=4)
    np.testing.assert_almost_equal((2*mxy)/(mxx+myy), 0.0, decimal=4)
    np.testing.assert_almost_equal(mxx / (sigma/pixel_scale)**2, (1+0.3)/fact, decimal=4)
    np.testing.assert_almost_equal(myy / (sigma/pixel_scale)**2, (1-0.3)/fact, decimal=4)
    np.testing.assert_almost_equal(mxy / (sigma/pixel_scale)**2, 0, decimal=4)

    # First a very simple case with no actual wavelength dependence, but using the
    # functional syntax.
    gal1 = galsim.ChromaticObject(gal).rotate(lambda w: 0.4 * galsim.radians)
    bp = galsim.Bandpass(lambda w: 1. - 0.12*(w-600)**2/100**2, 500, 700)
    im1 = gal1.drawImage(bp, scale=pixel_scale, dtype=float, method='no_pixel')
    mx, my, mxx, myy, mxy = getmoments(im1)
    print 'simple angle = ',(np.arctan2(2.*mxy,mxx-myy)/2.), 0.4
    np.testing.assert_almost_equal((mxx-myy)/(mxx+myy), 0.3*np.cos(2.*0.4), decimal=4)
    np.testing.assert_almost_equal((2*mxy)/(mxx+myy), 0.3*np.sin(2.*0.4), decimal=4)
    rot_e1 = 0.3*np.cos(2.*0.4)
    rot_e2 = 0.3*np.sin(2.*0.4)
    np.testing.assert_almost_equal(mxx / (sigma/pixel_scale)**2, (1+rot_e1)/fact, decimal=4)
    np.testing.assert_almost_equal(myy / (sigma/pixel_scale)**2, (1-rot_e1)/fact, decimal=4)
    np.testing.assert_almost_equal(mxy / (sigma/pixel_scale)**2, rot_e2/fact, decimal=4)

    # Use a rotation that varies quadratically within the range 500-700
    rotation = lambda w: (0.4 + 0.11*(w-600)/100 - 0.36*(w-600)**2/100**2) * galsim.radians
    gal2 = galsim.ChromaticObject(gal).rotate(rotation)
    im2 = gal2.drawImage(bp, scale=pixel_scale, dtype=float, method='no_pixel')
    mx, my, mxx, myy, mxy = getmoments(im2)
    # The analytic integrals:
    # mxx = int(dw (1 + 0.3 cos(2theta(w))) * F(w))  / int(dw F(w))
    # myy = int(dw (1 - 0.3 cos(2theta(w))) * F(w))  / int(dw F(w))
    # mxy = int(dw 0.3 sin(2theta(w)) * F(w))  / int(dw F(w))
    rot_mxx = galsim.integ.int1d(lambda w: (1.+0.3*np.cos(2*rotation(w).rad())) * bp(w),500,700)
    rot_mxx /= galsim.integ.int1d(lambda w: bp(w),500,700)
    rot_myy = galsim.integ.int1d(lambda w: (1.-0.3*np.cos(2*rotation(w).rad())) * bp(w),500,700)
    rot_myy /= galsim.integ.int1d(lambda w: bp(w),500,700)
    rot_mxy = galsim.integ.int1d(lambda w: (0.3*np.sin(2*rotation(w).rad())) * bp(w),500,700)
    rot_mxy /= galsim.integ.int1d(lambda w: bp(w),500,700)
    rot_e1 = (rot_mxx-rot_myy)/(rot_mxx+rot_myy)
    rot_e2 = (2*rot_mxy)/(rot_mxx+rot_myy)
    print 'rot e1 = ',(mxx-myy)/(mxx+myy), rot_e1
    print 'rot e2 = ',(2*mxy)/(mxx+myy), rot_e2
    print 'rot e = ',np.sqrt(rot_e1**2+rot_e2**2)
    np.testing.assert_almost_equal((mxx-myy)/(mxx+myy), rot_e1, decimal=4)
    np.testing.assert_almost_equal((2*mxy)/(mxx+myy), rot_e2, decimal=4)
    np.testing.assert_almost_equal(mxx / (sigma/pixel_scale)**2, (1+rot_e1)/fact, decimal=4)
    np.testing.assert_almost_equal(myy / (sigma/pixel_scale)**2, (1-rot_e1)/fact, decimal=4)
    np.testing.assert_almost_equal(mxy / (sigma/pixel_scale)**2, rot_e2/fact, decimal=4)

    # Repeat using transform rather than rotate
    gal3 = galsim.ChromaticObject(gal).transform(
                lambda w: np.cos(rotation(w).rad()),
                lambda w: -np.sin(rotation(w).rad()),
                lambda w: np.sin(rotation(w).rad()),
                lambda w: np.cos(rotation(w).rad()) )
    im3 = gal3.drawImage(bp, scale=pixel_scale, dtype=float, method='no_pixel')
    mx, my, mxx, myy, mxy = getmoments(im3)
    np.testing.assert_almost_equal((mxx-myy)/(mxx+myy), rot_e1, decimal=4)
    np.testing.assert_almost_equal((2*mxy)/(mxx+myy), rot_e2, decimal=4)
    np.testing.assert_almost_equal(mxx / (sigma/pixel_scale)**2, (1+rot_e1)/fact, decimal=4)
    np.testing.assert_almost_equal(myy / (sigma/pixel_scale)**2, (1-rot_e1)/fact, decimal=4)
    np.testing.assert_almost_equal(mxy / (sigma/pixel_scale)**2, rot_e2/fact, decimal=4)

    t2 = time.time()
    print 'time for %s = %.2f'%(funcname(),t2-t1)

def test_ChromaticObject_shear():
    import time
    t1 = time.time()
    im1 = galsim.ImageD(32, 32, scale=0.2)
    im2 = galsim.ImageD(32, 32, scale=0.2)
    shear = galsim.Shear(g1=0.1, g2=0.1)
    a = galsim.Gaussian(fwhm=1.0).shear(shear) * bulge_SED
    b = (galsim.Gaussian(fwhm=1.0) * bulge_SED).shear(shear)

    a.drawImage(bandpass, image=im1, method='no_pixel')
    b.drawImage(bandpass, image=im2, method='no_pixel')
    printval(im1, im2)
    np.testing.assert_array_almost_equal(im1.array, im2.array, 5,
                                         "ChromaticObject.shear not equal to Chromatic.shear")

    do_pickle(a)
    do_pickle(b)

    # Check flux scaling
    flux = im2.array.sum()
    im2 = (b * 2.).drawImage(bandpass, image=im2, method='no_pixel')
    flux2 = im2.array.sum()
    np.testing.assert_array_almost_equal(
        flux2, 2.*flux, 5,
        err_msg="rotated ChromaticObject * 2 resulted in wrong flux.")

    # Test the wavelength-dependent shear option
    pixel_scale = 0.3
    sigma = 1.7
    gal = galsim.Gaussian(sigma=sigma, flux=132)
    im0 = gal.drawImage(scale=pixel_scale, dtype=float, method='no_pixel')
    # Initial distortion should be (0,0).
    mx, my, mxx, myy, mxy = getmoments(im0)
    print 'mxx+myy = ',mxx+myy
    print 'e1 = ',(mxx-myy)/(mxx+myy)
    print 'e2 = ',(2*mxy)/(mxx+myy)
    np.testing.assert_almost_equal((mxx-myy)/(mxx+myy), 0.0, decimal=4)
    np.testing.assert_almost_equal((2*mxy)/(mxx+myy), 0.0, decimal=4)
    np.testing.assert_almost_equal(mxx / (sigma/pixel_scale)**2, 1.0, decimal=4)
    np.testing.assert_almost_equal(myy / (sigma/pixel_scale)**2, 1.0, decimal=4)
    np.testing.assert_almost_equal(mxy / (sigma/pixel_scale)**2, 0.0, decimal=4)

    # First a very simple case with no actual wavelength dependence, but using the
    # functional syntax.
    gal1 = galsim.ChromaticObject(gal).shear(lambda w: galsim.Shear(e1=0.23, e2=0.13))
    bp = galsim.Bandpass(lambda w: 1. - 0.12*(w-600)**2/100**2, 500, 700)
    im1 = gal1.drawImage(bp, scale=pixel_scale, dtype=float, method='no_pixel')
    mx, my, mxx, myy, mxy = getmoments(im1)
    print 'mxx+myy = ',mxx+myy
    print 'simple e1 = ',(mxx-myy)/(mxx+myy)
    print 'simple e2 = ',(2.*mxy)/(mxx+myy)
    np.testing.assert_almost_equal((mxx-myy)/(mxx+myy), 0.23, decimal=4)
    np.testing.assert_almost_equal((2*mxy)/(mxx+myy), 0.13, decimal=4)
    fact = np.sqrt(1. - 0.23**2 - 0.13**2)
    np.testing.assert_almost_equal(mxx / (sigma/pixel_scale)**2, (1+0.23)/fact, decimal=4)
    np.testing.assert_almost_equal(myy / (sigma/pixel_scale)**2, (1-0.23)/fact, decimal=4)
    np.testing.assert_almost_equal(mxy / (sigma/pixel_scale)**2, 0.13/fact, decimal=4)

    # Use a shear that varies quadratically within the range 500-700
    shear = lambda w: galsim.Shear(e1=0.23 + 0.11*(w-600)/100 - 0.36*(w-600)**2/100**2,
                                   e2=0.13 + 0.19*(w-600)/100 - 0.09*(w-600)**2/100**2)
    gal2 = galsim.ChromaticObject(gal).shear(shear)
    im2 = gal2.drawImage(bp, scale=pixel_scale, dtype=float, method='no_pixel')
    mx, my, mxx, myy, mxy = getmoments(im2)
    # The analytic integrals:
    # mxx = int(dw (1 + e1(w))/sqrt(1-e(w)^2) * F(w))  / int(dw F(w))
    # myy = int(dw (1 - e1(w))/sqrt(1-e(w)^2) * F(w))  / int(dw F(w))
    # mxy = int(dw e2(w)/sqrt(1-e(w)^2) * F(w))  / int(dw F(w))
    sh_mxx = galsim.integ.int1d(lambda w: (1.+shear(w).e1)/np.sqrt(1.-shear(w).e**2)*bp(w),500,700)
    sh_mxx /= galsim.integ.int1d(lambda w: bp(w),500,700)
    sh_myy = galsim.integ.int1d(lambda w: (1.-shear(w).e1)/np.sqrt(1.-shear(w).e**2)*bp(w),500,700)
    sh_myy /= galsim.integ.int1d(lambda w: bp(w),500,700)
    sh_mxy = galsim.integ.int1d(lambda w: shear(w).e2/np.sqrt(1.-shear(w).e**2)*bp(w),500,700)
    sh_mxy /= galsim.integ.int1d(lambda w: bp(w),500,700)
    print 'mxx+myy = ',mxx+myy
    print 'shear e1 = ',(mxx-myy)/(mxx+myy), (sh_mxx-sh_myy)/(sh_mxx+sh_myy)
    print 'shear e2 = ',(2*mxy)/(mxx+myy), (2*sh_mxy)/(sh_mxx+sh_myy)
    np.testing.assert_almost_equal((mxx-myy)/(mxx+myy), (sh_mxx-sh_myy)/(sh_mxx+sh_myy), decimal=4)
    np.testing.assert_almost_equal((2*mxy)/(mxx+myy), (2*sh_mxy)/(sh_mxx+sh_myy), decimal=4)
    np.testing.assert_almost_equal(mxx / (sigma/pixel_scale)**2, sh_mxx, decimal=4)
    np.testing.assert_almost_equal(myy / (sigma/pixel_scale)**2, sh_myy, decimal=4)
    np.testing.assert_almost_equal(mxy / (sigma/pixel_scale)**2, sh_mxy, decimal=4)

    # Repeat using transform rather than shear
    gal3 = galsim.ChromaticObject(gal).transform(
                lambda w: (1.+shear(w).g1)/np.sqrt(1.-shear(w).g**2),
                lambda w: shear(w).g2/np.sqrt(1.-shear(w).g**2),
                lambda w: shear(w).g2/np.sqrt(1.-shear(w).g**2),
                lambda w: (1.-shear(w).g1)/np.sqrt(1.-shear(w).g**2) )
    im3 = gal3.drawImage(bp, scale=pixel_scale, dtype=float, method='no_pixel')
    mx, my, mxx, myy, mxy = getmoments(im3)
    np.testing.assert_almost_equal((mxx-myy)/(mxx+myy), (sh_mxx-sh_myy)/(sh_mxx+sh_myy), decimal=4)
    np.testing.assert_almost_equal((2*mxy)/(mxx+myy), (2*sh_mxy)/(sh_mxx+sh_myy), decimal=4)
    np.testing.assert_almost_equal(mxx / (sigma/pixel_scale)**2, sh_mxx, decimal=4)
    np.testing.assert_almost_equal(myy / (sigma/pixel_scale)**2, sh_myy, decimal=4)
    np.testing.assert_almost_equal(mxy / (sigma/pixel_scale)**2, sh_mxy, decimal=4)

    # Repeat using lens
    gal4 = galsim.ChromaticObject(gal).lens(lambda w: shear(w).g1, lambda w: shear(w).g2, 1.)
    im4 = gal4.drawImage(bp, scale=pixel_scale, dtype=float, method='no_pixel')
    mx, my, mxx, myy, mxy = getmoments(im4)
    np.testing.assert_almost_equal((mxx-myy)/(mxx+myy), (sh_mxx-sh_myy)/(sh_mxx+sh_myy), decimal=4)
    np.testing.assert_almost_equal((2*mxy)/(mxx+myy), (2*sh_mxy)/(sh_mxx+sh_myy), decimal=4)
    np.testing.assert_almost_equal(mxx / (sigma/pixel_scale)**2, sh_mxx, decimal=4)
    np.testing.assert_almost_equal(myy / (sigma/pixel_scale)**2, sh_myy, decimal=4)
    np.testing.assert_almost_equal(mxy / (sigma/pixel_scale)**2, sh_mxy, decimal=4)

    t2 = time.time()
    print 'time for %s = %.2f'%(funcname(),t2-t1)

def test_ChromaticObject_shift():
    import time
    t1 = time.time()
    im1 = galsim.ImageD(32, 32, scale=0.2)
    im2 = galsim.ImageD(32, 32, scale=0.2)
    shift = (0.1, 0.3)
    a = galsim.Gaussian(fwhm=1.0).shift(shift) * bulge_SED
    b = (galsim.Gaussian(fwhm=1.0) * bulge_SED).shift(shift)

    a.drawImage(bandpass, image=im1, method='no_pixel')
    b.drawImage(bandpass, image=im2, method='no_pixel')
    printval(im1, im2)
    np.testing.assert_array_almost_equal(im1.array, im2.array, 5,
                                         "ChromaticObject.shift not equal to Chromatic.shift")

    do_pickle(a)
    do_pickle(b)

    # Check flux scaling
    flux = im2.array.sum()
    im2 = (b * 2.).drawImage(bandpass, image=im2, method='no_pixel')
    flux2 = im2.array.sum()
    np.testing.assert_array_almost_equal(
        flux2, 2.*flux, 5,
        err_msg="rotated ChromaticObject * 2 resulted in wrong flux.")

    t2 = time.time()
    print 'time for %s = %.2f'%(funcname(),t2-t1)

def test_ChromaticObject_compound_affine_transformation():
    """ Check that making a (separable) object chromatic before a bunch of transformations is
    equivalent to making it chromatic after a bunch of transformations.
    """
    import time
    t1 = time.time()
    im1 = galsim.ImageD(32, 32, scale=0.2)
    im2 = galsim.ImageD(32, 32, scale=0.2)
    shear = galsim.Shear(eta=1.0, beta=0.3*galsim.radians)
    scale = 1.1
    theta = 0.1 * galsim.radians
    shift = (0.1, 0.3)

    a = galsim.Gaussian(fwhm=1.0)
    a = a.shear(shear).shift(shift).rotate(theta).dilate(scale)
    a = a.shear(shear).shift(shift).rotate(theta).expand(scale)
    a = a.lens(g1=0.1, g2=0.1, mu=1.1).shift(shift).rotate(theta).magnify(scale)
    a = a * bulge_SED

    b = galsim.Gaussian(fwhm=1.0) * bulge_SED
    b = b.shear(shear).shift(shift).rotate(theta).dilate(scale)
    b = b.shear(shear).shift(shift).rotate(theta).expand(scale)
    b = b.lens(g1=0.1, g2=0.1, mu=1.1).shift(shift).rotate(theta).magnify(scale)

    a.drawImage(bandpass, image=im1, method='no_pixel')
    b.drawImage(bandpass, image=im2, method='no_pixel')
    printval(im1, im2)
    np.testing.assert_array_almost_equal(im1.array, im2.array, 5,
                                         "ChromaticObject affine transformation not equal to "
                                         "GSObject affine transformation")

    do_pickle(a)
    do_pickle(b)

    # Check flux scaling
    flux = im2.array.sum()
    im2 = (b * 2.).drawImage(bandpass, image=im2, method='no_pixel')
    flux2 = im2.array.sum()
    np.testing.assert_array_almost_equal(
        flux2, 2.*flux, 5,
        err_msg="transformed ChromaticObject * 2 resulted in wrong flux.")

    t2 = time.time()
    print 'time for %s = %.2f'%(funcname(),t2-t1)

def test_analytic_integrator():
    """Test that the analytic (i.e., not sampled) versions of SEDs and Bandpasses produce the
    same results as the sampled versions.
    """
    import time
    t1 = time.time()
    psf = galsim.Moffat(fwhm=1.0, beta=2.7)

    # pure analytic
    band1 = galsim.Bandpass('1', blue_limit=500, red_limit=750)
    sed1 = galsim.SED('wave**1.1', flux_type='fphotons').withFluxDensity(1.0, 500)
    gal1 = galsim.Gaussian(fwhm=1.0) * sed1
    final1 = galsim.Convolve(gal1, psf)
    image1 = galsim.ImageD(32, 32, scale=0.2)
    assert len(band1.wave_list) == 0
    assert len(sed1.wave_list) == 0
    final1.drawImage(band1, image=image1)

    # try making the SED sampled
    band2 = band1
    N = 250 # default N for ContinuousIntegrator
    h = (band2.red_limit*1.0 - band2.blue_limit)/N
    x = [band2.blue_limit + h * i for i in range(N+1)]
    # make a sampled SED
    sed2 = galsim.SED(galsim.LookupTable(x, sed1(x), interpolant='linear'),
                      flux_type='fphotons')
    gal2 = galsim.Gaussian(fwhm=1.0) * sed2
    final2 = galsim.Convolve(gal2, psf)
    image2 = galsim.ImageD(32, 32, scale=0.2)
    assert len(band2.wave_list) == 0
    assert len(sed2.wave_list) != 0
    final2.drawImage(band1, image=image2)

    # try making the Bandpass sampled
    sed3 = sed1
    band3 = galsim.Bandpass(galsim.LookupTable(x, band1(x), interpolant='linear'))
    gal3 = galsim.Gaussian(fwhm=1.0) * sed3
    final3 = galsim.Convolve(gal3, psf)
    image3 = galsim.ImageD(32, 32, scale=0.2)
    assert len(band3.wave_list) != 0
    assert len(sed3.wave_list) == 0
    final3.drawImage(band3, image=image3)

    printval(image1, image2)
    np.testing.assert_array_almost_equal(image1.array, image2.array, 5,
                                         "Analytic integrator doesn't match sample integrator")
    printval(image1, image3)
    np.testing.assert_array_almost_equal(image1.array, image3.array, 5,
                                         "Analytic integrator doesn't match sample integrator")
    t2 = time.time()
    print 'time for %s = %.2f'%(funcname(),t2-t1)

def test_gsparam():
    """Check that gsparams actually gets processed by ChromaticObjects.
    """
    import time
    t1 = time.time()

    # Setting maximum_fft_size this low causes an exception to be raised for GSObjects, so
    # make sure it does for ChromaticObjects too, thereby assuring that gsparams is really
    # getting properly forwarded through the internals of ChromaticObjects.
    gsparams = galsim.GSParams(maximum_fft_size=16)
    gal = galsim.ChromaticObject(galsim.Gaussian(fwhm=1, gsparams=gsparams))
    try:
        np.testing.assert_raises(RuntimeError, gal.drawImage, bandpass)
    except ImportError:
        print 'The assert_raises tests require nose'

    # Repeat, putting the gsparams argument in after the ChromaticObject constructor.
    gal = galsim.ChromaticObject(galsim.Gaussian(fwhm=1))
    psf = galsim.Gaussian(sigma=0.4)
    final = galsim.Convolve([gal, psf], gsparams=gsparams)
    try:
        np.testing.assert_raises(RuntimeError, final.drawImage, bandpass)
    except ImportError:
        print 'The assert_raises tests require nose'

    do_pickle(final)

    t2 = time.time()
    print 'time for %s = %.2f'%(funcname(),t2-t1)

def test_separable_ChromaticSum():
    """ Test that ChromaticSum separable profile grouping.
    """
    import time
    t1 = time.time()
    psf = galsim.Gaussian(fwhm=1)
    gal1 = galsim.Gaussian(fwhm=1)
    gal2 = galsim.Gaussian(fwhm=1.1)
    gal3 = galsim.Gaussian(fwhm=1.2)

    # check that 2 summands with same SED make a separable sum.
    gal = gal1 * bulge_SED + gal2 * bulge_SED
    img1 = galsim.ImageD(32, 32, scale=0.2)
    if not gal.separable:
        raise AssertionError("failed to identify separable ChromaticSum")

    # check that drawing the profile works as expected
    final = galsim.Convolve(gal, psf)
    final.drawImage(bandpass, image=img1)

    img2 = galsim.ImageD(32, 32, scale=0.2)
    component1 = galsim.Convolve(gal1*bulge_SED, psf)
    component1.drawImage(bandpass, image=img2)
    component2 = galsim.Convolve(gal2*bulge_SED, psf)
    component2.drawImage(bandpass, image=img2, add_to_image=True)

    np.testing.assert_array_almost_equal(img1.array, img2.array, 5,
                                         "separable ChromaticSum not correctly drawn")

    do_pickle(final)

    # Check flux scaling
    img3 = galsim.ImageD(32, 32, scale=0.2)
    flux = img1.array.sum()
    img3 = (final * 2).drawImage(bandpass, image=img3)
    flux2 = img3.array.sum()
    np.testing.assert_array_almost_equal(
        flux2, 2.*flux, 5,
        err_msg="ChromaticConvolution containing separable ChromaticSum * 2 resulted in wrong flux.")

    final2 = galsim.Convolve(gal * 2, psf)
    img3 = final2.drawImage(bandpass, image=img3)
    flux2 = img3.array.sum()
    np.testing.assert_array_almost_equal(
        flux2, 2.*flux, 5,
        err_msg="separable ChromaticSum * 2 resulted in wrong flux.")

    do_pickle(final2)

    # check that 3 summands, 2 with the same SED, 1 with a different SED, make an
    # inseparable sum.
    gal = galsim.Add(gal1 * bulge_SED, gal2 * bulge_SED, gal3 * disk_SED)
    if gal.separable:
        raise AssertionError("failed to identify inseparable ChromaticSum")
    # check that its objlist contains a separable Chromatic and a separable ChromaticSum
    types = dict((o.__class__, o) for o in gal.objlist)
    if galsim.Chromatic not in types or galsim.ChromaticSum not in types:
        raise AssertionError("failed to process list of objects with repeated SED")

    # check that drawing the profile works as expected
    final = galsim.Convolve(gal, psf)
    final.drawImage(bandpass, image=img1)

    do_pickle(final)

    component3 = galsim.Convolve(gal3*disk_SED, psf)
    component3.drawImage(bandpass, image=img2, add_to_image=True)

    np.testing.assert_array_almost_equal(img1.array, img2.array, 5,
                                         "inseparable ChromaticSum not correctly drawn")

    do_pickle(component3)

    t2 = time.time()
    print 'time for %s = %.2f'%(funcname(),t2-t1)

def test_centroid():
    """Test the ChromaticObject.centroid function."""
    import time
    t1 = time.time()

    sed = galsim.SED('wave', flux_type='fphotons')
    bp = galsim.Bandpass('wave', blue_limit=0, red_limit=1)
    shift_fn = lambda w: (w, 0)
    gal = sed * galsim.Gaussian(fwhm=1)
    gal = gal.shift(shift_fn)
    # The sed and bandpass each contribute a factor of wavelength to the flux integrand of the
    # galaxy.  The shift function contributes an additional factor of wavelength to the x-centroid
    # integrand.  The end result is that the x-centroid should be:
    # int(w^3, 0, 1) / int(w^2, 0, 1) = (1/4)/(1/3) = 3/4.
    centroid = gal.centroid(bp)
    np.testing.assert_almost_equal(centroid.x, 0.75, 5, "ChromaticObject.centroid() failed")
    np.testing.assert_almost_equal(centroid.y, 0.0, 5, "ChromaticObject.centroid() failed")

    # Now check the centroid sampling integrator...
    gal.wave_list = np.linspace(0.0, 1.0, 500)
    centroid = gal.centroid(bp)
    np.testing.assert_almost_equal(centroid.x, 0.75, 5, "ChromaticObject.centroid() failed")
    np.testing.assert_almost_equal(centroid.y, 0.0, 5, "ChromaticObject.centroid() failed")

    t2 = time.time()
    print 'time for %s = %.2f'%(funcname(),t2-t1)

def test_interpolated_ChromaticObject():
    """Test the ChromaticObject interpolation functionality."""
    import time
    t1 = time.time()

    # Define a ChromaticObject subclass for which interpolation could be helpful, but calculations
    # can be done quickly:
    # It's a Gaussian with a wavelength-dependent sigma [sigma = sigma_0 (wave / 500 nm)]
    # and shear g1 [g1 = 0.1 ((wave)/(500 nm) - 1)]
    class ChromaticGaussian(galsim.ChromaticObject):
        def __init__(self, sigma):
            # First, take the basic info.
            self.sigma = sigma
            self.separable = False
            self.wave_list = np.array([], dtype=float)

        def evaluateAtWavelength(self, wave):
            this_sigma = self.sigma * (wave / 500.)
            this_shear = 0.1 * ((wave/500.)-1.)
            ret = galsim.Gaussian(sigma = this_sigma)
            ret = ret.shear(g1 = this_shear)
            return ret

        def __repr__(self):
            return 'galsim.ChromaticGaussian(%r)'%self.sigma

    # For this test, we're going to use the ChromaticGaussian defined above.  This class is simple
    # enough that evaluation of both the interpolated and exact versions is very fast, so it won't
    # slow down the tests too much to do both ways.  Note that for initial tests (fair comparison
    # between exact and interpolated version) we're going to use a lot of images for the
    # interpolation, n_interp=100.  For more slowly-evaluated profiles, this is not going to be
    # feasible, and tests need to be done to check that a given n_interp is enough.  But that's an
    # accuracy test, not a unit test.
    sigma_0 = 0.06
    scale = 0.02
    n_interp = 100
    oversample_fac = 1.5
    blue_limit = min(bandpass.blue_limit, bandpass_g.blue_limit)
    red_limit = max(bandpass.red_limit, bandpass_g.red_limit)
    waves = np.linspace(blue_limit, red_limit, n_interp)
    # Make a version that tests the ability of the routine to handle non-sorted / non-array input.
    tricky_waves = list(waves[::-1])

    # Make a star.
    star = galsim.Gaussian(fwhm=1.e-8) * bulge_SED

    # First, compare images that are drawn with exact and interpolated ChromaticGaussian.
    exact_psf = ChromaticGaussian(sigma_0)
    interp_psf = exact_psf.interpolate(waves, oversample_fac=oversample_fac)
    exact_obj = galsim.Convolve(star, exact_psf)
    interp_obj = galsim.Convolve(star, interp_psf)
    im_exact = exact_obj.drawImage(bandpass, scale=scale, nx=40, ny=40)
    im_interp = im_exact.copy()
    im_interp = interp_obj.drawImage(bandpass, image=im_interp, scale=scale)
    # Note: peak value of array is around 0.3, so going to 4 decimal places is a reasonably
    # stringent test considering how different the exact vs. interpolated rendering process is.
    np.testing.assert_array_almost_equal(
        im_interp.array, im_exact.array, decimal=4,
        err_msg='Interpolated ChromaticObject results differ for exact vs. interpolated')

    # And test with midpoint rule (non-default).
    im_interp = interp_obj.drawImage(bandpass, image=im_interp, integrator='midpoint', scale=scale)
    np.testing.assert_array_almost_equal(
        im_interp.array, im_exact.array, decimal=4,
        err_msg='Interpolated ChromaticObject results differ for exact vs. interpolated (midpoint)')

    # Check that we can turn interpolation off and on at will.
    other_psf = interp_psf.original
    other_obj = galsim.Convolve(star, other_psf)
    im_other = im_exact.copy()
    im_other = other_obj.drawImage(bandpass, image=im_other, scale=scale)
    # Can test to very high accuracy.
    np.testing.assert_array_almost_equal(
        im_other.array, im_exact.array, decimal=8,
        err_msg='Failure to turn off interpolation in ChromaticObject')

    # Check that when an interpolated ChromaticObject is convolved with a ChromaticObject that has a
    # non-trivial surface brightness profile (i.e., a galaxy rather than a star), the image that we
    # get and the total flux normalization is correct. We are forcing it to go through the
    # evaluation of ChromaticConvolution.drawImage().
    gal = galsim.Exponential(half_light_radius = 2.*scale)
    gal = gal.shear(g2 = 0.3)
    gal = disk_SED*gal
    obj_exact = galsim.Convolve(exact_psf, gal)
    obj_interp = galsim.Convolve(interp_psf, gal)
    im_exact = obj_exact.drawImage(bandpass_g, scale=scale)
    im_interp = im_exact.copy()
    im_interp = obj_interp.drawImage(bandpass_g, image=im_interp, scale=scale)
    expected_flux = disk_SED.calculateFlux(bandpass_g)
    frac_diff_exact = abs(im_exact.array.sum()/expected_flux-1.0)
    frac_diff_interp = abs(im_interp.array.sum()/expected_flux-1.0)
    np.testing.assert_almost_equal(
        frac_diff_exact, 0.0, decimal=3,
        err_msg='ChromaticObject flux is wrong when convolved with ChromaticObject '
        ' (exact calculation)')
    np.testing.assert_almost_equal(
        frac_diff_interp, 0.0, decimal=3,
        err_msg='ChromaticObject (with interpolation) flux is wrong when convolved with '
        ' ChromaticObject')
    np.testing.assert_array_almost_equal(
        im_interp.array, im_exact.array, decimal=4,
        err_msg='ChromaticObject results differ for interpolated vs. exact'
        ' when convolving with ChromaticObject')

    # Check that when an ChromaticObject with interpolation is convolved with a ChromaticSum, the
    # image and flux normalization is correct.
    bulge = galsim.DeVaucouleurs(half_light_radius = 1.5*scale)
    bulge = bulge_SED*bulge
    tot_gal = gal + bulge
    obj_exact = galsim.Convolve(exact_psf, tot_gal)
    obj_interp = galsim.Convolve(interp_psf, tot_gal)
    im_exact = obj_exact.drawImage(bandpass, scale=scale)
    im_interp = im_exact.copy()
    im_interp = obj_interp.drawImage(bandpass, image=im_interp, scale=scale)
    expected_flux = disk_SED.calculateFlux(bandpass) + bulge_SED.calculateFlux(bandpass)
    frac_diff_exact = abs(im_exact.array.sum()/expected_flux-1.0)
    frac_diff_interp = abs(im_interp.array.sum()/expected_flux-1.0)
    # Check to 2%
    np.testing.assert_almost_equal(
        frac_diff_exact/2, 0.0, decimal=2,
        err_msg='ChromaticObject flux is wrong when convolved with ChromaticSum'
        ' (exact calculation)')
    np.testing.assert_almost_equal(
        frac_diff_interp/2, 0.0, decimal=2,
        err_msg='ChromaticObject flux is wrong when convolved with ChromaticSum'
        ' (interpolated calculation)')
    np.testing.assert_array_almost_equal(
        im_interp.array, im_exact.array, decimal=3,
        err_msg='ChromaticObject results differ for interpolated vs. exact'
        ' when convolving with ChromaticSum')

    # Check that we can render an image with chromatic transformations directly, and with
    # interpolation.  Use a ChromaticAtmosphere just because that's easily transformed.
    atm_fwhm = 0.7
    atm_scale = 0.2
    exact_psf = galsim.ChromaticAtmosphere(
        galsim.Kolmogorov(atm_fwhm), 500., zenith_angle=0.*galsim.degrees,
        parallactic_angle=0.*galsim.degrees)
    chrom_shear = lambda w: galsim.Shear(g1=0.2+0.2*(w-500.)/500.,g2=0.) if w<1000. else \
        galsim.Shear(g1=0.4, g2=0.)
    chrom_shift_y = lambda w: scale*(w-500.)
    # The 0.05 in the line below used to be 0.1.  When we went to the new extended SEDs, this unit
    # test began to fail by a tiny margin (0.02%).  Since this was so marginal I changed the
    # transformation to be a bit less extreme.
    chrom_dilate = lambda w: 1.0+0.05*(w-500.)/500.
    exact_psf = exact_psf.shear(shear=chrom_shear).shift(dx=0.,dy=chrom_shift_y).dilate(chrom_dilate)
    # Note here we are checking the use of more difficult input wavelengths.
    interp_psf = exact_psf.interpolate(tricky_waves, oversample_fac=oversample_fac)
    exact_obj = galsim.Convolve(star, exact_psf)
    interp_obj = galsim.Convolve(star, interp_psf)
    im_exact = exact_obj.drawImage(bandpass, scale=atm_scale)
    im_interp = im_exact.copy()
    im_interp = interp_obj.drawImage(bandpass, image=im_interp, scale=atm_scale)
    # Note: peak value of array is around 4, so going to 3 decimal places is a reasonably
    # stringent test considering how different the exact vs. interpolated rendering process is.
    np.testing.assert_array_almost_equal(
        im_interp.array, im_exact.array, decimal=3,
        err_msg='Interpolated ChromaticObject results differ for exact vs. interpolated'+
        ' when including chromatic transformations')

    # Check that we can render an image with achromatic transformations applied after
    # interpolation.
    exact_psf = galsim.ChromaticAtmosphere(
        galsim.Kolmogorov(atm_fwhm), 500., zenith_angle=0.*galsim.degrees,
        parallactic_angle=0.*galsim.degrees)
    interp_psf = exact_psf.interpolate(waves, oversample_fac=oversample_fac)

    achrom_shear = galsim.Shear(g1=0.05, g2=-0.1)
    exact_psf = exact_psf.shear(shear=achrom_shear)
    exact_obj = galsim.Convolve(star, exact_psf)
    interp_psf = interp_psf.shear(shear=achrom_shear)
    interp_obj = galsim.Convolve(star, interp_psf)

    im_exact = exact_obj.drawImage(bandpass, scale=atm_scale)
    im_interp = im_exact.copy()
    im_interp = interp_obj.drawImage(bandpass, image=im_interp, scale=atm_scale)
    # Note: peak value of array is around 4, so going to 3 decimal places is a reasonably
    # stringent test considering how different the exact vs. interpolated rendering process is.
    np.testing.assert_array_almost_equal(
        im_interp.array, im_exact.array, decimal=3,
        err_msg='Interpolated ChromaticObject results differ for exact vs. interpolated'+
        ' when including achromatic transformations after precomputation')

    # Check that the routine does not interpolate outside of its original bounds.
    try:
        np.testing.assert_raises(RuntimeError, obj_interp.drawImage, bandpass_z)
    except ImportError:
        print 'The assert_raises tests require nose'

    # Make sure it behaves appropriately when asked to apply chromatic transformations after
    # interpolating: it should do the job properly after un-setting the interpolation.
    # As a really strict test, we will apply chromatic transformations twice (before and after
    # setting up the interpolation).  This will make sure that it's really tracking and combining
    # all transformations.
    exact_psf = galsim.ChromaticAtmosphere(
        galsim.Kolmogorov(atm_fwhm), 500., zenith_angle=0.*galsim.degrees,
        parallactic_angle=0.*galsim.degrees)
    exact_psf = \
        exact_psf.shear(shear=chrom_shear).shift(dx=0.,dy=chrom_shift_y).dilate(chrom_dilate)
    interp_psf = exact_psf.interpolate(waves, oversample_fac=oversample_fac)
    trans_exact_psf = \
        exact_psf.shear(shear=chrom_shear).shift(dx=0.,dy=chrom_shift_y).dilate(chrom_dilate)
    # The object is going to emit a warning that we don't want to worry about (it's good for code
    # users, but a nuisance when testing), so let's deliberately ignore it by going into a
    # `catch_warnings` context.
    import warnings
    with warnings.catch_warnings():
        warnings.simplefilter("ignore")
        trans_interp_psf = \
            interp_psf.shear(shear=chrom_shear).shift(dx=0.,dy=chrom_shift_y).dilate(chrom_dilate)
        exact_obj = galsim.Convolve(star, trans_exact_psf)
        interp_obj = galsim.Convolve(star, trans_interp_psf)
        im_exact = exact_obj.drawImage(bandpass, scale=atm_scale)
        im_interp = im_exact.copy()
        im_interp = interp_obj.drawImage(bandpass, image=im_interp, scale=atm_scale)
        # Note: since the image rendering should have been done in exactly the same way (it should
        # have trashed the interpolation entirely), test to high precision.
        np.testing.assert_array_almost_equal(
            im_interp.array, im_exact.array, decimal=9,
            err_msg='Did not do exact chromatic transformation by discarding interpolation')
        # Also make sure that it ditched the interpolation.
        assert not hasattr(trans_interp_psf, 'waves')

    t2 = time.time()
    print 'time for %s = %.2f'%(funcname(),t2-t1)

def test_ChromaticOpticalPSF():
    """Test the ChromaticOpticalPSF functionality."""
    import time
    t1 = time.time()

    # For ChromaticOpticalPSF, exact evaluation is too slow for routine unit tests.  So, for
    # this unit test, we use an interpolated version only.  The tests of
    # ChromaticObject in the previous unit test should be enough to ensure that exact
    # and interpolated evaluation match in general (given reasonable settings).

    # First, compare the interpolated result with saved, exact results.
    # Exact results were generated using the following code, sitting in this directory:
    #
    # import galsim
    # import os
    # import numpy as np
    #
    # path, filename = os.path.split(__file__)
    # datapath = os.path.abspath(os.path.join(path, "../examples/data/"))
    # bandpass = galsim.Bandpass(os.path.join(datapath, 'LSST_r.dat')).thin()
    # disk_SED = galsim.SED(os.path.join(datapath, 'CWW_Sbc_ext.sed'), wave_type='ang')
    # disk_SED = disk_SED.withFluxDensity(target_flux_density=0.3, wavelength=500.0)
    #
    # star = galsim.Gaussian(sigma=1.e-8)*disk_SED
    #
    # aberrations = np.zeros(12)
    # aberrations[4] = 40. # nm
    # aberrations[7] = 20. # nm
    # lam = 600. # nm
    # aberrations /= lam
    # diam = 2.4 # meters
    # obscuration = 0.18
    # nstruts = 2
    # scale = 0.02
    #
    # psf = galsim.ChromaticOpticalPSF(lam=lam, diam=diam, aberrations=aberrations,
    #                                  obscuration=obscuration, nstruts=nstruts)
    # obj = galsim.Convolve(psf, star)
    # im_r = obj.drawImage(bandpass, scale=scale)
    # im_r.write('./chromatic_reference_images/r_exact.fits')
    #
    # That script took 17 seconds to run on a new-ish Macbook Pro, nearly all in the image rendering
    # process.  In contrast, the ChromaticOpticalPSF with interpolation that is used for this unit
    # test takes about 2.5 seconds to initialize, and 0.5s for the image rendering process.
    # Obviously, if many images are to be rendered after incurring the overhead of initializing this
    # object, the interpolated calculation leads to a huge savings compared to doing the exact
    # calculation each time.
    #
    # Note that exact results will have to be regenerated if any of the bandpasses or other
    # parameters defined here are changed.  Because of the parameters chosen here, there is a lot of
    # non-trivially complex structure in the PSFs, so this is a stringent test.
    aberrations = np.zeros(12)
    aberrations[4] = 40. # nm
    aberrations[7] = 20. # nm
    lam = 600. # nm
    aberrations /= lam
    diam = 2.4 # meters
    obscuration = 0.18
    nstruts = 4
    scale = 0.02
    n_interp = 15
    oversample_fac = 2.0
    waves = np.linspace(bandpass.blue_limit, bandpass.red_limit, n_interp)
    psf = galsim.ChromaticOpticalPSF(lam=lam, diam=diam, aberrations=aberrations,
                                     obscuration=obscuration, nstruts=nstruts)
    do_pickle(psf)

    psf = psf.interpolate(waves, oversample_fac=oversample_fac)
    star = galsim.Gaussian(fwhm=1.e-8) * disk_SED
    obj = galsim.Convolve(star, psf)

    if __name__ == '__main__':
        # This is slow, but it worth testing the pickling of InterpolatedChromaticObjects.
        do_pickle(psf)

    im_r_ref = galsim.fits.read(os.path.join(refdir, 'r_exact.fits'))
    im_r = im_r_ref.copy()
    obj.drawImage(bandpass, image=im_r, scale=scale)
    np.testing.assert_almost_equal(
        im_r.array.max(), im_r.array.max(), decimal=2,
        err_msg='Interpolated ChromaticOpticalPSF peak flux disagrees with reference in r band')
    im_r_ref /= im_r_ref.array.max()
    im_r /= im_r.array.max()
    # Test nearly passes at decimal=4, but 0.08% of pixels disagree.  However, decimal=3 after
    # normalization with peak flux is still very good.
    np.testing.assert_array_almost_equal(
        im_r.array, im_r_ref.array, decimal=3,
        err_msg='Interpolated ChromaticOpticalPSF results disagree with reference in r band')

    # Finally, check that flux normalization is preserved when we convolve with a chromatic object.
    gal = galsim.Exponential(half_light_radius = 2.*scale)
    gal = gal.shear(g2 = 0.3)
    gal = disk_SED*gal
    obj_conv = galsim.Convolve(psf, gal)
    im = obj_conv.drawImage(bandpass, scale=scale)
    expected_flux = disk_SED.calculateFlux(bandpass)
    frac_diff_exact = abs(im.array.sum()/expected_flux-1.0)/2.
    # Check to 2%
    np.testing.assert_almost_equal(
        frac_diff_exact, 0.0, decimal=2,
        err_msg='ChromaticObject flux is wrong when convolved with ChromaticOpticalPSF '
        ' (interpolated calculation)')

    t2 = time.time()
    print 'time for %s = %.2f'%(funcname(),t2-t1)

def test_ChromaticAiry():
    """Test the ChromaticAiry functionality."""
    import time
    t1 = time.time()

    # First, compare the interpolated result with saved, exact results.
    # Exact results were generated using the following code, sitting in this directory:
    #
    # import galsim
    # import os
    # import numpy as np
    #
    # path, filename = os.path.split(__file__)
    # datapath = os.path.abspath(os.path.join(path, "../examples/data/"))
    # bandpass = galsim.Bandpass(os.path.join(datapath, 'LSST_r.dat')).thin()
    # disk_SED = galsim.SED(os.path.join(datapath, 'CWW_Sbc_ext.sed'), wave_type='ang')
    # disk_SED = disk_SED.withFluxDensity(target_flux_density=0.3, wavelength=500.0)
    #
    # star = galsim.Gaussian(sigma=1.e-8)*disk_SED
    #
    # lam = 750. # nm
    # diam = 3.1 # meters
    # obscuration = 0.11
    # scale = 0.02
    #
    # psf = galsim.ChromaticAiry(lam=lam, diam=diam, obscuration=obscuration)
    # obj = galsim.Convolve(psf, star)
    # im_r = obj.drawImage(bandpass, scale=scale)
    # im_r.write('./chromatic_reference_images/r_exact_Airy.fits')
    #
    # Note that exact results will have to be regenerated if any of the bandpasses or other
    # parameters defined here are changed.  For example, had to regenerate on #590 because of new
    # version of r bandpass.

    # Define parameters:
    lam = 750. # nm
    diam = 3.1 # meters
    obscuration = 0.11
    scale = 0.02

    # Read in reference image:
    im_r_ref = galsim.fits.read(os.path.join(refdir, 'r_exact_Airy.fits'))
    im_r_tmp = im_r_ref.copy()

    # Make new object, and compare:
    psf = galsim.ChromaticAiry(lam=lam, diam=diam, obscuration=obscuration)
    do_pickle(psf)

    star = galsim.Gaussian(fwhm=1.e-8) * disk_SED
    obj = galsim.Convolve(psf, star)
    obj.drawImage(bandpass, image=im_r_tmp, scale=scale)
    np.testing.assert_array_almost_equal(
        im_r_tmp.array, im_r_ref.array, decimal=8,
        err_msg='ChromaticAiry image disagrees with reference in r band')

    # Initialize object in different way, make sure results are identical:
    lam_over_diam = (1.e-9*lam/diam)*galsim.radians
    psf = galsim.ChromaticAiry(lam=lam, lam_over_diam=lam_over_diam/galsim.arcsec,
                               obscuration=obscuration)
    obj = galsim.Convolve(psf, star)
    im_r_2 = im_r_tmp.copy()
    obj.drawImage(bandpass, image=im_r_2, scale=scale)
    np.testing.assert_array_almost_equal(
        im_r_2.array, im_r_ref.array, decimal=8,
        err_msg='ChromaticAiry image disagrees with reference in r band when initializing'
                ' a different way')

    # Also check evaluation at a single wavelength.
    chromatic_psf_400 = psf.evaluateAtWavelength(400.)
    new_lam_over_diam = (1.e-9*400/diam)*galsim.radians
    exact_psf_400 = galsim.Airy(lam_over_diam=new_lam_over_diam/galsim.arcsec,
                                obscuration=obscuration)
    chr_im = chromatic_psf_400.drawImage(scale=scale)
    exact_im = chr_im.copy()
    exact_psf_400.drawImage(image=exact_im, scale=scale)
    np.testing.assert_array_almost_equal(
        chr_im.array, exact_im.array, decimal=8,
        err_msg='ChromaticAiry evaluated at a single wavelength is not as expected')

    # Finally, check that flux normalization is preserved when we convolve with a chromatic object.
    gal = galsim.Exponential(half_light_radius = 2.*scale)
    gal = gal.shear(g2 = 0.3)
    gal = disk_SED*gal
    obj_conv = galsim.Convolve(psf, gal)
    im = obj_conv.drawImage(bandpass, scale=scale)
    expected_flux = disk_SED.calculateFlux(bandpass)
    frac_diff_exact = abs(im.array.sum()/expected_flux-1.0)
    # Check to 1%
    np.testing.assert_almost_equal(
        frac_diff_exact, 0.0, decimal=2,
        err_msg='ChromaticObject flux is wrong when convolved with ChromaticAiry')

    t2 = time.time()
    print 'time for %s = %.2f'%(funcname(),t2-t1)

def test_chromatic_fiducial_wavelength():
    """ Check that chromatic code can handle profiles with flux(effective_wavelength) = 0.
    """
    import time
    t1 = time.time()

    waves = np.arange(500., 600.1, 10.)
    blue_flux = waves < 550.0
    red_flux = waves > 550.0
    bp = galsim.Bandpass(galsim.LookupTable(waves, waves**0, interpolant='linear'))
    blue_sed = galsim.SED(galsim.LookupTable(waves, blue_flux, interpolant='linear'))
    red_sed = galsim.SED(galsim.LookupTable(waves, red_flux, interpolant='linear'))

    gal1 = galsim.Gaussian(fwhm=1) * blue_sed
    gal2 = galsim.Gaussian(fwhm=1) * red_sed
    img1 = gal1.drawImage(bp)
    img2 = gal2.drawImage(bp)
    # Didn't see an obvious np.testing method for checking finiteness, so just use assert.
    assert np.isfinite(img1.array.sum()), "drawImage failed to identify fiducial wavelength"
    assert np.isfinite(img2.array.sum()), "drawImage failed to identify fiducial wavelength"

def test_chromatic_image_setup():
    """Test ability for chromatic drawImage to setup output image."""
    import time
    t1 = time.time()

    psf = galsim.ChromaticAiry(lam=550, diam=0.1)
    gal1 = galsim.Sersic(n=1, half_light_radius=1.0) * bulge_SED
    gal2 = galsim.Sersic(n=2, half_light_radius=0.5) * disk_SED

    # Just going to try drawing a few different combinations of profiles to make sure that
    # the automatic image construction logic doesn't crash.  Most possibilities effectively get
    # tested in other scripts above anyway, so just focus on possibilities related to known previous
    # failures here; specifically, drawing a convolution of two inseparable profiles while
    # specifying `nx`, `ny`, and `scale` as keywords.
    img = galsim.Convolve(gal1+gal2, psf).drawImage(bandpass)
    img2 = galsim.Convolve(gal1+gal2, psf).drawImage(bandpass, nx=32, ny=32, scale=0.2)
    bds = galsim.BoundsI(1, 32, 1, 32)
    img3 = galsim.Convolve(gal1+gal2, psf).drawImage(bandpass, bounds=bds, scale=0.2)
    np.testing.assert_array_equal(img2.array.shape, (32, 32),
                                  "Got wrong size output image using nx=, ny= keywords.")
    np.testing.assert_array_equal(img3.array.shape, (32, 32),
                                  "Got wrong size output image using bounds= keyword.")
    np.testing.assert_almost_equal(img2.scale, 0.2, 9,
                                   "Got wrong output image scale using nx=, ny= keywords.")
    np.testing.assert_almost_equal(img3.scale, 0.2, 9,
                                   "Got wrong output image scale using bounds= keyword.")

    t2 = time.time()
    print 'time for %s = %.2f'%(funcname(),t2-t1)


if __name__ == "__main__":
    test_draw_add_commutativity()
    test_ChromaticConvolution_InterpolatedImage()
    test_chromatic_add()
    test_dcr_moments()
    test_chromatic_seeing_moments()
    test_monochromatic_filter()
    test_chromatic_flux()
    test_double_ChromaticSum()
    test_ChromaticConvolution_of_ChromaticConvolution()
    test_ChromaticAutoConvolution()
    test_ChromaticAutoCorrelation()
    test_ChromaticObject_expand()
    test_ChromaticObject_rotate()
    test_ChromaticObject_shear()
    test_ChromaticObject_shift()
    test_ChromaticObject_compound_affine_transformation()
    test_analytic_integrator()
    test_gsparam()
    test_separable_ChromaticSum()
    test_centroid()
    test_interpolated_ChromaticObject()
    test_ChromaticOpticalPSF()
    test_ChromaticAiry()
    test_chromatic_fiducial_wavelength()
    test_chromatic_image_setup()
