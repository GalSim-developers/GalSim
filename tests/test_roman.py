# Copyright (c) 2012-2022 by the GalSim developers team on GitHub
# https://github.com/GalSim-developers
#
# This file is part of GalSim: The modular galaxy image simulation toolkit.
# https://github.com/GalSim-developers/GalSim
#
# GalSim is free software: redistribution and use in source and binary forms,
# with or without modification, are permitted provided that the following
# conditions are met:
#
# 1. Redistributions of source code must retain the above copyright notice, this
#    list of conditions, and the disclaimer given in the accompanying LICENSE
#    file.
# 2. Redistributions in binary form must reproduce the above copyright notice,
#    this list of conditions, and the disclaimer given in the documentation
#    and/or other materials provided with the distribution.
#

import numpy as np
import datetime
from unittest import mock

import galsim
import galsim.roman
from galsim_test_helpers import *

@timer
def skip_roman_wcs():
    """Test the Roman WCS routines against ones provided by the Roman project office.
    """
    # This test is out of date and is not run, but since it was a useful test, the code is kept here
    # as a reminder to reinstate it if/when we get an updated version of the WCS software from the
    # Roman project office for cycle 7+.  Everything below this comment is the original code from
    # GalSim v1.4.
    ######################################################################################3
    # The standard against which we will compare is the output of some software provided by Jeff
    # Kruk.  The files used here were generated by Rachel on her Macbook using the script in
    # roman_files/make_standards.sh, and none of the parameters below can be changed without
    # modifying and rerunning that script.  We use 4 sky positions and rotation angles (2 defined
    # using the focal plane array, 2 using the observatory coordinates), and in each case, use a
    # different SCA for our tests.  We will simply read in the stored WCS and generate new ones, and
    # check that they have the right value of SCA center and pixel scale at the center, and that if
    # we offset by 500 pixels in some direction that gives the same sky position in each case.
    ra_test = [127., 307.4, -61.52, 0.0]
    dec_test = [-70., 50., 22.7, 0.0]
    pa_test = [160., 79., 23.4, -3.1]
    sca_test = [2, 13, 7, 18]
    import datetime
    ve = datetime.datetime(2025,3,20,9,2,0)
    date_test = [ve, ve, ve, datetime.date(2025,6,20)]
    pa_is_fpa_test = [True, False, True, False]

    dist_arcsec = []
    dist_2_arcsec = []
    pix_area_ratio = []
    for i_test in range(len(ra_test)):
         # Make the WCS for this test.
        world_pos = galsim.CelestialCoord(ra_test[i_test]*galsim.degrees,
                                          dec_test[i_test]*galsim.degrees)
        if i_test == 0:
            # Just for this case, we want to get the WCS for all SCAs.  This will enable some
            # additional tests that we don't do for the other test case.
            gs_wcs_dict = galsim.roman.getWCS(PA=pa_test[i_test]*galsim.degrees,
                                              world_pos=world_pos,
                                              PA_is_FPA=pa_is_fpa_test[i_test],
                                              date=date_test[i_test])
            np.testing.assert_equal(
                len(gs_wcs_dict), galsim.roman.n_sca,
                err_msg='WCS dict has wrong length: %d vs. %d'%(len(gs_wcs_dict),
                                                                galsim.roman.n_sca))
        else:
            # Use the SCAs keyword to just get the WCS for the SCA that we want.
            gs_wcs_dict = galsim.roman.getWCS(PA=pa_test[i_test]*galsim.degrees,
                                              world_pos=world_pos,
                                              PA_is_FPA=pa_is_fpa_test[i_test],
                                              SCAs=sca_test[i_test],
                                              date=date_test[i_test])
            np.testing.assert_equal(
                len(gs_wcs_dict), 1,
                err_msg='WCS dict has wrong length: %d vs. %d'%(len(gs_wcs_dict), 1))

        # Read in reference.
        test_file = 'test%d_sca_%02d.fits'%(i_test+1, sca_test[i_test])
        ref_wcs = galsim.FitsWCS(os.path.join('roman_files',test_file))

        gs_wcs = gs_wcs_dict[sca_test[i_test]]

        # Check center position:
        im_cent_pos = galsim.PositionD(galsim.roman.n_pix/2., galsim.roman.n_pix/2)
        ref_cent_pos = ref_wcs.toWorld(im_cent_pos)
        gs_cent_pos = gs_wcs.toWorld(im_cent_pos)
        dist_arcsec.append(ref_cent_pos.distanceTo(gs_cent_pos) / galsim.arcsec)

        # Check pixel area
        rat = ref_wcs.pixelArea(image_pos=im_cent_pos)/gs_wcs.pixelArea(image_pos=im_cent_pos)
        pix_area_ratio.append(rat-1.)

        # Check another position, just in case rotations are messed up.
        im_other_pos = galsim.PositionD(im_cent_pos.x+500., im_cent_pos.y-200.)
        ref_other_pos = ref_wcs.toWorld(im_other_pos)
        gs_other_pos = gs_wcs.toWorld(im_other_pos)
        dist_2_arcsec.append(ref_other_pos.distanceTo(gs_other_pos) / galsim.arcsec)

        if i_test == 0:
            # For just one of our tests cases, we'll do some additional tests.  These will target
            # the findSCA() functionality.  First, we'll choose an SCA and check that its center is
            # found to be in that SCA.
            found_sca = galsim.roman.findSCA(gs_wcs_dict, gs_cent_pos)
            np.testing.assert_equal(found_sca, sca_test[i_test],
                                    err_msg='Did not find SCA center position to be on that SCA!')

            # Then, we go to a place that should be off the side by a tiny bit, and check that it is
            # NOT on an SCA if we exclude borders, but IS on the SCA if we include borders.
            im_off_edge_pos = galsim.PositionD(-2., galsim.roman.n_pix/2.)
            world_off_edge_pos = gs_wcs.toWorld(im_off_edge_pos)
            found_sca = galsim.roman.findSCA(gs_wcs_dict, world_off_edge_pos)
            assert found_sca is None
            found_sca = galsim.roman.findSCA(gs_wcs_dict, world_off_edge_pos, include_border=True)
            np.testing.assert_equal(found_sca, sca_test[i_test],
                                    err_msg='Did not find slightly off-edge position on the SCA'
                                    ' when including borders!')

    np.testing.assert_array_less(
        np.array(dist_arcsec),
        np.ones(len(ra_test))*galsim.roman.pixel_scale/100,
        err_msg='For at least one WCS, center offset from reference was > 0.01(pixel scale).')
    np.testing.assert_array_less(
        np.array(dist_2_arcsec),
        np.ones(len(ra_test))*galsim.roman.pixel_scale/100,
        err_msg='For at least one WCS, other offset from reference was > 0.01(pixel scale).')
    np.testing.assert_array_less(
        np.array(pix_area_ratio),
        np.ones(len(ra_test))*0.0001,
        err_msg='For at least one WCS, pixel areas differ from reference by >0.01%.')

@timer
def test_roman_wcs():
    """Test the Roman WCS routines against the one produced by code from Chris Hirata.
    """
    # The standard against which we will compare is the output of some software provided by Chris
    # Hirata.  The files used here were generated by Rachel on her Macbook using the script in
    # roman_files/, with sky positions randomly selected and then stored as part of the
    # comparison.  We read in a list of FPA center positions and other RA/dec positions, the
    # position angle for the observation, and the SCA those other positions land on (if any).  Then
    # we compare that with the GalSim routines for finding SCAs.
    import datetime
    date = datetime.datetime(2025, 1, 12)
    test_data_file = os.path.join('roman_files','chris_comparison.txt')
    test_data = np.loadtxt(test_data_file).transpose()

    ra_cen = test_data[0,:]
    dec_cen = test_data[1,:]
    ra = test_data[2,:]
    dec = test_data[3,:]
    pa = test_data[4,:]
    chris_sca = test_data[5,:]
    if __name__ != "__main__":
        i_start = 4
        n_test = 3  # None of these 3 fail, so the nfail test is ok.
    else:
        i_start = 0
        n_test = len(ra_cen)

    n_fail = 0
    for i_test in range(i_start, i_start+n_test):
        print('i_test = ',i_test)
        # Make the WCS for this test.
        world_pos = galsim.CelestialCoord(ra_cen[i_test]*galsim.degrees,
                                          dec_cen[i_test]*galsim.degrees)
        gs_wcs_dict = galsim.roman.getWCS(PA=pa[i_test]*galsim.radians,
                                          world_pos=world_pos,
                                          PA_is_FPA=True,
                                          date=date)
        np.testing.assert_equal(
            len(gs_wcs_dict), galsim.roman.n_sca,
            err_msg='WCS dict has wrong length: %d vs. %d'%(len(gs_wcs_dict),
                                                            galsim.roman.n_sca))

        found_sca = galsim.roman.findSCA(
            gs_wcs_dict,
            galsim.CelestialCoord(ra[i_test]*galsim.degrees,
                                  dec[i_test]*galsim.degrees))
        if found_sca is None: found_sca=0
        if found_sca != chris_sca[i_test]:
            n_fail += 1
            print('Failed to find SCA: ',found_sca, chris_sca[i_test])

        # Just cycle through the SCAs for the next bits.
        sca_test = i_test % 18 + 1
        gs_wcs = gs_wcs_dict[sca_test]

        # Check center position:
        im_cent_pos = galsim.PositionD(galsim.roman.n_pix/2., galsim.roman.n_pix/2)
        gs_cent_pos = gs_wcs.toWorld(im_cent_pos)

        # Check pixel area
        pix_area = gs_wcs.pixelArea(image_pos=im_cent_pos)
        print('pix_area = ',pix_area)
        np.testing.assert_allclose(pix_area, 0.012, atol=0.001)

        if i_test == 0:
            # For just one of our tests cases, we'll do some additional tests.  These will target
            # the findSCA() functionality.  First, check that the center is found in that SCA.
            found_sca = galsim.roman.findSCA(gs_wcs_dict, gs_cent_pos)
            np.testing.assert_equal(found_sca, sca_test,
                                    err_msg='Did not find SCA center position to be on that SCA!')

            # Then, we go to a place that should be off the side by a tiny bit, and check that it is
            # NOT on an SCA if we exclude borders, but IS on the SCA if we include borders.
            im_off_edge_pos = galsim.PositionD(-2., galsim.roman.n_pix/2.)
            world_off_edge_pos = gs_wcs.toWorld(im_off_edge_pos)
            found_sca = galsim.roman.findSCA(gs_wcs_dict, world_off_edge_pos)
            assert found_sca is None
            found_sca = galsim.roman.findSCA(gs_wcs_dict, world_off_edge_pos, include_border=True)
            np.testing.assert_equal(found_sca, sca_test,
                                    err_msg='Did not find slightly off-edge position on the SCA'
                                    ' when including borders!')

        if i_test < 5:
            # Also make sure that for a given SCA, we find positions on it that should be on it,
            # without/with inclusion of borders.  Just do this test a limited number of times.
            for sca_ind in range(1,19):
                sca_edge_test = sca_ind
                tmp_wcs = gs_wcs_dict[sca_edge_test]
                im_test_pos = galsim.PositionD(10.0, galsim.roman.n_pix/2)
                tmp_pos = tmp_wcs.toWorld(im_test_pos)
                found_sca = galsim.roman.findSCA(gs_wcs_dict, tmp_pos, include_border=False)
                assert found_sca==sca_edge_test
                found_sca = galsim.roman.findSCA(gs_wcs_dict, tmp_pos, include_border=True)
                assert found_sca==sca_edge_test
                im_test_pos = galsim.PositionD(galsim.roman.n_pix/2, galsim.roman.n_pix+3)
                tmp_pos = tmp_wcs.toWorld(im_test_pos)
                found_sca = galsim.roman.findSCA(gs_wcs_dict, tmp_pos, include_border=False)
                assert found_sca==None
                found_sca = galsim.roman.findSCA(gs_wcs_dict, tmp_pos, include_border=True)
                assert found_sca==sca_edge_test

                # And check that we can go from the center of that SCA and reverse-engineer the
                # position of the center of the FPA.
                im_test_pos = galsim.PositionD(galsim.roman.n_pix/2, galsim.roman.n_pix/2)
                test_sca_pos = tmp_wcs.toWorld(im_test_pos)
                test_fpa_pos = galsim.roman.convertCenter(test_sca_pos, int(sca_edge_test),
                                                          PA=pa[i_test]*galsim.radians,
                                                          date=date, PA_is_FPA=True)
                # Also test that convertCenter checks inputs appropriately.
                with assert_raises(TypeError):
                    galsim.roman.convertCenter(test_sca_pos, 3.5)
                with assert_raises(TypeError):
                    galsim.roman.convertCenter(
                        test_sca_pos, int(sca_edge_test), PA=pa[i_test]*galsim.radians,
                        date=date, PA_is_FPA=True, tol=1.0)

                delta_arcsec = test_fpa_pos.distanceTo(world_pos) / galsim.arcsec
                assert delta_arcsec<0.5, "could not round-trip from FPA to SCA to FPA center"

    # There were few-arcsec offsets in our WCS, so allow some fraction of failures.
    print('n_fail = ',n_fail)
    assert n_fail < 0.2*n_test, 'Failed in SCA-matching against reference: %d %d'%(n_fail,n_test)

    # Check whether we're allowed to look at certain positions on certain dates.
    # Let's choose RA=90 degrees, dec=10 degrees.
    # We know that it's best to look about 90 degrees from the Sun.  So on the vernal and autumnal
    # equinox, this should be a great place to look, but not midway in between.
    pos = galsim.CelestialCoord(90.*galsim.degrees, 10.*galsim.degrees)
    import datetime
    assert galsim.roman.allowedPos(pos, datetime.date(2025,3,20))
    assert galsim.roman.allowedPos(pos, datetime.date(2025,9,20))
    assert not galsim.roman.allowedPos(pos, datetime.date(2025,6,20))
    assert galsim.roman.bestPA(pos, datetime.date(2025,6,20)) is None

    # Finally make sure it does something reasonable for the observatory position angle.
    # When the sun is at (0,0), and we look at (90,0), then +Z points towards the Sun and +Y points
    # North, giving a PA of 0 degrees.
    pos = galsim.CelestialCoord(90.*galsim.degrees, 0.*galsim.degrees)
    test_date = datetime.datetime(2025,3,20,9,2)
    pa = galsim.roman.bestPA(pos, test_date)
    np.testing.assert_almost_equal(pa.rad, 0., decimal=3)
    # Now make it look at the same RA as the sun but quite different declination.  It wants +Z
    # pointing North toward Sun, so we'll get a -90 degree angle for the PA.
    pos = galsim.CelestialCoord(0.*galsim.degrees, -70.*galsim.degrees)
    pa = galsim.roman.bestPA(pos, test_date)
    np.testing.assert_almost_equal(pa.rad, -np.pi/2, decimal=3)

    sun_pos= galsim.CelestialCoord(0*galsim.degrees, 0*galsim.degrees)
    sun_pa = galsim.roman.bestPA(sun_pos, test_date)
    assert sun_pa is None

    with assert_raises(TypeError):
        galsim.roman.getWCS(world_pos=galsim.PositionD(300,400))
    with assert_raises(galsim.GalSimError):
        galsim.roman.getWCS(world_pos=sun_pos, date=test_date)
    with assert_raises(TypeError):
        galsim.roman.getWCS(world_pos=pos, PA=33.)
    with assert_raises(galsim.GalSimRangeError):
        galsim.roman.getWCS(world_pos=pos, SCAs=[-1,1])
    with assert_raises(galsim.GalSimRangeError):
        galsim.roman.getWCS(world_pos=pos, SCAs=[1,23])

    # Check the rather bizarre convention that LONPOLE is always 180 EXCEPT (!!) when
    # observing directly at the south pole.  Apparently, this convention comes from the Roman
    # project office's use of the LONPOLE keyword.  So we keep it, even though it's stupid.
    # cf. https://github.com/GalSim-developers/GalSim/pull/651#discussion-diff-26277673
    assert gs_wcs_dict[1].header['LONPOLE'] == 180.
    south_pole = galsim.CelestialCoord(0*galsim.degrees, -90*galsim.degrees)
    wcs = galsim.roman.getWCS(world_pos=south_pole, SCAs=1)
    assert wcs[1].header['LONPOLE'] == 0

    with assert_raises(TypeError):
        galsim.roman.findSCA(wcs_dict=None, world_pos=pos)
    with assert_raises(TypeError):
        galsim.roman.findSCA(wcs_dict=wcs, world_pos=galsim.PositionD(300,400))

@timer
def test_roman_backgrounds():
    """Test the Roman background estimation routines for basic sanity.
    """
    import datetime

    # The routine should not allow us to look directly at the sun since the background there is high
    # (to understate the problem).  If no date is supplied, then the routine assumes RA=dec=0 means
    # we are looking at the sun.
    bp_dict = galsim.roman.getBandpasses()
    bp = bp_dict['J129'] # one of the standard filters, doesn't really matter which
    with assert_raises(ValueError):
        galsim.roman.getSkyLevel(
                bp, world_pos=galsim.CelestialCoord(0.*galsim.degrees, 0.*galsim.degrees))
        # near autumn equinox
    with assert_raises(ValueError):
        galsim.roman.getSkyLevel(
                bp, world_pos=galsim.CelestialCoord(180.*galsim.degrees, 5.*galsim.degrees),
                date=datetime.date(2025,9,15))

    # world_pos must be a CelestialCoord.
    with assert_raises(TypeError):
        galsim.roman.getSkyLevel(bp, world_pos=galsim.PositionD(300,400))

    # No world_pos works.  Produces sky level for some plausible generic location.
    sky_level = galsim.roman.getSkyLevel(bp)
    print('sky_level = ',sky_level)
    # regression test relative to v2.5
    np.testing.assert_allclose(sky_level, 6928.267815, rtol=0.01)

    # But not with a non-Roman bandpass
    with assert_raises(galsim.GalSimError):
        galsim.roman.getSkyLevel(galsim.Bandpass('wave', 'nm', 400, 550))

    # The routine should have some obvious symmetry, for example, ecliptic latitude above vs. below
    # plane and ecliptic longitude positive vs. negative (or vs. 360 degrees - original value).
    # Because of how equatorial and ecliptic coordinates are related on the adopted date, we can do
    # this test as follows:
    test_ra = 50.*galsim.degrees
    test_dec = 10.*galsim.degrees
    test_pos_p = galsim.CelestialCoord(test_ra, test_dec)
    test_pos_m = galsim.CelestialCoord(-1.*(test_ra/galsim.degrees)*galsim.degrees,
                                       -1.*(test_dec/galsim.degrees)*galsim.degrees)
    level_p = galsim.roman.getSkyLevel(bp, world_pos=test_pos_p)
    level_m = galsim.roman.getSkyLevel(bp, world_pos=test_pos_m)
    np.testing.assert_almost_equal(level_m, level_p, decimal=8)

    # The routine should handle an input exposure time sensibly.  Our original level_p was in
    # e-/arcsec^2 using the Roman exposure time.  We will define another exposure time, pass it in,
    # and confirm that the output is consistent with this.
    level_p_2 = galsim.roman.getSkyLevel(bp, world_pos=test_pos_p,
                                         exptime=1.7*galsim.roman.exptime)
    np.testing.assert_almost_equal(1.7*level_p, level_p_2, decimal=8)


@timer
def test_roman_bandpass():
    """Test the Roman bandpasses for basic sanity.
    """
    from galsim._pyfits import pyfits

    # Obtain the bandpasses with AB_zeropoint set
    bp = galsim.roman.getBandpasses(AB_zeropoint=True)

    # Check if the zeropoints have been set correctly
    AB_spec = lambda x: (3631e-23)
    AB_sed = galsim.SED(spec=AB_spec, wave_type='nm', flux_type='fnu')
    for filter_name, filter_ in bp.items():
        mag = AB_sed.calculateMagnitude(bandpass=filter_)
        np.testing.assert_almost_equal(mag,0.0,decimal=6,
            err_msg="Zeropoint not set accurately enough for bandpass filter "+filter_name)

    # Do a slightly less trivial check of bandpass-related calculations:
    # Jeff Kruk (at Goddard) took an SED template from the Castelli-Kurucz library, normalized it to
    # a particular magnitude in SDSS g band, and checked the count rates he expects for the Roman
    # bands.  I (RM) independently did the same calculation (downloading the templates and bandpass
    # myself and using GalSim for all the important bits of the calculation) and my results agree a
    # the 5% level.  Given that I didn't quite have the same SED, we were very happy with this level
    # of agreement.  The unit test below reproduces this test, and requires agreement at the 10%
    # level.
    # Jeff used the C-K template with solar metallicity, T=9550K, surface gravity logg=3.95.  I
    # downloaded a grid of templates and just used the nearest one, which has solar metallicity,
    # T=9500K, surface gravity logg=4.0.
    with pyfits.open(os.path.join('roman_files','ckp00_9500.fits')) as fits:
        sed_data = fits[1].data
    lam = sed_data.WAVELENGTH.astype(np.float64)
    t = sed_data.g40.astype(np.float64)
    sed_tab = galsim.LookupTable(x=lam, f=t, interpolant='linear')
    sed = galsim.SED(sed_tab, wave_type='A', flux_type='flambda')

    # Now take the SDSS g bandpass:
    # gfile =  '/Users/rmandelb/Downloads/g.dat'
    bp_dat = np.loadtxt(os.path.join('roman_files','g.dat')).transpose()
    bp_tab = galsim.LookupTable(x=bp_dat[0,:], f=bp_dat[1,:], interpolant='linear')
    bp_ref = galsim.Bandpass(bp_tab, wave_type='A').withZeropoint('AB')
    # Now get a new SED that has magnitude -0.093 in this filter, since that's the normalization
    # that Jeff imposed for his tests.
    sed = sed.withMagnitude(-0.093, bp_ref)

    # Reference count rates, from Jeff:
    reference = {}
    reference['Z087'] = 1.98e10
    reference['Y106'] = 1.97e10
    reference['J129'] = 1.52e10
    reference['H158'] = 1.11e10
    reference['F184'] = 0.58e10
    reference['W146'] = 4.34e10

    # Only 15% accuracy required because did not use quite the same stellar template.  Fortunately,
    # bugs can easily lead to orders of magnitude errors, so this unit test is still pretty
    # non-trivial.
    for filter_name, filter_ in bp.items():
        if filter_name not in reference:
            continue
        flux = sed.calculateFlux(filter_)  # photons / cm^2 / s
        print(flux, reference[filter_name])
        np.testing.assert_allclose(
            flux, reference[filter_name], rtol=0.15,
            err_msg="Count rate for stellar model not as expected for bandpass "
            "{0}".format(filter_name))

    # Finally, compare against some external zeropoint calculations from the Roman microlensing
    # group: https://roman.ipac.caltech.edu/sims/MABuLS_sim.html
    # They calculated instrumental zero points, defined such that the flux is 1 photon/sec (taking
    # into account the Roman collecting area).  This is now (as of v2.5) consistent with our
    # definition.  However, with the new bandpass changes since their calculation, the agreement
    # is only about 0.3 magnitudes.
    ref_zp = {
        'W146': 27.554,
        'Z087': 26.163
        }
    for key in ref_zp.keys():
        galsim_zp = bp[key].zeropoint
        # They use slightly different versions of the bandpasses, so we only require agreement to
        # 0.1 mag.
        print('zp for %s: '%key, galsim_zp, ref_zp[key])
        np.testing.assert_allclose(galsim_zp, ref_zp[key], atol=0.3,
                                   err_msg="Wrong zeropoint for bandpass "+key)

    # Note: the difference is not due to our default thinning.  This isn't any better.
    nothin_bp = galsim.roman.getBandpasses(AB_zeropoint=True, default_thin_trunc=False)
    for key in ref_zp.keys():
        galsim_zp = nothin_bp[key].zeropoint
        print('nothin zp for %s: '%key, galsim_zp, ref_zp[key])
        np.testing.assert_allclose(galsim_zp, ref_zp[key], atol=0.3,
                                   err_msg="Wrong zeropoint for bandpass "+key)

    # Even with fairly extreme thinning, the error is still 0.3 mag.
    verythin_bp = galsim.roman.getBandpasses(AB_zeropoint=True, default_thin_trunc=False,
                                             relative_throughput=0.05, rel_err=0.1)
    for key in ref_zp.keys():
        galsim_zp = verythin_bp[key].zeropoint
        print('verythin zp for %s: '%key, galsim_zp, ref_zp[key])
        np.testing.assert_allclose(galsim_zp, ref_zp[key], atol=0.3,
                                   err_msg="Wrong zeropoint for bandpass "+key)

    with assert_raises(TypeError):
        galsim.roman.getBandpasses(default_thin_trunc=False, rel_tp=0.05)
    with assert_warns(galsim.GalSimWarning):
        galsim.roman.getBandpasses(relative_throughput=0.05, rel_err=0.1)

    # Can also not bother to set the zeropoint.
    nozp_bp = galsim.roman.getBandpasses(AB_zeropoint=False)
    for key in nozp_bp:
        assert nozp_bp[key].zeropoint is None


@timer
def test_roman_detectors():
    """Test the Roman detector routines for consistency with standard detector routines.
    """
    # This seems almost silly, but for now the Roman detector routines are defined in terms of the
    # standard GalSim detector routines, and we should check that even if the routines are modified,
    # they still can agree given the same inputs.
    # So start by making a fairly simple image.
    obj = galsim.Gaussian(sigma=3.*galsim.roman.pixel_scale, flux=1.e5)
    im = obj.drawImage(scale=galsim.roman.pixel_scale)
    im.replaceNegative(0.)

    # Make copies that we transform using both sets of routines, and check for consistency.
    # First we do nonlinearity:
    im_1 = im.copy()
    im_2 = im.copy()
    im_1.applyNonlinearity(NLfunc=galsim.roman.NLfunc)
    galsim.roman.applyNonlinearity(im_2)
    assert im_2.scale == im_1.scale
    assert im_2.wcs == im_1.wcs
    assert im_2.dtype == im_1.dtype
    assert im_2.bounds == im_1.bounds
    np.testing.assert_array_equal(
        im_2.array, im_1.array,
        err_msg='Nonlinearity results depend on function used.')

    # Then we do reciprocity failure:
    im_1 = im.copy()
    im_2 = im.copy()
    im_1.addReciprocityFailure(exp_time=galsim.roman.exptime,
                               alpha=galsim.roman.reciprocity_alpha,
                               base_flux=1.0)
    galsim.roman.addReciprocityFailure(im_2)
    assert im_2.scale == im_1.scale
    assert im_2.wcs == im_1.wcs
    assert im_2.dtype == im_1.dtype
    assert im_2.bounds == im_1.bounds
    np.testing.assert_array_equal(
        im_2.array, im_1.array,
        err_msg='Reciprocity failure results depend on function used.')

    # Then we do Persistence
    im_1 = im.copy()
    im_2 = im.copy()

    rng = galsim.BaseDeviate(1234567)
    im0 = galsim.Image(im.bounds)       # create a new image for two noise images as 'ghost images'
    im0_1 = im0.copy()
    im0_1.addNoise(galsim.GaussianNoise(rng,sigma=10.))

    im0_2 = im0_1.copy()
    im0_2.addNoise(galsim.PoissonNoise(rng))

    im_list = [im0_1,im0_2]*4

    im_1.applyPersistence(im_list,galsim.roman.persistence_coefficients)
    galsim.roman.applyPersistence(im_2, im_list, method='linear') #check the linear method
    assert im_2.scale == im_1.scale
    assert im_2.wcs == im_1.wcs
    assert im_2.dtype == im_1.dtype
    assert im_2.bounds == im_1.bounds
    np.testing.assert_array_equal(
        im_2.array, im_1.array,
        err_msg='Persistence results depend on function used.')

    im_unit = galsim.Image(np.ones((2,2)), copy=True)
    im_f = im_unit*0.0
    im_f1 = im_unit*0.0
    illuminatin_list = [1.E3, 1.E4, 4.E4, 4.99E4, 5.01E4, 1.E5, 1.0E6]
    im_f_list = [x*im_unit for x in illuminatin_list]

    galsim.roman.applyPersistence(im_f, im_f_list, method='fermi') #check fermi method

    #Check the functionality of the fermi method.
    A, x0, dx, a, r, half_well = galsim.roman.persistence_fermi_parameters
    #formula of the fermi model. See the documentation of
    #galsim.roman.roman_detectors.applyPersistence for more info.
    f_fermi = lambda x, t: A* (x/x0)**a * (t/1000.)**(-r)/(np.exp( -(x-x0)/dx)+1.)
    ps = 0.0
    for i,x in enumerate(illuminatin_list):
        t = (0.5+i)*galsim.roman.exptime #mid-time of each exposure
        if x>=0.0 and x<half_well: #linear tail below half well of saturation
            ps += f_fermi(half_well, t)*x/half_well
        elif x>= half_well:
            ps += f_fermi(x,t)
    ps *= galsim.roman.exptime
    assert np.allclose( im_f.array, np.ones((2,2))*ps, rtol=1.E-06 ), 'Error in Fermi persistence model'

    galsim.roman.applyPersistence(im_f1, im_f_list)
    np.testing.assert_array_equal(im_f, im_f1,
        err_msg='The default method of roman.applyPersistence is not fermi.')

    assert_raises(TypeError, galsim.roman.applyPersistence, im_2, im0)
    assert_raises(galsim.GalSimValueError, galsim.roman.applyPersistence, im_2, im_list, method='wrong method')

    # Then we do IPC:
    im_1 = im.copy()
    im_2 = im.copy()
    im_1.applyIPC(IPC_kernel=galsim.roman.ipc_kernel, kernel_normalization=True)
    galsim.roman.applyIPC(im_2)
    assert im_2.scale == im_1.scale
    assert im_2.wcs == im_1.wcs
    assert im_2.dtype == im_1.dtype
    assert im_2.bounds == im_1.bounds
    np.testing.assert_array_equal(
        im_2.array, im_1.array,
        err_msg='IPC results depend on function used.')

    # Finally, just check that this runs.
    # (Accuracy of component functionality is all tested elsewhere.)
    ntest = 10  # number of exposures for this test
    past_images = []
    for i in range(ntest):
        im = obj.drawImage(scale=galsim.roman.pixel_scale)
        past_images = galsim.roman.allDetectorEffects(im, past_images, rng=rng)
    assert len(past_images) == ntest


@timer
def test_roman_psfs():
    """Test the Roman PSF routines for reasonable behavior.
    """
    # The Roman PSF routines can take a long time under some circumstances.  For example, storing
    # images for interpolation can be expensive, particularly when using the full pupil plane
    # functionality.  To speed up our calculations, we will limit the unit tests to certain
    # situations:
    # - fully chromatic PSFs without interpolation.  Then we just want to play with the objects in
    #   a fast way (e.g., evaluating at one  wavelength, not integrating over a bandpass).
    # - fully chromatic PSFs with interpolation, but only interpolating between two wavelengths.
    # - achromatic PSFs.
    #
    # We also only test pupil_bin=4,8 in nosetests runs.  Tests of pupil_bin=1,2 are done in
    # __main__ runs.

    # Providing a wavelength returns achromatic PSFs
    psf_5 = galsim.roman.getPSF(SCA=5, bandpass='F184', wavelength=1950., pupil_bin=8)
    assert isinstance(psf_5, galsim.GSObject)
    # Make sure we do the case where we add aberrations
    psf_5_ab = galsim.roman.getPSF(SCA=5, bandpass='F184', wavelength=1950., pupil_bin=8,
                                   extra_aberrations=np.zeros(23)+0.001)
    # Check that we get the same answer if we specify the center of the focal plane.
    psf_5_tmp = galsim.roman.getPSF(SCA=5, bandpass='F184', wavelength=1950., pupil_bin=8,
                                    SCA_pos=galsim.PositionD(galsim.roman.n_pix/2,
                                                             galsim.roman.n_pix/2))
    assert psf_5==psf_5_tmp

    # Check that if we specify a particular wavelength, the PSF that is drawn is the same as if we
    # had gotten chromatic PSFs and then used evaluateAtWavelength.  Note that this nominally seems
    # like a test of the chromatic functionality, but there are ways that getPSF() could mess up
    # inputs such that there is a disagreement.  That's why this unit test belongs here.
    use_sca = 5
    all_bp = galsim.roman.getBandpasses()
    zbp = all_bp['Z087']
    use_lam = zbp.effective_wavelength
    psf_chrom = galsim.roman.getPSF(use_sca, None, pupil_bin=8)
    psf_achrom = galsim.roman.getPSF(use_sca, None, wavelength=use_lam, pupil_bin=8)
    psf_achrom2 = galsim.roman.getPSF(use_sca, 'Z087', wavelength=use_lam, pupil_bin=8)
    # First, we can draw the achromatic PSF.
    im_achrom = psf_achrom.drawImage(scale=galsim.roman.pixel_scale)
    im_achrom2 = im_achrom.copy()
    im_achrom2 = psf_achrom2.drawImage(image=im_achrom2, scale=galsim.roman.pixel_scale)
    im_chrom = im_achrom.copy()
    obj_chrom = psf_chrom.evaluateAtWavelength(use_lam)
    im_chrom = obj_chrom.drawImage(image=im_chrom, scale=galsim.roman.pixel_scale)
    # Normalization should probably not be right.
    im_chrom *= im_achrom.array.sum()/im_chrom.array.sum()
    # But otherwise these images should agree *extremely* well.
    np.testing.assert_array_almost_equal(
        im_chrom.array, im_achrom.array, decimal=8,
        err_msg='PSF at a given wavelength and chromatic one evaluated at that wavelength disagree.')
    np.testing.assert_array_almost_equal(
        im_achrom.array, im_achrom2.array, decimal=8,
        err_msg='Two PSFs at a given wavelength specified in different ways disagree.')

    # Make a very limited check that interpolation works: just 2 wavelengths, 1 SCA.
    # use the blue and red limits for Z087:
    blue_limit = all_bp['Z087'].blue_limit
    red_limit = all_bp['Z087'].red_limit
    n_waves = 3
    psf_int = galsim.roman.getPSF(SCA=use_sca, bandpass='Z087', pupil_bin=8, n_waves=n_waves)
    # Check that evaluation at a single wavelength is consistent with previous results.
    im_int = im_achrom.copy()
    obj_int = psf_int.evaluateAtWavelength(use_lam)
    im_int = obj_int.drawImage(image=im_int, scale=galsim.roman.pixel_scale)
    # These images should agree well, but not perfectly.  One of them comes from drawing an image
    # from an object directly, whereas the other comes from drawing an image of that object, making
    # it into an InterpolatedImage, then re-drawing it.  Different accuracies are used for those
    # intermediate steps than would be used when drawing directly, so that can give rise to some
    # disagreement.  Check for agreement at the level of 2e-3 (requiring 1e-3 gives rise to failure
    # in 2 pixels!).
    diff_im = 0.5*(im_int.array-im_achrom.array)
    np.testing.assert_array_almost_equal(
        diff_im, np.zeros_like(diff_im), decimal=3,
        err_msg='PSF at a given wavelength and interpolated chromatic one evaluated at that '
        'wavelength disagree.')

    # Make sure the interpolated version isn't gratuitously copying the aperture.  It should be
    # able to use the same aperture object for each wavelength.
    for obj in psf_int.objs[1:]:
        assert obj._aper is psf_int.objs[0]._aper

    # Check some invalid inputs.
    with assert_raises(TypeError):
        galsim.roman.getPSF(SCA=use_sca, bandpass='Z087', n_waves=2, wavelength='Z087')
    with assert_raises(TypeError):
        galsim.roman.getPSF(SCA=use_sca, bandpass=None, n_waves=2, wavelength_limits=red_limit)
    with assert_raises(TypeError):
        galsim.roman.getPSF(SCA=use_sca, bandpass='Z087', wavelength='Z087')
    with assert_raises(ValueError):
        galsim.roman.getPSF(SCA=use_sca, bandpass='Z099', n_waves=2, wavelength='Z099')
    with assert_raises(ValueError):
        galsim.roman.getPSF(SCA=use_sca, bandpass='Z099', n_waves=2, wavelength='Z099')
    with assert_raises(TypeError):
        galsim.roman.getPSF(SCA=use_sca, bandpass='Z087', n_waves=2, wavelength='Z087')
    with assert_raises(TypeError):
        galsim.roman.getPSF(SCA=use_sca, bandpass='F184', n_waves=2, wavelength='F184')
    with assert_raises(galsim.GalSimValueError):
        galsim.roman.getPSF(SCA=use_sca, bandpass=3)

    # Make sure we can instantiate a PSF with bandpass='short'/'long' and get an equivalent object
    # when we're not using interpolation.
    use_sca = 3
    bp_type = 'long'
    bp = galsim.roman.longwave_bands[0]
    psf1 = galsim.roman.getPSF(use_sca, bp, pupil_bin=8)
    psf2 = galsim.roman.getPSF(use_sca, 'long', pupil_bin=8)
    assert psf1==psf2

    # Test some variation in the accuracy settings.
    kwargs_list = [
        { 'pupil_bin':4 },
        { 'pupil_bin':8 },
    ]
    if __name__ == '__main__':
        # A few more that are too slow to run in regular nosetests
        kwargs_list.extend([
            { 'pupil_bin':1 },
            { 'pupil_bin':2 },
            { 'pupil_bin':1, 'gsparams':galsim.GSParams(folding_threshold=2.e-3) },
            { 'pupil_bin':2, 'gsparams':galsim.GSParams(folding_threshold=2.e-3) },
            { 'pupil_bin':4, 'gsparams':galsim.GSParams(folding_threshold=2.e-3) },
        ])
    for kwargs in kwargs_list:
        psf = galsim.roman.getPSF(use_sca, 'Z087', **kwargs)
        psf_achrom = galsim.roman.getPSF(use_sca, 'Z087', wavelength=zbp, **kwargs)
        psf_chrom = psf.evaluateAtWavelength(use_lam)
        im_achrom = psf_achrom.drawImage(scale=galsim.roman.pixel_scale)
        im_chrom = psf_chrom.drawImage(image=im_achrom.copy())
        #im_achrom.write('im_achrom.fits')
        #im_chrom.write('im_chrom.fits')
        print("chrom, achrom fluxes = ", im_chrom.array.sum(), im_achrom.array.sum())
        im_chrom *= im_achrom.array.sum()/im_chrom.array.sum()
        print("max diff = ",np.max(np.abs(im_chrom.array - im_achrom.array)))
        np.testing.assert_array_almost_equal(
            im_chrom.array, im_achrom.array, decimal=8,
            err_msg='getPSF with %s has discrepency for chrom/achrom'%kwargs)

    # Check the stated method for recovering memory used in aperture caches.
    # Despite using a leading-underscore, sub-module-level function, the fact that we
    # document it makes it officially part of the API.  It requires a proper deprecation
    # if we change the syntax of this.
    galsim.roman.roman_psfs._make_aperture.clear()

    # Check for exceptions if we:
    # (1) Include optional aberrations in an unacceptable form.
    # (2) Invalid SCA numbers.
    # (3) Invalid kwarg combination.
    assert_raises(ValueError, galsim.roman.getPSF, 3, None, extra_aberrations=[0.03, -0.06]*20)
    assert_raises(ValueError, galsim.roman.getPSF, 30, None)
    assert_raises(ValueError, galsim.roman.getPSF, 0, None)
    assert_raises(ValueError, galsim.roman.getPSF, 3, 'short', n_waves=10)

@timer
def test_roman_basic_numbers():
    """Trivial test of basic numbers stored in Roman module.
    """
    # Would be better to have a non-trivial test, but this will do for now.
    ref_gain = 1.0
    ref_pixel_scale = 0.11  # arcsec / pixel
    ref_diameter = 2.36  # meters
    ref_obscuration = 0.32
    ref_exptime = 139.8  # s
    ref_dark_current = 0.015 # e-/pix/s
    ref_nonlinearity_beta = -6.e-7
    ref_reciprocity_alpha = 0.0065
    ref_read_noise = 8.5 # e-
    ref_n_dithers = 6
    ref_thermal_backgrounds = {'J129': 0.023, # e-/pix/s
                               'F184': 0.179,
                               'Y106': 0.023,
                               'Z087': 0.023,
                               'H158': 0.022,
                               'W146': 0.023}
    ref_pupil_plane_file = os.path.join(
            galsim.meta_data.share_dir, 'roman', 'SCA2_rim_mask.fits.gz')
    ref_stray_light_fraction = 0.1
    ref_ipc_kernel = np.array([ [0.001269938, 0.015399776, 0.001199862],
                                [0.013800177, 1.0,         0.015600367],
                                [0.001270391, 0.016129619, 0.001200137] ])
    ref_ipc_kernel /= np.sum(ref_ipc_kernel)
    ref_ipc_kernel = galsim.Image(ref_ipc_kernel)
    ref_persistence_coefficients = np.array(
        [0.045707683,0.014959818,0.009115737,0.00656769,0.005135571,
         0.004217028,0.003577534,0.003106601])/100.
    ref_persistence_fermi_parameters = np.array(
        [0.017, 60000., 50000., 0.045, 1., 50000.])
    ref_n_sca = 18
    ref_n_pix_tot = 4096
    ref_n_pix = 4088
    ref_jitter_rms = 0.014
    ref_charge_diffusion = 0.1

    assert galsim.roman.gain==ref_gain
    assert galsim.roman.pixel_scale==ref_pixel_scale
    assert galsim.roman.diameter==ref_diameter
    assert galsim.roman.obscuration==ref_obscuration
    assert galsim.roman.exptime==ref_exptime
    assert galsim.roman.dark_current==ref_dark_current
    assert galsim.roman.nonlinearity_beta==ref_nonlinearity_beta
    assert galsim.roman.reciprocity_alpha==ref_reciprocity_alpha
    assert galsim.roman.read_noise==ref_read_noise
    assert galsim.roman.n_dithers==ref_n_dithers
    assert galsim.roman.thermal_backgrounds.keys()==ref_thermal_backgrounds.keys()
    for key in ref_thermal_backgrounds.keys():
        assert galsim.roman.thermal_backgrounds[key]==ref_thermal_backgrounds[key]
    assert galsim.roman.pupil_plane_file==ref_pupil_plane_file
    assert galsim.roman.stray_light_fraction==ref_stray_light_fraction
    np.testing.assert_array_equal(ref_ipc_kernel, galsim.roman.ipc_kernel)
    np.testing.assert_array_equal(ref_persistence_coefficients,
                                  galsim.roman.persistence_coefficients)
    np.testing.assert_array_equal(ref_persistence_fermi_parameters,
                                  galsim.roman.persistence_fermi_parameters)
    assert galsim.roman.n_sca==ref_n_sca
    assert galsim.roman.n_pix_tot==ref_n_pix_tot
    assert galsim.roman.n_pix==ref_n_pix
    assert galsim.roman.jitter_rms==ref_jitter_rms
    assert galsim.roman.charge_diffusion==ref_charge_diffusion

@timer
def test_roman_psf_wcs():
    """Test drawing the PSF with a provided WCS."""

    # Make a PSF without giving a wcs
    image_pos = galsim.PositionD(153, 921)
    psf = galsim.roman.getPSF(SCA=5, bandpass='F184', wavelength=1950., pupil_bin=8,
                              SCA_pos=image_pos)

    # Draw it on an image with pixel_scale wcs
    im_scale = psf.drawImage(scale=galsim.roman.pixel_scale, center=image_pos)

    # Get a plausible commemorative observation for Roman's 100th birthday.
    world_pos = galsim.CelestialCoord(
        ra = galsim.Angle.from_hms('16:01:41.01257'),  # AG Draconis
        dec = galsim.Angle.from_dms('66:48:10.1312')
    )
    PA = 112*galsim.degrees  # Random.
    date = datetime.datetime(2025, 5, 16)  # NGR's 100th birthday.
    wcs_dict = galsim.roman.getWCS(PA=PA, world_pos=world_pos, date=date)
    wcs = wcs_dict[5]

    # Get the PSF in real world coordinates with this wcs
    psf = galsim.roman.getPSF(SCA=5, bandpass='F184', wavelength=1950., pupil_bin=8,
                              SCA_pos=image_pos, wcs=wcs)
    # Draw on an image with this wcs.
    im_wcs = psf.drawImage(bounds=im_scale.bounds, wcs=wcs, center=image_pos)

    np.testing.assert_allclose(im_wcs.array, im_scale.array)


@timer
def test_config_psf():
    """Test RomanPSF config type"""

    # Start with default everything
    config = {
        'modules' : ['galsim.roman'],
        'psf' : { 'type' : 'RomanPSF', 'SCA': 4, 'bandpass': 'H158' }
    }

    galsim.config.ImportModules(config)
    psf1 = galsim.config.BuildGSObject(config, 'psf')[0]
    psf2 = galsim.roman.getPSF(SCA=4, bandpass='H158')
    print('psf1 = ',str(psf1))
    print('psf2 = ',str(psf2))
    assert psf1 == psf2

    # Now check some non-default options
    config = galsim.config.CleanConfig(config)
    config['psf']['pupil_bin'] = 8
    config['psf']['n_waves'] = 4
    config['psf']['extra_aberrations'] = [0.01, 0, 0, 0.03, -0.05]
    config['psf']['gsparams'] = {'folding_threshold' : 1.e-2}
    psf1 = galsim.config.BuildGSObject(config, 'psf')[0]
    psf2 = galsim.roman.getPSF(SCA=4, bandpass='H158', pupil_bin=8, n_waves=4,
                               extra_aberrations=[0,0,0,0, 0.01, 0, 0, 0.03, -0.05],
                               gsparams=galsim.GSParams(folding_threshold=1.e-2))
    print('psf1 = ',str(psf1))
    print('psf2 = ',str(psf2))
    assert psf1 == psf2

    # Check using some values that are may already loaded into base config dict.
    config = galsim.config.CleanConfig(config)
    del config['psf']['SCA']
    del config['psf']['bandpass']
    del config['psf']['n_waves']
    config['bandpass'] = galsim.roman.getBandpasses(AB_zeropoint=True)['Z087']
    config['SCA'] = 9
    config['image_pos'] = galsim.PositionD(123,456)
    config['psf']['use_SCA_pos'] = True
    config['psf']['wavelength'] = 985.
    psf1 = galsim.config.BuildGSObject(config, 'psf')[0]
    psf2 = galsim.roman.getPSF(SCA=9, bandpass='Z087', pupil_bin=8, wavelength=985.,
                               SCA_pos=galsim.PositionD(123,456),
                               extra_aberrations=[0,0,0,0, 0.01, 0, 0, 0.03, -0.05],
                               gsparams=galsim.GSParams(folding_threshold=1.e-2))
    print('psf1 = ',str(psf1))
    print('psf2 = ',str(psf2))
    assert psf1 == psf2

    # Let bandpass be built by RomanBandpass type
    config = galsim.config.CleanConfig(config)
    config['image'] = {
        'bandpass' : { 'type' : 'RomanBandpass', 'name' : 'J129' }
    }
    config['bandpass'] = galsim.config.BuildBandpass(config['image'], 'bandpass', config)[0]
    psf1 = galsim.config.BuildGSObject(config, 'psf')[0]
    psf2 = galsim.roman.getPSF(SCA=9, bandpass='J129', pupil_bin=8, wavelength=985.,
                               SCA_pos=galsim.PositionD(123,456),
                               extra_aberrations=[0,0,0,0, 0.01, 0, 0, 0.03, -0.05],
                               gsparams=galsim.GSParams(folding_threshold=1.e-2))
    print('psf1 = ',str(psf1))
    print('psf2 = ',str(psf2))
    assert psf1 == psf2

@timer
def test_config_sca():
    """Test RomanSCA config type"""

    # The standard size of a Roman SCA is a bit large for an efficient unit test,
    # so we use mock to reduce the size of the image being constructed here.

    logger = logging.getLogger('test_config_sca')
    logger.addHandler(logging.StreamHandler(sys.stdout))
    logger.setLevel(logging.DEBUG)

    with mock.patch('galsim.roman.roman_config.n_pix', 64):

        config = {
            'modules': ['galsim.roman'],
            'image': {
                'type': 'RomanSCA',

                # These are required:
                'nobjects' : 1,
                'SCA': 5,
                'ra': '16 hours',
                'dec': '66 degrees',
                'filter': 'H158',
                'date': datetime.datetime(2025, 5, 16),

                # Set the rng seed:
                'random_seed': 1234,

                # Start with all the extra effects turned off.
                'stray_light': False,
                'thermal_background': False,
                'reciprocity_failure': False,
                'dark_current': False,
                'nonlinearity': False,
                'ipc': False,
                'read_noise': False,
                'sky_subtract': False,

                # image_pos can be either here or in stamp.
                'image_pos': (23,17),
            },

            # Nothing complicated for the object to draw.
            'gal': {
                'type': 'Exponential',
                'half_light_radius': 1.2,
                'flux': 177,
            },
        }

        galsim.config.ImportModules(config)
        im1 = galsim.config.BuildImage(config, obj_num=0)

        # Compare to manually constructed image
        pointing = galsim.CelestialCoord(ra=16*galsim.hours, dec=66*galsim.degrees)
        date = datetime.datetime(2025, 5, 16)
        wcs = galsim.roman.getWCS(world_pos=pointing, SCAs=[5], date=date)[5]
        im2 = galsim.Image(64,64, wcs=wcs)
        bp = galsim.roman.getBandpasses()['H158']
        sky_level = galsim.roman.getSkyLevel(bp, world_pos=wcs.toWorld(im2.true_center))
        wcs.makeSkyImage(im2, sky_level)
        gal = galsim.Exponential(half_light_radius=1.2, flux=177)
        gal.drawImage(im2, center=(23,17), add_to_image=True)
        first_seed = galsim.BaseDeviate(1234).raw()
        poisson_noise = galsim.PoissonNoise(galsim.BaseDeviate(first_seed))
        im2.addNoise(poisson_noise)
        im2 /= galsim.roman.gain
        im2.quantize()
        assert im1 == im2

        # Repeat with all of the detector effects
        config = galsim.config.CleanConfig(config)
        config['image']['stray_light'] = True
        config['image']['thermal_background'] = True
        config['image']['reciprocity_failure'] = True
        config['image']['dark_current'] = True
        config['image']['nonlinearity'] = True
        config['image']['ipc'] = True
        config['image']['read_noise'] = True
        config['image']['sky_subtract'] = True
        im1 = galsim.config.BuildImage(config, obj_num=0, logger=logger)
        sky_level *= (1.0 + galsim.roman.stray_light_fraction)
        wcs.makeSkyImage(im2, sky_level)
        im2 += galsim.roman.thermal_backgrounds['H158'] * galsim.roman.exptime
        sky_image = im2.copy()
        gal.drawImage(im2, center=(23,17), add_to_image=True)
        rng = galsim.BaseDeviate(first_seed)
        poisson_noise = galsim.PoissonNoise(rng)
        im2.addNoise(poisson_noise)
        galsim.roman.addReciprocityFailure(im2)
        dc = galsim.roman.dark_current * galsim.roman.exptime
        sky_image += dc
        im2.addNoise(galsim.DeviateNoise(galsim.PoissonDeviate(rng, dc)))
        galsim.roman.applyNonlinearity(im2)
        galsim.roman.applyIPC(im2)
        im2.addNoise(galsim.GaussianNoise(rng, sigma=galsim.roman.read_noise))
        im2 /= galsim.roman.gain
        im2.quantize()
        sky_image /= galsim.roman.gain
        sky_image.quantize()
        im2 -= sky_image
        assert im1 == im2

        # If photon shooting, objects already have Poisson noise.
        # Also, all detector effects on is the default, so can remove these items from config.
        # And use explicit Bandpass, which is allowed (possibly to override the default bp's),
        # but in this case is equivalent to the default behavior.
        config = galsim.config.CleanConfig(config)
        del config['image']['stray_light']
        del config['image']['thermal_background']
        del config['image']['reciprocity_failure']
        del config['image']['dark_current']
        del config['image']['nonlinearity']
        del config['image']['ipc']
        del config['image']['read_noise']
        del config['image']['sky_subtract']
        config['stamp'] = { 'draw_method' : 'phot' }
        config['image']['bandpass'] = { 'type' : 'RomanBandpass', 'name' : 'H158' }
        im1 = galsim.config.BuildImage(config, obj_num=0, logger=logger)
        wcs.makeSkyImage(im2, sky_level)
        im2 += galsim.roman.thermal_backgrounds['H158'] * galsim.roman.exptime
        sky_image = im2.copy()
        rng = galsim.BaseDeviate(first_seed)
        poisson_noise = galsim.PoissonNoise(rng)
        im2.addNoise(poisson_noise)
        gal_rng = galsim.BaseDeviate(first_seed+1)
        gal.drawImage(im2, center=(23,17), add_to_image=True, method='phot', rng=gal_rng)
        galsim.roman.addReciprocityFailure(im2)
        dc = galsim.roman.dark_current * galsim.roman.exptime
        sky_image += dc
        im2.addNoise(galsim.DeviateNoise(galsim.PoissonDeviate(rng, dc)))
        galsim.roman.applyNonlinearity(im2)
        galsim.roman.applyIPC(im2)
        im2.addNoise(galsim.GaussianNoise(rng, sigma=galsim.roman.read_noise))
        im2 /= galsim.roman.gain
        im2.quantize()
        sky_image /= galsim.roman.gain
        sky_image.quantize()
        im2 -= sky_image
        assert im1 == im2

@timer
def test_aberration_interpolation():
    
    """Test the Roman aberration interpolation method inside roman.roman_psfs
    """
    # We read in pairs of conjunction points, they are on different SCAs but are physically
    # adjacent on the FPA. The optical aberration between the two points in a pair should
    # be much less than the aberration range in the FPA. The maximum and minimum of aberration
    # in the FPA is pre-calculated using an 20x20 grid of positions on each SCA by Tianqing 
    # Zhang. The conjunction pairs between the first row and the second row are considered 
    # 'far', because are further separated. For 'far' pairs, z_diff<= 0.1*(z_max - z_min), 
    # elsewhere, z_diff<= 0.05*(z_max - z_min).

    print("Start continuity test for aberration interpolation")
    
    # Read the centers of the sca (in mm)
    infile = galsim.meta_data.share_dir+ '/roman/'+ 'sca_positions_7_6_8.txt'
    sca_data = np.loadtxt(infile).transpose()
    
    sca_xc_mm = -sca_data[3,:]
    sca_yc_mm = sca_data[4,:]
    
    horizontal_adjacent = []
    # list of horizontal contact (SCA# DOWN, SCA# UP)
    for i in range(1, 17, 3):
        horizontal_adjacent.append((i,i+1))
        horizontal_adjacent.append((i+1,i+2))
    
    vertical_adjacent = []
    # list of vertical contact (SCA# LEFT, SCA# RIGHT)
    for i in range(10,13):
        vertical_adjacent.append((i,i-9))
    
    ## Compute the fpa-position of all the contact points
    edge_pair_list = []
    
    # Compute horizontal adjacent pairs
    for pair in range(len(horizontal_adjacent)):
        sca1 = horizontal_adjacent[pair][0]-1
        sca2 = horizontal_adjacent[pair][1]-1

        pixel_size = galsim.roman.pixel_scale_mm # mm/pixel
        npix = galsim.roman.n_pix

        x_contact = (sca_xc_mm[sca1]+sca_xc_mm[sca2])/2
        x_1_mm = x_contact - sca_xc_mm[sca1]
        x_2_mm = x_contact - sca_xc_mm[sca2]

        y_1_mm = + npix*pixel_size/2
        y_2_mm = - npix*pixel_size/2

        sca_pos_1 = galsim.PositionD(x = npix/2 -x_1_mm/pixel_size , y = y_1_mm/pixel_size + npix/2)
        sca_pos_2 = galsim.PositionD(x = npix/2 -x_2_mm/pixel_size , y = y_2_mm/pixel_size + npix/2)


        edge_pair_list.append([sca1+1,sca_pos_1.x, sca_pos_1.y, sca2+1, sca_pos_2.x, sca_pos_2.y])



    for pair in range(len(vertical_adjacent)):
        sca1 = vertical_adjacent[pair][0]-1
        sca2 = vertical_adjacent[pair][1]-1

        y_contact = (sca_yc_mm[sca1]+sca_yc_mm[sca2])/2
        y_1_mm = y_contact - sca_yc_mm[sca1]
        y_2_mm = y_contact - sca_yc_mm[sca2]

        x_1_mm = + npix*pixel_size/2
        x_2_mm = - npix*pixel_size/2


        sca_pos_1 = galsim.PositionD(x = npix/2 -x_1_mm/pixel_size , y = y_1_mm/pixel_size + npix/2)
        sca_pos_2 = galsim.PositionD(x = npix/2 -x_2_mm/pixel_size , y = y_2_mm/pixel_size + npix/2)





        edge_pair_list.append([sca1+1,sca_pos_1.x, sca_pos_1.y, sca2+1, sca_pos_2.x, sca_pos_2.y])
        
    edge_pair_array = np.array(edge_pair_list)
    
    # Z_min, Z_max across the FPA. This is too slow to compute at runtime.
    Z_min_max = np.array([[ 0.00000000e+00,  0.00000000e+00],
                         [-9.41831458e-02 , 1.48836864e-02],
                         [-5.39685347e-02 , 6.77900000e-02],
                         [-6.71719717e-02 , 5.11592637e-02],
                         [-5.94858831e-02 , 4.73625734e-03],
                         [-5.39000000e-02 , 1.37568469e-02],
                         [-2.42295572e-02 , 1.92651932e-02],
                         [-2.04531483e-02 , 1.97997407e-02],
                         [-2.08693493e-02 , 2.56600000e-02],
                         [-2.24474951e-02 , 6.23876468e-03],
                         [-2.28480626e-02 , 2.36465119e-02],
                         [-3.97983366e-03 ,-2.16004403e-03],
                         [-2.06984100e-03 , 4.49926614e-04],
                         [-1.88975783e-03 , 2.06991438e-03],
                         [-1.89977984e-04 , 9.99706482e-05],
                         [-1.99958417e-04 , 1.79982877e-04],
                         [-9.69929061e-04 , 9.20000000e-04],
                         [ 7.00000000e-04 , 1.83993640e-03],
                         [-9.99755382e-06 , 9.99510823e-06],
                         [ 0.00000000e+00 , 9.99755382e-06],
                         [ 0.00000000e+00 , 0.00000000e+00],
                         [ 0.00000000e+00 , 0.00000000e+00],
                         [ 6.60000000e-04 , 6.70000000e-04]])

    #Read the aberration and sca_pos for the interpolation *reference* points from the roman files.
    aberration_list = []
    sca_x_list = []
    sca_y_list = []
    for sca_index in range(1,19):

        this_aberration, this_x, this_y = galsim.roman.roman_psfs._read_aberrations(sca_index)
        aberration_list.append(this_aberration)
        sca_x_list.append(this_x)
        sca_y_list.append(this_y)



    for pair in edge_pair_array:

        sca1 = int(pair[0])
        sca_pos_1 = galsim.PositionD(x = pair[1] , y = pair[2])

        sca2 = int(pair[3])
        sca_pos_2 = galsim.PositionD(x = pair[4] , y = pair[5])

        far = False
        if sca2%3==0 and sca2-sca1 == 1:
            far = True
    
        #For each pair of conjunction points, calculate their aberration by calling _interp_aberrations_bilinear
        point_1_abe = galsim.roman.roman_psfs._interp_aberrations_bilinear(aberration_list[sca1-1],
                                                                       sca_x_list[sca1-1], 
                                                                       sca_y_list[sca1-1],
                                                                       sca_pos_1)
        point_2_abe = galsim.roman.roman_psfs._interp_aberrations_bilinear(aberration_list[sca2-1],
                                                                       sca_x_list[sca2-1], 
                                                                       sca_y_list[sca2-1],
                                                                       sca_pos_2)
        for i in range(23):
            z_min, z_max = Z_min_max[i]
            #Skip the Z22 because it is indeed not continuous given the current roman file.
            if i ==22:
                continue


            z_diff = np.abs(point_2_abe[i] - point_1_abe[i])

            if far:

                assert z_diff<= 0.1*(z_max - z_min), 'z_diff > 0.1(z_max - z_min), failed aberration continuity test.\
                \n Fail for Z{}, z_diff = {}, sca1 = {}, sca2 = {}'.format(i,z_diff,sca1,sca2)


            else:

                assert z_diff<= 0.05*(z_max - z_min),'z_diff > 0.05(z_max - z_min), failed aberration continuity test.\
                \n Fail for Z{}, z_diff = {}, sca1 = {}, sca2 = {}'.format(i,z_diff,sca1,sca2)
                
    print("Continuity test passes.")






if __name__ == "__main__":
    #import cProfile, pstats
    #pr = cProfile.Profile()
    #pr.enable()
    testfns = [v for k, v in vars().items() if k[:5] == 'test_' and callable(v)]
    for testfn in testfns:
        testfn()
    #pr.disable()
    #ps = pstats.Stats(pr).sort_stats('tottime')
    #ps.print_stats(30)
